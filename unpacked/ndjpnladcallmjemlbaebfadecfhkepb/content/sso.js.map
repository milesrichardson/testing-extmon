{"version":3,"sources":["webpack://officechromeextension/./app/common/browserHandler.ts","webpack://officechromeextension/./app/content/content.helper.ts","webpack://officechromeextension/webpack/bootstrap","webpack://officechromeextension/./app/content/sso.ts"],"names":["browserListeners","propertyList","mergeProperties","target","source","key","value","Object","entries","Array","isArray","concat","console","log","browserHandler","browser","edgeBrowser","create","notifications","clear","notificationId","callback","options","priority","window","alert","message","onButtonClicked","addListener","onClicked","runtime","getPlatformInfo","chrome","jasmine","mock","browserAction","setIcon","icon","extension","getURL","name","i18n","getUILanguage","getMessage","onMessage","listener","push","removeListener","splice","indexOf","sendMessage","i","length","id","storage","local","get","set","data","hasOwnProperty","remove","tabs","createProperties","BrowserHandler","isIFrame","parent","severity","scriptfile","stack","Error","split","match","pop","activity","filename","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","SSOHelper","location","hostname","href","addEventListener","event","channel","channelId","request","method","body","extensionId","extList","document","getElementById","extElement","createElement","version","getManifest","setAttribute","appendChild","Call","port","response","Callback","description","lastError","status","code","e","toString","req","responseId","JSON","stringify","postMessage","origin","ports","stopImmediatePropagation","onmessage"],"mappings":"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","file":"\\content\\sso.js","sourcesContent":["declare let browser: any;\r\ndeclare let chrome: any;\r\n\r\nvar browserListeners: any[] = [];\r\nvar propertyList = {};\r\n\r\nfunction mergeProperties(target: any, source: any): any {\r\n    for (const [key, value] of Object.entries(source)) {\r\n        if (!target[key]) {\r\n            target[key] = value;\r\n            continue;\r\n        }\r\n\r\n        if (typeof value !== typeof target[key]) {\r\n            console.log(`skipping ${key} due to conflicting types`);\r\n            continue;\r\n        }\r\n\r\n        if (Array.isArray(value)) {\r\n            target[key] = target[key].concat(value);\r\n            continue;\r\n        }\r\n\r\n        if (typeof value === 'object') {\r\n            target[key] = mergeProperties(target[key], value);\r\n            continue;\r\n        }\r\n        target[key] = value;\r\n    }\r\n\r\n    return target;\r\n}\r\n\r\nexport default (function (): any {\r\n    var browserHandler = ((): any => {\r\n        if (typeof browser === 'object') {\r\n            var edgeBrowser = Object.create(browser);\r\n\r\n            edgeBrowser.notifications = {\r\n                clear: function (notificationId: string, callback: (wasCleared: boolean) => void): void {\r\n                    // Invoke callback with wasCleared == false\r\n                    callback(false);\r\n                },\r\n                create: function (\r\n                    notificationId: string,\r\n                    options: chrome.notifications.NotificationOptions,\r\n                    callback: (notificationId: string) => void\r\n                ): void {\r\n                    // Use window alert dialog to display notification message\r\n                    if (typeof options !== 'undefined' && options !== null) {\r\n                        // Only show when priority is 1 or 2\r\n                        if (typeof options.priority !== 'undefined' && options.priority !== null && options.priority > 0) {\r\n                            window.alert(options.message);\r\n                        }\r\n                    }\r\n\r\n                    // Invoke callback with notification id\r\n                    callback(notificationId);\r\n                },\r\n                onButtonClicked: {\r\n                    addListener: function (notificationId: string): void {\r\n                        // Not implemented\r\n                    },\r\n                },\r\n                onClicked: {\r\n                    addListener: function (notificationId: string): void {\r\n                        // Not implemented\r\n                    },\r\n                },\r\n            };\r\n\r\n            edgeBrowser.runtime = {\r\n                getPlatformInfo: function (callback: (platformInfo: chrome.runtime.PlatformInfo) => void): void {\r\n                    // Does not execute the callback function\r\n                    // Not implemented\r\n                },\r\n            };\r\n        } else if (typeof chrome === 'object') {\r\n            return Object.create(chrome);\r\n        }\r\n    })();\r\n\r\n    // when running in tests, provide override the necessary functions\r\n    if ((window as any).jasmine) {\r\n        const browserMock = {\r\n            mock: true,\r\n            browserAction: {\r\n                setIcon: function (icon: string): void {},\r\n            },\r\n            extension: {\r\n                getURL: function (name: any): string {\r\n                    return '';\r\n                },\r\n            },\r\n            i18n: {\r\n                getUILanguage: function (name: any, callback: any): string {\r\n                    return '';\r\n                },\r\n                getMessage: function (): string {\r\n                    return '';\r\n                },\r\n            },\r\n            runtime: {\r\n                onMessage: {\r\n                    addListener: function (listener: any): any {\r\n                        browserListeners.push(listener);\r\n                    },\r\n                    removeListener: function (listener: any): void {\r\n                        browserListeners.splice(browserListeners.indexOf(listener), 1);\r\n                    },\r\n                },\r\n                sendMessage: function (message: any): any {\r\n                    for (let i = 0; i < browserListeners.length; ++i) {\r\n                        browserListeners[i](message);\r\n                    }\r\n                },\r\n                id: 'ndjpnladcallmjemlbaebfadecfhkepb',\r\n            },\r\n            storage: {\r\n                local: {\r\n                    get: function (name: string, callback: (arg0: { [x: number]: any }) => void): any {\r\n                        callback({\r\n                            [name]: (propertyList as any)[name],\r\n                        });\r\n                    },\r\n\r\n                    set: function (data: { [x: string]: any; hasOwnProperty: (arg0: string) => any }): void {\r\n                        for (const key in data) {\r\n                            if (data.hasOwnProperty(key)) {\r\n                                (propertyList as any)[key] = /*JSON.stringify*/ data[key];\r\n                            }\r\n                        }\r\n                    },\r\n\r\n                    remove: function (name: string | number, callback: (arg0: any) => void): void {\r\n                        delete (propertyList as any)[name];\r\n                        callback(propertyList);\r\n                    },\r\n\r\n                    clear: function (name: any, callback: any): void {\r\n                        propertyList = {};\r\n                    },\r\n                },\r\n            },\r\n            tabs: {\r\n                create: function (createProperties: any, callback: (arg0: {}) => void): void {\r\n                    if (callback) callback({});\r\n                },\r\n            },\r\n        };\r\n        browserHandler = mergeProperties(browserHandler || {}, browserMock);\r\n        if (!(window as any).chrome) {\r\n            (window as any).chrome = browserHandler;\r\n        }\r\n    }\r\n\r\n    if (!(window as any).BrowserHandler) {\r\n        (window as any).BrowserHandler = browserHandler;\r\n    }\r\n\r\n    return browserHandler;\r\n})();\r\n","import BrowserHandler from '../common/browserHandler';\r\n\r\n('use strict');\r\n\r\nexport const isIFrame = window.parent !== window;\r\nexport function log(message: string, severity = 'DEBUG'): void {\r\n    var scriptfile = ((): string => {\r\n        var stack = new Error().stack.split('\\n');\r\n        if (stack.length < 4) {\r\n            return undefined;\r\n        }\r\n\r\n        var location = stack[3].match(/\\b[\\w.]+\\b:\\d+/g);\r\n        return location.pop();\r\n    })();\r\n\r\n    BrowserHandler.runtime.sendMessage({\r\n        activity: 'log',\r\n        filename: `${isIFrame ? '(iframe)' : ''}${scriptfile || ''}`,\r\n        severity,\r\n        log: message,\r\n    });\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// Copyright (c) 2017 Microsoft Corporation. All rights reserved.\r\n// Because it is a content script it is performance critical. Do the minimum in global space.\r\n/* global chrome*/\r\nimport { isIFrame, log } from './content.helper';\r\nlet SSOHelper: any = null;\r\n\r\nif (!isIFrame && location.hostname === 'login.microsoftonline.com') {\r\n    log(`Loaded ${location.href}`);\r\n}\r\n\r\nwindow.addEventListener(\r\n    'message',\r\n    function (event: MessageEvent): void {\r\n        'use strict';\r\n        if (event.data.channel) {\r\n            const channelId = '53ee284d-920a-4b59-9d30-a60315b26836';\r\n            try {\r\n                if (event.data.channel !== channelId) {\r\n                    log(`bad channel: ${event.data}`);\r\n                    return;\r\n                }\r\n\r\n                // Only accept messages from ourself.\r\n                if (event.source !== window) {\r\n                    log(`invalid event.source: ${event.source}`);\r\n                    return;\r\n                }\r\n\r\n                const request = event.data;\r\n                const method = request.body.method;\r\n                const extensionId = chrome.runtime.id;\r\n\r\n                if (method === 'CreateProviderAsync') {\r\n                    // Legacy communication pattern\r\n                    const extList = document.getElementById(`ch-${channelId}`);\r\n                    if (extList) {\r\n                        var extElement = document.createElement('div');\r\n                        extElement.id = extensionId;\r\n\r\n                        var version = chrome.runtime.getManifest().version;\r\n                        if (version) {\r\n                            extElement.setAttribute('ver', version);\r\n                        }\r\n\r\n                        extList.appendChild(extElement);\r\n                    }\r\n                    return;\r\n                } else if (!SSOHelper) {\r\n                    // Create helper function. They're not loaded in global because they're not needed in every page (optimization).\r\n                    // However, they're stored in global.\r\n                    SSOHelper = {\r\n                        Call: function (request: any, port: any): void {\r\n                            try {\r\n                                chrome.runtime.sendMessage({ activity: 'sso', body: request.body }, function (response) {\r\n                                    if (response === null || response === undefined) {\r\n                                        const description = chrome.runtime.lastError ? chrome.runtime.lastError.message : 'No response';\r\n\r\n                                        SSOHelper.Callback(request, {\r\n                                            status: 'Fail',\r\n                                            code: 'ContentError',\r\n                                            description,\r\n                                        }, port);\r\n\r\n                                        return;\r\n                                    }\r\n                                    SSOHelper.Callback(request, response, port);\r\n                                });\r\n                            } catch (e) {\r\n                                SSOHelper.Callback(request, {\r\n                                    status: 'Fail',\r\n                                    code: 'ContentError',\r\n                                    description: e.toString(),\r\n                                }, port);\r\n                            }\r\n                        },\r\n\r\n                        Callback: function (request: any, response: any, port?: MessagePort): void {\r\n                            const req = {\r\n                                channel: channelId,\r\n                                extensionId: extensionId,\r\n                                responseId: request.responseId,\r\n\r\n                                body: {\r\n                                    method: 'Response',\r\n                                    response: response,\r\n                                },\r\n                            };\r\n\r\n                            log(`SSO response status: ${JSON.stringify(response.status)}`, response.status === 'Fail' ? 'ERROR' : 'DEBUG');\r\n                            if (port) {\r\n                                log('Sending response over MessageChannel port');\r\n                                port.postMessage(req);\r\n                            } else {\r\n                                log('Sending response over window.postMessage');\r\n                                window.postMessage(req, location.origin);\r\n                            }\r\n                        },\r\n                    };\r\n                }\r\n                \r\n                if (method === \"Handshake\" && (!request.extensionId || request.extensionId === extensionId) && event.ports && event.ports.length) {\r\n                    // Stop event propagation to prevent caller and other extensions from reacting to this event\r\n                    event.stopImmediatePropagation();\r\n                    log('Received Handshake request, sending HandshakeResponse');\r\n                    var req  = {\r\n                        channel: channelId,\r\n                        extensionId: extensionId,\r\n                        responseId: request.responseId,\r\n                        body: {\r\n                            method: \"HandshakeResponse\",\r\n                            version: chrome.runtime.getManifest().version\r\n                        }\r\n                    };\r\n\r\n                    var port = event.ports[0];\r\n                    port.onmessage = (event: MessageEvent): void => {\r\n                        var request = event.data;\r\n                        SSOHelper.Call(request, port);\r\n                    };\r\n                    port.postMessage(req);\r\n                } else if (request.extensionId === extensionId && method !== \"Response\") {\r\n                    // Legacy communication pattern\r\n                    SSOHelper.Call(request);\r\n                } else {\r\n                    log(`method: ${method} not handled, location: ${location.href}`);\r\n                }\r\n            } catch (e) {\r\n                log(`caught exception: ${JSON.stringify(e)}`, 'INFO');\r\n\r\n                // Swallow exception to not break page excecution.\r\n            }\r\n        }\r\n    },\r\n    true\r\n); // \"true\" is important to give priority to the content script.\r\n"],"sourceRoot":""}