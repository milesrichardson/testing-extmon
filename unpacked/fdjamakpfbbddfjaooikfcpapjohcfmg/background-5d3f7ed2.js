/*! For license information please see background-5d3f7ed2.js.LICENSE.txt */
(self.webpackChunk_dashlane_amphora = self.webpackChunk_dashlane_amphora || []).push([
  [433],
  {
    16946: (e, t, r) => {
      "use strict";
      r.d(t, { O: () => s });
      var s = (function (e) {
        return (
          (e.PopupCarbon = "Popup"),
          (e.PopupCarbonLoader = "PopupCarbonLoader"),
          (e.OptionsCarbon = "OptionsCarbon"),
          (e.WebappCarbon = "leeloo"),
          e
        );
      })({});
    },
    13186: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => u, y: () => c });
      r(86847),
        r(4473),
        r(68126),
        r(41437),
        r(24814),
        r(71632),
        r(75815),
        r(73636),
        r(55566),
        r(72029),
        r(2165),
        r(296),
        r(30094),
        r(83746),
        r(37944),
        r(32721),
        r(55402),
        r(22250),
        r(92665),
        r(88737);
      function s(e) {
        return (
          (s =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                }),
          s(e)
        );
      }
      function a(e, t) {
        for (var r = 0; r < t.length; r++) {
          var a = t[r];
          (a.enumerable = a.enumerable || !1),
            (a.configurable = !0),
            "value" in a && (a.writable = !0),
            Object.defineProperty(
              e,
              ((n = a.key),
              (i = void 0),
              (i = (function (e, t) {
                if ("object" !== s(e) || null === e) return e;
                var r = e[Symbol.toPrimitive];
                if (void 0 !== r) {
                  var a = r.call(e, t || "default");
                  if ("object" !== s(a)) return a;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === t ? String : Number)(e);
              })(n, "string")),
              "symbol" === s(i) ? i : String(i)),
              a
            );
        }
        var n, i;
      }
      function n(e, t) {
        return (
          (n = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (e, t) {
                return (e.__proto__ = t), e;
              }),
          n(e, t)
        );
      }
      function i(e) {
        var t = (function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        })();
        return function () {
          var r,
            a = o(e);
          if (t) {
            var n = o(this).constructor;
            r = Reflect.construct(a, arguments, n);
          } else r = a.apply(this, arguments);
          return (function (e, t) {
            if (t && ("object" === s(t) || "function" == typeof t)) return t;
            if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
            return (function (e) {
              if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e;
            })(e);
          })(this, r);
        };
      }
      function o(e) {
        return (
          (o = Object.setPrototypeOf
            ? Object.getPrototypeOf.bind()
            : function (e) {
                return e.__proto__ || Object.getPrototypeOf(e);
              }),
          o(e)
        );
      }
      var c = (function (e) {
          !(function (e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } })),
              Object.defineProperty(e, "prototype", { writable: !1 }),
              t && n(e, t);
          })(c, e);
          var t,
            r,
            s,
            o = i(c);
          function c() {
            var e;
            !(function (e, t) {
              if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
            })(this, c);
            for (var t = arguments.length, r = new Array(t), s = 0; s < t; s++) r[s] = arguments[s];
            return ((e = o.call.apply(o, [this].concat(r))).isConnected = !1), (e.onMessage = null), e;
          }
          return (
            (t = c),
            (r = [
              {
                key: "connect",
                value: function (e) {
                  (this.onMessage = function (t) {
                    e.receive(t);
                  }),
                    (this.isConnected = !0),
                    this._connected();
                }
              },
              {
                key: "receive",
                value: function (e) {
                  this._messageReceived(e);
                }
              },
              {
                key: "send",
                value: function (e) {
                  if (!this.isConnected) throw new Error("Channel not connected");
                  if (!this.onMessage) throw new Error("onMessage handler not set");
                  this.onMessage(e);
                }
              }
            ]) && a(t.prototype, r),
            s && a(t, s),
            Object.defineProperty(t, "prototype", { writable: !1 }),
            c
          );
        })(r(71796).GenericChannel),
        u = function (e, t) {
          e.connect(t), t.connect(e);
        };
    },
    89515: (e, t, r) => {
      "use strict";
      r.d(t, { Y: () => l });
      r(37391),
        r(38298),
        r(4473),
        r(68126),
        r(22250),
        r(26589),
        r(75815),
        r(92665),
        r(88737),
        r(2191),
        r(75986),
        r(41437),
        r(24814),
        r(71632),
        r(73636),
        r(55566),
        r(72029),
        r(2165),
        r(296),
        r(30094),
        r(83746),
        r(37944),
        r(32721),
        r(55402);
      var s = r(71796),
        a = r(62568),
        n = r(20500);
      function i(e) {
        return (
          (i =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                }),
          i(e)
        );
      }
      function o(e, t) {
        for (var r = 0; r < t.length; r++) {
          var s = t[r];
          (s.enumerable = s.enumerable || !1),
            (s.configurable = !0),
            "value" in s && (s.writable = !0),
            Object.defineProperty(
              e,
              ((a = s.key),
              (n = void 0),
              (n = (function (e, t) {
                if ("object" !== i(e) || null === e) return e;
                var r = e[Symbol.toPrimitive];
                if (void 0 !== r) {
                  var s = r.call(e, t || "default");
                  if ("object" !== i(s)) return s;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === t ? String : Number)(e);
              })(a, "string")),
              "symbol" === i(n) ? n : String(n)),
              s
            );
        }
        var a, n;
      }
      function c(e, t) {
        return (
          (c = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (e, t) {
                return (e.__proto__ = t), e;
              }),
          c(e, t)
        );
      }
      function u(e) {
        var t = (function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        })();
        return function () {
          var r,
            s = d(e);
          if (t) {
            var a = d(this).constructor;
            r = Reflect.construct(s, arguments, a);
          } else r = s.apply(this, arguments);
          return (function (e, t) {
            if (t && ("object" === i(t) || "function" == typeof t)) return t;
            if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
            return (function (e) {
              if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e;
            })(e);
          })(this, r);
        };
      }
      function d(e) {
        return (
          (d = Object.setPrototypeOf
            ? Object.getPrototypeOf.bind()
            : function (e) {
                return e.__proto__ || Object.getPrototypeOf(e);
              }),
          d(e)
        );
      }
      var l = (function (e) {
        !(function (e, t) {
          if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
          (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } })),
            Object.defineProperty(e, "prototype", { writable: !1 }),
            t && c(e, t);
        })(d, e);
        var t,
          r,
          s,
          i = u(d);
        function d(e) {
          var t,
            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
          return (
            (function (e, t) {
              if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
            })(this, d),
            ((t = i.call(this, r)).name = void 0),
            (t.currentPorts = void 0),
            (t.onConnectListener = function (e) {
              if (e.name.startsWith(t.name)) {
                if (t.currentPorts.has(e.name)) throw new Error("Port already connected");
                if (!(0, a.k)(e)) throw new Error("Sender origin not trusted");
                t.setup(e);
              }
            }),
            (t.onDisconnectListener = function (e) {
              n.b.removeListener(t.onConnectListener);
              var r = t.currentPorts.get(e.name);
              if (
                (r &&
                  (r.onMessage.removeListener(t.onMessageListener),
                  r.onDisconnect.removeListener(t.onDisconnectListener),
                  t.currentPorts.delete(e.name)),
                t._disconnected(),
                chrome.runtime.lastError)
              ) {
                var s,
                  a = null != (s = chrome.runtime.lastError.message) ? s : "Unknown chrome.runtime.lastError";
                throw new Error(a);
              }
            }),
            (t.onMessageListener = function (e) {
              t._messageReceived(e);
            }),
            (t.name = e),
            (t.currentPorts = new Map()),
            t
          );
        }
        return (
          (t = d),
          (r = [
            {
              key: "connect",
              value: function () {
                n.b.addListener(this.onConnectListener);
              }
            },
            {
              key: "autoReconnect",
              value: function () {
                this.connect();
              }
            },
            {
              key: "send",
              value: function (e) {
                if (!this.currentPorts.size) throw new Error("No port to send message");
                this.currentPorts.forEach(function (t) {
                  return t.postMessage(e);
                });
              }
            },
            {
              key: "setup",
              value: function (e) {
                var t = this.currentPorts.get(e.name);
                t && (t.disconnect(), this.onDisconnectListener(t)),
                  e.onMessage.addListener(this.onMessageListener),
                  e.onDisconnect.addListener(this.onDisconnectListener),
                  this.currentPorts.set(e.name, e),
                  this._connected();
              }
            }
          ]) && o(t.prototype, r),
          s && o(t, s),
          Object.defineProperty(t, "prototype", { writable: !1 }),
          d
        );
      })(s.GenericChannel);
    },
    97875: (e, t, r) => {
      "use strict";
      r.d(t, { s: () => l });
      r(37391),
        r(4473),
        r(68126),
        r(41437),
        r(24814),
        r(71632),
        r(75815),
        r(73636),
        r(55566),
        r(72029),
        r(2165),
        r(296),
        r(30094),
        r(83746),
        r(37944),
        r(32721),
        r(55402),
        r(22250),
        r(92665),
        r(88737);
      var s = r(71796),
        a = r(62568),
        n = r(20500);
      function i(e) {
        return (
          (i =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                }),
          i(e)
        );
      }
      function o(e, t) {
        for (var r = 0; r < t.length; r++) {
          var s = t[r];
          (s.enumerable = s.enumerable || !1),
            (s.configurable = !0),
            "value" in s && (s.writable = !0),
            Object.defineProperty(
              e,
              ((a = s.key),
              (n = void 0),
              (n = (function (e, t) {
                if ("object" !== i(e) || null === e) return e;
                var r = e[Symbol.toPrimitive];
                if (void 0 !== r) {
                  var s = r.call(e, t || "default");
                  if ("object" !== i(s)) return s;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === t ? String : Number)(e);
              })(a, "string")),
              "symbol" === i(n) ? n : String(n)),
              s
            );
        }
        var a, n;
      }
      function c(e, t) {
        return (
          (c = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (e, t) {
                return (e.__proto__ = t), e;
              }),
          c(e, t)
        );
      }
      function u(e) {
        var t = (function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        })();
        return function () {
          var r,
            s = d(e);
          if (t) {
            var a = d(this).constructor;
            r = Reflect.construct(s, arguments, a);
          } else r = s.apply(this, arguments);
          return (function (e, t) {
            if (t && ("object" === i(t) || "function" == typeof t)) return t;
            if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
            return (function (e) {
              if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e;
            })(e);
          })(this, r);
        };
      }
      function d(e) {
        return (
          (d = Object.setPrototypeOf
            ? Object.getPrototypeOf.bind()
            : function (e) {
                return e.__proto__ || Object.getPrototypeOf(e);
              }),
          d(e)
        );
      }
      var l = (function (e) {
        !(function (e, t) {
          if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
          (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } })),
            Object.defineProperty(e, "prototype", { writable: !1 }),
            t && c(e, t);
        })(d, e);
        var t,
          r,
          s,
          i = u(d);
        function d(e) {
          var t,
            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
          return (
            (function (e, t) {
              if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
            })(this, d),
            ((t = i.call(this, r)).name = void 0),
            (t.port = void 0),
            (t.onConnectListener = function (e) {
              if (e.name === t.name) {
                if (!(0, a.k)(e)) throw new Error("Sender origin not trusted");
                t.setup(e);
              }
            }),
            (t.onDisconnectListener = function () {
              if (
                (n.b.removeListener(t.onConnectListener),
                t.port &&
                  (t.port.onMessage.removeListener(t.onMessageListener),
                  t.port.onDisconnect.removeListener(t.onDisconnectListener),
                  (t.port = void 0)),
                t._disconnected(),
                chrome.runtime.lastError)
              ) {
                var e,
                  r = null != (e = chrome.runtime.lastError.message) ? e : "Unknown chrome.runtime.lastError";
                throw new Error(r);
              }
            }),
            (t.onMessageListener = function (e) {
              t._messageReceived(e);
            }),
            (t.name = e),
            t
          );
        }
        return (
          (t = d),
          (r = [
            {
              key: "connect",
              value: function () {
                this.port && (this.port.disconnect(), this.onDisconnectListener()), n.b.addListener(this.onConnectListener);
              }
            },
            {
              key: "autoReconnect",
              value: function () {
                this.connect();
              }
            },
            {
              key: "send",
              value: function (e) {
                if (!this.port) throw new Error("No port to send message");
                this.port.postMessage(e);
              }
            },
            {
              key: "setup",
              value: function (e) {
                (this.port = e),
                  this.port.onMessage.addListener(this.onMessageListener),
                  this.port.onDisconnect.addListener(this.onDisconnectListener),
                  this._connected();
              }
            }
          ]) && o(t.prototype, r),
          s && o(t, s),
          Object.defineProperty(t, "prototype", { writable: !1 }),
          d
        );
      })(s.GenericChannel);
    },
    62568: (e, t, r) => {
      "use strict";
      r.d(t, { k: () => i });
      r(22250), r(75815), r(92665), r(88737), r(23389), r(21675);
      var s = r(92204);
      function a(e) {
        var t = (function (e) {
          var t, r, s, a, n, i, o;
          return null != (t = null === (r = e.sender) || void 0 === r ? void 0 : r.origin)
            ? t
            : new URL(
                null !=
                (s =
                  null != (a = null === (n = e.sender) || void 0 === n ? void 0 : n.url)
                    ? a
                    : null === (i = e.sender) || void 0 === i || null === (o = i.tab) || void 0 === o
                    ? void 0
                    : o.url)
                  ? s
                  : ""
              ).origin;
        })(e);
        return new URL((0, s.A)("")).origin === t;
      }
      function n(e) {
        var t, r;
        return (null != (t = null === (r = e.sender) || void 0 === r ? void 0 : r.id) ? t : "") === chrome.runtime.id;
      }
      function i(e) {
        return !!n(e) || !!a(e);
      }
    },
    70920: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => y });
      r(75815),
        r(45749),
        r(23041),
        r(22250),
        r(92665),
        r(88737),
        r(2165),
        r(83746),
        r(37944),
        r(55402),
        r(97979),
        r(38509),
        r(95665),
        r(41533),
        r(72029),
        r(71632),
        r(2191),
        r(4473),
        r(68126),
        r(75986),
        r(37391),
        r(41437),
        r(5744),
        r(18549),
        r(15442);
      var s = r(30754),
        a = r(82324),
        n = r(81805);
      function i(e) {
        return (
          (i =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                }),
          i(e)
        );
      }
      function o() {
        o = function () {
          return e;
        };
        var e = {},
          t = Object.prototype,
          r = t.hasOwnProperty,
          s =
            Object.defineProperty ||
            function (e, t, r) {
              e[t] = r.value;
            },
          a = "function" == typeof Symbol ? Symbol : {},
          n = a.iterator || "@@iterator",
          c = a.asyncIterator || "@@asyncIterator",
          u = a.toStringTag || "@@toStringTag";
        function d(e, t, r) {
          return Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }), e[t];
        }
        try {
          d({}, "");
        } catch (e) {
          d = function (e, t, r) {
            return (e[t] = r);
          };
        }
        function l(e, t, r, a) {
          var n = t && t.prototype instanceof m ? t : m,
            i = Object.create(n.prototype),
            o = new R(a || []);
          return s(i, "_invoke", { value: b(e, r, o) }), i;
        }
        function p(e, t, r) {
          try {
            return { type: "normal", arg: e.call(t, r) };
          } catch (e) {
            return { type: "throw", arg: e };
          }
        }
        e.wrap = l;
        var h = {};
        function m() {}
        function y() {}
        function g() {}
        var v = {};
        d(v, n, function () {
          return this;
        });
        var f = Object.getPrototypeOf,
          w = f && f(f(I([])));
        w && w !== t && r.call(w, n) && (v = w);
        var S = (g.prototype = m.prototype = Object.create(v));
        function E(e) {
          ["next", "throw", "return"].forEach(function (t) {
            d(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function _(e, t) {
          function a(s, n, o, c) {
            var u = p(e[s], e, n);
            if ("throw" !== u.type) {
              var d = u.arg,
                l = d.value;
              return l && "object" == i(l) && r.call(l, "__await")
                ? t.resolve(l.__await).then(
                    function (e) {
                      a("next", e, o, c);
                    },
                    function (e) {
                      a("throw", e, o, c);
                    }
                  )
                : t.resolve(l).then(
                    function (e) {
                      (d.value = e), o(d);
                    },
                    function (e) {
                      return a("throw", e, o, c);
                    }
                  );
            }
            c(u.arg);
          }
          var n;
          s(this, "_invoke", {
            value: function (e, r) {
              function s() {
                return new t(function (t, s) {
                  a(e, r, t, s);
                });
              }
              return (n = n ? n.then(s, s) : s());
            }
          });
        }
        function b(e, t, r) {
          var s = "suspendedStart";
          return function (a, n) {
            if ("executing" === s) throw new Error("Generator is already running");
            if ("completed" === s) {
              if ("throw" === a) throw n;
              return x();
            }
            for (r.method = a, r.arg = n; ; ) {
              var i = r.delegate;
              if (i) {
                var o = T(i, r);
                if (o) {
                  if (o === h) continue;
                  return o;
                }
              }
              if ("next" === r.method) r.sent = r._sent = r.arg;
              else if ("throw" === r.method) {
                if ("suspendedStart" === s) throw ((s = "completed"), r.arg);
                r.dispatchException(r.arg);
              } else "return" === r.method && r.abrupt("return", r.arg);
              s = "executing";
              var c = p(e, t, r);
              if ("normal" === c.type) {
                if (((s = r.done ? "completed" : "suspendedYield"), c.arg === h)) continue;
                return { value: c.arg, done: r.done };
              }
              "throw" === c.type && ((s = "completed"), (r.method = "throw"), (r.arg = c.arg));
            }
          };
        }
        function T(e, t) {
          var r = t.method,
            s = e.iterator[r];
          if (void 0 === s)
            return (
              (t.delegate = null),
              ("throw" === r && e.iterator.return && ((t.method = "return"), (t.arg = void 0), T(e, t), "throw" === t.method)) ||
                ("return" !== r && ((t.method = "throw"), (t.arg = new TypeError("The iterator does not provide a '" + r + "' method")))),
              h
            );
          var a = p(s, e.iterator, t.arg);
          if ("throw" === a.type) return (t.method = "throw"), (t.arg = a.arg), (t.delegate = null), h;
          var n = a.arg;
          return n
            ? n.done
              ? ((t[e.resultName] = n.value),
                (t.next = e.nextLoc),
                "return" !== t.method && ((t.method = "next"), (t.arg = void 0)),
                (t.delegate = null),
                h)
              : n
            : ((t.method = "throw"), (t.arg = new TypeError("iterator result is not an object")), (t.delegate = null), h);
        }
        function A(e) {
          var t = { tryLoc: e[0] };
          1 in e && (t.catchLoc = e[1]), 2 in e && ((t.finallyLoc = e[2]), (t.afterLoc = e[3])), this.tryEntries.push(t);
        }
        function C(e) {
          var t = e.completion || {};
          (t.type = "normal"), delete t.arg, (e.completion = t);
        }
        function R(e) {
          (this.tryEntries = [{ tryLoc: "root" }]), e.forEach(A, this), this.reset(!0);
        }
        function I(e) {
          if (e) {
            var t = e[n];
            if (t) return t.call(e);
            if ("function" == typeof e.next) return e;
            if (!isNaN(e.length)) {
              var s = -1,
                a = function t() {
                  for (; ++s < e.length; ) if (r.call(e, s)) return (t.value = e[s]), (t.done = !1), t;
                  return (t.value = void 0), (t.done = !0), t;
                };
              return (a.next = a);
            }
          }
          return { next: x };
        }
        function x() {
          return { value: void 0, done: !0 };
        }
        return (
          (y.prototype = g),
          s(S, "constructor", { value: g, configurable: !0 }),
          s(g, "constructor", { value: y, configurable: !0 }),
          (y.displayName = d(g, u, "GeneratorFunction")),
          (e.isGeneratorFunction = function (e) {
            var t = "function" == typeof e && e.constructor;
            return !!t && (t === y || "GeneratorFunction" === (t.displayName || t.name));
          }),
          (e.mark = function (e) {
            return (
              Object.setPrototypeOf ? Object.setPrototypeOf(e, g) : ((e.__proto__ = g), d(e, u, "GeneratorFunction")),
              (e.prototype = Object.create(S)),
              e
            );
          }),
          (e.awrap = function (e) {
            return { __await: e };
          }),
          E(_.prototype),
          d(_.prototype, c, function () {
            return this;
          }),
          (e.AsyncIterator = _),
          (e.async = function (t, r, s, a, n) {
            void 0 === n && (n = Promise);
            var i = new _(l(t, r, s, a), n);
            return e.isGeneratorFunction(r)
              ? i
              : i.next().then(function (e) {
                  return e.done ? e.value : i.next();
                });
          }),
          E(S),
          d(S, u, "Generator"),
          d(S, n, function () {
            return this;
          }),
          d(S, "toString", function () {
            return "[object Generator]";
          }),
          (e.keys = function (e) {
            var t = Object(e),
              r = [];
            for (var s in t) r.push(s);
            return (
              r.reverse(),
              function e() {
                for (; r.length; ) {
                  var s = r.pop();
                  if (s in t) return (e.value = s), (e.done = !1), e;
                }
                return (e.done = !0), e;
              }
            );
          }),
          (e.values = I),
          (R.prototype = {
            constructor: R,
            reset: function (e) {
              if (
                ((this.prev = 0),
                (this.next = 0),
                (this.sent = this._sent = void 0),
                (this.done = !1),
                (this.delegate = null),
                (this.method = "next"),
                (this.arg = void 0),
                this.tryEntries.forEach(C),
                !e)
              )
                for (var t in this) "t" === t.charAt(0) && r.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0);
            },
            stop: function () {
              this.done = !0;
              var e = this.tryEntries[0].completion;
              if ("throw" === e.type) throw e.arg;
              return this.rval;
            },
            dispatchException: function (e) {
              if (this.done) throw e;
              var t = this;
              function s(r, s) {
                return (i.type = "throw"), (i.arg = e), (t.next = r), s && ((t.method = "next"), (t.arg = void 0)), !!s;
              }
              for (var a = this.tryEntries.length - 1; a >= 0; --a) {
                var n = this.tryEntries[a],
                  i = n.completion;
                if ("root" === n.tryLoc) return s("end");
                if (n.tryLoc <= this.prev) {
                  var o = r.call(n, "catchLoc"),
                    c = r.call(n, "finallyLoc");
                  if (o && c) {
                    if (this.prev < n.catchLoc) return s(n.catchLoc, !0);
                    if (this.prev < n.finallyLoc) return s(n.finallyLoc);
                  } else if (o) {
                    if (this.prev < n.catchLoc) return s(n.catchLoc, !0);
                  } else {
                    if (!c) throw new Error("try statement without catch or finally");
                    if (this.prev < n.finallyLoc) return s(n.finallyLoc);
                  }
                }
              }
            },
            abrupt: function (e, t) {
              for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                var a = this.tryEntries[s];
                if (a.tryLoc <= this.prev && r.call(a, "finallyLoc") && this.prev < a.finallyLoc) {
                  var n = a;
                  break;
                }
              }
              n && ("break" === e || "continue" === e) && n.tryLoc <= t && t <= n.finallyLoc && (n = null);
              var i = n ? n.completion : {};
              return (i.type = e), (i.arg = t), n ? ((this.method = "next"), (this.next = n.finallyLoc), h) : this.complete(i);
            },
            complete: function (e, t) {
              if ("throw" === e.type) throw e.arg;
              return (
                "break" === e.type || "continue" === e.type
                  ? (this.next = e.arg)
                  : "return" === e.type
                  ? ((this.rval = this.arg = e.arg), (this.method = "return"), (this.next = "end"))
                  : "normal" === e.type && t && (this.next = t),
                h
              );
            },
            finish: function (e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), C(r), h;
              }
            },
            catch: function (e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.tryLoc === e) {
                  var s = r.completion;
                  if ("throw" === s.type) {
                    var a = s.arg;
                    C(r);
                  }
                  return a;
                }
              }
              throw new Error("illegal catch attempt");
            },
            delegateYield: function (e, t, r) {
              return (this.delegate = { iterator: I(e), resultName: t, nextLoc: r }), "next" === this.method && (this.arg = void 0), h;
            }
          }),
          e
        );
      }
      function c(e, t, r, s, a, n, i) {
        try {
          var o = e[n](i),
            c = o.value;
        } catch (e) {
          return void r(e);
        }
        o.done ? t(c) : Promise.resolve(c).then(s, a);
      }
      var u = " ";
      function d(e, t) {
        return l.apply(this, arguments);
      }
      function l() {
        var e;
        return (
          (e = o().mark(function e(t, r) {
            var i, c, d, l;
            return o().wrap(
              function (e) {
                for (;;)
                  switch ((e.prev = e.next)) {
                    case 0:
                      return (e.prev = 0), (e.next = 3), (0, s.U)(t);
                    case 3:
                      if (
                        ((i = e.sent), "controllable_by_this_extension" === (c = i.levelOfControl) || "controlled_by_this_extension" === c)
                      ) {
                        e.next = 8;
                        break;
                      }
                      throw (
                        ((d = [
                          "Impossible to change browser setting: ".concat(t, "."),
                          "Extension prevented from changing: ".concat(c)
                        ].join(u)),
                        new Error(d))
                      );
                    case 8:
                      e.next = 18;
                      break;
                    case 10:
                      if (((e.prev = 10), (e.t0 = e.catch(0)), !(0, a.b)(e.t0))) {
                        e.next = 15;
                        break;
                      }
                      throw ((l = "Browser setting not supported: ".concat(t)), new Error(l));
                    case 15:
                      if (!(0, a.I)(e.t0)) {
                        e.next = 17;
                        break;
                      }
                      throw e.t0.runtimeError;
                    case 17:
                      throw e.t0;
                    case 18:
                      return (e.prev = 18), (e.next = 21), (0, n.t)(t, r);
                    case 21:
                      e.next = 27;
                      break;
                    case 23:
                      throw ((e.prev = 23), (e.t1 = e.catch(18)), (0, a.I)(e.t1) ? e.t1.runtimeError : e.t1);
                    case 27:
                    case "end":
                      return e.stop();
                  }
              },
              e,
              null,
              [
                [0, 10],
                [18, 23]
              ]
            );
          })),
          (l = function () {
            var t = this,
              r = arguments;
            return new Promise(function (s, a) {
              var n = e.apply(t, r);
              function i(e) {
                c(n, s, a, i, o, "next", e);
              }
              function o(e) {
                c(n, s, a, i, o, "throw", e);
              }
              i(void 0);
            });
          }),
          l.apply(this, arguments)
        );
      }
      function p(e) {
        return (
          (p =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                }),
          p(e)
        );
      }
      function h() {
        h = function () {
          return e;
        };
        var e = {},
          t = Object.prototype,
          r = t.hasOwnProperty,
          s =
            Object.defineProperty ||
            function (e, t, r) {
              e[t] = r.value;
            },
          a = "function" == typeof Symbol ? Symbol : {},
          n = a.iterator || "@@iterator",
          i = a.asyncIterator || "@@asyncIterator",
          o = a.toStringTag || "@@toStringTag";
        function c(e, t, r) {
          return Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }), e[t];
        }
        try {
          c({}, "");
        } catch (e) {
          c = function (e, t, r) {
            return (e[t] = r);
          };
        }
        function u(e, t, r, a) {
          var n = t && t.prototype instanceof m ? t : m,
            i = Object.create(n.prototype),
            o = new R(a || []);
          return s(i, "_invoke", { value: b(e, r, o) }), i;
        }
        function d(e, t, r) {
          try {
            return { type: "normal", arg: e.call(t, r) };
          } catch (e) {
            return { type: "throw", arg: e };
          }
        }
        e.wrap = u;
        var l = {};
        function m() {}
        function y() {}
        function g() {}
        var v = {};
        c(v, n, function () {
          return this;
        });
        var f = Object.getPrototypeOf,
          w = f && f(f(I([])));
        w && w !== t && r.call(w, n) && (v = w);
        var S = (g.prototype = m.prototype = Object.create(v));
        function E(e) {
          ["next", "throw", "return"].forEach(function (t) {
            c(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function _(e, t) {
          function a(s, n, i, o) {
            var c = d(e[s], e, n);
            if ("throw" !== c.type) {
              var u = c.arg,
                l = u.value;
              return l && "object" == p(l) && r.call(l, "__await")
                ? t.resolve(l.__await).then(
                    function (e) {
                      a("next", e, i, o);
                    },
                    function (e) {
                      a("throw", e, i, o);
                    }
                  )
                : t.resolve(l).then(
                    function (e) {
                      (u.value = e), i(u);
                    },
                    function (e) {
                      return a("throw", e, i, o);
                    }
                  );
            }
            o(c.arg);
          }
          var n;
          s(this, "_invoke", {
            value: function (e, r) {
              function s() {
                return new t(function (t, s) {
                  a(e, r, t, s);
                });
              }
              return (n = n ? n.then(s, s) : s());
            }
          });
        }
        function b(e, t, r) {
          var s = "suspendedStart";
          return function (a, n) {
            if ("executing" === s) throw new Error("Generator is already running");
            if ("completed" === s) {
              if ("throw" === a) throw n;
              return x();
            }
            for (r.method = a, r.arg = n; ; ) {
              var i = r.delegate;
              if (i) {
                var o = T(i, r);
                if (o) {
                  if (o === l) continue;
                  return o;
                }
              }
              if ("next" === r.method) r.sent = r._sent = r.arg;
              else if ("throw" === r.method) {
                if ("suspendedStart" === s) throw ((s = "completed"), r.arg);
                r.dispatchException(r.arg);
              } else "return" === r.method && r.abrupt("return", r.arg);
              s = "executing";
              var c = d(e, t, r);
              if ("normal" === c.type) {
                if (((s = r.done ? "completed" : "suspendedYield"), c.arg === l)) continue;
                return { value: c.arg, done: r.done };
              }
              "throw" === c.type && ((s = "completed"), (r.method = "throw"), (r.arg = c.arg));
            }
          };
        }
        function T(e, t) {
          var r = t.method,
            s = e.iterator[r];
          if (void 0 === s)
            return (
              (t.delegate = null),
              ("throw" === r && e.iterator.return && ((t.method = "return"), (t.arg = void 0), T(e, t), "throw" === t.method)) ||
                ("return" !== r && ((t.method = "throw"), (t.arg = new TypeError("The iterator does not provide a '" + r + "' method")))),
              l
            );
          var a = d(s, e.iterator, t.arg);
          if ("throw" === a.type) return (t.method = "throw"), (t.arg = a.arg), (t.delegate = null), l;
          var n = a.arg;
          return n
            ? n.done
              ? ((t[e.resultName] = n.value),
                (t.next = e.nextLoc),
                "return" !== t.method && ((t.method = "next"), (t.arg = void 0)),
                (t.delegate = null),
                l)
              : n
            : ((t.method = "throw"), (t.arg = new TypeError("iterator result is not an object")), (t.delegate = null), l);
        }
        function A(e) {
          var t = { tryLoc: e[0] };
          1 in e && (t.catchLoc = e[1]), 2 in e && ((t.finallyLoc = e[2]), (t.afterLoc = e[3])), this.tryEntries.push(t);
        }
        function C(e) {
          var t = e.completion || {};
          (t.type = "normal"), delete t.arg, (e.completion = t);
        }
        function R(e) {
          (this.tryEntries = [{ tryLoc: "root" }]), e.forEach(A, this), this.reset(!0);
        }
        function I(e) {
          if (e) {
            var t = e[n];
            if (t) return t.call(e);
            if ("function" == typeof e.next) return e;
            if (!isNaN(e.length)) {
              var s = -1,
                a = function t() {
                  for (; ++s < e.length; ) if (r.call(e, s)) return (t.value = e[s]), (t.done = !1), t;
                  return (t.value = void 0), (t.done = !0), t;
                };
              return (a.next = a);
            }
          }
          return { next: x };
        }
        function x() {
          return { value: void 0, done: !0 };
        }
        return (
          (y.prototype = g),
          s(S, "constructor", { value: g, configurable: !0 }),
          s(g, "constructor", { value: y, configurable: !0 }),
          (y.displayName = c(g, o, "GeneratorFunction")),
          (e.isGeneratorFunction = function (e) {
            var t = "function" == typeof e && e.constructor;
            return !!t && (t === y || "GeneratorFunction" === (t.displayName || t.name));
          }),
          (e.mark = function (e) {
            return (
              Object.setPrototypeOf ? Object.setPrototypeOf(e, g) : ((e.__proto__ = g), c(e, o, "GeneratorFunction")),
              (e.prototype = Object.create(S)),
              e
            );
          }),
          (e.awrap = function (e) {
            return { __await: e };
          }),
          E(_.prototype),
          c(_.prototype, i, function () {
            return this;
          }),
          (e.AsyncIterator = _),
          (e.async = function (t, r, s, a, n) {
            void 0 === n && (n = Promise);
            var i = new _(u(t, r, s, a), n);
            return e.isGeneratorFunction(r)
              ? i
              : i.next().then(function (e) {
                  return e.done ? e.value : i.next();
                });
          }),
          E(S),
          c(S, o, "Generator"),
          c(S, n, function () {
            return this;
          }),
          c(S, "toString", function () {
            return "[object Generator]";
          }),
          (e.keys = function (e) {
            var t = Object(e),
              r = [];
            for (var s in t) r.push(s);
            return (
              r.reverse(),
              function e() {
                for (; r.length; ) {
                  var s = r.pop();
                  if (s in t) return (e.value = s), (e.done = !1), e;
                }
                return (e.done = !0), e;
              }
            );
          }),
          (e.values = I),
          (R.prototype = {
            constructor: R,
            reset: function (e) {
              if (
                ((this.prev = 0),
                (this.next = 0),
                (this.sent = this._sent = void 0),
                (this.done = !1),
                (this.delegate = null),
                (this.method = "next"),
                (this.arg = void 0),
                this.tryEntries.forEach(C),
                !e)
              )
                for (var t in this) "t" === t.charAt(0) && r.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0);
            },
            stop: function () {
              this.done = !0;
              var e = this.tryEntries[0].completion;
              if ("throw" === e.type) throw e.arg;
              return this.rval;
            },
            dispatchException: function (e) {
              if (this.done) throw e;
              var t = this;
              function s(r, s) {
                return (i.type = "throw"), (i.arg = e), (t.next = r), s && ((t.method = "next"), (t.arg = void 0)), !!s;
              }
              for (var a = this.tryEntries.length - 1; a >= 0; --a) {
                var n = this.tryEntries[a],
                  i = n.completion;
                if ("root" === n.tryLoc) return s("end");
                if (n.tryLoc <= this.prev) {
                  var o = r.call(n, "catchLoc"),
                    c = r.call(n, "finallyLoc");
                  if (o && c) {
                    if (this.prev < n.catchLoc) return s(n.catchLoc, !0);
                    if (this.prev < n.finallyLoc) return s(n.finallyLoc);
                  } else if (o) {
                    if (this.prev < n.catchLoc) return s(n.catchLoc, !0);
                  } else {
                    if (!c) throw new Error("try statement without catch or finally");
                    if (this.prev < n.finallyLoc) return s(n.finallyLoc);
                  }
                }
              }
            },
            abrupt: function (e, t) {
              for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                var a = this.tryEntries[s];
                if (a.tryLoc <= this.prev && r.call(a, "finallyLoc") && this.prev < a.finallyLoc) {
                  var n = a;
                  break;
                }
              }
              n && ("break" === e || "continue" === e) && n.tryLoc <= t && t <= n.finallyLoc && (n = null);
              var i = n ? n.completion : {};
              return (i.type = e), (i.arg = t), n ? ((this.method = "next"), (this.next = n.finallyLoc), l) : this.complete(i);
            },
            complete: function (e, t) {
              if ("throw" === e.type) throw e.arg;
              return (
                "break" === e.type || "continue" === e.type
                  ? (this.next = e.arg)
                  : "return" === e.type
                  ? ((this.rval = this.arg = e.arg), (this.method = "return"), (this.next = "end"))
                  : "normal" === e.type && t && (this.next = t),
                l
              );
            },
            finish: function (e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), C(r), l;
              }
            },
            catch: function (e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.tryLoc === e) {
                  var s = r.completion;
                  if ("throw" === s.type) {
                    var a = s.arg;
                    C(r);
                  }
                  return a;
                }
              }
              throw new Error("illegal catch attempt");
            },
            delegateYield: function (e, t, r) {
              return (this.delegate = { iterator: I(e), resultName: t, nextLoc: r }), "next" === this.method && (this.arg = void 0), l;
            }
          }),
          e
        );
      }
      function m(e, t, r, s, a, n, i) {
        try {
          var o = e[n](i),
            c = o.value;
        } catch (e) {
          return void r(e);
        }
        o.done ? t(c) : Promise.resolve(c).then(s, a);
      }
      function y() {
        return g.apply(this, arguments);
      }
      function g() {
        var e;
        return (
          (e = h().mark(function e() {
            var t;
            return h().wrap(function (e) {
              for (;;)
                switch ((e.prev = e.next)) {
                  case 0:
                    return (
                      (t = ["autofillAddressEnabled", "autofillCreditCardEnabled", "passwordSavingEnabled"].map(function (e) {
                        return d(e, !1);
                      })),
                      (e.next = 4),
                      Promise.all(t)
                    );
                  case 4:
                  case "end":
                    return e.stop();
                }
            }, e);
          })),
          (g = function () {
            var t = this,
              r = arguments;
            return new Promise(function (s, a) {
              var n = e.apply(t, r);
              function i(e) {
                m(n, s, a, i, o, "next", e);
              }
              function o(e) {
                m(n, s, a, i, o, "throw", e);
              }
              i(void 0);
            });
          }),
          g.apply(this, arguments)
        );
      }
    },
    88417: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => d });
      r(35758),
        r(82312),
        r(37391),
        r(75815),
        r(45749),
        r(2165),
        r(83746),
        r(37944),
        r(55402),
        r(22250),
        r(92665),
        r(88737),
        r(97979),
        r(38509),
        r(95665),
        r(41533),
        r(72029),
        r(71632),
        r(2191),
        r(4473),
        r(68126),
        r(75986),
        r(41437),
        r(5744),
        r(18549);
      var s = r(84318),
        a = r(16241);
      function n(e) {
        return (
          (n =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                }),
          n(e)
        );
      }
      function i() {
        i = function () {
          return e;
        };
        var e = {},
          t = Object.prototype,
          r = t.hasOwnProperty,
          s =
            Object.defineProperty ||
            function (e, t, r) {
              e[t] = r.value;
            },
          a = "function" == typeof Symbol ? Symbol : {},
          o = a.iterator || "@@iterator",
          c = a.asyncIterator || "@@asyncIterator",
          u = a.toStringTag || "@@toStringTag";
        function d(e, t, r) {
          return Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }), e[t];
        }
        try {
          d({}, "");
        } catch (e) {
          d = function (e, t, r) {
            return (e[t] = r);
          };
        }
        function l(e, t, r, a) {
          var n = t && t.prototype instanceof m ? t : m,
            i = Object.create(n.prototype),
            o = new R(a || []);
          return s(i, "_invoke", { value: b(e, r, o) }), i;
        }
        function p(e, t, r) {
          try {
            return { type: "normal", arg: e.call(t, r) };
          } catch (e) {
            return { type: "throw", arg: e };
          }
        }
        e.wrap = l;
        var h = {};
        function m() {}
        function y() {}
        function g() {}
        var v = {};
        d(v, o, function () {
          return this;
        });
        var f = Object.getPrototypeOf,
          w = f && f(f(I([])));
        w && w !== t && r.call(w, o) && (v = w);
        var S = (g.prototype = m.prototype = Object.create(v));
        function E(e) {
          ["next", "throw", "return"].forEach(function (t) {
            d(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function _(e, t) {
          function a(s, i, o, c) {
            var u = p(e[s], e, i);
            if ("throw" !== u.type) {
              var d = u.arg,
                l = d.value;
              return l && "object" == n(l) && r.call(l, "__await")
                ? t.resolve(l.__await).then(
                    function (e) {
                      a("next", e, o, c);
                    },
                    function (e) {
                      a("throw", e, o, c);
                    }
                  )
                : t.resolve(l).then(
                    function (e) {
                      (d.value = e), o(d);
                    },
                    function (e) {
                      return a("throw", e, o, c);
                    }
                  );
            }
            c(u.arg);
          }
          var i;
          s(this, "_invoke", {
            value: function (e, r) {
              function s() {
                return new t(function (t, s) {
                  a(e, r, t, s);
                });
              }
              return (i = i ? i.then(s, s) : s());
            }
          });
        }
        function b(e, t, r) {
          var s = "suspendedStart";
          return function (a, n) {
            if ("executing" === s) throw new Error("Generator is already running");
            if ("completed" === s) {
              if ("throw" === a) throw n;
              return x();
            }
            for (r.method = a, r.arg = n; ; ) {
              var i = r.delegate;
              if (i) {
                var o = T(i, r);
                if (o) {
                  if (o === h) continue;
                  return o;
                }
              }
              if ("next" === r.method) r.sent = r._sent = r.arg;
              else if ("throw" === r.method) {
                if ("suspendedStart" === s) throw ((s = "completed"), r.arg);
                r.dispatchException(r.arg);
              } else "return" === r.method && r.abrupt("return", r.arg);
              s = "executing";
              var c = p(e, t, r);
              if ("normal" === c.type) {
                if (((s = r.done ? "completed" : "suspendedYield"), c.arg === h)) continue;
                return { value: c.arg, done: r.done };
              }
              "throw" === c.type && ((s = "completed"), (r.method = "throw"), (r.arg = c.arg));
            }
          };
        }
        function T(e, t) {
          var r = t.method,
            s = e.iterator[r];
          if (void 0 === s)
            return (
              (t.delegate = null),
              ("throw" === r && e.iterator.return && ((t.method = "return"), (t.arg = void 0), T(e, t), "throw" === t.method)) ||
                ("return" !== r && ((t.method = "throw"), (t.arg = new TypeError("The iterator does not provide a '" + r + "' method")))),
              h
            );
          var a = p(s, e.iterator, t.arg);
          if ("throw" === a.type) return (t.method = "throw"), (t.arg = a.arg), (t.delegate = null), h;
          var n = a.arg;
          return n
            ? n.done
              ? ((t[e.resultName] = n.value),
                (t.next = e.nextLoc),
                "return" !== t.method && ((t.method = "next"), (t.arg = void 0)),
                (t.delegate = null),
                h)
              : n
            : ((t.method = "throw"), (t.arg = new TypeError("iterator result is not an object")), (t.delegate = null), h);
        }
        function A(e) {
          var t = { tryLoc: e[0] };
          1 in e && (t.catchLoc = e[1]), 2 in e && ((t.finallyLoc = e[2]), (t.afterLoc = e[3])), this.tryEntries.push(t);
        }
        function C(e) {
          var t = e.completion || {};
          (t.type = "normal"), delete t.arg, (e.completion = t);
        }
        function R(e) {
          (this.tryEntries = [{ tryLoc: "root" }]), e.forEach(A, this), this.reset(!0);
        }
        function I(e) {
          if (e) {
            var t = e[o];
            if (t) return t.call(e);
            if ("function" == typeof e.next) return e;
            if (!isNaN(e.length)) {
              var s = -1,
                a = function t() {
                  for (; ++s < e.length; ) if (r.call(e, s)) return (t.value = e[s]), (t.done = !1), t;
                  return (t.value = void 0), (t.done = !0), t;
                };
              return (a.next = a);
            }
          }
          return { next: x };
        }
        function x() {
          return { value: void 0, done: !0 };
        }
        return (
          (y.prototype = g),
          s(S, "constructor", { value: g, configurable: !0 }),
          s(g, "constructor", { value: y, configurable: !0 }),
          (y.displayName = d(g, u, "GeneratorFunction")),
          (e.isGeneratorFunction = function (e) {
            var t = "function" == typeof e && e.constructor;
            return !!t && (t === y || "GeneratorFunction" === (t.displayName || t.name));
          }),
          (e.mark = function (e) {
            return (
              Object.setPrototypeOf ? Object.setPrototypeOf(e, g) : ((e.__proto__ = g), d(e, u, "GeneratorFunction")),
              (e.prototype = Object.create(S)),
              e
            );
          }),
          (e.awrap = function (e) {
            return { __await: e };
          }),
          E(_.prototype),
          d(_.prototype, c, function () {
            return this;
          }),
          (e.AsyncIterator = _),
          (e.async = function (t, r, s, a, n) {
            void 0 === n && (n = Promise);
            var i = new _(l(t, r, s, a), n);
            return e.isGeneratorFunction(r)
              ? i
              : i.next().then(function (e) {
                  return e.done ? e.value : i.next();
                });
          }),
          E(S),
          d(S, u, "Generator"),
          d(S, o, function () {
            return this;
          }),
          d(S, "toString", function () {
            return "[object Generator]";
          }),
          (e.keys = function (e) {
            var t = Object(e),
              r = [];
            for (var s in t) r.push(s);
            return (
              r.reverse(),
              function e() {
                for (; r.length; ) {
                  var s = r.pop();
                  if (s in t) return (e.value = s), (e.done = !1), e;
                }
                return (e.done = !0), e;
              }
            );
          }),
          (e.values = I),
          (R.prototype = {
            constructor: R,
            reset: function (e) {
              if (
                ((this.prev = 0),
                (this.next = 0),
                (this.sent = this._sent = void 0),
                (this.done = !1),
                (this.delegate = null),
                (this.method = "next"),
                (this.arg = void 0),
                this.tryEntries.forEach(C),
                !e)
              )
                for (var t in this) "t" === t.charAt(0) && r.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0);
            },
            stop: function () {
              this.done = !0;
              var e = this.tryEntries[0].completion;
              if ("throw" === e.type) throw e.arg;
              return this.rval;
            },
            dispatchException: function (e) {
              if (this.done) throw e;
              var t = this;
              function s(r, s) {
                return (i.type = "throw"), (i.arg = e), (t.next = r), s && ((t.method = "next"), (t.arg = void 0)), !!s;
              }
              for (var a = this.tryEntries.length - 1; a >= 0; --a) {
                var n = this.tryEntries[a],
                  i = n.completion;
                if ("root" === n.tryLoc) return s("end");
                if (n.tryLoc <= this.prev) {
                  var o = r.call(n, "catchLoc"),
                    c = r.call(n, "finallyLoc");
                  if (o && c) {
                    if (this.prev < n.catchLoc) return s(n.catchLoc, !0);
                    if (this.prev < n.finallyLoc) return s(n.finallyLoc);
                  } else if (o) {
                    if (this.prev < n.catchLoc) return s(n.catchLoc, !0);
                  } else {
                    if (!c) throw new Error("try statement without catch or finally");
                    if (this.prev < n.finallyLoc) return s(n.finallyLoc);
                  }
                }
              }
            },
            abrupt: function (e, t) {
              for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                var a = this.tryEntries[s];
                if (a.tryLoc <= this.prev && r.call(a, "finallyLoc") && this.prev < a.finallyLoc) {
                  var n = a;
                  break;
                }
              }
              n && ("break" === e || "continue" === e) && n.tryLoc <= t && t <= n.finallyLoc && (n = null);
              var i = n ? n.completion : {};
              return (i.type = e), (i.arg = t), n ? ((this.method = "next"), (this.next = n.finallyLoc), h) : this.complete(i);
            },
            complete: function (e, t) {
              if ("throw" === e.type) throw e.arg;
              return (
                "break" === e.type || "continue" === e.type
                  ? (this.next = e.arg)
                  : "return" === e.type
                  ? ((this.rval = this.arg = e.arg), (this.method = "return"), (this.next = "end"))
                  : "normal" === e.type && t && (this.next = t),
                h
              );
            },
            finish: function (e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), C(r), h;
              }
            },
            catch: function (e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.tryLoc === e) {
                  var s = r.completion;
                  if ("throw" === s.type) {
                    var a = s.arg;
                    C(r);
                  }
                  return a;
                }
              }
              throw new Error("illegal catch attempt");
            },
            delegateYield: function (e, t, r) {
              return (this.delegate = { iterator: I(e), resultName: t, nextLoc: r }), "next" === this.method && (this.arg = void 0), h;
            }
          }),
          e
        );
      }
      function o(e, t, r, s, a, n, i) {
        try {
          var o = e[n](i),
            c = o.value;
        } catch (e) {
          return void r(e);
        }
        o.done ? t(c) : Promise.resolve(c).then(s, a);
      }
      var c = { nightly: "icon_nightly_auth", mv2: "icon_auth", mv3: "icon_mv3_auth" },
        u = "icon_not_auth";
      function d(e) {
        return l.apply(this, arguments);
      }
      function l() {
        var e;
        return (
          (e = i().mark(function e(t) {
            var r, n, o, d;
            return i().wrap(function (e) {
              for (;;)
                switch ((e.prev = e.next)) {
                  case 0:
                    return (
                      (r = t.isUserAuthenticated),
                      (n = r
                        ? ((i = void 0),
                          (i = (0, s.W)()).name.includes("Nightly")
                            ? c.nightly
                            : i.name.includes("Beta") || 3 === i.manifest_version
                            ? c.mv3
                            : c.mv2)
                        : u),
                      (o = "icons/action/".concat(n)),
                      (d = { 16: "".concat(o, ".png"), 32: "".concat(o, "@2x.png") }),
                      (e.next = 6),
                      (0, a.B)(d)
                    );
                  case 6:
                  case "end":
                    return e.stop();
                }
              var i;
            }, e);
          })),
          (l = function () {
            var t = this,
              r = arguments;
            return new Promise(function (s, a) {
              var n = e.apply(t, r);
              function i(e) {
                o(n, s, a, i, c, "next", e);
              }
              function c(e) {
                o(n, s, a, i, c, "throw", e);
              }
              i(void 0);
            });
          }),
          l.apply(this, arguments)
        );
      }
    },
    36956: (e, t, r) => {
      "use strict";
      r.d(t, { $: () => u });
      r(38298),
        r(86847),
        r(22250),
        r(75815),
        r(45749),
        r(92665),
        r(88737),
        r(23041),
        r(37391),
        r(2165),
        r(83746),
        r(37944),
        r(55402),
        r(97979),
        r(38509),
        r(95665),
        r(41533),
        r(72029),
        r(71632),
        r(2191),
        r(4473),
        r(68126),
        r(75986),
        r(41437),
        r(5744),
        r(18549);
      var s = r(329),
        a = r(98641);
      function n(e) {
        return (
          (n =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                }),
          n(e)
        );
      }
      function i() {
        i = function () {
          return e;
        };
        var e = {},
          t = Object.prototype,
          r = t.hasOwnProperty,
          s =
            Object.defineProperty ||
            function (e, t, r) {
              e[t] = r.value;
            },
          a = "function" == typeof Symbol ? Symbol : {},
          o = a.iterator || "@@iterator",
          c = a.asyncIterator || "@@asyncIterator",
          u = a.toStringTag || "@@toStringTag";
        function d(e, t, r) {
          return Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }), e[t];
        }
        try {
          d({}, "");
        } catch (e) {
          d = function (e, t, r) {
            return (e[t] = r);
          };
        }
        function l(e, t, r, a) {
          var n = t && t.prototype instanceof m ? t : m,
            i = Object.create(n.prototype),
            o = new R(a || []);
          return s(i, "_invoke", { value: b(e, r, o) }), i;
        }
        function p(e, t, r) {
          try {
            return { type: "normal", arg: e.call(t, r) };
          } catch (e) {
            return { type: "throw", arg: e };
          }
        }
        e.wrap = l;
        var h = {};
        function m() {}
        function y() {}
        function g() {}
        var v = {};
        d(v, o, function () {
          return this;
        });
        var f = Object.getPrototypeOf,
          w = f && f(f(I([])));
        w && w !== t && r.call(w, o) && (v = w);
        var S = (g.prototype = m.prototype = Object.create(v));
        function E(e) {
          ["next", "throw", "return"].forEach(function (t) {
            d(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function _(e, t) {
          function a(s, i, o, c) {
            var u = p(e[s], e, i);
            if ("throw" !== u.type) {
              var d = u.arg,
                l = d.value;
              return l && "object" == n(l) && r.call(l, "__await")
                ? t.resolve(l.__await).then(
                    function (e) {
                      a("next", e, o, c);
                    },
                    function (e) {
                      a("throw", e, o, c);
                    }
                  )
                : t.resolve(l).then(
                    function (e) {
                      (d.value = e), o(d);
                    },
                    function (e) {
                      return a("throw", e, o, c);
                    }
                  );
            }
            c(u.arg);
          }
          var i;
          s(this, "_invoke", {
            value: function (e, r) {
              function s() {
                return new t(function (t, s) {
                  a(e, r, t, s);
                });
              }
              return (i = i ? i.then(s, s) : s());
            }
          });
        }
        function b(e, t, r) {
          var s = "suspendedStart";
          return function (a, n) {
            if ("executing" === s) throw new Error("Generator is already running");
            if ("completed" === s) {
              if ("throw" === a) throw n;
              return x();
            }
            for (r.method = a, r.arg = n; ; ) {
              var i = r.delegate;
              if (i) {
                var o = T(i, r);
                if (o) {
                  if (o === h) continue;
                  return o;
                }
              }
              if ("next" === r.method) r.sent = r._sent = r.arg;
              else if ("throw" === r.method) {
                if ("suspendedStart" === s) throw ((s = "completed"), r.arg);
                r.dispatchException(r.arg);
              } else "return" === r.method && r.abrupt("return", r.arg);
              s = "executing";
              var c = p(e, t, r);
              if ("normal" === c.type) {
                if (((s = r.done ? "completed" : "suspendedYield"), c.arg === h)) continue;
                return { value: c.arg, done: r.done };
              }
              "throw" === c.type && ((s = "completed"), (r.method = "throw"), (r.arg = c.arg));
            }
          };
        }
        function T(e, t) {
          var r = t.method,
            s = e.iterator[r];
          if (void 0 === s)
            return (
              (t.delegate = null),
              ("throw" === r && e.iterator.return && ((t.method = "return"), (t.arg = void 0), T(e, t), "throw" === t.method)) ||
                ("return" !== r && ((t.method = "throw"), (t.arg = new TypeError("The iterator does not provide a '" + r + "' method")))),
              h
            );
          var a = p(s, e.iterator, t.arg);
          if ("throw" === a.type) return (t.method = "throw"), (t.arg = a.arg), (t.delegate = null), h;
          var n = a.arg;
          return n
            ? n.done
              ? ((t[e.resultName] = n.value),
                (t.next = e.nextLoc),
                "return" !== t.method && ((t.method = "next"), (t.arg = void 0)),
                (t.delegate = null),
                h)
              : n
            : ((t.method = "throw"), (t.arg = new TypeError("iterator result is not an object")), (t.delegate = null), h);
        }
        function A(e) {
          var t = { tryLoc: e[0] };
          1 in e && (t.catchLoc = e[1]), 2 in e && ((t.finallyLoc = e[2]), (t.afterLoc = e[3])), this.tryEntries.push(t);
        }
        function C(e) {
          var t = e.completion || {};
          (t.type = "normal"), delete t.arg, (e.completion = t);
        }
        function R(e) {
          (this.tryEntries = [{ tryLoc: "root" }]), e.forEach(A, this), this.reset(!0);
        }
        function I(e) {
          if (e) {
            var t = e[o];
            if (t) return t.call(e);
            if ("function" == typeof e.next) return e;
            if (!isNaN(e.length)) {
              var s = -1,
                a = function t() {
                  for (; ++s < e.length; ) if (r.call(e, s)) return (t.value = e[s]), (t.done = !1), t;
                  return (t.value = void 0), (t.done = !0), t;
                };
              return (a.next = a);
            }
          }
          return { next: x };
        }
        function x() {
          return { value: void 0, done: !0 };
        }
        return (
          (y.prototype = g),
          s(S, "constructor", { value: g, configurable: !0 }),
          s(g, "constructor", { value: y, configurable: !0 }),
          (y.displayName = d(g, u, "GeneratorFunction")),
          (e.isGeneratorFunction = function (e) {
            var t = "function" == typeof e && e.constructor;
            return !!t && (t === y || "GeneratorFunction" === (t.displayName || t.name));
          }),
          (e.mark = function (e) {
            return (
              Object.setPrototypeOf ? Object.setPrototypeOf(e, g) : ((e.__proto__ = g), d(e, u, "GeneratorFunction")),
              (e.prototype = Object.create(S)),
              e
            );
          }),
          (e.awrap = function (e) {
            return { __await: e };
          }),
          E(_.prototype),
          d(_.prototype, c, function () {
            return this;
          }),
          (e.AsyncIterator = _),
          (e.async = function (t, r, s, a, n) {
            void 0 === n && (n = Promise);
            var i = new _(l(t, r, s, a), n);
            return e.isGeneratorFunction(r)
              ? i
              : i.next().then(function (e) {
                  return e.done ? e.value : i.next();
                });
          }),
          E(S),
          d(S, u, "Generator"),
          d(S, o, function () {
            return this;
          }),
          d(S, "toString", function () {
            return "[object Generator]";
          }),
          (e.keys = function (e) {
            var t = Object(e),
              r = [];
            for (var s in t) r.push(s);
            return (
              r.reverse(),
              function e() {
                for (; r.length; ) {
                  var s = r.pop();
                  if (s in t) return (e.value = s), (e.done = !1), e;
                }
                return (e.done = !0), e;
              }
            );
          }),
          (e.values = I),
          (R.prototype = {
            constructor: R,
            reset: function (e) {
              if (
                ((this.prev = 0),
                (this.next = 0),
                (this.sent = this._sent = void 0),
                (this.done = !1),
                (this.delegate = null),
                (this.method = "next"),
                (this.arg = void 0),
                this.tryEntries.forEach(C),
                !e)
              )
                for (var t in this) "t" === t.charAt(0) && r.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0);
            },
            stop: function () {
              this.done = !0;
              var e = this.tryEntries[0].completion;
              if ("throw" === e.type) throw e.arg;
              return this.rval;
            },
            dispatchException: function (e) {
              if (this.done) throw e;
              var t = this;
              function s(r, s) {
                return (i.type = "throw"), (i.arg = e), (t.next = r), s && ((t.method = "next"), (t.arg = void 0)), !!s;
              }
              for (var a = this.tryEntries.length - 1; a >= 0; --a) {
                var n = this.tryEntries[a],
                  i = n.completion;
                if ("root" === n.tryLoc) return s("end");
                if (n.tryLoc <= this.prev) {
                  var o = r.call(n, "catchLoc"),
                    c = r.call(n, "finallyLoc");
                  if (o && c) {
                    if (this.prev < n.catchLoc) return s(n.catchLoc, !0);
                    if (this.prev < n.finallyLoc) return s(n.finallyLoc);
                  } else if (o) {
                    if (this.prev < n.catchLoc) return s(n.catchLoc, !0);
                  } else {
                    if (!c) throw new Error("try statement without catch or finally");
                    if (this.prev < n.finallyLoc) return s(n.finallyLoc);
                  }
                }
              }
            },
            abrupt: function (e, t) {
              for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                var a = this.tryEntries[s];
                if (a.tryLoc <= this.prev && r.call(a, "finallyLoc") && this.prev < a.finallyLoc) {
                  var n = a;
                  break;
                }
              }
              n && ("break" === e || "continue" === e) && n.tryLoc <= t && t <= n.finallyLoc && (n = null);
              var i = n ? n.completion : {};
              return (i.type = e), (i.arg = t), n ? ((this.method = "next"), (this.next = n.finallyLoc), h) : this.complete(i);
            },
            complete: function (e, t) {
              if ("throw" === e.type) throw e.arg;
              return (
                "break" === e.type || "continue" === e.type
                  ? (this.next = e.arg)
                  : "return" === e.type
                  ? ((this.rval = this.arg = e.arg), (this.method = "return"), (this.next = "end"))
                  : "normal" === e.type && t && (this.next = t),
                h
              );
            },
            finish: function (e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), C(r), h;
              }
            },
            catch: function (e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.tryLoc === e) {
                  var s = r.completion;
                  if ("throw" === s.type) {
                    var a = s.arg;
                    C(r);
                  }
                  return a;
                }
              }
              throw new Error("illegal catch attempt");
            },
            delegateYield: function (e, t, r) {
              return (this.delegate = { iterator: I(e), resultName: t, nextLoc: r }), "next" === this.method && (this.arg = void 0), h;
            }
          }),
          e
        );
      }
      function o(e, t, r, s, a, n, i) {
        try {
          var o = e[n](i),
            c = o.value;
        } catch (e) {
          return void r(e);
        }
        o.done ? t(c) : Promise.resolve(c).then(s, a);
      }
      function c(e) {
        var t = "http".concat(e.secure ? "s" : ""),
          r = e.domain.startsWith(".") ? e.domain.substring(1) : e.domain;
        return "".concat(t, "://").concat(r).concat(e.path);
      }
      function u(e) {
        return d.apply(this, arguments);
      }
      function d() {
        var e;
        return (
          (e = i().mark(function e(t) {
            var r;
            return i().wrap(function (e) {
              for (;;)
                switch ((e.prev = e.next)) {
                  case 0:
                    return (e.next = 2), (0, s.g)({ domain: t });
                  case 2:
                    return (
                      (r = e.sent),
                      e.abrupt(
                        "return",
                        Promise.all(
                          r.map(function (e) {
                            return (0, a.O)({ url: c(e), name: e.name });
                          })
                        )
                      )
                    );
                  case 4:
                  case "end":
                    return e.stop();
                }
            }, e);
          })),
          (d = function () {
            var t = this,
              r = arguments;
            return new Promise(function (s, a) {
              var n = e.apply(t, r);
              function i(e) {
                o(n, s, a, i, c, "next", e);
              }
              function c(e) {
                o(n, s, a, i, c, "throw", e);
              }
              i(void 0);
            });
          }),
          d.apply(this, arguments)
        );
      }
    },
    79563: (e, t, r) => {
      "use strict";
      r.d(t, { j: () => c });
      r(75815),
        r(45749),
        r(2165),
        r(83746),
        r(37944),
        r(55402),
        r(22250),
        r(92665),
        r(88737),
        r(97979),
        r(38509),
        r(95665),
        r(41533),
        r(72029),
        r(71632),
        r(2191),
        r(4473),
        r(68126),
        r(75986),
        r(37391),
        r(41437),
        r(5744),
        r(18549);
      var s = r(39680),
        a = r(41808);
      function n(e) {
        return (
          (n =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                }),
          n(e)
        );
      }
      function i() {
        i = function () {
          return e;
        };
        var e = {},
          t = Object.prototype,
          r = t.hasOwnProperty,
          s =
            Object.defineProperty ||
            function (e, t, r) {
              e[t] = r.value;
            },
          a = "function" == typeof Symbol ? Symbol : {},
          o = a.iterator || "@@iterator",
          c = a.asyncIterator || "@@asyncIterator",
          u = a.toStringTag || "@@toStringTag";
        function d(e, t, r) {
          return Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }), e[t];
        }
        try {
          d({}, "");
        } catch (e) {
          d = function (e, t, r) {
            return (e[t] = r);
          };
        }
        function l(e, t, r, a) {
          var n = t && t.prototype instanceof m ? t : m,
            i = Object.create(n.prototype),
            o = new R(a || []);
          return s(i, "_invoke", { value: b(e, r, o) }), i;
        }
        function p(e, t, r) {
          try {
            return { type: "normal", arg: e.call(t, r) };
          } catch (e) {
            return { type: "throw", arg: e };
          }
        }
        e.wrap = l;
        var h = {};
        function m() {}
        function y() {}
        function g() {}
        var v = {};
        d(v, o, function () {
          return this;
        });
        var f = Object.getPrototypeOf,
          w = f && f(f(I([])));
        w && w !== t && r.call(w, o) && (v = w);
        var S = (g.prototype = m.prototype = Object.create(v));
        function E(e) {
          ["next", "throw", "return"].forEach(function (t) {
            d(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function _(e, t) {
          function a(s, i, o, c) {
            var u = p(e[s], e, i);
            if ("throw" !== u.type) {
              var d = u.arg,
                l = d.value;
              return l && "object" == n(l) && r.call(l, "__await")
                ? t.resolve(l.__await).then(
                    function (e) {
                      a("next", e, o, c);
                    },
                    function (e) {
                      a("throw", e, o, c);
                    }
                  )
                : t.resolve(l).then(
                    function (e) {
                      (d.value = e), o(d);
                    },
                    function (e) {
                      return a("throw", e, o, c);
                    }
                  );
            }
            c(u.arg);
          }
          var i;
          s(this, "_invoke", {
            value: function (e, r) {
              function s() {
                return new t(function (t, s) {
                  a(e, r, t, s);
                });
              }
              return (i = i ? i.then(s, s) : s());
            }
          });
        }
        function b(e, t, r) {
          var s = "suspendedStart";
          return function (a, n) {
            if ("executing" === s) throw new Error("Generator is already running");
            if ("completed" === s) {
              if ("throw" === a) throw n;
              return x();
            }
            for (r.method = a, r.arg = n; ; ) {
              var i = r.delegate;
              if (i) {
                var o = T(i, r);
                if (o) {
                  if (o === h) continue;
                  return o;
                }
              }
              if ("next" === r.method) r.sent = r._sent = r.arg;
              else if ("throw" === r.method) {
                if ("suspendedStart" === s) throw ((s = "completed"), r.arg);
                r.dispatchException(r.arg);
              } else "return" === r.method && r.abrupt("return", r.arg);
              s = "executing";
              var c = p(e, t, r);
              if ("normal" === c.type) {
                if (((s = r.done ? "completed" : "suspendedYield"), c.arg === h)) continue;
                return { value: c.arg, done: r.done };
              }
              "throw" === c.type && ((s = "completed"), (r.method = "throw"), (r.arg = c.arg));
            }
          };
        }
        function T(e, t) {
          var r = t.method,
            s = e.iterator[r];
          if (void 0 === s)
            return (
              (t.delegate = null),
              ("throw" === r && e.iterator.return && ((t.method = "return"), (t.arg = void 0), T(e, t), "throw" === t.method)) ||
                ("return" !== r && ((t.method = "throw"), (t.arg = new TypeError("The iterator does not provide a '" + r + "' method")))),
              h
            );
          var a = p(s, e.iterator, t.arg);
          if ("throw" === a.type) return (t.method = "throw"), (t.arg = a.arg), (t.delegate = null), h;
          var n = a.arg;
          return n
            ? n.done
              ? ((t[e.resultName] = n.value),
                (t.next = e.nextLoc),
                "return" !== t.method && ((t.method = "next"), (t.arg = void 0)),
                (t.delegate = null),
                h)
              : n
            : ((t.method = "throw"), (t.arg = new TypeError("iterator result is not an object")), (t.delegate = null), h);
        }
        function A(e) {
          var t = { tryLoc: e[0] };
          1 in e && (t.catchLoc = e[1]), 2 in e && ((t.finallyLoc = e[2]), (t.afterLoc = e[3])), this.tryEntries.push(t);
        }
        function C(e) {
          var t = e.completion || {};
          (t.type = "normal"), delete t.arg, (e.completion = t);
        }
        function R(e) {
          (this.tryEntries = [{ tryLoc: "root" }]), e.forEach(A, this), this.reset(!0);
        }
        function I(e) {
          if (e) {
            var t = e[o];
            if (t) return t.call(e);
            if ("function" == typeof e.next) return e;
            if (!isNaN(e.length)) {
              var s = -1,
                a = function t() {
                  for (; ++s < e.length; ) if (r.call(e, s)) return (t.value = e[s]), (t.done = !1), t;
                  return (t.value = void 0), (t.done = !0), t;
                };
              return (a.next = a);
            }
          }
          return { next: x };
        }
        function x() {
          return { value: void 0, done: !0 };
        }
        return (
          (y.prototype = g),
          s(S, "constructor", { value: g, configurable: !0 }),
          s(g, "constructor", { value: y, configurable: !0 }),
          (y.displayName = d(g, u, "GeneratorFunction")),
          (e.isGeneratorFunction = function (e) {
            var t = "function" == typeof e && e.constructor;
            return !!t && (t === y || "GeneratorFunction" === (t.displayName || t.name));
          }),
          (e.mark = function (e) {
            return (
              Object.setPrototypeOf ? Object.setPrototypeOf(e, g) : ((e.__proto__ = g), d(e, u, "GeneratorFunction")),
              (e.prototype = Object.create(S)),
              e
            );
          }),
          (e.awrap = function (e) {
            return { __await: e };
          }),
          E(_.prototype),
          d(_.prototype, c, function () {
            return this;
          }),
          (e.AsyncIterator = _),
          (e.async = function (t, r, s, a, n) {
            void 0 === n && (n = Promise);
            var i = new _(l(t, r, s, a), n);
            return e.isGeneratorFunction(r)
              ? i
              : i.next().then(function (e) {
                  return e.done ? e.value : i.next();
                });
          }),
          E(S),
          d(S, u, "Generator"),
          d(S, o, function () {
            return this;
          }),
          d(S, "toString", function () {
            return "[object Generator]";
          }),
          (e.keys = function (e) {
            var t = Object(e),
              r = [];
            for (var s in t) r.push(s);
            return (
              r.reverse(),
              function e() {
                for (; r.length; ) {
                  var s = r.pop();
                  if (s in t) return (e.value = s), (e.done = !1), e;
                }
                return (e.done = !0), e;
              }
            );
          }),
          (e.values = I),
          (R.prototype = {
            constructor: R,
            reset: function (e) {
              if (
                ((this.prev = 0),
                (this.next = 0),
                (this.sent = this._sent = void 0),
                (this.done = !1),
                (this.delegate = null),
                (this.method = "next"),
                (this.arg = void 0),
                this.tryEntries.forEach(C),
                !e)
              )
                for (var t in this) "t" === t.charAt(0) && r.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0);
            },
            stop: function () {
              this.done = !0;
              var e = this.tryEntries[0].completion;
              if ("throw" === e.type) throw e.arg;
              return this.rval;
            },
            dispatchException: function (e) {
              if (this.done) throw e;
              var t = this;
              function s(r, s) {
                return (i.type = "throw"), (i.arg = e), (t.next = r), s && ((t.method = "next"), (t.arg = void 0)), !!s;
              }
              for (var a = this.tryEntries.length - 1; a >= 0; --a) {
                var n = this.tryEntries[a],
                  i = n.completion;
                if ("root" === n.tryLoc) return s("end");
                if (n.tryLoc <= this.prev) {
                  var o = r.call(n, "catchLoc"),
                    c = r.call(n, "finallyLoc");
                  if (o && c) {
                    if (this.prev < n.catchLoc) return s(n.catchLoc, !0);
                    if (this.prev < n.finallyLoc) return s(n.finallyLoc);
                  } else if (o) {
                    if (this.prev < n.catchLoc) return s(n.catchLoc, !0);
                  } else {
                    if (!c) throw new Error("try statement without catch or finally");
                    if (this.prev < n.finallyLoc) return s(n.finallyLoc);
                  }
                }
              }
            },
            abrupt: function (e, t) {
              for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                var a = this.tryEntries[s];
                if (a.tryLoc <= this.prev && r.call(a, "finallyLoc") && this.prev < a.finallyLoc) {
                  var n = a;
                  break;
                }
              }
              n && ("break" === e || "continue" === e) && n.tryLoc <= t && t <= n.finallyLoc && (n = null);
              var i = n ? n.completion : {};
              return (i.type = e), (i.arg = t), n ? ((this.method = "next"), (this.next = n.finallyLoc), h) : this.complete(i);
            },
            complete: function (e, t) {
              if ("throw" === e.type) throw e.arg;
              return (
                "break" === e.type || "continue" === e.type
                  ? (this.next = e.arg)
                  : "return" === e.type
                  ? ((this.rval = this.arg = e.arg), (this.method = "return"), (this.next = "end"))
                  : "normal" === e.type && t && (this.next = t),
                h
              );
            },
            finish: function (e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), C(r), h;
              }
            },
            catch: function (e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.tryLoc === e) {
                  var s = r.completion;
                  if ("throw" === s.type) {
                    var a = s.arg;
                    C(r);
                  }
                  return a;
                }
              }
              throw new Error("illegal catch attempt");
            },
            delegateYield: function (e, t, r) {
              return (this.delegate = { iterator: I(e), resultName: t, nextLoc: r }), "next" === this.method && (this.arg = void 0), h;
            }
          }),
          e
        );
      }
      function o(e, t, r, s, a, n, i) {
        try {
          var o = e[n](i),
            c = o.value;
        } catch (e) {
          return void r(e);
        }
        o.done ? t(c) : Promise.resolve(c).then(s, a);
      }
      function c(e) {
        return u.apply(this, arguments);
      }
      function u() {
        var e;
        return (
          (e = i().mark(function e(t) {
            var r, n, o, c;
            return i().wrap(function (e) {
              for (;;)
                switch ((e.prev = e.next)) {
                  case 0:
                    if (!(0, s.G)()) {
                      e.next = 5;
                      break;
                    }
                    return (e.next = 3), (0, s.y)(t);
                  case 3:
                    return (r = e.sent), e.abrupt("return", r > 0);
                  case 5:
                    return (e.next = 7), (0, a.U)(t);
                  case 7:
                    return (n = e.sent), (o = void 0 === n[t]), (c = null === n[t]), e.abrupt("return", !o && !c);
                  case 11:
                  case "end":
                    return e.stop();
                }
            }, e);
          })),
          (u = function () {
            var t = this,
              r = arguments;
            return new Promise(function (s, a) {
              var n = e.apply(t, r);
              function i(e) {
                o(n, s, a, i, c, "next", e);
              }
              function c(e) {
                o(n, s, a, i, c, "throw", e);
              }
              i(void 0);
            });
          }),
          u.apply(this, arguments)
        );
      }
    },
    48758: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => x });
      r(86847),
        r(72424),
        r(23041),
        r(15442),
        r(37391),
        r(32202),
        r(75815),
        r(68585),
        r(45749),
        r(2165),
        r(83746),
        r(37944),
        r(55402),
        r(22250),
        r(92665),
        r(88737),
        r(97979),
        r(38509),
        r(95665),
        r(41533),
        r(72029),
        r(71632),
        r(2191),
        r(4473),
        r(68126),
        r(75986),
        r(41437),
        r(5744),
        r(18549),
        r(296),
        r(30094),
        r(32721),
        r(7541),
        r(22440),
        r(94973);
      var s = r(92204),
        a = r(24715),
        n = r(72733),
        i = r(57306),
        o = r(31460),
        c = (r(38298), r(61222));
      function u(e) {
        return (
          (u =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                }),
          u(e)
        );
      }
      function d() {
        d = function () {
          return e;
        };
        var e = {},
          t = Object.prototype,
          r = t.hasOwnProperty,
          s =
            Object.defineProperty ||
            function (e, t, r) {
              e[t] = r.value;
            },
          a = "function" == typeof Symbol ? Symbol : {},
          n = a.iterator || "@@iterator",
          i = a.asyncIterator || "@@asyncIterator",
          o = a.toStringTag || "@@toStringTag";
        function c(e, t, r) {
          return Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }), e[t];
        }
        try {
          c({}, "");
        } catch (e) {
          c = function (e, t, r) {
            return (e[t] = r);
          };
        }
        function l(e, t, r, a) {
          var n = t && t.prototype instanceof m ? t : m,
            i = Object.create(n.prototype),
            o = new R(a || []);
          return s(i, "_invoke", { value: b(e, r, o) }), i;
        }
        function p(e, t, r) {
          try {
            return { type: "normal", arg: e.call(t, r) };
          } catch (e) {
            return { type: "throw", arg: e };
          }
        }
        e.wrap = l;
        var h = {};
        function m() {}
        function y() {}
        function g() {}
        var v = {};
        c(v, n, function () {
          return this;
        });
        var f = Object.getPrototypeOf,
          w = f && f(f(I([])));
        w && w !== t && r.call(w, n) && (v = w);
        var S = (g.prototype = m.prototype = Object.create(v));
        function E(e) {
          ["next", "throw", "return"].forEach(function (t) {
            c(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function _(e, t) {
          function a(s, n, i, o) {
            var c = p(e[s], e, n);
            if ("throw" !== c.type) {
              var d = c.arg,
                l = d.value;
              return l && "object" == u(l) && r.call(l, "__await")
                ? t.resolve(l.__await).then(
                    function (e) {
                      a("next", e, i, o);
                    },
                    function (e) {
                      a("throw", e, i, o);
                    }
                  )
                : t.resolve(l).then(
                    function (e) {
                      (d.value = e), i(d);
                    },
                    function (e) {
                      return a("throw", e, i, o);
                    }
                  );
            }
            o(c.arg);
          }
          var n;
          s(this, "_invoke", {
            value: function (e, r) {
              function s() {
                return new t(function (t, s) {
                  a(e, r, t, s);
                });
              }
              return (n = n ? n.then(s, s) : s());
            }
          });
        }
        function b(e, t, r) {
          var s = "suspendedStart";
          return function (a, n) {
            if ("executing" === s) throw new Error("Generator is already running");
            if ("completed" === s) {
              if ("throw" === a) throw n;
              return x();
            }
            for (r.method = a, r.arg = n; ; ) {
              var i = r.delegate;
              if (i) {
                var o = T(i, r);
                if (o) {
                  if (o === h) continue;
                  return o;
                }
              }
              if ("next" === r.method) r.sent = r._sent = r.arg;
              else if ("throw" === r.method) {
                if ("suspendedStart" === s) throw ((s = "completed"), r.arg);
                r.dispatchException(r.arg);
              } else "return" === r.method && r.abrupt("return", r.arg);
              s = "executing";
              var c = p(e, t, r);
              if ("normal" === c.type) {
                if (((s = r.done ? "completed" : "suspendedYield"), c.arg === h)) continue;
                return { value: c.arg, done: r.done };
              }
              "throw" === c.type && ((s = "completed"), (r.method = "throw"), (r.arg = c.arg));
            }
          };
        }
        function T(e, t) {
          var r = t.method,
            s = e.iterator[r];
          if (void 0 === s)
            return (
              (t.delegate = null),
              ("throw" === r && e.iterator.return && ((t.method = "return"), (t.arg = void 0), T(e, t), "throw" === t.method)) ||
                ("return" !== r && ((t.method = "throw"), (t.arg = new TypeError("The iterator does not provide a '" + r + "' method")))),
              h
            );
          var a = p(s, e.iterator, t.arg);
          if ("throw" === a.type) return (t.method = "throw"), (t.arg = a.arg), (t.delegate = null), h;
          var n = a.arg;
          return n
            ? n.done
              ? ((t[e.resultName] = n.value),
                (t.next = e.nextLoc),
                "return" !== t.method && ((t.method = "next"), (t.arg = void 0)),
                (t.delegate = null),
                h)
              : n
            : ((t.method = "throw"), (t.arg = new TypeError("iterator result is not an object")), (t.delegate = null), h);
        }
        function A(e) {
          var t = { tryLoc: e[0] };
          1 in e && (t.catchLoc = e[1]), 2 in e && ((t.finallyLoc = e[2]), (t.afterLoc = e[3])), this.tryEntries.push(t);
        }
        function C(e) {
          var t = e.completion || {};
          (t.type = "normal"), delete t.arg, (e.completion = t);
        }
        function R(e) {
          (this.tryEntries = [{ tryLoc: "root" }]), e.forEach(A, this), this.reset(!0);
        }
        function I(e) {
          if (e) {
            var t = e[n];
            if (t) return t.call(e);
            if ("function" == typeof e.next) return e;
            if (!isNaN(e.length)) {
              var s = -1,
                a = function t() {
                  for (; ++s < e.length; ) if (r.call(e, s)) return (t.value = e[s]), (t.done = !1), t;
                  return (t.value = void 0), (t.done = !0), t;
                };
              return (a.next = a);
            }
          }
          return { next: x };
        }
        function x() {
          return { value: void 0, done: !0 };
        }
        return (
          (y.prototype = g),
          s(S, "constructor", { value: g, configurable: !0 }),
          s(g, "constructor", { value: y, configurable: !0 }),
          (y.displayName = c(g, o, "GeneratorFunction")),
          (e.isGeneratorFunction = function (e) {
            var t = "function" == typeof e && e.constructor;
            return !!t && (t === y || "GeneratorFunction" === (t.displayName || t.name));
          }),
          (e.mark = function (e) {
            return (
              Object.setPrototypeOf ? Object.setPrototypeOf(e, g) : ((e.__proto__ = g), c(e, o, "GeneratorFunction")),
              (e.prototype = Object.create(S)),
              e
            );
          }),
          (e.awrap = function (e) {
            return { __await: e };
          }),
          E(_.prototype),
          c(_.prototype, i, function () {
            return this;
          }),
          (e.AsyncIterator = _),
          (e.async = function (t, r, s, a, n) {
            void 0 === n && (n = Promise);
            var i = new _(l(t, r, s, a), n);
            return e.isGeneratorFunction(r)
              ? i
              : i.next().then(function (e) {
                  return e.done ? e.value : i.next();
                });
          }),
          E(S),
          c(S, o, "Generator"),
          c(S, n, function () {
            return this;
          }),
          c(S, "toString", function () {
            return "[object Generator]";
          }),
          (e.keys = function (e) {
            var t = Object(e),
              r = [];
            for (var s in t) r.push(s);
            return (
              r.reverse(),
              function e() {
                for (; r.length; ) {
                  var s = r.pop();
                  if (s in t) return (e.value = s), (e.done = !1), e;
                }
                return (e.done = !0), e;
              }
            );
          }),
          (e.values = I),
          (R.prototype = {
            constructor: R,
            reset: function (e) {
              if (
                ((this.prev = 0),
                (this.next = 0),
                (this.sent = this._sent = void 0),
                (this.done = !1),
                (this.delegate = null),
                (this.method = "next"),
                (this.arg = void 0),
                this.tryEntries.forEach(C),
                !e)
              )
                for (var t in this) "t" === t.charAt(0) && r.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0);
            },
            stop: function () {
              this.done = !0;
              var e = this.tryEntries[0].completion;
              if ("throw" === e.type) throw e.arg;
              return this.rval;
            },
            dispatchException: function (e) {
              if (this.done) throw e;
              var t = this;
              function s(r, s) {
                return (i.type = "throw"), (i.arg = e), (t.next = r), s && ((t.method = "next"), (t.arg = void 0)), !!s;
              }
              for (var a = this.tryEntries.length - 1; a >= 0; --a) {
                var n = this.tryEntries[a],
                  i = n.completion;
                if ("root" === n.tryLoc) return s("end");
                if (n.tryLoc <= this.prev) {
                  var o = r.call(n, "catchLoc"),
                    c = r.call(n, "finallyLoc");
                  if (o && c) {
                    if (this.prev < n.catchLoc) return s(n.catchLoc, !0);
                    if (this.prev < n.finallyLoc) return s(n.finallyLoc);
                  } else if (o) {
                    if (this.prev < n.catchLoc) return s(n.catchLoc, !0);
                  } else {
                    if (!c) throw new Error("try statement without catch or finally");
                    if (this.prev < n.finallyLoc) return s(n.finallyLoc);
                  }
                }
              }
            },
            abrupt: function (e, t) {
              for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                var a = this.tryEntries[s];
                if (a.tryLoc <= this.prev && r.call(a, "finallyLoc") && this.prev < a.finallyLoc) {
                  var n = a;
                  break;
                }
              }
              n && ("break" === e || "continue" === e) && n.tryLoc <= t && t <= n.finallyLoc && (n = null);
              var i = n ? n.completion : {};
              return (i.type = e), (i.arg = t), n ? ((this.method = "next"), (this.next = n.finallyLoc), h) : this.complete(i);
            },
            complete: function (e, t) {
              if ("throw" === e.type) throw e.arg;
              return (
                "break" === e.type || "continue" === e.type
                  ? (this.next = e.arg)
                  : "return" === e.type
                  ? ((this.rval = this.arg = e.arg), (this.method = "return"), (this.next = "end"))
                  : "normal" === e.type && t && (this.next = t),
                h
              );
            },
            finish: function (e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), C(r), h;
              }
            },
            catch: function (e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.tryLoc === e) {
                  var s = r.completion;
                  if ("throw" === s.type) {
                    var a = s.arg;
                    C(r);
                  }
                  return a;
                }
              }
              throw new Error("illegal catch attempt");
            },
            delegateYield: function (e, t, r) {
              return (this.delegate = { iterator: I(e), resultName: t, nextLoc: r }), "next" === this.method && (this.arg = void 0), h;
            }
          }),
          e
        );
      }
      function l(e, t, r, s, a, n, i) {
        try {
          var o = e[n](i),
            c = o.value;
        } catch (e) {
          return void r(e);
        }
        o.done ? t(c) : Promise.resolve(c).then(s, a);
      }
      function p() {
        return h.apply(this, arguments);
      }
      function h() {
        var e;
        return (
          (e = d().mark(function e() {
            var t, r, a, n;
            return d().wrap(function (e) {
              for (;;)
                switch ((e.prev = e.next)) {
                  case 0:
                    return (e.next = 2), (0, c.I)({});
                  case 2:
                    return (
                      (t = e.sent),
                      (r = (0, s.A)("")),
                      (a = function (e) {
                        return "string" == typeof e.url && e.url.startsWith(r);
                      }),
                      (n = function (e) {
                        return "" !== e.url;
                      }),
                      e.abrupt("return", t.filter(a).filter(n))
                    );
                  case 7:
                  case "end":
                    return e.stop();
                }
            }, e);
          })),
          (h = function () {
            var t = this,
              r = arguments;
            return new Promise(function (s, a) {
              var n = e.apply(t, r);
              function i(e) {
                l(n, s, a, i, o, "next", e);
              }
              function o(e) {
                l(n, s, a, i, o, "throw", e);
              }
              i(void 0);
            });
          }),
          h.apply(this, arguments)
        );
      }
      function m(e) {
        return (
          (m =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                }),
          m(e)
        );
      }
      function y(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var s = Object.getOwnPropertySymbols(e);
          t &&
            (s = s.filter(function (t) {
              return Object.getOwnPropertyDescriptor(e, t).enumerable;
            })),
            r.push.apply(r, s);
        }
        return r;
      }
      function g(e) {
        for (var t = 1; t < arguments.length; t++) {
          var r = null != arguments[t] ? arguments[t] : {};
          t % 2
            ? y(Object(r), !0).forEach(function (t) {
                v(e, t, r[t]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
            : y(Object(r)).forEach(function (t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
              });
        }
        return e;
      }
      function v(e, t, r) {
        return (
          (t = (function (e) {
            var t = (function (e, t) {
              if ("object" !== m(e) || null === e) return e;
              var r = e[Symbol.toPrimitive];
              if (void 0 !== r) {
                var s = r.call(e, t || "default");
                if ("object" !== m(s)) return s;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return ("string" === t ? String : Number)(e);
            })(e, "string");
            return "symbol" === m(t) ? t : String(t);
          })(t)) in e
            ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
            : (e[t] = r),
          e
        );
      }
      function f() {
        f = function () {
          return e;
        };
        var e = {},
          t = Object.prototype,
          r = t.hasOwnProperty,
          s =
            Object.defineProperty ||
            function (e, t, r) {
              e[t] = r.value;
            },
          a = "function" == typeof Symbol ? Symbol : {},
          n = a.iterator || "@@iterator",
          i = a.asyncIterator || "@@asyncIterator",
          o = a.toStringTag || "@@toStringTag";
        function c(e, t, r) {
          return Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }), e[t];
        }
        try {
          c({}, "");
        } catch (e) {
          c = function (e, t, r) {
            return (e[t] = r);
          };
        }
        function u(e, t, r, a) {
          var n = t && t.prototype instanceof p ? t : p,
            i = Object.create(n.prototype),
            o = new R(a || []);
          return s(i, "_invoke", { value: b(e, r, o) }), i;
        }
        function d(e, t, r) {
          try {
            return { type: "normal", arg: e.call(t, r) };
          } catch (e) {
            return { type: "throw", arg: e };
          }
        }
        e.wrap = u;
        var l = {};
        function p() {}
        function h() {}
        function y() {}
        var g = {};
        c(g, n, function () {
          return this;
        });
        var v = Object.getPrototypeOf,
          w = v && v(v(I([])));
        w && w !== t && r.call(w, n) && (g = w);
        var S = (y.prototype = p.prototype = Object.create(g));
        function E(e) {
          ["next", "throw", "return"].forEach(function (t) {
            c(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function _(e, t) {
          function a(s, n, i, o) {
            var c = d(e[s], e, n);
            if ("throw" !== c.type) {
              var u = c.arg,
                l = u.value;
              return l && "object" == m(l) && r.call(l, "__await")
                ? t.resolve(l.__await).then(
                    function (e) {
                      a("next", e, i, o);
                    },
                    function (e) {
                      a("throw", e, i, o);
                    }
                  )
                : t.resolve(l).then(
                    function (e) {
                      (u.value = e), i(u);
                    },
                    function (e) {
                      return a("throw", e, i, o);
                    }
                  );
            }
            o(c.arg);
          }
          var n;
          s(this, "_invoke", {
            value: function (e, r) {
              function s() {
                return new t(function (t, s) {
                  a(e, r, t, s);
                });
              }
              return (n = n ? n.then(s, s) : s());
            }
          });
        }
        function b(e, t, r) {
          var s = "suspendedStart";
          return function (a, n) {
            if ("executing" === s) throw new Error("Generator is already running");
            if ("completed" === s) {
              if ("throw" === a) throw n;
              return x();
            }
            for (r.method = a, r.arg = n; ; ) {
              var i = r.delegate;
              if (i) {
                var o = T(i, r);
                if (o) {
                  if (o === l) continue;
                  return o;
                }
              }
              if ("next" === r.method) r.sent = r._sent = r.arg;
              else if ("throw" === r.method) {
                if ("suspendedStart" === s) throw ((s = "completed"), r.arg);
                r.dispatchException(r.arg);
              } else "return" === r.method && r.abrupt("return", r.arg);
              s = "executing";
              var c = d(e, t, r);
              if ("normal" === c.type) {
                if (((s = r.done ? "completed" : "suspendedYield"), c.arg === l)) continue;
                return { value: c.arg, done: r.done };
              }
              "throw" === c.type && ((s = "completed"), (r.method = "throw"), (r.arg = c.arg));
            }
          };
        }
        function T(e, t) {
          var r = t.method,
            s = e.iterator[r];
          if (void 0 === s)
            return (
              (t.delegate = null),
              ("throw" === r && e.iterator.return && ((t.method = "return"), (t.arg = void 0), T(e, t), "throw" === t.method)) ||
                ("return" !== r && ((t.method = "throw"), (t.arg = new TypeError("The iterator does not provide a '" + r + "' method")))),
              l
            );
          var a = d(s, e.iterator, t.arg);
          if ("throw" === a.type) return (t.method = "throw"), (t.arg = a.arg), (t.delegate = null), l;
          var n = a.arg;
          return n
            ? n.done
              ? ((t[e.resultName] = n.value),
                (t.next = e.nextLoc),
                "return" !== t.method && ((t.method = "next"), (t.arg = void 0)),
                (t.delegate = null),
                l)
              : n
            : ((t.method = "throw"), (t.arg = new TypeError("iterator result is not an object")), (t.delegate = null), l);
        }
        function A(e) {
          var t = { tryLoc: e[0] };
          1 in e && (t.catchLoc = e[1]), 2 in e && ((t.finallyLoc = e[2]), (t.afterLoc = e[3])), this.tryEntries.push(t);
        }
        function C(e) {
          var t = e.completion || {};
          (t.type = "normal"), delete t.arg, (e.completion = t);
        }
        function R(e) {
          (this.tryEntries = [{ tryLoc: "root" }]), e.forEach(A, this), this.reset(!0);
        }
        function I(e) {
          if (e) {
            var t = e[n];
            if (t) return t.call(e);
            if ("function" == typeof e.next) return e;
            if (!isNaN(e.length)) {
              var s = -1,
                a = function t() {
                  for (; ++s < e.length; ) if (r.call(e, s)) return (t.value = e[s]), (t.done = !1), t;
                  return (t.value = void 0), (t.done = !0), t;
                };
              return (a.next = a);
            }
          }
          return { next: x };
        }
        function x() {
          return { value: void 0, done: !0 };
        }
        return (
          (h.prototype = y),
          s(S, "constructor", { value: y, configurable: !0 }),
          s(y, "constructor", { value: h, configurable: !0 }),
          (h.displayName = c(y, o, "GeneratorFunction")),
          (e.isGeneratorFunction = function (e) {
            var t = "function" == typeof e && e.constructor;
            return !!t && (t === h || "GeneratorFunction" === (t.displayName || t.name));
          }),
          (e.mark = function (e) {
            return (
              Object.setPrototypeOf ? Object.setPrototypeOf(e, y) : ((e.__proto__ = y), c(e, o, "GeneratorFunction")),
              (e.prototype = Object.create(S)),
              e
            );
          }),
          (e.awrap = function (e) {
            return { __await: e };
          }),
          E(_.prototype),
          c(_.prototype, i, function () {
            return this;
          }),
          (e.AsyncIterator = _),
          (e.async = function (t, r, s, a, n) {
            void 0 === n && (n = Promise);
            var i = new _(u(t, r, s, a), n);
            return e.isGeneratorFunction(r)
              ? i
              : i.next().then(function (e) {
                  return e.done ? e.value : i.next();
                });
          }),
          E(S),
          c(S, o, "Generator"),
          c(S, n, function () {
            return this;
          }),
          c(S, "toString", function () {
            return "[object Generator]";
          }),
          (e.keys = function (e) {
            var t = Object(e),
              r = [];
            for (var s in t) r.push(s);
            return (
              r.reverse(),
              function e() {
                for (; r.length; ) {
                  var s = r.pop();
                  if (s in t) return (e.value = s), (e.done = !1), e;
                }
                return (e.done = !0), e;
              }
            );
          }),
          (e.values = I),
          (R.prototype = {
            constructor: R,
            reset: function (e) {
              if (
                ((this.prev = 0),
                (this.next = 0),
                (this.sent = this._sent = void 0),
                (this.done = !1),
                (this.delegate = null),
                (this.method = "next"),
                (this.arg = void 0),
                this.tryEntries.forEach(C),
                !e)
              )
                for (var t in this) "t" === t.charAt(0) && r.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0);
            },
            stop: function () {
              this.done = !0;
              var e = this.tryEntries[0].completion;
              if ("throw" === e.type) throw e.arg;
              return this.rval;
            },
            dispatchException: function (e) {
              if (this.done) throw e;
              var t = this;
              function s(r, s) {
                return (i.type = "throw"), (i.arg = e), (t.next = r), s && ((t.method = "next"), (t.arg = void 0)), !!s;
              }
              for (var a = this.tryEntries.length - 1; a >= 0; --a) {
                var n = this.tryEntries[a],
                  i = n.completion;
                if ("root" === n.tryLoc) return s("end");
                if (n.tryLoc <= this.prev) {
                  var o = r.call(n, "catchLoc"),
                    c = r.call(n, "finallyLoc");
                  if (o && c) {
                    if (this.prev < n.catchLoc) return s(n.catchLoc, !0);
                    if (this.prev < n.finallyLoc) return s(n.finallyLoc);
                  } else if (o) {
                    if (this.prev < n.catchLoc) return s(n.catchLoc, !0);
                  } else {
                    if (!c) throw new Error("try statement without catch or finally");
                    if (this.prev < n.finallyLoc) return s(n.finallyLoc);
                  }
                }
              }
            },
            abrupt: function (e, t) {
              for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                var a = this.tryEntries[s];
                if (a.tryLoc <= this.prev && r.call(a, "finallyLoc") && this.prev < a.finallyLoc) {
                  var n = a;
                  break;
                }
              }
              n && ("break" === e || "continue" === e) && n.tryLoc <= t && t <= n.finallyLoc && (n = null);
              var i = n ? n.completion : {};
              return (i.type = e), (i.arg = t), n ? ((this.method = "next"), (this.next = n.finallyLoc), l) : this.complete(i);
            },
            complete: function (e, t) {
              if ("throw" === e.type) throw e.arg;
              return (
                "break" === e.type || "continue" === e.type
                  ? (this.next = e.arg)
                  : "return" === e.type
                  ? ((this.rval = this.arg = e.arg), (this.method = "return"), (this.next = "end"))
                  : "normal" === e.type && t && (this.next = t),
                l
              );
            },
            finish: function (e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), C(r), l;
              }
            },
            catch: function (e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.tryLoc === e) {
                  var s = r.completion;
                  if ("throw" === s.type) {
                    var a = s.arg;
                    C(r);
                  }
                  return a;
                }
              }
              throw new Error("illegal catch attempt");
            },
            delegateYield: function (e, t, r) {
              return (this.delegate = { iterator: I(e), resultName: t, nextLoc: r }), "next" === this.method && (this.arg = void 0), l;
            }
          }),
          e
        );
      }
      function w(e, t, r, s, a, n, i) {
        try {
          var o = e[n](i),
            c = o.value;
        } catch (e) {
          return void r(e);
        }
        o.done ? t(c) : Promise.resolve(c).then(s, a);
      }
      function S(e) {
        return function () {
          var t = this,
            r = arguments;
          return new Promise(function (s, a) {
            var n = e.apply(t, r);
            function i(e) {
              w(n, s, a, i, o, "next", e);
            }
            function o(e) {
              w(n, s, a, i, o, "throw", e);
            }
            i(void 0);
          });
        };
      }
      var E = "index.html";
      function _() {
        var e = (0, s.A)("");
        return "".concat(e).concat(E);
      }
      function b(e) {
        var t = e.identifier,
          r = e.queryInfo,
          s = e.name,
          a = _();
        if (!s) return a;
        var n = t ? "#".concat(s, "/").concat(t) : "#".concat(s),
          i = r
            ? "?".concat(
                (function (e) {
                  return Object.keys(e)
                    .map(function (t) {
                      return "".concat(t, "=").concat(e[t]);
                    })
                    .join("&");
                })(r)
              )
            : "";
        return encodeURI("".concat(a).concat(n).concat(i));
      }
      function T(e) {
        return A.apply(this, arguments);
      }
      function A() {
        return (A = S(
          f().mark(function e(t) {
            var r;
            return f().wrap(function (e) {
              for (;;)
                switch ((e.prev = e.next)) {
                  case 0:
                    return (r = { url: t }), (e.next = 3), (0, a.U)(r);
                  case 3:
                  case "end":
                    return e.stop();
                }
            }, e);
          })
        )).apply(this, arguments);
      }
      function C(e) {
        var t,
          r = e.existingTabs,
          s = e.focusedWindow,
          a = r.filter(function (e) {
            return e.active;
          }),
          n = a.find(function (e) {
            return e.windowId === s.id;
          }),
          i = a.pop(),
          o = r.pop();
        return null != (t = null != n ? n : i) ? t : o;
      }
      function R(e) {
        return I.apply(this, arguments);
      }
      function I() {
        return (I = S(
          f().mark(function e(t) {
            var r, s, a, c, u, d;
            return f().wrap(function (e) {
              for (;;)
                switch ((e.prev = e.next)) {
                  case 0:
                    return (r = t.path), (s = t.tabs), (e.next = 3), (0, n.T)();
                  case 3:
                    if (((a = e.sent), (c = C({ existingTabs: s, focusedWindow: a })))) {
                      e.next = 7;
                      break;
                    }
                    return e.abrupt("return");
                  case 7:
                    if ((c.windowId !== a.id && (0, i.V)(c.windowId, { focused: !0 }), c.id)) {
                      e.next = 10;
                      break;
                    }
                    return e.abrupt("return");
                  case 10:
                    return (u = r === _() ? {} : { url: r }), (d = g({ active: !0 }, u)), (e.next = 14), (0, o.V)(c.id, d);
                  case 14:
                  case "end":
                    return e.stop();
                }
            }, e);
          })
        )).apply(this, arguments);
      }
      function x(e) {
        return P.apply(this, arguments);
      }
      function P() {
        return (
          (P = S(
            f().mark(function e(t) {
              var r, s, a, n, i;
              return f().wrap(function (e) {
                for (;;)
                  switch ((e.prev = e.next)) {
                    case 0:
                      return (r = t.id), (s = t.query), (a = t.route), (n = b({ identifier: r, queryInfo: s, name: a })), (e.next = 4), p();
                    case 4:
                      if (!(i = e.sent).length) {
                        e.next = 9;
                        break;
                      }
                      return (e.next = 8), R({ path: n, tabs: i });
                    case 8:
                      return e.abrupt("return");
                    case 9:
                      return (e.next = 11), T(n);
                    case 11:
                    case "end":
                      return e.stop();
                  }
              }, e);
            })
          )),
          P.apply(this, arguments)
        );
      }
    },
    61476: (e, t, r) => {
      "use strict";
      r.d(t, { J: () => o });
      var s = r(86952),
        a = r(46047),
        n = r(70219),
        i = r(26331);
      const o = (0, s.Q)({
        name: "permissions",
        commands: { addGroupManager: a.B, removeGroupManager: n.d },
        events: {},
        queries: { userPermissions: i.l }
      });
    },
    46047: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    70219: (e, t, r) => {
      "use strict";
      r.d(t, { d: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    26331: (e, t, r) => {
      "use strict";
      r.d(t, { l: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.Device }) {}
    },
    43897: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => A });
      var s,
        a = r(88802),
        n = r(99634),
        i = r(61476),
        o = r(1824),
        c = r(63663),
        u = r(46047),
        d = r(60399),
        l = r(57924),
        p = r(61501),
        h = r(53576),
        m = r(87279),
        y = r(48844);
      !(function (e) {
        e[(e.GroupManager = 0)] = "GroupManager";
      })(s || (s = {}));
      let g = class {
        constructor(e, t) {
          (this.serverApiClient = e), (this.carbonLegacyClient = t);
        }
        async addRole({ role: e, params: t }) {
          if (e === s.GroupManager) return await this.addGroupManager(t);
        }
        async removeRole({ role: e, params: t }) {
          if (e === s.GroupManager) return await this.removeGroupManager(t);
        }
        async getSpecialUserGroupRevision(e) {
          const {
              commands: { carbon: t }
            } = this.carbonLegacyClient,
            r = await t({ name: "getSpecialUserGroupRevision", args: [{ teamId: e }] });
          let s;
          if (!(0, m.d6)(r)) throw r.error.error;
          {
            const { carbonResult: e } = r.data,
              { specialUserGroupRevision: t } = e;
            s = t;
          }
          return s;
        }
        async removeGroupManager({ memberLogin: e, teamId: t }) {
          const r = await this.getSpecialUserGroupRevision(t);
          return await (0, d.z)(
            this.serverApiClient.v1.teams.removeGroupManager({ memberLogin: e, userGroupRevision: r }).pipe(
              (0, y.DZ)((e) => {
                throw new Error(e.message);
              }),
              (0, y.lk)((e) => {
                if (e.data) return (0, m.Vp)(void 0);
                throw new Error("Unknown server error occurred while attempting to remove group manager");
              })
            )
          );
        }
        async addGroupManager({ memberLogin: e, teamId: t }) {
          const r = await this.getSpecialUserGroupRevision(t),
            {
              commands: { carbon: s }
            } = this.carbonLegacyClient,
            a = await s({ name: "getSpecialUserGroupInviteValuesForMemberInTeam", args: [{ memberLogin: e, teamId: t }] });
          let n = "",
            i = "";
          if (!(0, m.d6)(a)) throw a.error.error;
          {
            const { carbonResult: e } = a.data,
              { groupKey: t, proposeSignature: r } = e;
            (n = t), (i = r);
          }
          return await (0, d.z)(
            this.serverApiClient.v1.teams.addGroupManager({ memberLogin: e, groupKey: n, proposeSignature: i, userGroupRevision: r }).pipe(
              (0, y.DZ)((e) => {
                throw new Error(e.message);
              }),
              (0, y.lk)((e) => {
                if (e.data) return (0, m.Vp)(void 0);
                throw new Error("Unknown server error occurred while attempting to add group manager");
              })
            )
          );
        }
      };
      g = (0, a.__decorate)([(0, l.GS)(), (0, a.__metadata)("design:paramtypes", [p.l, h.CarbonLegacyClient])], g);
      let v = class {
        constructor(e) {
          this.roleService = e;
        }
        async execute({ body: e }) {
          return await this.roleService.addRole({ role: s.GroupManager, params: e });
        }
      };
      v = (0, a.__decorate)([(0, c.W)(u.B), (0, a.__metadata)("design:paramtypes", [g])], v);
      var f = r(70219);
      let w = class {
        constructor(e) {
          this.roleService = e;
        }
        async execute({ body: e }) {
          return await this.roleService.removeRole({ role: s.GroupManager, params: e });
        }
      };
      w = (0, a.__decorate)([(0, c.W)(f.d), (0, a.__metadata)("design:paramtypes", [g])], w);
      var S = r(26331),
        E = r(20754);
      const _ = r(7165).z.enum(["ALL", "BILLING_EDIT", "BILLING_READ", "GROUP_CREATE", "GROUP_DELETE", "GROUP_EDIT", "GROUP_READ"]);
      let b = class {
        constructor(e) {
          this.serverApiClient = e;
        }
        getActiveUserPermissions() {
          return this.serverApiClient.v1.teams.getUserPermissions().pipe(
            (0, y.DZ)((e) => {
              throw new Error(`getUserPermissions failed with error: ${e}`);
            }),
            (0, y.lk)((e) => (0, m.Vp)(this.serverToDomainPermissionsMapper(e.data.permissions)))
          );
        }
        serverToDomainPermissionsMapper(e) {
          return e.filter((e) => _.safeParse(e).success);
        }
      };
      b = (0, a.__decorate)([(0, l.GS)(), (0, a.__metadata)("design:paramtypes", [p.l])], b);
      let T = class {
        constructor(e) {
          this.permissionsService = e;
        }
        execute() {
          return this.permissionsService.getActiveUserPermissions();
        }
      };
      T = (0, a.__decorate)([(0, E.e)(S.l), (0, a.__metadata)("design:paramtypes", [b])], T);
      let A = class {};
      A = (0, a.__decorate)(
        [
          (0, n.Y)({
            api: i.J,
            imports: [o.n],
            providers: [b, g],
            handlers: { commands: { addGroupManager: v, removeGroupManager: w }, events: {}, queries: { userPermissions: T } }
          })
        ],
        A
      );
    },
    18183: (e, t, r) => {
      "use strict";
      r.d(t, { j: () => S });
      var s = r(86952),
        a = r(13060),
        n = r(22481),
        i = r(74593),
        o = r(23823),
        c = r(78519),
        u = r(6790),
        d = r(78548),
        l = r(60017),
        p = r(24662),
        h = r(77539),
        m = r(22632),
        y = r(14074),
        g = r(40956),
        v = r(22618),
        f = r(36261),
        w = r(80448);
      const S = (0, s.Q)({
        name: "accountRecoveryKey",
        commands: {
          goToActivationNextStep: a.Z,
          goToActivationPrevStep: n.H,
          requestActivation: i.e,
          cancelActivation: o.w,
          cancelGeneration: c.r,
          confirmActivation: u.W,
          confirmNewPassword: d.v,
          deactivate: l.E,
          submitRecoveryKey: p.Y,
          tryAgainRecovery: h.d,
          cancelRecoveryFlow: m.b,
          startRecoveryFlow: y.Q
        },
        queries: { activationFlowStatus: g.S, accountRecoveryKeyStatus: v.D, recoveryFlowStatus: f.y, recoveryMethodsInfo: w.V },
        events: {}
      });
    },
    23823: (e, t, r) => {
      "use strict";
      r.d(t, { w: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    78519: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    22632: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.Device }) {}
    },
    6790: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    78548: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.Device }) {}
    },
    60017: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    13060: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    22481: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    74593: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    14074: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.Device }) {}
    },
    24662: (e, t, r) => {
      "use strict";
      r.d(t, { Y: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.Device }) {}
    },
    77539: (e, t, r) => {
      "use strict";
      r.d(t, { d: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.Device }) {}
    },
    22618: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.Device }) {}
    },
    40956: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    36261: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.Device }) {}
    },
    80448: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    8443: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => pt });
      var s = r(88802),
        a = r(18183),
        n = r(11433),
        i = r(99634),
        o = r(38679),
        c = r(1824),
        u = r(37935),
        d = r(80310),
        l = r(87279),
        p = r(63663),
        h = r(13060),
        m = r(64472),
        y = r(24966),
        g = r(57924),
        v = r(31948),
        f = r(5331),
        w = r(60399),
        S = r(30523),
        E = r(87065),
        _ = r(53576),
        b = r(61501),
        T = r(21869),
        A = r(48844),
        C = r(18533),
        R = r(20195),
        I = r(25029),
        x = r(95681),
        P = r(23347);
      const D = (e) => !(!e || "object" != typeof e) && "isEnabled" in e;
      class U extends (0, x.Q)({
        initialValue: { isEnabled: void 0, login: void 0 },
        persist: !1,
        scope: I.F.Device,
        storeName: "account-recovery-key",
        storeTypeGuard: D,
        capacity: P.Y._001KB
      }) {}
      const F = ["email_token", "totp", "duo_push", "dashlane_authenticator"],
        O = (e) => "object" == typeof e && "type" in e;
      var N,
        k = r(96168);
      !(function (e) {
        (e.GENERIC_ERROR = "GENERIC_ERROR"),
          (e.NETWORK_ERROR = "NETWORK_ERROR"),
          (e.INITIALIZE_MACHINE_ERROR = "INITIALIZE_MACHINE_ERROR"),
          (e.WRONG_RECOVERY_KEY_ERROR = "WRONG_RECOVERY_KEY_ERROR"),
          (e.CHANGE_MASTER_PASSWORD_ERROR = "CHANGE_MASTER_PASSWORD_ERROR");
      })(N || (N = {}));
      class L extends (0, k.Hu)(N.NETWORK_ERROR, "There is an issue with your connection") {}
      let M = class {
        constructor(e, t, r, s) {
          (this.store = e), (this.serverApiClient = t), (this.carbon = r), (this.context = s);
        }
        getCurrentUserLogin() {
          return this.context.get(T.l.UserName);
        }
        getAuthTicketInfo() {
          const { carbonState: e } = this.carbon.queries;
          return (0, w.z)(
            e({ path: "userSession.authTicketInfo" }).pipe(
              (0, A.nb)({
                success: (e) => e,
                failure: () => {
                  throw new Error("Failure getting auth ticket info");
                }
              })
            )
          );
        }
        retrieveLocalAccounts() {
          const { carbonState: e } = this.carbon.queries;
          return (0, w.z)(
            e({ path: "authentication.localAccounts" }).pipe(
              (0, S.h)(l.d6),
              (0, S.h)((e) => e.data.accountsListInitialized),
              (0, E.U)((e) => e.data.accountsList)
            )
          );
        }
        async getCurrentPersonalSettings() {
          const { carbonStateList: e } = this.carbon.queries;
          return await (0, w.z)(
            e({ paths: ["userSession.personalSettings.AccountRecoveryKey", "userSession.personalSettings.AccountRecoveryKeyId"] }).pipe(
              (0, A.nb)({
                success: ([e, t]) => ({ AccountRecoveryKey: e, AccountRecoveryKeyId: t }),
                failure: () => {
                  throw new Error("Failure getting state list");
                }
              })
            )
          );
        }
        getLastAuthenticatedUserRecoveryData() {
          return this.store.state$.pipe((0, E.U)((e) => ({ isEnabled: e.isEnabled, login: e.login })));
        }
        async updateLastAuthenticatedUserRecoveryStatus(e) {
          if (!e) throw new Error("No user login provided");
          const t = await (0, w.z)(this.serverApiClient.v1.accountrecovery.getStatus({ login: e }));
          if ((0, l.hx)(t)) throw new Error("Server call failed");
          await this.store.set({ isEnabled: t.data.data.enabled, login: e });
        }
        async generateRecoveryKey() {
          const { carbon: e } = this.carbon.commands,
            t = { length: 28, digits: !0, letters: !0, avoidAmbiguous: !0, symbols: !1 };
          return await e({ name: "generatePassword", args: [{ settings: t }] });
        }
        async setPersonalSettings(e) {
          const { carbon: t } = this.carbon.commands;
          return await t({ name: "updateAccountRecoveryKeyPersonalSettings", args: [e] });
        }
        async getPreferredVerificationMethod(e) {
          return await (0, w.z)(
            this.serverApiClient.v1.authentication.getAuthenticationMethodsForDevice({ login: e, methods: F }).pipe(
              (0, A.DZ)((e) =>
                (0, C.EQ)(e, {
                  BusinessError: () => {
                    throw new Error(N.GENERIC_ERROR);
                  },
                  FetchFailedError: () => new L(),
                  InternalServerError: R.j,
                  InvalidRequest: R.j,
                  RateLimited: R.j,
                  ServiceUnavailable: R.j,
                  UnspecifiedBadStatus: R.j
                })
              ),
              (0, A.lk)((e) => {
                const t = e.data.verifications.find(O);
                if (t) return (0, l.Vp)(t);
                throw new Error("Unsupported authentication method");
              })
            )
          );
        }
        async requestActivation(e) {
          return await (0, w.z)(
            this.serverApiClient.v1.accountrecovery.requestActivation({ encryptedVaultKey: e }).pipe(
              (0, A.DZ)((e) =>
                (0, C.EQ)(e, {
                  BusinessError: () => {
                    throw new Error(N.GENERIC_ERROR);
                  },
                  FetchFailedError: () => new L(),
                  UnspecifiedBadStatus: R.j,
                  InternalServerError: R.j,
                  InvalidRequest: R.j,
                  RateLimited: R.j,
                  ServiceUnavailable: R.j
                })
              ),
              (0, A.lk)((e) => {
                if (e.data.recoveryId) return (0, l.Vp)(e.data.recoveryId);
                throw new Error(N.GENERIC_ERROR);
              })
            )
          );
        }
        async confirmActivation(e) {
          return await (0, w.z)(
            this.serverApiClient.v1.accountrecovery.confirmActivation({ recoveryId: e }).pipe(
              (0, A.DZ)((e) =>
                (0, C.EQ)(e, {
                  BusinessError: () => {
                    throw new Error(N.GENERIC_ERROR);
                  },
                  FetchFailedError: () => new L(),
                  UnspecifiedBadStatus: R.j,
                  InternalServerError: R.j,
                  InvalidRequest: R.j,
                  RateLimited: R.j,
                  ServiceUnavailable: R.j
                })
              ),
              (0, A.lk)(() => (0, l.Vp)(void 0))
            )
          );
        }
        async deactivate(e) {
          return await (0, w.z)(
            this.serverApiClient.v1.accountrecovery.deactivate({ reason: e }).pipe(
              (0, A.DZ)((e) =>
                (0, C.EQ)(e, {
                  BusinessError: () => {
                    throw new Error(N.GENERIC_ERROR);
                  },
                  FetchFailedError: () => new L(),
                  UnspecifiedBadStatus: R.j,
                  InternalServerError: R.j,
                  InvalidRequest: R.j,
                  RateLimited: R.j,
                  ServiceUnavailable: R.j
                })
              ),
              (0, A.lk)(() => (0, l.Vp)(void 0))
            )
          );
        }
        async getEncryptedVaultKey(e, t) {
          return await (0, w.z)(
            this.serverApiClient.v1.accountrecovery.getEncryptedVaultKey({ login: e, authTicket: t }).pipe(
              (0, A.DZ)((e) =>
                (0, C.EQ)(e, {
                  BusinessError: () => {
                    throw new Error(N.GENERIC_ERROR);
                  },
                  FetchFailedError: () => new L(),
                  UnspecifiedBadStatus: R.j,
                  InternalServerError: R.j,
                  InvalidRequest: R.j,
                  RateLimited: R.j,
                  ServiceUnavailable: R.j
                })
              ),
              (0, A.lk)((e) => {
                const { encryptedVaultKey: t, recoveryId: r } = e.data;
                if (t && r) return (0, l.Vp)({ encryptedVaultKey: t, recoveryId: r });
                throw new Error(N.GENERIC_ERROR);
              })
            )
          );
        }
      };
      M = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [U, b.l, _.CarbonLegacyClient, T.f])], M);
      let V = class {
        constructor(e) {
          this.recoveryKeyService = e;
        }
        async execute() {
          try {
            const e = await (0, w.z)(this.recoveryKeyService.getLastAuthenticatedUserRecoveryData());
            return Promise.resolve({ isFeatureEnabled: e.isEnabled, recoveryKey: "", recoveryId: "", encryptedVaultKey: "" });
          } catch (e) {
            return Promise.reject(new Error("Unable to retrieve initialization data"));
          }
        }
      };
      V = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [M])], V);
      var G = r(54066),
        j = r(10370),
        q = r(89685),
        K = r(56268),
        W = r(66122),
        B = r(94805),
        z = r(16698);
      let H = class {
        constructor(e, t) {
          (this.carbon = e), (this.flexibleEncryptor = t);
        }
        makeDerivationConfig(e) {
          const [, , t] = e.split("$");
          return "pbkdf2" === t ? B.E1 : B.mr;
        }
        async getUserCryptoConfig() {
          const { carbonStateList: e } = this.carbon.queries;
          return await (0, w.z)(
            e({ paths: ["userSession.personalSettings.CryptoFixedSalt", "userSession.personalSettings.CryptoUserPayload"] }).pipe(
              (0, A.nb)({
                success: ([e, t]) => {
                  if ("string" != typeof e) throw new Error("Fixed salt is not a string");
                  if ("string" != typeof t) throw new Error("Marker is not a string");
                  return { fixedSalt: e, derivationConfig: this.makeDerivationConfig(t) };
                },
                failure: () => {
                  throw new Error("Failure getting state list");
                }
              })
            )
          );
        }
        async getUserMasterPassword() {
          const { carbonState: e } = this.carbon.queries;
          return await (0, w.z)(
            e({ path: "userSession.session.masterPassword" }).pipe(
              (0, E.U)((e) => {
                if (!(0, l.d6)(e)) throw new Error("Error when fetching master password from session");
                const t = e.data;
                if ("string" != typeof t) throw new Error("Result data is not a string");
                return (0, G.u)(t);
              })
            )
          );
        }
        async encrypt(e) {
          const t = await this.getUserMasterPassword(),
            { derivationConfig: r, fixedSalt: s } = await this.getUserCryptoConfig();
          return await this.flexibleEncryptor.encrypt(e, t, r, z.Nw, { salt: (0, W.R)(s) });
        }
      };
      H = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [_.CarbonLegacyClient, K._])], H);
      let $ = class {
        constructor(e, t) {
          (this.accountRecoveryKeyService = e), (this.recoveryKeyEncryptor = t);
        }
        async executeWithParams(e) {
          if (e.recoveryKey)
            return (0, l.Vp)({ recoveryKey: e.recoveryKey, encryptedVaultKey: e.encryptedVaultKey, recoveryId: e.recoveryId });
          const t = await this.accountRecoveryKeyService.generateRecoveryKey();
          if ((0, l.hx)(t)) return (0, l.Rn)({ tag: N.GENERIC_ERROR });
          const r = (0, G.u)(t.data.carbonResult.password.toUpperCase()),
            s = await this.recoveryKeyEncryptor.encrypt(r),
            a = (0, j.s)(s),
            n = await this.accountRecoveryKeyService.requestActivation(a);
          return (0, l.hx)(n)
            ? (0, l.Rn)({ tag: n.error.tag })
            : (0, l.Vp)({ recoveryKey: (0, q.v)(r), encryptedVaultKey: a, recoveryId: n.data });
        }
      };
      $ = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [M, H])], $);
      var Q = r(60765),
        Y = r(76183);
      let X = class {
        constructor(e, t) {
          (this.accountRecoveryKeyService = e), (this.syncService = t);
        }
        async executeWithParams(e, t) {
          const r = await this.accountRecoveryKeyService.getCurrentPersonalSettings(),
            s = { AccountRecoveryKey: e, AccountRecoveryKeyId: t };
          if (
            (await this.accountRecoveryKeyService.setPersonalSettings(s),
            (0, l.hx)(await this.syncService.waitForSync(Q.Trigger.SettingsChange)))
          )
            return await this.accountRecoveryKeyService.setPersonalSettings(r), (0, l.Rn)({ tag: N.GENERIC_ERROR });
          const a = await this.accountRecoveryKeyService.confirmActivation(t);
          if ((0, l.hx)(a))
            return (
              await this.accountRecoveryKeyService.setPersonalSettings(r),
              (0, l.hx)(await this.syncService.waitForSync(Q.Trigger.SettingsChange))
                ? (0, l.Rn)({ tag: N.GENERIC_ERROR })
                : (0, l.Rn)({ tag: a.error.tag })
            );
          const n = this.accountRecoveryKeyService.getCurrentUserLogin();
          if (!n) throw new Error("No user login provided");
          return await this.accountRecoveryKeyService.updateLastAuthenticatedUserRecoveryStatus(n), Promise.resolve((0, l.Vp)(void 0));
        }
      };
      X = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [M, Y._])], X);
      let J = class {
        constructor(e, t, r) {
          (this.initializeMachineService = e), (this.requestActivationService = t), (this.confirmActivationService = r);
        }
        create() {
          return (0, v.C)(
            {
              predictableActionArguments: !0,
              schema: { events: {}, context: {} },
              initial: "Starting",
              id: "ActivationFlowMachine",
              context: { isFeatureEnabled: !1, recoveryKey: "", recoveryId: "", encryptedVaultKey: "" },
              states: {
                Starting: {
                  invoke: {
                    src: "initializeMachine",
                    onDone: [
                      { actions: ["assignInitialContext"], target: "InitAccountRecoveryKeyActivation", cond: "isActivationFlow" },
                      { actions: ["assignInitialContext"], target: "GenerateNewAccountRecoveryKey" }
                    ]
                  }
                },
                InitAccountRecoveryKeyActivation: { on: { REQUEST_ACTIVATION: { target: "RequestingActivation" } } },
                RequestingActivation: {
                  invoke: {
                    src: "requestActivation",
                    onDone: [
                      { cond: "isFunctionalError", actions: ["assignFunctionalError"], target: "AccountRecoveryKeyActivationError" },
                      { actions: ["assignKeys"], target: "DisplayAccountRecoveryKey" }
                    ],
                    onError: { actions: ["assignGenericError"], target: "AccountRecoveryKeyActivationError" }
                  }
                },
                DisplayAccountRecoveryKey: { on: { GO_TO_NEXT_STEP: { target: "ConfirmAccountRecoveryKey" } } },
                ConfirmAccountRecoveryKey: {
                  on: {
                    GO_TO_NEXT_STEP: { target: "FinalisingAccountRecoveryKeyActivation" },
                    GO_TO_PREV_STEP: { target: "DisplayAccountRecoveryKey" }
                  }
                },
                FinalisingAccountRecoveryKeyActivation: {
                  invoke: {
                    src: "confirmActivation",
                    onDone: [
                      { cond: "isFunctionalError", actions: ["assignFunctionalError"], target: "AccountRecoveryKeyActivationError" },
                      { target: "AccountRecoveryKeyActivationDone" }
                    ],
                    onError: { actions: ["assignGenericError"], target: "AccountRecoveryKeyActivationError" }
                  }
                },
                AccountRecoveryKeyActivationDone: {},
                GenerateNewAccountRecoveryKey: {
                  on: {
                    REQUEST_ACTIVATION: { target: "RequestingActivation" },
                    CANCEL_GENERATION: { target: "CancelNewAccountRecoveryKey" }
                  }
                },
                CancelNewAccountRecoveryKey: { on: { GO_TO_PREV_STEP: { target: "GenerateNewAccountRecoveryKey" } } },
                AccountRecoveryKeyActivationError: {}
              },
              on: { RESET_FLOW: { actions: ["clearContext"], target: "Starting" } }
            },
            {
              actions: {
                assignInitialContext: (0, f.f0)({
                  encryptedVaultKey: (e, t) => t.data.encryptedVaultKey,
                  recoveryKey: (e, t) => t.data.recoveryKey,
                  recoveryId: (e, t) => t.data.recoveryId,
                  isFeatureEnabled: (e, t) => t.data.isFeatureEnabled
                }),
                assignKeys: (0, f.f0)({
                  recoveryKey: (e, t) => t.data.data.recoveryKey,
                  encryptedVaultKey: (e, t) => t.data.data.encryptedVaultKey,
                  recoveryId: (e, t) => t.data.data.recoveryId
                }),
                assignFunctionalError: (0, f.f0)({ error: (e, t) => t.data.error.tag }),
                assignGenericError: (0, f.f0)({ error: () => N.GENERIC_ERROR }),
                clearContext: (0, f.f0)({ encryptedVaultKey: () => "", recoveryKey: () => "", recoveryId: () => "", error: () => {} })
              },
              services: {
                initializeMachine: () => this.initializeMachineService.execute(),
                requestActivation: (e) => this.requestActivationService.executeWithParams(e),
                confirmActivation: (e) => this.confirmActivationService.executeWithParams(e.recoveryKey, e.recoveryId)
              },
              guards: {
                isActivationFlow: (e, t) =>
                  (function (e) {
                    return e.type.startsWith("done.invoke.ActivationFlowMachine.Starting");
                  })(t) && !t.data.isFeatureEnabled,
                isFunctionalError: (e, t) =>
                  ((function (e) {
                    return e.type.startsWith("done.invoke.ActivationFlowMachine.RequestingActivation");
                  })(t) ||
                    (function (e) {
                      return e.type.startsWith("done.invoke.ActivationFlowMachine.FinalisingAccountRecoveryKeyActivation");
                    })(t)) &&
                  (0, l.hx)(t.data)
              }
            }
          );
        }
      };
      J = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [V, $, X])], J);
      var Z = r(26290);
      const ee = (e) => !0;
      class te extends (0, x.Q)({
        initialValue: void 0,
        persist: !1,
        scope: I.F.Device,
        storeName: "activation-flow-machine",
        storeTypeGuard: ee
      }) {}
      let re = class {
        constructor(e, t) {
          this.activationMachineStore = t;
          const r = e.create();
          this.interpreter = m.kJ(r).onTransition(async (e) => {
            e.changed ||
              "xstate.init" === e.event.type ||
              console.warn(
                `[ARK Activation] State is unchanged. Unexpected transition on ${JSON.stringify(e.value)} with event ${e.event.type} `
              );
            try {
              const e = this.interpreter?.getSnapshot();
              e &&
                (await (async (e, t) => {
                  await e.set(JSON.stringify(t));
                })(this.activationMachineStore, e));
            } catch (e) {
              console.warn("[ARK Activation] Unable to get snapshot", e);
            }
          });
        }
        async prepare() {
          if (this.interpreter)
            try {
              const e = await (async (e) => {
                const t = await e.getState();
                return t ? Z.ZM.create(JSON.parse(t)) : void 0;
              })(this.activationMachineStore);
              try {
                this.interpreter.start(e);
              } catch (e) {
                console.error("[ARK Activation] Unable to reuse the stored state: ", e), this.interpreter.start();
              }
            } catch (e) {
              console.error("[ARK Activation] Unable to start machine", e);
            }
        }
        ready() {
          return new y.X(!0);
        }
        continue(e) {
          if (!this.interpreter) throw new Error("Activation flow not started");
          this.interpreter.send(e);
        }
        stop() {
          this.isStarted() && (this.interpreter = void 0);
        }
        isStarted() {
          return Boolean(this.interpreter);
        }
      };
      re = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [J, te])], re);
      let se = class {
        constructor(e) {
          this.activationFlow = e;
        }
        execute() {
          return this.activationFlow.continue({ type: "GO_TO_NEXT_STEP" }), Promise.resolve((0, l.Vp)(void 0));
        }
      };
      se = (0, s.__decorate)([(0, p.W)(h.Z), (0, s.__metadata)("design:paramtypes", [re])], se);
      var ae = r(22481);
      let ne = class {
        constructor(e) {
          this.activationFlow = e;
        }
        execute() {
          return this.activationFlow.continue({ type: "GO_TO_PREV_STEP" }), Promise.resolve((0, l.Vp)(void 0));
        }
      };
      ne = (0, s.__decorate)([(0, p.W)(ae.H), (0, s.__metadata)("design:paramtypes", [re])], ne);
      var ie = r(74593);
      let oe = class {
        constructor(e) {
          this.activationFlow = e;
        }
        execute() {
          return this.activationFlow.continue({ type: "REQUEST_ACTIVATION" }), Promise.resolve((0, l.Vp)(void 0));
        }
      };
      oe = (0, s.__decorate)([(0, p.W)(ie.e), (0, s.__metadata)("design:paramtypes", [re])], oe);
      var ce = r(23823);
      let ue = class {
        constructor(e) {
          this.activationFlow = e;
        }
        execute() {
          return this.activationFlow.continue({ type: "RESET_FLOW" }), Promise.resolve((0, l.Vp)(void 0));
        }
      };
      ue = (0, s.__decorate)([(0, p.W)(ce.w), (0, s.__metadata)("design:paramtypes", [re])], ue);
      var de = r(78519);
      let le = class {
        constructor(e) {
          this.activationFlow = e;
        }
        execute() {
          return this.activationFlow.continue({ type: "CANCEL_GENERATION" }), Promise.resolve((0, l.Vp)(void 0));
        }
      };
      le = (0, s.__decorate)([(0, p.W)(de.r), (0, s.__metadata)("design:paramtypes", [re])], le);
      var pe = r(6790);
      let he = class {
        constructor(e) {
          this.activationFlow = e;
        }
        execute() {
          return this.activationFlow.continue({ type: "GO_TO_NEXT_STEP" }), Promise.resolve((0, l.Vp)(void 0));
        }
      };
      he = (0, s.__decorate)([(0, p.W)(pe.W), (0, s.__metadata)("design:paramtypes", [re])], he);
      var me = r(78548);
      let ye = class {
        constructor(e) {
          this.recoveryKeyService = e;
        }
        async execute() {
          try {
            const { authTicket: e } = await this.recoveryKeyService.getAuthTicketInfo();
            return Promise.resolve(e ?? "");
          } catch (e) {
            return Promise.reject(new Error("Unable to retrieve initialization data"));
          }
        }
      };
      ye = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [M])], ye);
      var ge = r(25594);
      let ve = class {
        constructor(e) {
          this.flexibleDecryptor = e;
        }
        async decrypt(e, t) {
          return await this.flexibleDecryptor.decrypt(e, t);
        }
      };
      ve = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [ge.a])], ve);
      let fe = class {
        constructor(e, t) {
          (this.accountRecoveryKeyService = e), (this.recoveryKeyDecryptor = t);
        }
        async executeWithParams({ login: e, authTicket: t, recoveryKey: r }) {
          try {
            const s = await this.accountRecoveryKeyService.getEncryptedVaultKey(e, t);
            if ((0, l.hx)(s)) return Promise.reject(N.GENERIC_ERROR);
            const a = (0, G.u)(r),
              n = (0, W.R)(s.data.encryptedVaultKey),
              i = await this.recoveryKeyDecryptor.decrypt(a, n),
              o = (0, j.s)(i),
              c = atob(o);
            return Promise.resolve({ oldPassword: c });
          } catch (e) {
            return (s = e) instanceof Error && s.message.includes("Signature cannot be verified")
              ? Promise.reject(N.WRONG_RECOVERY_KEY_ERROR)
              : Promise.reject(N.GENERIC_ERROR);
          }
          var s;
        }
      };
      fe = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [M, ve])], fe);
      let we = class {
        constructor(e) {
          this.carbon = e;
        }
        async executeWithParams(e) {
          const { commands: t, queries: r } = this.carbon;
          try {
            const r = await t.carbonLegacyLeeloo({
              name: "openSessionWithMasterPassword",
              arg: [{ login: e.login, password: e.oldPassword, rememberPassword: !1, requiredPermissions: void 0 }]
            });
            if ((0, l.hx)(r))
              return Promise.reject(new Error(`[ARK] - Error while trying to open session with deciphered recovery key: ${r.error}`));
            const s = await t.carbon({
              name: "changeMasterPassword",
              args: [{ newPassword: e.newPassword, currentPassword: e.oldPassword, flow: "ACCOUNT_RECOVERY_KEY" }]
            });
            return (0, l.hx)(s)
              ? Promise.reject(new Error(`[ARK] - Error while changing user Master Password: ${s.error}`))
              : Promise.resolve(void 0);
          } catch (e) {
            const s = await (0, w.z)(r.carbonState({ path: "userSession.account.isAuthenticated" }));
            return (
              (0, l.d6)(s) && s.data && (await t.carbonLegacyLeeloo({ name: "closeSession", arg: [{}] })),
              Promise.reject(new Error(`[ARK] - Unable to change user Master Password: ${e}`))
            );
          }
        }
      };
      we = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [_.CarbonLegacyClient])], we);
      var Se = r(81822);
      let Ee = class {
        constructor(e, t) {
          (this.recoveryKeyService = e), (this.identityVerification = t), (this.recoveryKeyService = e), (this.identityVerification = t);
        }
        async executeWithParams(e) {
          try {
            const t = await this.recoveryKeyService.getPreferredVerificationMethod(e);
            if ((0, l.hx)(t)) throw new Error("Unable to retrieve verifications methods for login");
            const r = t.data.type;
            return (
              this.identityVerification.commands.startIdentityVerification({ login: e, verificationMethod: r }), Promise.resolve(void 0)
            );
          } catch (e) {
            return Promise.reject(new Error("Something went wrong..."));
          }
        }
      };
      Ee = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [M, Se.l])], Ee);
      let _e = class {
        constructor(e, t, r, s) {
          (this.initializeMachineService = e),
            (this.checkAccountRecoveryKeyService = t),
            (this.changeMasterPasswordService = r),
            (this.requestAuthenticationMethodForLoginService = s);
        }
        create() {
          return (0, v.C)(
            {
              predictableActionArguments: !0,
              schema: { events: {}, context: {} },
              initial: "Idle",
              id: "RecoveryFlowMachine",
              context: { login: "", authTicket: "", newPassword: "", recoveryKey: "", oldPassword: "", encryptedVaultKey: "" },
              states: {
                Idle: { entry: ["clearContext"], on: { START_RECOVERY_FLOW: { target: "Starting", actions: ["assignAccountEmail"] } } },
                Starting: {
                  invoke: {
                    src: "initializeMachine",
                    onDone: [
                      { actions: ["assignInitialContext"], target: "IdentityVerification", cond: "isAuthTicketNeeded" },
                      { actions: ["assignInitialContext"], target: "EnterRecoveryKey" }
                    ]
                  }
                },
                IdentityVerification: { entry: ["requestAuthenticationMethodForLogin"] },
                EnterRecoveryKey: { on: { SUBMIT_RECOVERY_KEY: { actions: ["assignRecoveryKey"], target: "CheckAccountRecoveryKey" } } },
                CheckAccountRecoveryKey: {
                  invoke: {
                    src: "checkAccountRecoveryKey",
                    onDone: { actions: ["assignOldPassword"], target: "ChangeMasterPassword" },
                    onError: { actions: ["assignError"], target: "EnterRecoveryKey" }
                  }
                },
                ChangeMasterPassword: { on: { CONFIRM_NEW_PASSWORD: { actions: ["assignNewPassword"], target: "FinalisingRecovery" } } },
                FinalisingRecovery: {
                  invoke: {
                    src: "changeMasterPassword",
                    onDone: { target: "RecoverySuccess" },
                    onError: { actions: ["assignError"], target: "RecoveryError" }
                  }
                },
                RecoveryError: { on: { TRY_AGAIN: { actions: ["clearError"], target: "ChangeMasterPassword" } } },
                RecoverySuccess: { type: "final" }
              },
              on: {
                CLEAR_ERROR: { actions: ["clearError"] },
                IDENTITY_VERIFICATION_COMPLETE: { actions: ["assignAuthTicket"], target: "EnterRecoveryKey" },
                CANCEL_RECOVERY_FLOW: { target: "Idle" }
              }
            },
            {
              actions: {
                assignAccountEmail: (0, f.f0)({ login: (e, t) => t.login }),
                assignInitialContext: (0, f.f0)({ authTicket: (e, t) => t.data }),
                assignAuthTicket: (0, f.f0)({ authTicket: (e, t) => t.authTicket }),
                assignNewPassword: (0, f.f0)({ newPassword: (e, t) => t.password }),
                assignRecoveryKey: (0, f.f0)({ recoveryKey: (e, t) => t.recoveryKey }),
                assignOldPassword: (0, f.f0)({ oldPassword: (e, t) => t.data.oldPassword }),
                assignError: (0, f.f0)({ error: (e, t) => t.data }),
                clearError: (0, f.f0)({ error: () => {} }),
                requestAuthenticationMethodForLogin: (e) => this.requestAuthenticationMethodForLoginService.executeWithParams(e.login),
                clearContext: (0, f.f0)({
                  login: () => "",
                  newPassword: () => "",
                  localAccounts: () => [],
                  recoveryKey: () => "",
                  oldPassword: () => "",
                  encryptedVaultKey: () => "",
                  authTicket: () => ""
                })
              },
              services: {
                initializeMachine: () => this.initializeMachineService.execute(),
                checkAccountRecoveryKey: (e) => this.checkAccountRecoveryKeyService.executeWithParams(e),
                changeMasterPassword: (e) => this.changeMasterPasswordService.executeWithParams(e)
              },
              guards: { isAuthTicketNeeded: (e, t) => !t.data }
            }
          );
        }
      };
      _e = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [ye, fe, we, Ee])], _e);
      const be = (e) => !0;
      class Te extends (0, x.Q)({
        initialValue: void 0,
        persist: !1,
        scope: I.F.Device,
        storeName: "recovery-flow-machine",
        storeTypeGuard: be
      }) {}
      let Ae = class {
        constructor(e, t) {
          this.recoveryMachineStore = t;
          const r = e.create();
          this.interpreter = m.kJ(r).onTransition(async (e) => {
            e.changed ||
              "xstate.init" === e.event.type ||
              console.warn(
                `[ARK Recovery] State is unchanged. Unexpected transition on ${JSON.stringify(e.value)} with event ${e.event.type} `
              );
            try {
              const e = this.interpreter?.getSnapshot();
              e &&
                (await (async (e, t) => {
                  await e.set(JSON.stringify(t));
                })(this.recoveryMachineStore, e));
            } catch (e) {
              console.warn("[ARK Recovery] Unable to get snapshot", e);
            }
          });
        }
        async prepare() {
          if (this.interpreter)
            try {
              const e = await (async (e) => {
                const t = await e.getState();
                return t ? Z.ZM.create(JSON.parse(t)) : void 0;
              })(this.recoveryMachineStore);
              try {
                this.interpreter.start(e);
              } catch (e) {
                console.error("[ARK Recovery] Unable to reuse the stored state: ", e), this.interpreter.start();
              }
            } catch (e) {
              console.error("[ARK Recovery] Unable to start machine", e);
            }
        }
        ready() {
          return new y.X(!0);
        }
        continue(e) {
          if (!this.interpreter) throw new Error("Recovery flow not started");
          this.interpreter.send(e);
        }
        stop() {
          this.isStarted() && (this.interpreter = void 0);
        }
        isStarted() {
          return Boolean(this.interpreter);
        }
      };
      Ae = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [_e, Te])], Ae);
      let Ce = class {
        constructor(e) {
          (this.recoveryFlow = e), (this.recoveryFlow = e);
        }
        execute(e) {
          return (
            this.recoveryFlow.continue({ type: "CONFIRM_NEW_PASSWORD", password: e.body.password }), Promise.resolve((0, l.Vp)(void 0))
          );
        }
      };
      Ce = (0, s.__decorate)([(0, p.W)(me.v), (0, s.__metadata)("design:paramtypes", [Ae])], Ce);
      var Re = r(60017),
        Ie = r(26457),
        xe = r(9671);
      let Pe = class {
        constructor(e, t, r, s, a) {
          (this.accountRecoveryKeyService = e),
            (this.activationFlow = t),
            (this.syncService = r),
            (this.logger = s),
            (this.allowedToFail = a);
        }
        async execute(e) {
          const { reason: t } = e.body,
            r = await this.accountRecoveryKeyService.deactivate(t);
          if ((0, l.hx)(r)) return this.logger.trace("Deactivate ARK: " + r.error.message), (0, l.Rn)({ tag: r.error.tag });
          const s = this.accountRecoveryKeyService.getCurrentUserLogin();
          return s
            ? (await this.accountRecoveryKeyService.updateLastAuthenticatedUserRecoveryStatus(s),
              this.activationFlow.continue({ type: "RESET_FLOW" }),
              await this.accountRecoveryKeyService.setPersonalSettings({ AccountRecoveryKey: void 0, AccountRecoveryKeyId: void 0 }),
              await this.allowedToFail.doOne(async () => await this.syncService.waitForSync(Q.Trigger.SettingsChange), "waitForSync"),
              (0, l.Vp)(void 0))
            : (this.logger.trace("Deactivate ARK: No user login provided"), (0, l.Rn)({ tag: N.GENERIC_ERROR }));
        }
      };
      Pe = (0, s.__decorate)([(0, p.W)(Re.E), (0, s.__metadata)("design:paramtypes", [M, re, Y._, Ie.V, xe.J])], Pe);
      var De = r(24662);
      let Ue = class {
        constructor(e) {
          this.recoveryFlow = e;
        }
        execute(e) {
          return (
            this.recoveryFlow.continue({ type: "SUBMIT_RECOVERY_KEY", recoveryKey: e.body.recoveryKey }), Promise.resolve((0, l.Vp)(void 0))
          );
        }
      };
      Ue = (0, s.__decorate)([(0, p.W)(De.Y), (0, s.__metadata)("design:paramtypes", [Ae])], Ue);
      var Fe = r(77539);
      let Oe = class {
        constructor(e) {
          this.recoveryFlow = e;
        }
        execute() {
          return this.recoveryFlow.continue({ type: "TRY_AGAIN" }), Promise.resolve((0, l.Vp)(void 0));
        }
      };
      Oe = (0, s.__decorate)([(0, p.W)(Fe.d), (0, s.__metadata)("design:paramtypes", [Ae])], Oe);
      var Ne = r(22632),
        ke = r(94189);
      let Le = class {
        constructor(e, t) {
          (this.recoveryFlow = e), (this.cqrsClient = t), (this.recoveryFlow = e);
        }
        execute() {
          return (
            this.recoveryFlow.continue({ type: "CANCEL_RECOVERY_FLOW" }),
            this.cqrsClient.getClient(n.i).commands.cancelIdentityVerification(),
            Promise.resolve((0, l.Vp)(void 0))
          );
        }
      };
      Le = (0, s.__decorate)([(0, p.W)(Ne.b), (0, s.__metadata)("design:paramtypes", [Ae, ke.w])], Le);
      var Me = r(14074);
      let Ve = class {
        constructor(e) {
          (this.recoveryFlow = e), (this.recoveryFlow = e);
        }
        execute(e) {
          const { login: t } = e.body;
          return this.recoveryFlow.continue({ type: "START_RECOVERY_FLOW", login: t }), Promise.resolve((0, l.Vp)(void 0));
        }
      };
      Ve = (0, s.__decorate)([(0, p.W)(Me.Q), (0, s.__metadata)("design:paramtypes", [Ae])], Ve);
      var Ge,
        je,
        qe = r(85390),
        Ke = r(6136),
        We = r(20754),
        Be = r(40956),
        ze = r(69885),
        He = r(6220);
      !(function (e) {
        (e[(e.InitActivation = 0)] = "InitActivation"),
          (e[(e.RequestActivation = 1)] = "RequestActivation"),
          (e[(e.DisplayKey = 2)] = "DisplayKey"),
          (e[(e.ConfirmKey = 3)] = "ConfirmKey"),
          (e[(e.FinaliseActivation = 4)] = "FinaliseActivation"),
          (e[(e.ActivationDone = 5)] = "ActivationDone"),
          (e[(e.ShowError = 6)] = "ShowError"),
          (e[(e.GenerateNewKey = 7)] = "GenerateNewKey"),
          (e[(e.CancelGenerateNewKey = 8)] = "CancelGenerateNewKey");
      })(Ge || (Ge = {})),
        (function (e) {
          (e[(e.InitRecovery = 0)] = "InitRecovery"),
            (e[(e.IdentityVerification = 1)] = "IdentityVerification"),
            (e[(e.EnterRecoveryKey = 2)] = "EnterRecoveryKey"),
            (e[(e.CheckAccountRecoveryKey = 3)] = "CheckAccountRecoveryKey"),
            (e[(e.ChangeMasterPassword = 4)] = "ChangeMasterPassword"),
            (e[(e.Finalising = 5)] = "Finalising"),
            (e[(e.Success = 6)] = "Success"),
            (e[(e.Failure = 7)] = "Failure");
        })(je || (je = {}));
      const $e = (e) =>
          (0, ze.of)(
            (0, l.Vp)(
              (function (e) {
                if (!e.matches("Starting"))
                  return e.matches("InitAccountRecoveryKeyActivation")
                    ? { step: Ge.InitActivation }
                    : e.matches("RequestingActivation")
                    ? { step: Ge.RequestActivation }
                    : e.matches("DisplayAccountRecoveryKey")
                    ? { step: Ge.DisplayKey, recoveryKey: e.context.recoveryKey }
                    : e.matches("ConfirmAccountRecoveryKey")
                    ? { step: Ge.ConfirmKey, recoveryKey: e.context.recoveryKey }
                    : e.matches("FinalisingAccountRecoveryKeyActivation")
                    ? { step: Ge.FinaliseActivation }
                    : e.matches("AccountRecoveryKeyActivationDone")
                    ? { step: Ge.ActivationDone, isFeatureEnabled: e.context.isFeatureEnabled }
                    : e.matches("AccountRecoveryKeyActivationError")
                    ? { step: Ge.ShowError, error: e.context.error }
                    : e.matches("GenerateNewAccountRecoveryKey")
                    ? { step: Ge.GenerateNewKey }
                    : e.matches("CancelNewAccountRecoveryKey")
                    ? { step: Ge.CancelGenerateNewKey }
                    : void console.warn("[ARK Activation] - No view associated to state ", e.value);
              })(e)
            )
          ),
        Qe = (e) => e.pipe((0, He.z)($e));
      var Ye = r(52800);
      const Xe = (e, t) => {
        const r = t.matches(e.value),
          s = (0, Ye.Z)(e.context, t.context);
        return r && s;
      };
      let Je = class {
        constructor(e, t) {
          (this.activationFlow = e), (this.activationFlowMachineStore = t);
        }
        execute() {
          return (0, qe.a)(
            [
              ((e = this.activationFlowMachineStore), e.state$.pipe((0, E.U)((e) => (e ? Z.ZM.create(JSON.parse(e)) : void 0)))),
              this.activationFlow.ready()
            ],
            (e, t) => {
              if (e && t) return e;
            }
          ).pipe(
            (0, S.h)(Boolean),
            (0, Ke.x)((e, t) => Xe(e, t)),
            Qe
          );
          var e;
        }
      };
      Je = (0, s.__decorate)([(0, We.e)(Be.S), (0, s.__metadata)("design:paramtypes", [re, te])], Je);
      var Ze = r(43978),
        et = r(22618);
      let tt = class {
        constructor(e) {
          this.accountRecoveryKeyService = e;
        }
        execute({ body: e }) {
          const { login: t } = e;
          return "" === t
            ? (0, ze.of)((0, l.Vp)({ isEnabled: !1 }))
            : this.accountRecoveryKeyService.getLastAuthenticatedUserRecoveryData().pipe(
                (0, Ze.w)(
                  async (e) => (
                    (void 0 !== e.isEnabled && t === e.login) ||
                      (await this.accountRecoveryKeyService.updateLastAuthenticatedUserRecoveryStatus(t)),
                    e
                  )
                ),
                (0, E.U)((e) => (0, l.Vp)({ isEnabled: e.isEnabled }))
              );
        }
      };
      tt = (0, s.__decorate)([(0, We.e)(et.D), (0, s.__metadata)("design:paramtypes", [M])], tt);
      var rt = r(162),
        st = r(80448);
      let at = class {
        constructor(e, t) {
          (this.accountRecoveryKeyService = e), (this.carbonLegacyClient = t);
        }
        execute() {
          const e = this.accountRecoveryKeyService.getCurrentUserLogin();
          if (!e) throw new Error("No user login provided");
          const t = (0, rt.D)(this.accountRecoveryKeyService.updateLastAuthenticatedUserRecoveryStatus(e)).pipe(
              (0, Ze.w)(() => this.carbonLegacyClient.queries.carbonState({ path: "userSession.personalSettings.RecoveryOptIn" })),
              (0, S.h)(l.d6),
              (0, E.U)((e) => "boolean" == typeof e.data && e.data)
            ),
            r = this.accountRecoveryKeyService
              .getLastAuthenticatedUserRecoveryData()
              .pipe((0, E.U)((e) => void 0 !== e.isEnabled && e.isEnabled));
          return (0, qe.a)([t, r]).pipe((0, E.U)(([e, t]) => (0, l.Vp)({ adminAssistedRecovery: e, accountRecoveryKey: t })));
        }
      };
      at = (0, s.__decorate)([(0, We.e)(st.V), (0, s.__metadata)("design:paramtypes", [M, _.CarbonLegacyClient])], at);
      var nt = r(36261);
      const it = (e) =>
          (0, ze.of)(
            (0, l.Vp)(
              (function (e) {
                return e.matches("Starting")
                  ? { step: je.InitRecovery, error: e.context.error }
                  : e.matches("IdentityVerification")
                  ? { step: je.IdentityVerification, login: e.context.login }
                  : e.matches("EnterRecoveryKey") || e.matches("CheckAccountRecoveryKey")
                  ? { step: je.EnterRecoveryKey, error: e.context.error }
                  : e.matches("ChangeMasterPassword")
                  ? { step: je.ChangeMasterPassword, error: e.context.error }
                  : e.matches("FinalisingRecovery")
                  ? { step: je.Finalising }
                  : e.matches("RecoverySuccess")
                  ? { step: je.Success }
                  : e.matches("RecoveryError")
                  ? { step: je.Failure }
                  : void console.warn("[ARK Recovery] - No view associated to state ", e.value);
              })(e)
            )
          ),
        ot = (e) => e.pipe((0, He.z)(it));
      let ct = class {
        constructor(e, t) {
          (this.recoveryFlow = e), (this.recoveryFlowMachineStore = t);
        }
        execute() {
          return (0, qe.a)(
            [
              ((e = this.recoveryFlowMachineStore), e.state$.pipe((0, E.U)((e) => (e ? Z.ZM.create(JSON.parse(e)) : void 0)))),
              this.recoveryFlow.ready()
            ],
            (e, t) => {
              if (e && t) return e;
            }
          ).pipe(
            (0, S.h)(Boolean),
            (0, Ke.x)((e, t) => Xe(e, t)),
            ot
          );
          var e;
        }
      };
      ct = (0, s.__decorate)([(0, We.e)(nt.y), (0, s.__metadata)("design:paramtypes", [Ae, Te])], ct);
      var ut = r(68307),
        dt = r(13089);
      let lt = class {
        constructor(e) {
          (this.recoveryFlow = e), (this.recoveryFlow = e);
        }
        handle(e) {
          const { authTicket: t } = e.body;
          return this.recoveryFlow.continue({ type: "IDENTITY_VERIFICATION_COMPLETE", authTicket: t }), Promise.resolve();
        }
      };
      lt = (0, s.__decorate)([(0, ut.b)(dt.w), (0, s.__metadata)("design:paramtypes", [Ae])], lt);
      let pt = class {};
      pt = (0, s.__decorate)(
        [
          (0, i.Y)({
            api: a.j,
            stores: [te, Te, U],
            imports: [c.n, u.D, d.R],
            handlers: {
              commands: {
                goToActivationNextStep: se,
                goToActivationPrevStep: ne,
                requestActivation: oe,
                cancelActivation: ue,
                cancelGeneration: le,
                confirmActivation: he,
                confirmNewPassword: Ce,
                deactivate: Pe,
                submitRecoveryKey: Ue,
                tryAgainRecovery: Oe,
                cancelRecoveryFlow: Le,
                startRecoveryFlow: Ve
              },
              events: { ...(0, i.g)(n.i, { identityVerificationCompleted: lt }) },
              queries: { activationFlowStatus: Je, accountRecoveryKeyStatus: tt, recoveryMethodsInfo: at, recoveryFlowStatus: ct }
            },
            providers: [
              ...(0, o.H)(re, {
                inject: [J, te],
                asyncFactory: async (e, t) => {
                  const r = new re(e, t);
                  return await r.prepare(), r;
                }
              }),
              ...(0, o.H)(Ae, {
                inject: [_e, Te],
                asyncFactory: async (e, t) => {
                  const r = new Ae(e, t);
                  return await r.prepare(), r;
                }
              }),
              J,
              _e,
              V,
              ye,
              fe,
              Ee,
              M,
              $,
              X,
              ve,
              H,
              we
            ]
          })
        ],
        pt
      );
    },
    69211: (e, t, r) => {
      "use strict";
      r.d(t, { m: () => c });
      var s = r(86952),
        a = r(46255),
        n = r(21087),
        i = r(12729),
        o = r(6118);
      const c = (0, s.Q)({
        name: "accountDeletion",
        commands: { completeAccountDeletion: i.w, initiateAccountDeletion: o.G },
        events: {},
        queries: { userAuthenticationMethod: a.c, isFlowCompleted: n.h }
      });
    },
    12729: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => s, w: () => o });
      var s,
        a = r(74354),
        n = r(25029),
        i = r(7165);
      !(function (e) {
        (e.INVALID_OTP_ALREADY_USED = "INVALID_OTP_ALREADY_USED"),
          (e.INVALID_OTP_BLOCKED = "INVALID_OTP_BLOCKED"),
          (e.VERIFICATION_FAILED = "VERIFICATION_FAILED"),
          (e.ACCOUNT_BLOCKED_CONTACT_SUPPORT = "ACCOUNT_BLOCKED_CONTACT_SUPPORT"),
          (e.VERIFICATION_REQUIRES_REQUEST = "VERIFICATION_REQUIRES_REQUEST"),
          (e.VERIFICATION_TIMEOUT = "VERIFICATION_TIMEOUT");
      })(s || (s = {}));
      i.z.object({ tag: i.z.nativeEnum(s) });
      class o extends (0, a.g)({ scope: n.F.Device }) {}
    },
    6118: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => o, q: () => s });
      var s,
        a = r(74354),
        n = r(25029),
        i = r(7165);
      !(function (e) {
        (e.UNKNOWN_USER = "user_not_found"), (e.SSO_BLOCKED = "SSO_BLOCKED");
      })(s || (s = {}));
      i.z.object({ tag: i.z.nativeEnum(s) });
      class o extends (0, a.g)({ scope: n.F.Device }) {}
    },
    21087: (e, t, r) => {
      "use strict";
      r.d(t, { h: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.Device }) {}
    },
    46255: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.Device }) {}
    },
    24452: (e, t, r) => {
      "use strict";
      r.d(t, { l: () => i });
      var s = r(86952),
        a = r(39129),
        n = r(55398);
      const i = (0, s.Q)({ name: "accountReferral", commands: { inviteByEmail: n.P }, events: {}, queries: { getSharingLink: a.h } });
    },
    55398: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    39129: (e, t, r) => {
      "use strict";
      r.d(t, { h: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    97040: (e, t, r) => {
      "use strict";
      r.d(t, { X: () => D });
      var s = r(88802),
        a = r(99634),
        n = r(1824),
        i = r(69211),
        o = r(60399),
        c = r(87065),
        u = r(6118),
        d = r(12729),
        l = r(57924),
        p = r(61501),
        h = r(48844),
        m = r(18533),
        y = r(20195),
        g = r(87279);
      let v = class {
        constructor(e) {
          (this.serverApiClient = e),
            (this.getFunctionalError = (e) => {
              switch (e) {
                case u.q.UNKNOWN_USER:
                  return { tag: u.q.UNKNOWN_USER };
                case u.q.SSO_BLOCKED:
                  return { tag: u.q.SSO_BLOCKED };
                default:
                  throw new Error(`GetAuthenticationMethodsForReset: error ${e}`);
              }
            });
        }
        getAuthenticationMethodsForReset(e) {
          return this.serverApiClient.v1.authentication
            .getAuthenticationMethodsForReset({ login: e, methods: ["email_token", "totp"] })
            .pipe(
              (0, h.DZ)((e) =>
                (0, m.EQ)(e, {
                  BusinessError: (e) => this.getFunctionalError(e.code),
                  FetchFailedError: () => {
                    throw new Error("Fetch Failed error");
                  },
                  BadStatus: y.j,
                  InternalServerError: y.j,
                  InvalidRequest: y.j,
                  RateLimited: y.j,
                  ServiceUnavailable: y.j,
                  UnspecifiedBadStatus: y.j
                })
              ),
              (0, h.Qn)((e) => {
                if (e.data.verifications.length >= 1) return e.data.verifications[0].type;
                throw new Error("GetAuthenticationMethodsForReset: couldn't retrieve any method");
              })
            );
        }
        requestEmailTokenVerificationSending(e) {
          return (0, o.z)(
            this.serverApiClient.v1.authentication.requestEmailTokenVerification({ login: e }).pipe((0, c.U)((e) => (0, g.d6)(e)))
          );
        }
        getVerifyTokenFunctionalError(e) {
          switch (e) {
            case "invalid_otp_already_used":
              return { tag: d.D.INVALID_OTP_ALREADY_USED };
            case "invalid_otp_blocked":
              return { tag: d.D.INVALID_OTP_BLOCKED };
            case "verification_failed":
              return { tag: d.D.VERIFICATION_FAILED };
            case "account_blocked_contact_support":
              return { tag: d.D.ACCOUNT_BLOCKED_CONTACT_SUPPORT };
            case "verification_requires_request":
              return { tag: d.D.VERIFICATION_REQUIRES_REQUEST };
            case "verification_timeout":
              return { tag: d.D.VERIFICATION_TIMEOUT };
            default:
              throw new Error("performTokenVerification: Business error not handled");
          }
        }
        verifyTOTPToken(e, t) {
          return (0, o.z)(
            this.serverApiClient.v1.authentication.performTotpVerification({ login: e, otp: t, intent: "account_delete_or_reset" }).pipe(
              (0, h.DZ)((e) =>
                (0, m.EQ)(e, {
                  BusinessError: (e) => this.getVerifyTokenFunctionalError(e.code),
                  FetchFailedError: y.j,
                  BadStatus: y.j,
                  InternalServerError: y.j,
                  InvalidRequest: y.j,
                  RateLimited: y.j,
                  ServiceUnavailable: y.j,
                  UnspecifiedBadStatus: y.j
                })
              ),
              (0, h.Qn)((e) => e.data.authTicket)
            )
          );
        }
        verifyEmailToken(e, t) {
          return (0, o.z)(
            this.serverApiClient.v1.authentication
              .performEmailTokenVerification({ login: e, token: t, intent: "account_delete_or_reset" })
              .pipe(
                (0, h.DZ)((e) =>
                  (0, m.EQ)(e, {
                    BusinessError: (e) => this.getVerifyTokenFunctionalError(e.code),
                    FetchFailedError: y.j,
                    BadStatus: y.j,
                    InternalServerError: y.j,
                    InvalidRequest: y.j,
                    RateLimited: y.j,
                    ServiceUnavailable: y.j,
                    UnspecifiedBadStatus: y.j
                  })
                ),
                (0, h.Qn)((e) => e.data.authTicket)
              )
          );
        }
        deleteOrResetAccount(e, t, r = !0) {
          return (0, o.z)(
            this.serverApiClient.v1.account.deleteOrResetAccount({ authTicket: t, isDelete: r, login: e }).pipe(
              (0, h.DZ)((e) =>
                (0, m.EQ)(e, {
                  BusinessError: y.j,
                  FetchFailedError: y.j,
                  BadStatus: y.j,
                  InternalServerError: y.j,
                  InvalidRequest: y.j,
                  RateLimited: y.j,
                  ServiceUnavailable: y.j,
                  UnspecifiedBadStatus: y.j
                })
              ),
              (0, h.Qn)(() => !0)
            )
          );
        }
      };
      v = (0, s.__decorate)([(0, l.GS)(), (0, s.__metadata)("design:paramtypes", [p.l])], v);
      var f = r(20754),
        w = r(46255),
        S = r(25029),
        E = r(95681),
        _ = r(23347);
      class b extends (0, E.Q)({
        persist: !1,
        scope: S.F.Device,
        storeName: "account-deletion",
        initialValue: { login: "", userAuthenticationMethod: null, isFlowCompleted: !1 },
        capacity: _.Y._001KB
      }) {}
      let T = class {
        constructor(e) {
          this.accountDeletionStore = e;
        }
        execute() {
          return this.accountDeletionStore.state$.pipe((0, c.U)((e) => (0, g.Vp)(e.userAuthenticationMethod)));
        }
      };
      T = (0, s.__decorate)([(0, f.e)(w.c), (0, s.__metadata)("design:paramtypes", [b])], T);
      var A = r(21087);
      let C = class {
        constructor(e) {
          this.accountDeletionStore = e;
        }
        execute() {
          return this.accountDeletionStore.state$.pipe((0, c.U)((e) => (0, g.Vp)(e.isFlowCompleted)));
        }
      };
      var R;
      (C = (0, s.__decorate)([(0, f.e)(A.h), (0, s.__metadata)("design:paramtypes", [b])], C)),
        (function (e) {
          (e.EMAIL = "EMAIL"), (e.TOTP = "TOTP");
        })(R || (R = {}));
      var I = r(63663);
      let x = class {
        constructor(e, t) {
          (this.accountDeletionStore = e), (this.deleteAccountService = t);
        }
        async execute({ body: e }) {
          const { token: t, isDelete: r } = e,
            s = await this.accountDeletionStore.getState(),
            { userAuthenticationMethod: a, login: n } = s,
            i =
              a === R.EMAIL
                ? await this.deleteAccountService.verifyEmailToken(n, t)
                : await this.deleteAccountService.verifyTOTPToken(n, t);
          if ((0, g.hx)(i)) return Promise.resolve(i);
          const o = await this.deleteAccountService.deleteOrResetAccount(n, i.data, r);
          if ((0, g.hx)(o)) throw new Error("CompleteAccountDeletionCommand : error while deleting the account");
          return this.accountDeletionStore.set({ ...s, isFlowCompleted: !0 }), Promise.resolve((0, g.Vp)(void 0));
        }
      };
      x = (0, s.__decorate)([(0, I.W)(d.w), (0, s.__metadata)("design:paramtypes", [b, v])], x);
      let P = class {
        constructor(e, t) {
          (this.accountDeletionStore = e), (this.deleteAccountService = t);
        }
        async execute({ body: e }) {
          const { login: t } = e,
            r = await (0, o.z)(
              this.deleteAccountService.getAuthenticationMethodsForReset(t).pipe((0, h.Qn)((e) => ("email_token" === e ? R.EMAIL : R.TOTP)))
            );
          if ((0, g.hx)(r)) return Promise.resolve(r);
          r.data === R.EMAIL && this.deleteAccountService.requestEmailTokenVerificationSending(t);
          const s = await this.accountDeletionStore.getState();
          return (
            await this.accountDeletionStore.set({ ...s, login: t, userAuthenticationMethod: r.data }), Promise.resolve((0, g.Vp)(void 0))
          );
        }
      };
      P = (0, s.__decorate)([(0, I.W)(u.G), (0, s.__metadata)("design:paramtypes", [b, v])], P);
      let D = class {};
      D = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: i.m,
            handlers: {
              commands: { completeAccountDeletion: x, initiateAccountDeletion: P },
              events: {},
              queries: { userAuthenticationMethod: T, isFlowCompleted: C }
            },
            stores: [b],
            imports: [n.n],
            providers: [v]
          })
        ],
        D
      );
    },
    17802: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => w });
      var s = r(88802),
        a = r(99634),
        n = r(24452),
        i = r(34987),
        o = r(20754),
        c = r(39129),
        u = r(61501),
        d = r(48844),
        l = r(53576);
      let p = class {
        constructor(e, t) {
          (this.serverApiClient = e), (this.carbon = t);
        }
        execute() {
          return this.carbon.queries.getSubscriptionCode().pipe(
            (0, i.b)((e) =>
              this.serverApiClient.v1.invitation.getSharingLink({ userKey: "success" === e.tag ? e.data : "" }).pipe(
                (0, d.Qn)((e) => e.data),
                (0, d.DZ)((e) => {
                  throw new Error(e.message);
                })
              )
            )
          );
        }
      };
      p = (0, s.__decorate)([(0, o.e)(c.h), (0, s.__metadata)("design:paramtypes", [u.l, l.CarbonLegacyClient])], p);
      var h = r(1824),
        m = r(60399),
        y = r(63663),
        g = r(55398),
        v = r(87279);
      let f = class {
        constructor(e, t) {
          (this.serverApiClient = e), (this.carbon = t);
        }
        async execute({ body: { identifiers: e } }) {
          try {
            const t = await (0, m.z)(this.carbon.queries.getSubscriptionCode()),
              r = await (0, m.z)(
                this.serverApiClient.v1.invitation.invite({ userKey: (0, v.d6)(t) ? t.data : "", identifiers: e, type: "mail" })
              );
            if ((0, v.hx)(r)) throw new Error("InviteByEmailCommand failure: something went wrong in call to /invitation/invite");
            return (0, v.Vp)(void 0);
          } catch (e) {
            throw new Error("InviteByEmailCommand failure: something went wrong in execute method");
          }
        }
      };
      f = (0, s.__decorate)([(0, y.W)(g.P), (0, s.__metadata)("design:paramtypes", [u.l, l.CarbonLegacyClient])], f);
      let w = class {};
      w = (0, s.__decorate)(
        [(0, a.Y)({ api: n.l, imports: [h.n], handlers: { commands: { inviteByEmail: f }, events: {}, queries: { getSharingLink: p } } })],
        w
      );
    },
    1534: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => n });
      var s = r(86952),
        a = r(65446);
      const n = (0, s.Q)({ name: "overrides", commands: {}, events: {}, queries: { OverridesQuery: a.N } });
    },
    65446: (e, t, r) => {
      "use strict";
      r.d(t, { N: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.Device }) {}
    },
    5540: (e, t, r) => {
      "use strict";
      r.d(t, { x: () => I });
      var s = r(88802),
        a = r(99634);
      var n = r(1534),
        i = r(57924),
        o = r(26457),
        c = r(43702),
        u = r(25859),
        d = r(6220),
        l = r(30523),
        p = r(87065),
        h = r(39995);
      class m {
        constructor(e, t, r, s) {
          (this.settings = e), (this.store = t), (this.appLogger = r), (this.rfuDispatcher = s);
          const { fileName: a } = e;
          (this.jsonSerializerCodec = new c.b()),
            (this.newlyUpdatedFiles$ = (0, u.P)(async () => {
              const e = await this.store.getState();
              return { [a]: e.revision };
            }).pipe((0, d.z)((e) => this.rfuDispatcher.fileSubscription(e))));
        }
        initFileObservation() {
          this.newlyUpdatedFiles$.subscribe(this._handleRFUDownload.bind(this));
        }
        streamFileUpdate() {
          return this.store.state$.pipe(
            (0, l.h)((e) => 0 !== e.revision),
            (0, p.U)((e) => e.data),
            (0, l.h)((e) => this.settings.typeguard(e))
          );
        }
        async _handleRFUDownload(e) {
          const { fileName: t } = this.settings;
          if (!(t in e)) return;
          const r = e[t],
            s = this.jsonSerializerCodec.decode(r.buffer);
          this.settings.typeguard(s) &&
            (await this.store.set({ filename: r.fileName, data: s, revision: r.revision, lastDownloadTimestamp: r.lastDownloadTimestamp }),
            this.rfuDispatcher.fileSubscription({ [t]: r.revision }));
        }
      }
      var y = r(73881),
        g = r(95681),
        v = r(23347),
        f = r(10722),
        w = r(25029);
      const S = (e) =>
          !("object" != typeof e || null === e) &&
          "filename" in e &&
          null !== e.filename &&
          void 0 !== e.filename &&
          "string" == typeof e.filename &&
          "revision" in e &&
          null !== e.revision &&
          void 0 !== e.revision &&
          "number" == typeof e.revision,
        E = (e) => ({ filename: e, revision: 0, data: {}, lastDownloadTimestamp: Date.now() });
      let _ = class {
        constructor(e) {
          this.rfuClient = e;
        }
        onFrameworkInit() {
          this.rfuClient.initFileObservation();
        }
      };
      _ = (0, s.__decorate)([(0, i.ar)(), (0, s.__metadata)("design:paramtypes", [m])], _);
      var b = r(20754),
        T = r(65446),
        A = r(87279);
      let C = class {
        constructor(e) {
          this.rfuClient = e;
        }
        execute() {
          return this.rfuClient.streamFileUpdate().pipe((0, p.U)((e) => (0, A.Vp)({ overrides: e })));
        }
      };
      C = (0, s.__decorate)([(0, b.e)(T.N), (0, s.__metadata)("design:paramtypes", [m])], C);
      const R = ((e, t) => {
        const r = ((e) =>
          class extends (0, g.Q)({
            storeName: "RFUStore",
            persist: !0,
            storage: { schemaVersion: 1, initialValue: E(e), typeGuard: S },
            codec: f.E,
            storeTypeGuard: S,
            capacity: v.Y._010KB,
            scope: w.F.Device,
            isCache: !0
          }) {})(e);
        var s;
        return {
          providers: [
            {
              token: m,
              asyncFactory: (e, t, r) => Promise.resolve(new m(s, e, t, r)),
              inject: [(s = { fileName: e, storeClass: r, typeguard: t }).storeClass, o.V, h.Q]
            }
          ],
          onFrameworkInit: [_],
          imports: [y.Q],
          stores: [r]
        };
      })(
        "overrides.json",
        (e) =>
          null != e &&
          "object" == typeof e &&
          Object.values(e).every(
            (e) =>
              Array.isArray(e) &&
              e.every((e) =>
                ((e) => {
                  if (!e || "object" != typeof e) return !1;
                  const t = "type" in e && void 0 !== e.type && ("startsWith" === e.type || "regexp" === e.type),
                    r =
                      "value" in e &&
                      void 0 !== e.value &&
                      ((Array.isArray(e.value) && e.value.every((e) => "string" == typeof e)) || "string" == typeof e.value),
                    s =
                      "conditions" in e &&
                      void 0 !== e.conditions &&
                      Array.isArray(e.conditions) &&
                      e.conditions.every((e) =>
                        ((e) => {
                          const t = "type" in e && void 0 !== e.type && ("css" === e.type || "xpath" === e.type),
                            r = "selector" in e && void 0 !== e.selector && "string" == typeof e.selector;
                          return t && r;
                        })(e)
                      ),
                    a =
                      "actions" in e &&
                      void 0 !== e.actions &&
                      Array.isArray(e.actions) &&
                      e.actions.every((e) =>
                        ((e) => {
                          const t = "type" in e && void 0 !== e.type && ("set" === e.type || "ignore" === e.type),
                            r = "cssSelector" in e && void 0 !== e.cssSelector && "string" == typeof e.cssSelector;
                          return t && r;
                        })(e)
                      );
                  return t && r && s && a;
                })(e)
              )
          )
      );
      let I = class {};
      I = (0, s.__decorate)([(0, a.Y)({ api: n.D, composes: [R], handlers: { commands: {}, events: {}, queries: { overrides: C } } })], I);
    },
    36636: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => n });
      var s = r(67837),
        a = r(29986);
      class n extends (0, s.E)(a.V) {}
      (0, s.K)(a.V, n);
    },
    29986: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => i });
      var s = r(86952),
        a = r(28096),
        n = r(75203);
      const i = (0, s.Q)({
        name: "authenticationFlow",
        commands: {
          changeLogin: n.hW,
          changeTwoFactorAuthenticationOtpType: n.eG,
          clearError: n.jq,
          cancelDeviceTransferRequest: n.Yc,
          resendEmailToken: n.Gc,
          resendPushNotification: n.rF,
          sendAccountEmail: n.A,
          sendMasterPassword: n.rT,
          submitBackupCode: n.sH,
          submitEmailToken: n.XH,
          submitTotp: n.ad,
          switchToDashlaneAuthenticator: n.K1,
          switchToEmailToken: n.v5,
          retryWebAuthnAuthentication: n.M6,
          useMasterPassword: n.Cc,
          webAuthnAuthenticationFail: n.O3,
          logout: n.N5,
          lockSession: n.Y$,
          loginViaSSO: n.yv,
          initiateLoginWithSSO: n.Hr,
          initiateAutologinWithSSOCommand: n.x2
        },
        queries: { authenticationFlowStatus: a.DW, getSsoUserSettings: a.Dc, getProviderInfo: a.L2 },
        events: {}
      });
    },
    75203: (e, t, r) => {
      "use strict";
      r.d(t, {
        A: () => n,
        Cc: () => f,
        Gc: () => p,
        Hr: () => b,
        K1: () => o,
        M6: () => v,
        N5: () => S,
        O3: () => w,
        XH: () => c,
        Y$: () => E,
        Yc: () => A,
        ad: () => u,
        eG: () => l,
        hW: () => i,
        jq: () => g,
        rF: () => m,
        rT: () => h,
        sH: () => d,
        v5: () => y,
        x2: () => T,
        yv: () => _
      });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.Device }) {}
      class i extends (0, s.g)({ scope: a.F.Device }) {}
      class o extends (0, s.g)({ scope: a.F.Device }) {}
      class c extends (0, s.g)({ scope: a.F.Device }) {}
      class u extends (0, s.g)({ scope: a.F.Device }) {}
      class d extends (0, s.g)({ scope: a.F.Device }) {}
      class l extends (0, s.g)({ scope: a.F.Device }) {}
      class p extends (0, s.g)({ scope: a.F.Device }) {}
      class h extends (0, s.g)({ scope: a.F.Device }) {}
      class m extends (0, s.g)({ scope: a.F.Device }) {}
      class y extends (0, s.g)({ scope: a.F.Device }) {}
      class g extends (0, s.g)({ scope: a.F.Device }) {}
      class v extends (0, s.g)({ scope: a.F.Device }) {}
      class f extends (0, s.g)({ scope: a.F.Device }) {}
      class w extends (0, s.g)({ scope: a.F.Device }) {}
      class S extends (0, s.g)({ scope: a.F.Device }) {}
      class E extends (0, s.g)({ scope: a.F.Device }) {}
      class _ extends (0, s.g)({ scope: a.F.Device }) {}
      class b extends (0, s.g)({ scope: a.F.Device }) {}
      class T extends (0, s.g)({ scope: a.F.Device }) {}
      class A extends (0, s.g)({ scope: a.F.Device }) {}
    },
    28096: (e, t, r) => {
      "use strict";
      r.d(t, { DW: () => n, Dc: () => i, L2: () => o });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.Device }) {}
      class i extends (0, s.k)({ scope: a.F.Device }) {}
      class o extends (0, s.k)({ scope: a.F.Device }) {}
    },
    95109: (e, t, r) => {
      "use strict";
      var s, a, n;
      r.d(t, { E6: () => a, UY: () => n, ao: () => i, hr: () => s, vX: () => o }),
        (function (e) {
          (e.SSO = "sso"), (e.MP = "master_password");
        })(s || (s = {})),
        (function (e) {
          (e.WaitingForTransferRequest = "WaitingForTransferRequest"),
            (e.DisplayInstructions = "DisplayInstructions"),
            (e.DisplayPassphrase = "DisplayPassphrase"),
            (e.Error = "Error"),
            (e.DeviceRegistered = "DeviceRegistered");
        })(a || (a = {})),
        (function (e) {
          (e.GENERIC_ERROR = "GENERIC_ERROR"),
            (e.TIMEOUT = "TIMEOUT"),
            (e.REQUEST_REJECTED = "REQUEST_REJECTED"),
            (e.ACCOUNT_ERROR = "ACCOUNT_ERROR"),
            (e.RATE_LIMIT = "RATE_LIMIT");
        })(n || (n = {}));
      const i = (e) => Object.values(n).includes(e);
      var o;
      !(function (e) {
        (e[(e.MP_TO_SSO = 0)] = "MP_TO_SSO"),
          (e[(e.MP_TO_SSO_WITH_INFO = 1)] = "MP_TO_SSO_WITH_INFO"),
          (e[(e.SSO_TO_MP = 2)] = "SSO_TO_MP");
      })(o || (o = {}));
    },
    6218: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => l });
      var s = r(86952),
        a = r(53835),
        n = r(33969),
        i = r(97891),
        o = r(87041),
        c = r(55870),
        u = r(48214),
        d = r(81540);
      const l = (0, s.Q)({
        name: "deviceTransfer",
        commands: {
          refreshRequest: n.V,
          cancelRequest: i.b,
          approveRequest: o.G,
          rejectRequest: c.a,
          submitPassphraseChallenge: u.I,
          returnToDeviceSetupCommand: d.n
        },
        events: {},
        queries: { trustedDeviceFlowStatus: a.N }
      });
    },
    87041: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    97891: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    33969: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    55870: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    81540: (e, t, r) => {
      "use strict";
      r.d(t, { n: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    48214: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    53835: (e, t, r) => {
      "use strict";
      r.d(t, { N: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.Device }) {}
    },
    70486: (e, t, r) => {
      "use strict";
      var s, a;
      r.d(t, { SA: () => s, Te: () => a, dJ: () => n }),
        (function (e) {
          (e.GENERIC_ERROR = "GENERIC_ERROR"), (e.INVALID_PASSPHRASE = "INVALID_PASSPHRASE"), (e.TIMEOUT = "TIMEOUT");
        })(s || (s = {}));
      class n extends Error {
        constructor(e, t) {
          super(e), (this.code = void 0), (this.code = t);
        }
      }
      !(function (e) {
        (e[(e.WaitingForNewDeviceRequest = 0)] = "WaitingForNewDeviceRequest"),
          (e[(e.NewDeviceRequestAvailable = 1)] = "NewDeviceRequestAvailable"),
          (e[(e.DisplayPassphraseChallenge = 2)] = "DisplayPassphraseChallenge"),
          (e[(e.DeviceTransferComplete = 3)] = "DeviceTransferComplete"),
          (e[(e.DeviceTransferRejected = 4)] = "DeviceTransferRejected"),
          (e[(e.Error = 5)] = "Error");
      })(a || (a = {}));
    },
    11433: (e, t, r) => {
      "use strict";
      r.d(t, { i: () => o });
      var s = r(86952),
        a = r(41025),
        n = r(13744),
        i = r(13089);
      const o = (0, s.Q)({
        name: "identityVerificationFlow",
        commands: {
          changeTwoFactorAuthenticationOtpType: n.eG,
          clearError: n.$5,
          resendEmailToken: n.Gc,
          resendPushNotification: n.rF,
          submitBackupCode: n.sH,
          submitEmailToken: n.XH,
          submitTotp: n.ad,
          switchToDashlaneAuthenticator: n.K1,
          switchToEmailToken: n.v5,
          startIdentityVerification: n.qw,
          cancelIdentityVerification: n.Vs
        },
        queries: { identityVerificationFlowStatus: a.O },
        events: { identityVerificationCompleted: i.w }
      });
    },
    13744: (e, t, r) => {
      "use strict";
      r.d(t, {
        $5: () => i,
        Gc: () => o,
        K1: () => p,
        Vs: () => y,
        XH: () => u,
        ad: () => l,
        eG: () => n,
        qw: () => m,
        rF: () => c,
        sH: () => d,
        v5: () => h
      });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.Device }) {}
      class i extends (0, s.g)({ scope: a.F.Device }) {}
      class o extends (0, s.g)({ scope: a.F.Device }) {}
      class c extends (0, s.g)({ scope: a.F.Device }) {}
      class u extends (0, s.g)({ scope: a.F.Device }) {}
      class d extends (0, s.g)({ scope: a.F.Device }) {}
      class l extends (0, s.g)({ scope: a.F.Device }) {}
      class p extends (0, s.g)({ scope: a.F.Device }) {}
      class h extends (0, s.g)({ scope: a.F.Device }) {}
      class m extends (0, s.g)({ scope: a.F.Device }) {}
      class y extends (0, s.g)({ scope: a.F.Device }) {}
    },
    13089: (e, t, r) => {
      "use strict";
      r.d(t, { w: () => n });
      var s = r(88885),
        a = r(25029);
      class n extends (0, s.d)({ scope: a.F.Device }) {}
    },
    41025: (e, t, r) => {
      "use strict";
      r.d(t, { O: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.Device }) {}
    },
    81822: (e, t, r) => {
      "use strict";
      r.d(t, { l: () => n });
      var s = r(67837),
        a = r(11433);
      class n extends (0, s.E)(a.i) {}
      (0, s.K)(a.i, n);
    },
    81719: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          AuthenticationFlowContracts: () => s,
          DeviceTransferContracts: () => n,
          IdentityVerificationFlowContracts: () => a,
          Request2FaCodesByPhoneCommand: () => C.x,
          Request2FaCodesByPhoneErrorCodes: () => R.A,
          ValidateWebauthnAssertionCommand: () => C.L,
          userVerificationApi: () => A.M
        });
      var s = {};
      r.r(s),
        r.d(s, {
          AuthenticationFlowClient: () => d.e,
          AuthenticationFlowStatusQuery: () => c.DW,
          CancelDeviceTransferRequestCommand: () => o.Yc,
          ChangeAccountEmailCommand: () => o.hW,
          ChangeTwoFactorAuthenticationOtpTypeCommand: () => o.eG,
          ClearErrorCommand: () => o.jq,
          DeviceToDeviceAuthenticationErrors: () => u.UY,
          DeviceToDeviceAuthenticationFlowStep: () => u.E6,
          GetSsoProviderInfoQuery: () => c.L2,
          GetSsoUserSettingsQuery: () => c.Dc,
          InitiateAutologinWithSSOCommand: () => o.x2,
          InitiateLoginWithSSOCommand: () => o.Hr,
          LockCommand: () => o.Y$,
          LoginViaSSOCommand: () => o.yv,
          LogoutCommand: () => o.N5,
          ResendEmailTokenCommand: () => o.Gc,
          ResendPushNotificationCommand: () => o.rF,
          RetryWebAuthnAuthenticationCommand: () => o.M6,
          SSOMigrationType: () => u.vX,
          SendAccountEmailCommand: () => o.A,
          SendMasterPasswordCommand: () => o.rT,
          SsoMigrationServerMethod: () => u.hr,
          SubmitBackupCodeCommand: () => o.sH,
          SubmitEmailTokenCommand: () => o.XH,
          SubmitTotpCommand: () => o.ad,
          SwitchToDashlaneAuthenticatorCommand: () => o.K1,
          SwitchToEmailTokenCommand: () => o.v5,
          UseMasterPasswordCommand: () => o.Cc,
          WebAuthnAuthenticationFailCommand: () => o.O3,
          authenticationFlowApi: () => i.V,
          isDeviceToDeviceAuthenticationError: () => u.ao
        });
      var a = {};
      r.r(a),
        r.d(a, {
          CancelIdentityVerificationCommand: () => p.Vs,
          ChangeTwoFactorAuthenticationOtpTypeCommand: () => p.eG,
          ClearIdentityVerificationErrorCommand: () => p.$5,
          IdentityVerificationClient: () => m.l,
          IdentityVerificationCompletedEvent: () => y.w,
          IdentityVerificationFlowStatusQuery: () => h.O,
          ResendEmailTokenCommand: () => p.Gc,
          ResendPushNotificationCommand: () => p.rF,
          StartIdentityVerificationCommand: () => p.qw,
          SubmitBackupCodeCommand: () => p.sH,
          SubmitEmailTokenCommand: () => p.XH,
          SubmitTotpCommand: () => p.ad,
          SwitchToDashlaneAuthenticatorCommand: () => p.K1,
          SwitchToEmailTokenCommand: () => p.v5,
          identityVerificationFlowApi: () => l.i
        });
      var n = {};
      r.r(n),
        r.d(n, {
          ApproveDeviceTransferRequestCommand: () => f.G,
          CancelRequestCommand: () => E.b,
          RefreshRequestCommand: () => v.V,
          RejectDeviceTransferRequestCommand: () => w.a,
          ReturnToDeviceSetupCommand: () => _.n,
          SubmitPassphraseChallengeCommand: () => S.I,
          TrustedDeviceFlowError: () => T.dJ,
          TrustedDeviceFlowErrors: () => T.SA,
          TrustedDeviceFlowStatusQuery: () => b.N,
          TrustedDeviceFlowStep: () => T.Te,
          deviceTransferApi: () => g.F
        });
      var i = r(29986),
        o = r(75203),
        c = r(28096),
        u = r(95109),
        d = r(36636),
        l = r(11433),
        p = r(13744),
        h = r(41025),
        m = r(81822),
        y = r(13089),
        g = r(6218),
        v = r(33969),
        f = r(87041),
        w = r(55870),
        S = r(48214),
        E = r(97891),
        _ = r(81540),
        b = r(53835),
        T = r(70486),
        A = r(69401),
        C = r(11088),
        R = r(83853);
    },
    83853: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { A: () => s }),
        (function (e) {
          (e.AccountNotEligible = "AccountNotEligible"), (e.NetworkError = "NetworkError");
        })(s || (s = {}));
    },
    69401: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => n });
      var s = r(86952),
        a = r(11088);
      const n = (0, s.Q)({
        name: "userVerification",
        commands: { validateWebauthnAssertion: a.L, request2FaCodesByPhone: a.x },
        queries: {},
        events: {}
      });
    },
    11088: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => n, x: () => i });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
      class i extends (0, s.g)({ scope: a.F.Device }) {}
    },
    64017: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => _t });
      var s = r(88802),
        a = r(99634),
        n = r(38679),
        i = r(9671),
        o = r(53576),
        c = r(29986),
        u = r(1824),
        d = r(44985),
        l = r(26290),
        p = r(25029),
        h = r(95681),
        m = r(87065);
      const y = (e) => !0;
      class g extends (0, h.Q)({
        initialValue: void 0,
        persist: !1,
        scope: p.F.Device,
        storeName: "authentication-flow-machine",
        storeTypeGuard: y
      }) {}
      var v = r(23347),
        f = r(10722);
      const w = (e) => !(!e || "object" != typeof e) && "rememberMeForSSOPreference" in e;
      class S extends (0, h.Q)({
        codec: f.E,
        persist: !0,
        storage: { initialValue: { rememberMeForSSOPreference: !0 }, schemaVersion: 1, typeGuard: w },
        scope: p.F.Device,
        storeName: "sso-info",
        storeTypeGuard: w,
        capacity: v.Y._001KB
      }) {}
      const E = (e) => !0;
      class _ extends (0, h.Q)({
        persist: !1,
        initialValue: {},
        scope: p.F.Device,
        storeName: "sso-provider-info",
        storeTypeGuard: E,
        capacity: v.Y._001KB
      }) {}
      var b = r(87279),
        T = r(63663),
        A = r(75203),
        C = r(64472),
        R = r(11746),
        I = r(57924);
      class x {
        constructor(e, t) {
          (this.interpreter = e), (this.carbon = t);
        }
        execute() {
          try {
            const { carbonState: e } = this.carbon.queries;
            e({ path: "userSession.loginDeviceLimitFlow.flow" })
              .pipe(
                (0, m.U)((e) => {
                  if ("success" === e.tag) return e.data;
                })
              )
              .subscribe((e) => {
                Boolean(this.lastDeviceLimitFlowValue) && !e && this.interpreter.send({ type: "DEVICE_LIMIT_ABORTED" }),
                  (this.lastDeviceLimitFlowValue = e);
              });
          } catch (e) {
            return Promise.reject(new Error("Unable to subscribe to loginDeviceLimitFlow state"));
          }
        }
      }
      var P = r(5331),
        D = r(31948);
      class U extends Error {
        constructor() {
          super("Error verifying SK");
        }
      }
      var F = r(89358),
        O = r(60399);
      let N = class {
        constructor(e, t) {
          (this.carbon = e), (this.session = t);
        }
        async executeWithParams({ login: e, masterPassword: t, isRememberMeEnabled: r, serverKey: s }) {
          const a = await (0, O.z)(this.session.queries.createdSessionsState());
          if ((0, b.hx)(a)) throw new Error("coudltn get sessions");
          if (e in a.data)
            try {
              return await this.session.commands.openUserSession({
                email: e,
                rememberPassword: r,
                sessionKey: { type: "mp", masterPassword: t, secondaryKey: s }
              });
            } catch (e) {
              return Promise.reject(new Error("UNKNOWN_ERROR"));
            }
          try {
            return (
              await this.carbon.commands.carbonLegacyLeeloo({
                name: "openSessionWithMasterPassword",
                arg: [{ login: e, password: t, rememberPassword: r, requiredPermissions: void 0 }]
              }),
              Promise.resolve()
            );
          } catch (e) {}
        }
      };
      N = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient, F.x])], N);
      let k = class {
        constructor(e) {
          this.carbonLegacy = e;
        }
        async execute() {
          try {
            const e = await this.carbonLegacy.commands.carbon({ name: "checkDoesLocalRecoveryKeyExist", args: [] });
            if (!(0, b.d6)(e)) throw new Error("Carbon command failed");
            return { isAccountRecoveryAvailable: e.data.carbonResult.doesExist };
          } catch (e) {
            return { isAccountRecoveryAvailable: !1 };
          }
        }
      };
      k = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient])], k);
      var L = r(48844),
        M = r(61501),
        V = r(95109);
      const G = (e) => "object" == typeof e && "type" in e,
        j = (e) => {
          if (e)
            switch (e) {
              case "sso_member_to_admin":
              case "sso_member_to_mp_user":
                return V.vX.SSO_TO_MP;
              case "mp_user_to_sso_member":
                return V.vX.MP_TO_SSO;
              default:
                return;
            }
        };
      let q = class {
        constructor(e, t) {
          (this.ssoProviderInfoStore = e), (this.serverApiClient = t), (this.ssoProviderInfoStore = e), (this.serverApiClient = t);
        }
        async getSsoMigration(e) {
          const t = await (0, O.z)(
            this.serverApiClient.v1.authentication
              .getAuthenticationMethodsForDevice({
                login: e,
                methods: ["email_token", "totp", "duo_push", "dashlane_authenticator", "u2f"]
              })
              .pipe(
                (0, L.DZ)((e) => {
                  throw new Error(e.message);
                }),
                (0, L.lk)((e) => {
                  const t = e.data.verifications.find(G);
                  if (t) return (0, b.Vp)(t);
                  throw new Error("Unsupported authentication method");
                })
              )
          );
          if ((0, b.hx)(t)) throw new Error("Retrieve of verificationMethods failed ");
          if ("sso" === t.data.type)
            return {
              serviceProviderUrl: t.data.ssoInfo.serviceProviderUrl,
              isNitroProvider: t.data.ssoInfo.isNitroProvider,
              migration: t.data.ssoInfo.migration
            };
        }
        async executeWithParams({ login: e }) {
          const t = await this.getSsoMigration(e);
          if (t)
            return (
              await this.ssoProviderInfoStore.set({
                isNitroProvider: t.isNitroProvider ?? !1,
                serviceProviderUrl: t.serviceProviderUrl,
                migrationType: j(t.migration)
              }),
              { serviceProviderRedirectUrl: t.serviceProviderUrl, isNitroProvider: t.isNitroProvider }
            );
        }
      };
      q = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [_, M.l])], q);
      let K = class {
        constructor(e) {
          this.session = e;
        }
        async executeWithParams(e) {
          const t = await (0, O.z)(
            this.session.queries.checkSessionKey({
              email: e.login,
              sessionKey: { type: "mp", masterPassword: e.masterPassword, secondaryKey: e.serverKey }
            })
          );
          if (!(0, b.d6)(t)) throw new Error("Error verifying SK");
          if (t.data) return !0;
          throw new U();
        }
      };
      K = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [F.x])], K);
      let W = class {
        constructor(e, t, r, s) {
          (this.accountRecoveryStatusService = e),
            (this.masterPasswordService = t),
            (this.checkIsMigrationNeededService = r),
            (this.mpVerificationService = s);
        }
        desc() {
          return {
            config: {
              predictableActionArguments: !0,
              schema: { events: {}, context: {} },
              initial: "CheckingAccountRecoveryStatus",
              id: "MasterPasswordFlowMachine",
              context: { isRememberMeEnabled: !1, isAccountRecoveryAvailable: !1 },
              states: {
                CheckingAccountRecoveryStatus: {
                  invoke: {
                    src: "checkAccountRecoveryStatus",
                    onDone: { target: "WaitingForMasterPassword", actions: ["assignAccountRecoveryStatus"] }
                  }
                },
                WaitingForMasterPassword: {
                  on: { INPUT_MASTER_PASSWORD: { target: "ValidatingMasterPassword", actions: ["assignMasterPassword"] } }
                },
                ValidatingMasterPassword: {
                  invoke: {
                    src: "validateMasterPassword",
                    onDone: { target: "OpeningSessionWithMasterpassword" },
                    onError: { actions: ["assignMpError"], target: "WaitingForMasterPassword" }
                  }
                },
                OpeningSessionWithMasterpassword: {
                  invoke: {
                    src: "authenticateWithMasterPassword",
                    onError: { actions: ["assignGenericServiceError"] },
                    onDone: { target: "CheckingMigrationNeeded" }
                  },
                  on: {
                    CARBON_LEGACY_ERROR: { target: "WaitingForMasterPassword", actions: ["assignError"] },
                    DEVICE_LIMIT_ABORTED: { target: "DeviceLimitAborted" }
                  }
                },
                CheckingMigrationNeeded: {
                  invoke: {
                    src: "checkIsMigrationNeeded",
                    onDone: { target: "MasterPasswordDone", actions: ["assignSSOMigrationStatus"] },
                    onError: { target: "WaitingForMasterPassword", actions: ["assignGenericServiceError"] }
                  },
                  on: { CARBON_LEGACY_ERROR: { target: "WaitingForMasterPassword", actions: ["assignError"] } }
                },
                DeviceLimitAborted: { type: "final", data: { shouldResetAuthenticationFlow: !0 } },
                MasterPasswordDone: { type: "final", data: { shouldResetAuthenticationFlow: !1 } }
              }
            },
            options: {
              actions: {
                assignMasterPassword: (0, P.f0)({
                  masterPassword: (e, t) => t.masterPassword,
                  isRememberMeEnabled: (e, t) => t.rememberMe
                }),
                assignAccountRecoveryStatus: (0, P.f0)({ isAccountRecoveryAvailable: (e, t) => t.data.isAccountRecoveryAvailable }),
                assignError: (0, P.f0)({ error: (e, t) => ({ code: "unknown_error", data: { message: t.error } }) }),
                assignGenericServiceError: (0, P.f0)({ error: () => ({ code: "unknown_error", data: { message: "UNKNOWN_ERROR" } }) }),
                assignMpError: (0, P.f0)({
                  error: (e, t) => ({ code: "unknown_error", data: { message: t.data instanceof U ? "WRONG_PASSWORD" : "UNKNOWN_ERROR" } })
                }),
                assignSSOMigrationStatus: (0, P.f0)({
                  serviceProviderRedirectUrl: (e, t) => t.data?.serviceProviderRedirectUrl,
                  isNitroProvider: (e, t) => t.data?.isNitroProvider
                })
              },
              services: {
                authenticateWithMasterPassword: (e) => {
                  const { login: t, masterPassword: r, isRememberMeEnabled: s, serverKey: a } = e;
                  return this.masterPasswordService.executeWithParams({
                    login: t ?? "",
                    masterPassword: r ?? "",
                    isRememberMeEnabled: s,
                    serverKey: a
                  });
                },
                checkAccountRecoveryStatus: () => this.accountRecoveryStatusService.execute(),
                checkIsMigrationNeeded: (e) => this.checkIsMigrationNeededService.executeWithParams({ login: e.login ?? "" }),
                validateMasterPassword: ({ login: e, masterPassword: t, serverKey: r }) =>
                  this.mpVerificationService.executeWithParams({ login: e ?? "", masterPassword: t ?? "", serverKey: r })
              }
            }
          };
        }
        create() {
          const { config: e, options: t } = this.desc();
          return (0, D.C)(e, t);
        }
      };
      W = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [k, N, q, K])], W);
      let B = class {
        constructor(e) {
          this.carbonLegacy = e;
        }
        async execute(e) {
          try {
            return (
              await this.carbonLegacy.commands.carbonLegacyLeeloo({ name: "openSessionResendToken", arg: [{ login: e.login ?? "" }] }),
              Promise.resolve()
            );
          } catch (e) {}
        }
      };
      B = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient])], B);
      let z = class {
        constructor(e) {
          this.carbonLegacy = e;
        }
        async requestCodeAgainstServer() {}
        async execute({ login: e }) {
          return (
            await this.carbonLegacy.commands.carbonLegacyLeeloo({
              name: "openSessionWithDashlaneAuthenticator",
              arg: [{ login: e, password: null, persistData: !0, deviceName: "" }]
            }),
            Promise.resolve()
          );
        }
        async cancel() {
          return (
            await this.carbonLegacy.commands.carbonLegacyLeeloo({ name: "cancelDashlaneAuthenticatorRegistration", arg: [] }),
            Promise.resolve()
          );
        }
      };
      z = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient])], z);
      let H = class {
        constructor(e, t) {
          (this.dashlaneAuthenticatorService = e), (this.sendEmailToken = t);
        }
        desc() {
          return {
            config: {
              predictableActionArguments: !0,
              schema: { events: {}, context: {} },
              id: "AuthenticatorMachine",
              context: { isDashlaneAuthenticatorAvailable: !1 },
              initial: "RequestingServerPush",
              states: {
                RequestingServerPush: {
                  entry: ["updateDashlaneAuthenticatorAvailability"],
                  invoke: { src: "authenticateWithDashlaneAuthenticator" },
                  on: {
                    CARBON_LEGACY_ERROR: { actions: ["assignError", "updateDashlaneAuthenticatorAvailability"] },
                    RESEND_PUSH_NOTIFICATION: { target: "RequestingServerPush", actions: ["clearError"] },
                    SWITCH_TO_EMAIL_TOKEN: { actions: ["cancelDashlaneAuthenticator", "clearError"], target: "EmailTokenRequested" }
                  }
                },
                AuthenticatorPushValidated: { type: "final", data: { switchToEmailToken: !1 } },
                EmailTokenRequested: { entry: ["sendEmailToken"], type: "final", data: { switchToEmailToken: !0 } }
              }
            },
            options: {
              actions: {
                clearError: (0, P.f0)({ error: () => {} }),
                assignError: (0, P.f0)({ error: (e, t) => ({ code: "unknown_error", data: { message: t.error } }) }),
                switchToEmailToken: (0, P.f0)({ switchToEmailToken: () => !0 }),
                updateDashlaneAuthenticatorAvailability: (0, P.f0)({ isDashlaneAuthenticatorAvailable: !0 }),
                cancelDashlaneAuthenticator: () => {
                  this.dashlaneAuthenticatorService.cancel();
                },
                sendEmailToken: (e) => {
                  const { login: t } = e;
                  this.sendEmailToken.execute({ login: t });
                }
              },
              services: {
                authenticateWithDashlaneAuthenticator: (e) => {
                  const { login: t } = e;
                  return this.dashlaneAuthenticatorService.execute({ login: t });
                }
              },
              guards: {}
            }
          };
        }
        create() {
          const { config: e, options: t } = this.desc();
          return (0, D.C)(e, t);
        }
      };
      H = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [z, B])], H);
      let $ = class {
        constructor(e) {
          this.carbonLegacy = e;
        }
        async execute(e) {
          try {
            await this.carbonLegacy.commands.carbonLegacyLeeloo({
              name: "openSessionWithToken",
              arg: [{ login: e.login ?? "", password: null, token: e.emailToken ?? "", persistData: !0, deviceName: e.deviceName }]
            });
          } catch (e) {}
        }
      };
      $ = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient])], $);
      let Q = class {
        constructor(e, t) {
          (this.authenticateWithEmailToken = e), (this.sendEmailToken = t);
        }
        desc() {
          return {
            config: {
              predictableActionArguments: !0,
              schema: { events: {}, context: {} },
              id: "EmailTokenMachine",
              context: { login: "", emailToken: "", deviceName: "" },
              initial: "WaitingForEmailToken",
              states: {
                SendEmailToken: {
                  invoke: { src: "sendEmailToken", onError: { target: "WaitingForEmailToken" }, onDone: { target: "WaitingForEmailToken" } }
                },
                WaitingForEmailToken: {
                  on: {
                    INPUT_EMAIL_TOKEN: { target: "ValidatingEmailToken", actions: ["assignEmailToken"] },
                    RESEND_EMAIL_TOKEN: { target: "SendEmailToken", actions: ["clearError"] }
                  }
                },
                ValidatingEmailToken: {
                  entry: ["authenticateWithEmailToken"],
                  on: { CARBON_LEGACY_ERROR: { target: "WaitingForEmailToken", actions: ["assignError"] } }
                },
                FinishingEmailToken: { type: "final", data: { switchToDashlaneAuthenticator: !1 } },
                DashlaneAuthenticatorRequested: { type: "final", data: { switchToDashlaneAuthenticator: !0 } }
              },
              on: { SWITCH_TO_DASHLANE_AUTHENTICATOR: { target: ".DashlaneAuthenticatorRequested", internal: !0, actions: ["clearError"] } }
            },
            options: {
              actions: {
                clearError: (0, P.f0)({ error: () => {} }),
                assignError: (0, P.f0)({ error: (e, t) => ({ code: "unknown_error", data: { message: t.error } }) }),
                assignEmailToken: (0, P.f0)({ emailToken: (e, t) => t.emailToken }),
                authenticateWithEmailToken: (e) => {
                  const { deviceName: t, emailToken: r, login: s } = e;
                  return this.authenticateWithEmailToken.execute({ deviceName: t, emailToken: r, login: s });
                }
              },
              services: {
                sendEmailToken: (e) => {
                  const { login: t } = e;
                  return this.sendEmailToken.execute({ login: t });
                }
              },
              guards: {}
            }
          };
        }
        create() {
          const { config: e, options: t } = this.desc();
          return (0, D.C)(e, t);
        }
      };
      Q = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [$, B])], Q);
      const Y = (e) => ({ initial: e.initial, states: e.states, on: e.on ?? {} });
      let X = class {
        constructor(e, t) {
          (this.authenticatorMachine = e), (this.emailTokenMachine = t);
        }
        desc() {
          return {
            config: {
              predictableActionArguments: !0,
              schema: { events: {}, context: {}, guards: {} },
              id: "DeviceRegistrationMachine",
              context: {
                ...this.authenticatorMachine.desc().config.context,
                ...this.emailTokenMachine.desc().config.context,
                registrationMethod: void 0
              },
              initial: "StartDeviceRegistration",
              states: {
                StartDeviceRegistration: {
                  always: [
                    { target: "EmailToken", cond: "isRegistrationMethodEmailToken" },
                    { target: "DashlaneAuthenticator", cond: "isRegistrationMethodAuthenticator" },
                    { target: "TwoFactorAuthentication", cond: "isRegistrationMethodOTP" }
                  ]
                },
                DashlaneAuthenticator: {
                  ...Y(this.authenticatorMachine.desc().config),
                  onDone: [{ target: "EmailToken", cond: "shouldSwitchToEmailToken" }, { target: "DeviceRegistrationDone" }]
                },
                EmailToken: {
                  ...Y(this.emailTokenMachine.desc().config),
                  onDone: [{ target: "DashlaneAuthenticator", cond: "shouldSwitchToAuthenticator" }, { target: "DeviceRegistrationDone" }]
                },
                TwoFactorAuthentication: { onDone: { target: "DeviceRegistrationDone" } },
                DeviceRegistrationDone: { type: "final" }
              }
            },
            options: {
              actions: {
                ...this.authenticatorMachine.desc().options.actions,
                ...this.emailTokenMachine.desc().options.actions,
                assignUnknownDeviceRegistrationError: (0, P.f0)({
                  error: () => ({ code: "unknown_error", data: { message: "Unknown device registration error" } })
                })
              },
              services: { ...this.authenticatorMachine.desc().options.services, ...this.emailTokenMachine.desc().options.services },
              guards: {
                ...this.authenticatorMachine.desc().options.guards,
                ...this.emailTokenMachine.desc().options.guards,
                isRegistrationMethodEmailToken: (e) => "email_token" === e.registrationMethod,
                isRegistrationMethodOTP: (e) => "otp" === e.registrationMethod,
                isRegistrationMethodAuthenticator: (e) => "dashlane_authenticator" === e.registrationMethod,
                shouldSwitchToEmailToken: (e, t) => t.data.switchToEmailToken,
                shouldSwitchToAuthenticator: (e, t) => t.data.switchToDashlaneAuthenticator
              }
            }
          };
        }
        create() {
          const { config: e, options: t } = this.desc();
          return (0, D.C)(e, t);
        }
      };
      X = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [H, Q])], X);
      let J = class {
        desc() {
          return {
            config: {
              predictableActionArguments: !0,
              schema: { events: {}, context: {} },
              id: "WebAuthnMachine",
              context: {},
              initial: "InitWebAuthnAuthentication",
              states: {
                InitWebAuthnAuthentication: {
                  on: { WEBAUTHN_AUTHENTICATION_FAIL: { target: "WebAuthnAuthenticationFailed", actions: ["assignWebAuthnError"] } }
                },
                WebAuthnAuthenticationFailed: {
                  on: { RETRY_WEBAUTHN_AUTHENTICATION: { target: "InitWebAuthnAuthentication", actions: ["clearError"] } }
                },
                WebAuthnAuthenticationDone: { type: "final", data: { switchToMasterPassword: !1 } },
                MasterPasswordRequested: { type: "final", data: { switchToMasterPassword: !0 } }
              },
              on: { USE_MASTER_PASSWORD: { actions: ["clearError"], target: ".MasterPasswordRequested", internal: !0 } }
            },
            options: {
              actions: { clearError: (0, P.f0)({ error: () => {} }), assignWebAuthnError: (0, P.f0)({ error: (e, t) => t.error }) },
              services: {},
              guards: {}
            }
          };
        }
        create() {
          const { config: e, options: t } = this.desc();
          return (0, D.C)(e, t);
        }
      };
      J = (0, s.__decorate)([(0, I.GS)()], J);
      let Z = class {
        constructor(e) {
          this.carbonLegacy = e;
        }
        executeWithParams({
          login: e,
          masterPassword: t,
          otp: r,
          twoFactorAuthenticationOtpType: s,
          otpVerificationMode: a,
          deviceName: n
        }) {
          const i = { login: e, password: t ?? null, otp: r, withBackupCode: "backupCode" === s, persistData: !0 };
          try {
            "otp2" === a
              ? this.carbonLegacy.commands.carbonLegacyLeeloo({ name: "openSessionWithOTP", arg: [{ ...i, deviceName: n }] })
              : "otp1" === a && this.carbonLegacy.commands.carbonLegacyLeeloo({ name: "openSessionWithOTPForNewDevice", arg: [i] });
          } catch (e) {}
          return Promise.resolve();
        }
      };
      Z = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient])], Z);
      let ee = class {
        constructor(e) {
          this.twoFactorAuthenticationService = e;
        }
        desc() {
          return {
            config: {
              predictableActionArguments: !0,
              schema: { events: {}, context: {} },
              id: "WebAuthnMachine",
              context: { twoFactorAuthenticationOtpType: "totp" },
              initial: "WaitingForTotp",
              states: {
                WaitingForTotp: {
                  on: {
                    INPUT_TOTP: { target: "ValidatingTwoFactorAuthenticationOtp", actions: ["assignTwoFactorAuthenticationOtpValue"] },
                    SWITCH_TWO_FACTOR_AUTHENTICATION_TYPE: {
                      target: "WaitingForBackupCode",
                      actions: ["assignTwoFactorAuthenticationOtpType", "clearError"]
                    }
                  }
                },
                WaitingForBackupCode: {
                  on: {
                    INPUT_BACKUP_CODE: {
                      target: "ValidatingTwoFactorAuthenticationOtp",
                      actions: ["assignTwoFactorAuthenticationOtpValue"]
                    },
                    SWITCH_TWO_FACTOR_AUTHENTICATION_TYPE: {
                      target: "WaitingForTotp",
                      actions: ["assignTwoFactorAuthenticationOtpType", "clearError"]
                    }
                  }
                },
                ValidatingTwoFactorAuthenticationOtp: {
                  entry: ["authenticateWithTwoFactorAuthentication"],
                  on: {
                    CARBON_LEGACY_ERROR: [
                      { target: "WaitingForBackupCode", cond: "isBackupCode", actions: ["assignError"] },
                      { target: "WaitingForTotp", actions: ["assignError"] }
                    ]
                  }
                },
                TwoFactorAuthenticationDone: { type: "final" }
              }
            },
            options: {
              actions: {
                assignError: (0, P.f0)({ error: (e, t) => ({ code: "unknown_error", data: { message: t.error } }) }),
                clearError: (0, P.f0)({ error: () => {} }),
                assignTwoFactorAuthenticationOtpValue: (0, P.f0)({
                  twoFactorAuthenticationOtpValue: (e, t) => t.twoFactorAuthenticationOtpValue
                }),
                assignTwoFactorAuthenticationOtpType: (0, P.f0)({
                  twoFactorAuthenticationOtpType: (e, t) => t.twoFactorAuthenticationOtpType
                }),
                authenticateWithTwoFactorAuthentication: (e) => {
                  const t = {
                    login: e.login ?? "",
                    masterPassword: e.masterPassword ?? null,
                    otp: e.twoFactorAuthenticationOtpValue,
                    twoFactorAuthenticationOtpType: e.twoFactorAuthenticationOtpType,
                    persistData: !0,
                    otpVerificationMode: e.otpVerificationMode,
                    deviceName: e.deviceName
                  };
                  this.twoFactorAuthenticationService.executeWithParams(t);
                }
              },
              services: {},
              guards: { isBackupCode: (e) => "backupCode" === e.twoFactorAuthenticationOtpType }
            }
          };
        }
        create() {
          const { config: e, options: t } = this.desc();
          return (0, D.C)(e, t);
        }
      };
      ee = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [Z])], ee);
      var te = r(10430),
        re = r(10551),
        se = r(16053);
      let ae = class {
        constructor(e) {
          this.d2dAuthenticationService = e;
        }
        async execute({ login: e }) {
          const t = re.getDefaultDeviceName();
          if (!e || !t) throw new te.z("No user login/device name", V.UY.GENERIC_ERROR);
          const r = await this.d2dAuthenticationService.requestTransfer(e, t);
          if ((0, b.hx)(r)) throw new te.z("Request transfer error", V.UY.GENERIC_ERROR);
          const { transferId: s, expireDateUnix: a } = r.data;
          return Promise.resolve({ transferId: s, expireDateUnix: a });
        }
      };
      ae = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [se.C])], ae);
      var ne = r(15652);
      let ie = class {
        constructor(e, t) {
          (this.d2dCryptoService = e), (this.d2dAuthenticationService = t);
        }
        async execute({ transferId: e }) {
          if (!e) throw new te.z("No transferId in context", V.UY.GENERIC_ERROR);
          const { privateKey: t, publicKey: r } = this.d2dCryptoService.generateKeyPair(),
            s = this.d2dCryptoService.hash(r),
            a = await this.d2dAuthenticationService.startReceiverKeyExchange(e, s);
          if ((0, b.hx)(a)) throw new te.z("Error with startReceiverKeyExchangeResponse", V.UY.GENERIC_ERROR);
          const { senderPublicKey: n } = a.data;
          return Promise.resolve({ receiverPrivateKey: t, receiverPublicKey: r, senderPublicKey: n });
        }
      };
      ie = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [ne.q, se.C])], ie);
      let oe = class {
        constructor(e, t) {
          (this.d2dCryptoService = e), (this.d2dAuthenticationService = t);
        }
        async execute(e) {
          if (!e.transferId || !e.login) throw new te.z("No transferId or user login in the machine context", V.UY.GENERIC_ERROR);
          const t = await this.d2dAuthenticationService.startTransfer(e.transferId);
          if ((0, b.hx)(t)) throw new te.z("StartTransfer failed", V.UY.GENERIC_ERROR);
          const { encryptedData: r, nonce: s } = t.data;
          if (!e.receiverPrivateKey || !e.receiverPublicKey || !e.senderPublicKey)
            throw new te.z("Missing keys in context", V.UY.GENERIC_ERROR);
          if (!e.sharedSecret) throw new te.z("Missing sharedSecret in context", V.UY.GENERIC_ERROR);
          const a = this.d2dCryptoService.generateSymmetricKey(e.login, e.transferId, e.sharedSecret),
            n = this.d2dCryptoService.decryptInvisibleMasterPassword(r, s, a);
          return await this.d2dAuthenticationService.openSession(n.login, n.token, n.key.value, e.deviceName), Promise.resolve();
        }
      };
      oe = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [ne.q, se.C])], oe);
      var ce = r(69605);
      let ue = class {
        constructor(e, t, r) {
          (this.d2dCryptoService = e), (this.d2dAuthenticationService = t), (this.passphraseService = r);
        }
        async execute(e) {
          if (!e.receiverPrivateKey || !e.receiverPublicKey || !e.senderPublicKey)
            throw new te.z("Keys not found in the state machine context", V.UY.GENERIC_ERROR);
          if (!e.transferId) throw new te.z("TransferId not found in the state machine context/store", V.UY.GENERIC_ERROR);
          if (!e.login) throw new te.z("User login not found in state machine context/store", V.UY.GENERIC_ERROR);
          const t = await this.d2dAuthenticationService.completeKeyExchange(e.transferId, e.receiverPublicKey);
          if ((0, b.hx)(t)) throw new te.z("Error with completeKeyExchange", V.UY.GENERIC_ERROR);
          const r = this.d2dCryptoService.generateReceiverSharedSecret(e.receiverPublicKey, e.receiverPrivateKey, e.senderPublicKey),
            s = this.d2dCryptoService.generateVisualCheckSeed(e.login, e.transferId, r),
            { passphrase: a } = await this.passphraseService.generatePassphraseChallenge(s);
          return Promise.resolve({ sharedSecret: r, passphrase: a });
        }
      };
      ue = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [ne.q, se.C, ce.Kp])], ue);
      let de = class {
        constructor(e, t, r, s) {
          (this.requestDeviceTransfer = e),
            (this.startReceiverKeyExchange = t),
            (this.completeKeyExchangeAndGeneratePassphrase = r),
            (this.startTransfer = s);
        }
        desc() {
          return {
            config: {
              predictableActionArguments: !0,
              schema: { events: {}, context: {} },
              id: "DeviceToDeviceAuthenticationFlow",
              initial: "WaitingForTransferRequest",
              context: { transferId: void 0 },
              states: {
                WaitingForTransferRequest: {
                  invoke: {
                    src: "requestDeviceTransfer",
                    onDone: { target: "DisplayInstructions", actions: ["assignTransferId"] },
                    onError: { actions: ["assignDeviceToDeviceError"], target: "DeviceTransferError" }
                  }
                },
                DisplayInstructions: {
                  invoke: {
                    src: "startReceiverKeyExchange",
                    onDone: { actions: ["assignKeys"], target: "GeneratePassphrase" },
                    onError: { actions: ["assignDeviceToDeviceError"], target: "DeviceTransferError" }
                  }
                },
                GeneratePassphrase: {
                  invoke: {
                    src: "completeKeyExchangeAndGeneratePassphrase",
                    onDone: { actions: ["assignPassphrase"], target: "StartTransfer" },
                    onError: { actions: ["assignDeviceToDeviceError"], target: "DeviceTransferError" }
                  }
                },
                StartTransfer: {
                  invoke: {
                    src: "startTransfer",
                    onDone: { target: "DeviceRegistered" },
                    onError: { actions: ["assignDeviceToDeviceError"], target: "DeviceTransferError" }
                  }
                },
                DeviceTransferError: {},
                DeviceRegistered: { type: "final" }
              }
            },
            options: {
              actions: {
                assignTransferId: (0, P.f0)({ transferId: (e, t) => t.data.transferId }),
                assignKeys: (0, P.f0)({
                  receiverPublicKey: (e, t) => t.data.receiverPublicKey,
                  receiverPrivateKey: (e, t) => t.data.receiverPrivateKey,
                  senderPublicKey: (e, t) => t.data.senderPublicKey
                }),
                assignPassphrase: (0, P.f0)({ passphrase: (e, t) => t.data.passphrase, sharedSecret: (e, t) => t.data.sharedSecret }),
                clearContext: (0, P.f0)({
                  deviceName: () => {},
                  transferId: () => {},
                  receiverPublicKey: () => {},
                  receiverPrivateKey: () => {},
                  senderPublicKey: () => {},
                  sharedSecret: () => {},
                  passphrase: () => {}
                }),
                assignDeviceToDeviceError: (0, P.f0)({ error: (e, t) => (t.data instanceof te.z ? t.data.code : V.UY.GENERIC_ERROR) })
              },
              services: {
                requestDeviceTransfer: (e) => this.requestDeviceTransfer.execute(e),
                startReceiverKeyExchange: (e) => this.startReceiverKeyExchange.execute(e),
                completeKeyExchangeAndGeneratePassphrase: (e) => this.completeKeyExchangeAndGeneratePassphrase.execute(e),
                startTransfer: (e) => this.startTransfer.execute(e)
              }
            }
          };
        }
        create() {
          const { config: e, options: t } = this.desc();
          return (0, D.C)(e, t);
        }
      };
      de = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [ae, ie, ue, oe])], de);
      var le = r(30523);
      let pe = class {
        constructor(e) {
          this.carbonLegacy = e;
        }
        retrieveLocalAccounts(e) {
          return (0, O.z)(
            e.queries.carbonState({ path: "authentication.localAccounts" }).pipe(
              (0, le.h)(b.d6),
              (0, le.h)((e) => e.data.accountsListInitialized),
              (0, m.U)((e) => e.data.accountsList)
            )
          );
        }
        async execute() {
          try {
            const e = await this.retrieveLocalAccounts(this.carbonLegacy),
              t = e?.find((e) => e.isLastSuccessfulLogin);
            return {
              localAccounts: e ?? [],
              lastUsedLogin: t?.login ?? "",
              shouldAskMasterPassword: t?.shouldAskMasterPassword ?? !1,
              shouldAskOTP: t?.hasLoginOtp ?? !1,
              rememberMeType: t?.rememberMeType ?? "disabled"
            };
          } catch (e) {
            return Promise.reject(new Error("Unable to retrieve initialization data"));
          }
        }
      };
      pe = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient])], pe);
      let he = class {
        constructor(e) {
          this.carbonLegacy = e;
        }
        async execute(e) {
          await this.carbonLegacy.commands.carbon({ name: "loginViaSSO", args: [e] });
        }
      };
      he = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient])], he);
      let me = class {
        constructor(e) {
          (this.ssoProviderInfoStore = e), (this.ssoProviderInfoStore = e);
        }
        async execute({ isNitroProvider: e, serviceProviderRedirectUrl: t }) {
          await this.ssoProviderInfoStore.set({ isNitroProvider: e, serviceProviderUrl: t });
        }
      };
      me = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [_])], me);
      let ye = class {
        constructor(e) {
          this.carbonLegacy = e;
        }
        async execute({ login: e }) {
          return await this.carbonLegacy.commands.carbonLegacyLeeloo({ name: "openSession", arg: [{ login: e ?? "" }] }), Promise.resolve();
        }
      };
      ye = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient])], ye);
      let ge = class {
        constructor(e, t, r, s, a, n, i, o, c) {
          (this.deviceRegistrationMachine = e),
            (this.masterPasswordFlowMachine = t),
            (this.twoFactorAuthenticationMachine = r),
            (this.webAuthnMachine = s),
            (this.deviceToDeviceAuthenticationMachine = a),
            (this.initializeMachineService = n),
            (this.legacySSOLoginService = i),
            (this.requestAuthenticationMethodForLogin = o),
            (this.storeSSOInfoService = c);
        }
        desc() {
          const e = {
            config: {
              predictableActionArguments: !0,
              schema: { events: {}, context: {} },
              initial: "Starting",
              id: "AuthenticationFlowMachine",
              context: {
                ...this.deviceRegistrationMachine.desc().config.context,
                ...this.masterPasswordFlowMachine.desc().config.context,
                ...this.twoFactorAuthenticationMachine.desc().config.context,
                ...this.webAuthnMachine.desc().config.context,
                ...this.deviceToDeviceAuthenticationMachine.desc().config.context,
                ready: !1,
                shouldAskMasterPassword: !1,
                shouldAskOTP: !1
              },
              states: {
                Starting: {
                  invoke: {
                    src: "initializeMachine",
                    onDone: { actions: ["assignInitializationResults"], target: "RememberMeRedirection" }
                  }
                },
                RememberMeRedirection: {
                  always: [
                    { target: "MasterPassword", cond: "shouldAskMasterPassword" },
                    { target: "CheckSessionForOtp2", cond: "shouldAskOTP" },
                    { target: "WebAuthn", cond: "rememberMeIsWebAuthn" },
                    { target: "WaitingForEmail" }
                  ]
                },
                CheckSessionForOtp2: { entry: ["requestAuthenticationMethodForLogin"] },
                WaitingForEmail: {
                  on: { INPUT_ACCOUNT_EMAIL: { target: "ValidatingEmail", actions: ["assignAccountEmail", "clearError"] } }
                },
                ValidatingEmail: {
                  entry: ["requestAuthenticationMethodForLogin"],
                  on: { CARBON_LEGACY_ERROR: { target: "WaitingForEmail", actions: ["assignError"] } }
                },
                DeviceRegistration: { ...Y(this.deviceRegistrationMachine.desc().config) },
                WebAuthn: {
                  ...Y(this.webAuthnMachine.desc().config),
                  onDone: [{ target: "MasterPassword", cond: "shouldSwitchToMasterPassword" }, { target: "AuthenticationDone" }]
                },
                TwoFactorAuthentication: {
                  ...Y(this.twoFactorAuthenticationMachine.desc().config),
                  onDone: { target: "AuthenticationDone" }
                },
                SSOAuthentication: { entry: ["legacySSOLogin"] },
                SSORedirectionToIdp: { entry: ["assignServiceProviderInfo", "storeSSOInfo"] },
                DeviceToDeviceAuthentication: {
                  ...Y(this.deviceToDeviceAuthenticationMachine.desc().config),
                  onDone: { target: "AuthenticationDone" }
                },
                MasterPassword: {
                  ...Y(this.masterPasswordFlowMachine.desc().config),
                  onDone: [{ target: "WaitingForEmail", cond: "shouldResetAuthenticationFlow" }, { target: "AuthenticationDone" }]
                },
                AuthenticationDone: { on: { CARBON_LEGACY_LOGIN_STATUS_CHANGED: { cond: "isLoggedOut", target: "Starting" } } }
              },
              on: {
                CHANGE_ACCOUNT_EMAIL: [
                  { target: "ValidatingEmail", actions: ["clearError", "assignAccountEmail"], cond: "isAccountLoginAvailable" },
                  { target: "WaitingForEmail", actions: ["clearError", "clearEmail"] }
                ],
                CARBON_LEGACY_ASK_MASTER_PASSWORD: { target: "MasterPassword", actions: ["assignServerKey", "clearError"] },
                CARBON_LEGACY_OPEN_SESSION_TOKEN_SENT: [
                  {
                    target: "DeviceRegistration.EmailToken",
                    actions: ["assignAccountEmail", "clearError"],
                    cond: "isGrapheneDeviceRegistrationFlow"
                  },
                  { target: "DeviceRegistration.EmailToken", actions: ["assignAccountEmail", "clearError"] }
                ],
                CARBON_LEGACY_OPEN_SESSION_DASHLANE_AUTHENTICATOR: {
                  target: "DeviceRegistration.DashlaneAuthenticator",
                  actions: ["clearError"]
                },
                CARBON_LEGACY_OPEN_SESSION_SSO_REDIRECTION_TO_IDP_REQUIRED: { target: "SSORedirectionToIdp", actions: ["clearError"] },
                CARBON_LEGACY_SSO_LOGIN_BYPASS: { target: "SSOAuthentication", actions: ["assignSsoData"] },
                CARBON_LEGACY_OPEN_SESSION_OTP_SENT: {
                  target: "TwoFactorAuthentication",
                  actions: ["assignOtpVerificationMode", "clearError"]
                },
                CARBON_LEGACY_OPEN_SESSION_DEVICE_TO_DEVICE: { target: "DeviceToDeviceAuthentication" },
                CLEAR_ERROR: { actions: ["clearError"] }
              }
            },
            options: {
              actions: {
                ...this.deviceRegistrationMachine.desc().options.actions,
                ...this.masterPasswordFlowMachine.desc().options.actions,
                ...this.twoFactorAuthenticationMachine.desc().options.actions,
                ...this.webAuthnMachine.desc().options.actions,
                ...this.deviceToDeviceAuthenticationMachine.desc().options.actions,
                assignInitializationResults: (0, P.f0)({
                  login: (e, t) => t.data.lastUsedLogin,
                  localAccounts: (e, t) => t.data.localAccounts,
                  shouldAskMasterPassword: (e, t) => t.data.shouldAskMasterPassword,
                  shouldAskOTP: (e, t) => t.data.shouldAskOTP,
                  rememberMeType: (e, t) => t.data.rememberMeType,
                  ready: () => !0
                }),
                assignAccountEmail: (0, P.f0)({ login: (e, t) => t.login }),
                assignError: (0, P.f0)({ error: (e, t) => ({ code: "unknown_error", data: { message: t.error } }) }),
                assignOtpVerificationMode: (0, P.f0)({ otpVerificationMode: (e, t) => t.otpVerificationMode }),
                assignSsoData: (0, P.f0)({ ssoData: (e, t) => t }),
                assignServiceProviderInfo: (0, P.f0)({
                  serviceProviderRedirectUrl: (e, t) => t.serviceProviderRedirectUrl,
                  isNitroProvider: (e, t) => t.isNitroProvider,
                  rememberMeForSSOPreference: (e, t) => t.rememberMeForSSOPreference
                }),
                assignServerKey: (0, P.f0)({ serverKey: (e, t) => t.serverKey }),
                clearEmail: (0, P.f0)({ login: void 0 }),
                clearError: (0, P.f0)({ error: () => {} }),
                clearContext: (0, P.f0)({
                  login: () => "",
                  shouldAskOTP: () => !1,
                  shouldAskMasterPassword: () => !1,
                  twoFactorAuthenticationOtpType: () => "totp",
                  registrationMethod: () => {},
                  emailToken: () => "",
                  deviceName: () => "",
                  isDashlaneAuthenticatorAvailable: () => !1,
                  isRememberMeEnabled: () => !1,
                  isAccountRecoveryAvailable: () => !1
                }),
                legacySSOLogin: (e, t) => this.legacySSOLoginService.execute(t),
                requestAuthenticationMethodForLogin: (e) => this.requestAuthenticationMethodForLogin.execute(e),
                storeSSOInfo: (e, t) => this.storeSSOInfoService.execute(t)
              },
              services: {
                ...this.deviceRegistrationMachine.desc().options.services,
                ...this.masterPasswordFlowMachine.desc().options.services,
                ...this.twoFactorAuthenticationMachine.desc().options.services,
                ...this.webAuthnMachine.desc().options.services,
                ...this.deviceToDeviceAuthenticationMachine.desc().options.services,
                initializeMachine: () => this.initializeMachineService.execute()
              },
              guards: {
                ...this.deviceRegistrationMachine.desc().options.guards,
                ...this.twoFactorAuthenticationMachine.desc().options.guards,
                ...this.webAuthnMachine.desc().options.guards,
                isAccountLoginAvailable: (e, t) => Boolean(t.login),
                isLoggedOut: (e, t) => !t.loggedIn,
                shouldAskMasterPassword: (e) => !!e.shouldAskMasterPassword && e.shouldAskMasterPassword,
                shouldAskOTP: (e) => !!e.shouldAskOTP && e.shouldAskOTP,
                shouldSwitchToMasterPassword: (e, t) => t.data.switchToMasterPassword,
                shouldResetAuthenticationFlow: (e, t) => t.data.shouldResetAuthenticationFlow,
                rememberMeIsWebAuthn: (e) => void 0 !== e.rememberMeType && "webauthn" === e.rememberMeType,
                isGrapheneDeviceRegistrationFlow: (e) => !!e.login && e.login.includes("kw_test_newdevice")
              }
            }
          };
          return (
            (function (e) {
              const t = [...Object.entries(e.config.states).map(([e, t]) => ({ path: e, state: t }))];
              for (; t.length > 0; ) {
                const e = t.pop();
                if (!e) continue;
                const { path: r, state: s } = e;
                t.push(...Object.entries(s.states ?? {}).map(([e, t]) => ({ path: `${r}.${e}`, state: t }))),
                  "invoke" in s &&
                    "object" == typeof s.invoke &&
                    ("onError" in s.invoke ||
                      (s.invoke.onError = {
                        actions: (...e) => {
                          console.error("Missing onError callback" + r, ...e);
                        }
                      }));
              }
            })(e),
            e
          );
        }
        create() {
          const { config: e, options: t } = this.desc();
          return (0, D.C)(e, t);
        }
      };
      ge = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [X, W, ee, J, de, pe, he, ye, me])], ge);
      let ve = class {
        constructor(e, t, r, s) {
          (this.carbon = r), (this.allowedToFail = s), (this.loginMachineStore = t);
          const a = e.create();
          (this.interpreter = C.kJ(a)
            .onTransition(
              (function (e) {
                return async (t) => {
                  t.changed ||
                    "xstate.init" === t.event.type ||
                    (await e.doOne(() => {
                      throw new Error(
                        `State machine unchanged: Unexpected transition on ${JSON.stringify(t.value)} with event ${t.event.type} `
                      );
                    }));
                };
              })(this.allowedToFail)
            )
            .onTransition(async () => {
              const e = this.interpreter.getSnapshot();
              await (async (e, t) => {
                await e.set(JSON.stringify(t));
              })(this.loginMachineStore, e);
            })
            .onEvent(
              (function (e) {
                return async (t) => {
                  if (t.type.startsWith("error.")) {
                    const r = "data" in t ? t.data : "";
                    await e.doOne(() => {
                      throw new Error(`Error executing state machine service: ${t.type} ${r}`);
                    });
                  }
                };
              })(this.allowedToFail)
            )),
            (this.abortDeviceLimitEventHandler = new x(this.interpreter, this.carbon));
        }
        async prepare() {
          await this.abortDeviceLimitEventHandler.execute();
          const e = await (async (e) => {
            const t = await e.getState();
            return t ? l.ZM.create(JSON.parse(t)) : void 0;
          })(this.loginMachineStore);
          if (!e) {
            const e = this.interpreter.start();
            return void (await (0, R.x)(e, (e) => e.context.ready));
          }
          let t;
          await this.allowedToFail.doOne(() => {
            if (e.done) throw new Error("Restarting a machine which is already in its final state. Starting from scratch instead.");
            t = this.interpreter.start(e);
          }, "Resuming state machine"),
            t || (t = this.interpreter.start()),
            await (0, R.x)(t, (e) => e.context.ready);
        }
        continue(e) {
          this.interpreter.send(e);
        }
      };
      ve = (0, s.__decorate)([(0, I.GS)(), (0, s.__metadata)("design:paramtypes", [ge, g, o.CarbonLegacyClient, i.J])], ve);
      let fe = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute(e) {
          const { login: t } = e.body;
          return this.authenticationFlow.continue({ type: "CHANGE_ACCOUNT_EMAIL", login: t }), Promise.resolve((0, b.Vp)(void 0));
        }
      };
      fe = (0, s.__decorate)([(0, T.W)(A.hW), (0, s.__metadata)("design:paramtypes", [ve])], fe);
      let we = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute(e) {
          const { twoFactorAuthenticationOtpType: t } = e.body;
          return (
            this.authenticationFlow.continue({ type: "SWITCH_TWO_FACTOR_AUTHENTICATION_TYPE", twoFactorAuthenticationOtpType: t }),
            Promise.resolve((0, b.Vp)(void 0))
          );
        }
      };
      we = (0, s.__decorate)([(0, T.W)(A.eG), (0, s.__metadata)("design:paramtypes", [ve])], we);
      let Se = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute() {
          return this.authenticationFlow.continue({ type: "CLEAR_ERROR" }), Promise.resolve((0, b.Vp)(void 0));
        }
      };
      Se = (0, s.__decorate)([(0, T.W)(A.jq), (0, s.__metadata)("design:paramtypes", [ve])], Se);
      let Ee = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute() {
          return this.authenticationFlow.continue({ type: "CANCEL_DEVICE_TRANSFER_REQUEST" }), Promise.resolve((0, b.Vp)(void 0));
        }
      };
      Ee = (0, s.__decorate)([(0, T.W)(A.Yc), (0, s.__metadata)("design:paramtypes", [ve])], Ee);
      let _e = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute() {
          return this.authenticationFlow.continue({ type: "RESEND_EMAIL_TOKEN" }), Promise.resolve((0, b.Vp)(void 0));
        }
      };
      _e = (0, s.__decorate)([(0, T.W)(A.Gc), (0, s.__metadata)("design:paramtypes", [ve])], _e);
      let be = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute() {
          return this.authenticationFlow.continue({ type: "RESEND_PUSH_NOTIFICATION" }), Promise.resolve((0, b.Vp)(void 0));
        }
      };
      be = (0, s.__decorate)([(0, T.W)(A.rF), (0, s.__metadata)("design:paramtypes", [ve])], be);
      let Te = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute(e) {
          const { login: t } = e.body;
          return this.authenticationFlow.continue({ type: "INPUT_ACCOUNT_EMAIL", login: t }), Promise.resolve((0, b.Vp)(void 0));
        }
      };
      Te = (0, s.__decorate)([(0, T.W)(A.A), (0, s.__metadata)("design:paramtypes", [ve])], Te);
      let Ae = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute(e) {
          const { masterPassword: t, rememberMe: r } = e.body;
          return (
            this.authenticationFlow.continue({ type: "INPUT_MASTER_PASSWORD", masterPassword: t, rememberMe: r }),
            Promise.resolve((0, b.Vp)(void 0))
          );
        }
      };
      Ae = (0, s.__decorate)([(0, T.W)(A.rT), (0, s.__metadata)("design:paramtypes", [ve])], Ae);
      let Ce = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute(e) {
          const { twoFactorAuthenticationOtpValue: t } = e.body;
          return (
            this.authenticationFlow.continue({ type: "INPUT_BACKUP_CODE", twoFactorAuthenticationOtpValue: t }),
            Promise.resolve((0, b.Vp)(void 0))
          );
        }
      };
      Ce = (0, s.__decorate)([(0, T.W)(A.sH), (0, s.__metadata)("design:paramtypes", [ve])], Ce);
      let Re = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute(e) {
          const { emailToken: t, deviceName: r } = e.body;
          return (
            this.authenticationFlow.continue({ type: "INPUT_EMAIL_TOKEN", emailToken: t, deviceName: r }),
            Promise.resolve((0, b.Vp)(void 0))
          );
        }
      };
      Re = (0, s.__decorate)([(0, T.W)(A.XH), (0, s.__metadata)("design:paramtypes", [ve])], Re);
      let Ie = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute(e) {
          const { twoFactorAuthenticationOtpValue: t } = e.body;
          return (
            this.authenticationFlow.continue({ type: "INPUT_TOTP", twoFactorAuthenticationOtpValue: t }), Promise.resolve((0, b.Vp)(void 0))
          );
        }
      };
      Ie = (0, s.__decorate)([(0, T.W)(A.ad), (0, s.__metadata)("design:paramtypes", [ve])], Ie);
      let xe = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute() {
          return this.authenticationFlow.continue({ type: "SWITCH_TO_DASHLANE_AUTHENTICATOR" }), Promise.resolve((0, b.Vp)(void 0));
        }
      };
      xe = (0, s.__decorate)([(0, T.W)(A.K1), (0, s.__metadata)("design:paramtypes", [ve])], xe);
      let Pe = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute() {
          return this.authenticationFlow.continue({ type: "SWITCH_TO_EMAIL_TOKEN" }), Promise.resolve((0, b.Vp)(void 0));
        }
      };
      Pe = (0, s.__decorate)([(0, T.W)(A.v5), (0, s.__metadata)("design:paramtypes", [ve])], Pe);
      let De = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute() {
          return this.authenticationFlow.continue({ type: "RETRY_WEBAUTHN_AUTHENTICATION" }), Promise.resolve((0, b.Vp)(void 0));
        }
      };
      De = (0, s.__decorate)([(0, T.W)(A.M6), (0, s.__metadata)("design:paramtypes", [ve])], De);
      let Ue = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute() {
          return this.authenticationFlow.continue({ type: "USE_MASTER_PASSWORD" }), Promise.resolve((0, b.Vp)(void 0));
        }
      };
      Ue = (0, s.__decorate)([(0, T.W)(A.Cc), (0, s.__metadata)("design:paramtypes", [ve])], Ue);
      let Fe = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute(e) {
          const { webAuthnError: t } = e.body;
          return this.authenticationFlow.continue({ type: "WEBAUTHN_AUTHENTICATION_FAIL", error: t }), Promise.resolve((0, b.Vp)(void 0));
        }
      };
      Fe = (0, s.__decorate)([(0, T.W)(A.O3), (0, s.__metadata)("design:paramtypes", [ve])], Fe);
      var Oe = r(26457);
      let Ne = class {
        constructor(e, t) {
          (this.carbonLegacy = e), (this.logger = t);
        }
        async execute() {
          try {
            await this.carbonLegacy.commands.carbonLegacyLeeloo({ name: "closeSession", arg: [{}] });
          } catch (e) {
            this.logger.trace("Logout Command error :" + e);
          }
          return Promise.resolve((0, b.Vp)(void 0));
        }
      };
      Ne = (0, s.__decorate)([(0, T.W)(A.N5), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient, Oe.V])], Ne);
      let ke = class {
        constructor(e, t) {
          (this.carbonLegacy = e), (this.logger = t);
        }
        async execute() {
          try {
            await this.carbonLegacy.commands.carbonLegacyLeeloo({ name: "lockSession", arg: [{}] });
          } catch (e) {
            this.logger.trace("LockSession command handler: " + e);
          }
          return Promise.resolve((0, b.Vp)(void 0));
        }
      };
      ke = (0, s.__decorate)([(0, T.W)(A.Y$), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient, Oe.V])], ke);
      let Le = class {
        constructor(e) {
          this.authenticationFlow = e;
        }
        execute(e) {
          return (
            this.authenticationFlow.continue({ type: "CARBON_LEGACY_SSO_LOGIN_BYPASS", ...e.body }), Promise.resolve((0, b.Vp)(void 0))
          );
        }
      };
      Le = (0, s.__decorate)([(0, T.W)(A.yv), (0, s.__metadata)("design:paramtypes", [ve])], Le);
      var Me = r(28489),
        Ve = r(94189),
        Ge = r(95082);
      class je {}
      let qe = class {
        constructor(e, t, r, s) {
          (this.carbonLegacyClient = e), (this.ssoUserSettingsStore = r), (this.client = t), (this.authenticationFlowInfraContext = s);
        }
        async retrieveSSOInfo() {
          const e = await (0, O.z)(
            this.carbonLegacyClient.queries.carbonState({ path: "userSession.ssoSettings" }).pipe(
              (0, m.U)((e) => {
                if (
                  !(
                    (0, b.d6)(e) &&
                    ((t = e.data), t && "object" == typeof t && (0, Me.l$)(t, "ssoUser") && (0, Me.l$)(t, "serviceProviderUrl"))
                  )
                )
                  throw new Error("SsoSettings is not of the expected type");
                var t;
                return e.data;
              })
            )
          );
          return { isNitroProvider: e.isNitroProvider ?? !1, serviceProviderUrl: e.serviceProviderUrl };
        }
        async execute(e) {
          const { loginUserWithEnclaveSSO: t } = this.client.getClient(Ge.y).commands,
            r = await this.retrieveSSOInfo(),
            { login: s, rememberMeForSSOPreference: a } = e.body;
          return (
            await this.ssoUserSettingsStore.set({ rememberMeForSSOPreference: a }),
            r.isNitroProvider
              ? await t({ userEmailAddress: s })
              : this.authenticationFlowInfraContext.redirectUserToExternalUrl({ externalUrl: r.serviceProviderUrl, tabFocus: !0 }),
            Promise.resolve((0, b.Vp)(void 0))
          );
        }
      };
      qe = (0, s.__decorate)([(0, T.W)(A.Hr), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient, Ve.w, S, je])], qe);
      var Ke = r(74081);
      const We = (e) => !!e && "object" == typeof e && (0, Me.l$)(e, "type") && "sso" === e.type;
      let Be = class {
        constructor(e, t, r, s, a) {
          (this.allowToFail = a),
            (this.client = t),
            (this.carbonLegacyClient = e),
            (this.authenticationFlowInfraContext = r),
            (this.serverApiClient = s);
        }
        getDeviceAccessKeys(e) {
          return this.carbonLegacyClient.queries.carbonState({ path: "authentication.localUsers" }).pipe(
            (0, le.h)(b.d6),
            (0, m.U)((t) => t.data[e])
          );
        }
        async checkSSOInfo(e) {
          const t = (
            await (0, O.z)(
              this.getDeviceAccessKeys(e).pipe(
                (0, m.U)((t) =>
                  this.serverApiClient.v1.authentication.getAuthenticationMethodsForLogin({
                    login: e,
                    deviceAccessKey: t.deviceAccessKey,
                    methods: ["email_token", "totp", "duo_push", "dashlane_authenticator"]
                  })
                ),
                (0, Ke.J)(),
                (0, le.h)(b.d6),
                (0, m.U)((e) => e.data.data)
              )
            )
          ).verifications.find(We);
          if (t) {
            const e = t.ssoInfo;
            return { isNitroProvider: e.isNitroProvider, serviceProviderUrl: e.serviceProviderUrl };
          }
          throw new Error("No SSO authentication available for the user");
        }
        async execute(e) {
          const { login: t } = e.body,
            { loginUserWithEnclaveSSO: r } = this.client.getClient(Ge.y).commands;
          return (
            await this.allowToFail.doOne(async () => {
              const e = await this.checkSSOInfo(t);
              e.isNitroProvider
                ? await r({ userEmailAddress: t })
                : this.authenticationFlowInfraContext.redirectUserToExternalUrl({ externalUrl: e.serviceProviderUrl, tabFocus: !1 });
            }, "InitiateAutologinWithSSOCommandHandler.execute"),
            Promise.resolve((0, b.Vp)(void 0))
          );
        }
      };
      Be = (0, s.__decorate)([(0, T.W)(A.x2), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient, Ve.w, je, M.l, i.J])], Be);
      var ze = r(68307);
      let He = class {
        constructor(e, t, r) {
          (this.authenticationFlow = e), (this.ssoUserSettingsStore = t), (this.carbon = r);
        }
        getLoginFlowMigrationKillswitch() {
          return (0, O.z)(
            this.carbon.queries.carbonState({ path: "device.killswitch.disableLoginFlowMigration" }).pipe(
              (0, le.h)(b.d6),
              (0, m.U)((e) => e)
            )
          );
        }
        async handle(e) {
          const t = await this.getLoginFlowMigrationKillswitch();
          let r = !1;
          if ("undefined" != typeof self && self.localStorage) {
            const e = self.localStorage.getItem("extng.loginFlow.forceLegacyFallback");
            r = Boolean(e) && "true" === e;
          }
          if (("success" === t.tag && t.data) || r)
            return (
              console.warn("[Authentication-flow] Ignoring carbon event due to legacy login fallback", {
                isKillSwitchEnabled: t,
                isForceLoginFlowFallbackOptionEnabled: r
              }),
              Promise.resolve()
            );
          switch (e.body.eventName) {
            case "openSessionMasterPasswordLess":
              this.authenticationFlow.continue({ type: "CARBON_LEGACY_OPEN_SESSION_DEVICE_TO_DEVICE" });
              break;
            case "openSessionTokenSent":
              if (
                !e.body.eventData ||
                "object" != typeof e.body.eventData ||
                !("login" in e.body.eventData) ||
                "string" != typeof e.body.eventData.login
              )
                throw new Error("login not in eventData");
              this.authenticationFlow.continue({ type: "CARBON_LEGACY_OPEN_SESSION_TOKEN_SENT", login: e.body.eventData.login });
              break;
            case "openSessionAskMasterPassword":
              {
                const e = await (0, O.z)(this.carbon.queries.getMasterPasswordAndServerKey());
                if ((0, b.hx)(e)) throw new Error("Failed to get  server key from carbon");
                const { serverKey: t } = e.data;
                this.authenticationFlow.continue({ type: "CARBON_LEGACY_ASK_MASTER_PASSWORD", serverKey: t });
              }
              break;
            case "openSessionDashlaneAuthenticator":
              this.authenticationFlow.continue({ type: "CARBON_LEGACY_OPEN_SESSION_DASHLANE_AUTHENTICATOR" });
              break;
            case "openSessionOTPSent":
            case "openSessionOTPForNewDeviceRequired":
              this.authenticationFlow.continue({
                type: "CARBON_LEGACY_OPEN_SESSION_OTP_SENT",
                otpVerificationMode: "openSessionOTPSent" === e.body.eventName ? "otp2" : "otp1"
              });
              break;
            case "openSessionSsoRedirectionToIdpRequired":
              {
                const t = e.body.eventData,
                  { rememberMeForSSOPreference: r } = await this.ssoUserSettingsStore.getState();
                this.authenticationFlow.continue({
                  type: "CARBON_LEGACY_OPEN_SESSION_SSO_REDIRECTION_TO_IDP_REQUIRED",
                  serviceProviderRedirectUrl: t.serviceProviderRedirectUrl,
                  isNitroProvider: t.isNitroProvider,
                  rememberMeForSSOPreference: r
                });
              }
              break;
            case "openSessionFailed":
              {
                const t = e.body.eventData;
                this.authenticationFlow.continue({ type: "CARBON_LEGACY_ERROR", error: t.errorCode });
              }
              break;
            case "loginStatusChanged": {
              const t = e.body.eventData;
              this.authenticationFlow.continue({ type: "CARBON_LEGACY_LOGIN_STATUS_CHANGED", loggedIn: t.loggedIn });
            }
          }
          return Promise.resolve();
        }
      };
      He = (0, s.__decorate)([(0, ze.b)(o.CarbonLegacyEvent), (0, s.__metadata)("design:paramtypes", [ve, S, o.CarbonLegacyClient])], He);
      var $e = r(6136),
        Qe = r(20754),
        Ye = r(28096),
        Xe = r(69885),
        Je = r(6220);
      const Ze = (e) => ({
          step: "EmailStep",
          loginEmail: e.context.login,
          localAccounts: e.context.localAccounts ?? [],
          isLoading: e.matches("ValidatingEmail") && !e.context.error,
          error: e.context.error?.data?.message
        }),
        et = (e) => ({
          step: "DeviceToDeviceAuthenticationStep",
          deviceToDeviceStep: V.E6.WaitingForTransferRequest,
          localAccounts: e.context.localAccounts ?? [],
          loginEmail: e.context.login,
          error: e.context.error
        }),
        tt = (e) => ({
          step: "DeviceToDeviceAuthenticationStep",
          deviceToDeviceStep: V.E6.DisplayInstructions,
          localAccounts: e.context.localAccounts ?? [],
          loginEmail: e.context.login,
          error: e.context.error
        }),
        rt = (e) => ({
          step: "DeviceToDeviceAuthenticationStep",
          deviceToDeviceStep: V.E6.DisplayPassphrase,
          localAccounts: e.context.localAccounts ?? [],
          loginEmail: e.context.login,
          passphrase: e.context.passphrase?.split(ce.iy) || [],
          error: e.context.error
        }),
        st = (e) => ({
          step: "DeviceToDeviceAuthenticationStep",
          deviceToDeviceStep: V.E6.Error,
          localAccounts: e.context.localAccounts ?? [],
          loginEmail: e.context.login,
          error: e.context.error ?? V.UY.GENERIC_ERROR
        }),
        at = (e) => ({
          step: "DeviceToDeviceAuthenticationStep",
          deviceToDeviceStep: V.E6.DeviceRegistered,
          localAccounts: e.context.localAccounts ?? [],
          loginEmail: e.context.login,
          error: e.context.error
        }),
        nt = (e) => ({
          step: "EmailTokenStep",
          localAccounts: e.context.localAccounts ?? [],
          loginEmail: e.context.login,
          isLoading: e.matches({ DeviceRegistration: { EmailToken: "ValidatingEmailToken" } }) && !e.context.error,
          error: e.context.error?.data?.message,
          emailToken: e.context.emailToken,
          isDashlaneAuthenticatorAvailable: e.context.isDashlaneAuthenticatorAvailable
        }),
        it = (e) => ({
          step: "DashlaneAuthenticatorStep",
          localAccounts: e.context.localAccounts ?? [],
          isLoading: e.matches({ DeviceRegistration: { DashlaneAuthenticator: "RequestingServerPush" } }) && !e.context.error,
          error: e.context.error?.data?.message
        }),
        ot = (e) => ({
          step: "TwoFactorAuthenticationOtpStep",
          localAccounts: e.context.localAccounts ?? [],
          loginEmail: e.context.login,
          isLoading: e.matches({ TwoFactorAuthentication: "ValidatingTwoFactorAuthenticationOtp" }) && !e.context.error,
          error: e.context.error?.data?.message,
          twoFactorAuthenticationOtpValue: e.context.twoFactorAuthenticationOtpValue,
          twoFactorAuthenticationOtpType: e.context.twoFactorAuthenticationOtpType
        }),
        ct = (e) => ({
          step: "WebAuthnStep",
          localAccounts: e.context.localAccounts ?? [],
          loginEmail: e.context.login,
          isLoading: e.matches({ WebAuthn: "InitWebAuthnAuthentication" }) && !e.context.error,
          error: e.context.error?.data?.message
        }),
        ut = (e) => ({
          step: "SSORedirectionToIdpStep",
          loginEmail: e.context.login,
          serviceProviderRedirectUrl: e.context.serviceProviderRedirectUrl ?? "",
          isNitroProvider: e.context.isNitroProvider ?? !1,
          rememberMeForSSOPreference: e.context.rememberMeForSSOPreference,
          isLoading: e.matches({ SSORedirectionToIdp: "InitSSOAuthentication" }) && !e.context.error,
          error: e.context.error?.data?.message,
          localAccounts: e.context.localAccounts ?? []
        }),
        dt = (e) => ({
          step: "MasterPasswordStep",
          loginEmail: e.context.login ?? "",
          localAccounts: e.context.localAccounts ?? [],
          isLoading:
            (e.matches({ MasterPassword: "ValidatingMasterPassword" }) ||
              e.matches({ MasterPassword: "CheckingMigrationNeeded" }) ||
              e.matches({ MasterPassword: "OpeningSessionWithMasterpassword" }) ||
              e.matches("AuthenticationDone")) &&
            !e.context.error,
          isAccountRecoveryAvailable: e.context.isAccountRecoveryAvailable,
          error: e.context.error?.data?.message,
          serviceProviderRedirectUrl: e.context.serviceProviderRedirectUrl,
          isNitroProvider: e.context.isNitroProvider ?? !1
        }),
        lt = (e) => ({
          step: "AuthenticationDoneStep",
          loginEmail: e.context.login ?? "",
          localAccounts: e.context.localAccounts ?? [],
          isLoading:
            (e.matches({ MasterPassword: "ValidatingMasterPassword" }) ||
              e.matches({ MasterPassword: "CheckingMigrationNeeded" }) ||
              e.matches({ MasterPassword: "OpeningSessionWithMasterpassword" }) ||
              e.matches("AuthenticationDone")) &&
            !e.context.error,
          isAccountRecoveryAvailable: e.context.isAccountRecoveryAvailable,
          isDeviceToDeviceAuthentication: Boolean(e.context.transferId && e.context.passphrase),
          error: e.context.error?.data?.message,
          serviceProviderRedirectUrl: e.context.serviceProviderRedirectUrl,
          isNitroProvider: e.context.isNitroProvider ?? !1
        }),
        pt = (e) => ({ step: "StartingStep", localAccounts: e.context.localAccounts ?? [] });
      const ht = (e) =>
          (0, Xe.of)(
            (0, b.Vp)(
              (function (e) {
                return e.matches("Starting")
                  ? pt(e)
                  : e.matches("WaitingForEmail") || e.matches("ValidatingEmail")
                  ? Ze(e)
                  : e.matches({ DeviceRegistration: { EmailToken: "SendEmailToken" } }) ||
                    e.matches({ DeviceRegistration: { EmailToken: "WaitingForEmailToken" } }) ||
                    e.matches({ DeviceRegistration: { EmailToken: "ValidatingEmailToken" } }) ||
                    e.matches({ DeviceRegistration: { EmailToken: "FinishingEmailToken" } })
                  ? nt(e)
                  : e.matches({ DeviceRegistration: { DashlaneAuthenticator: "RequestingServerPush" } }) ||
                    e.matches({ DeviceRegistration: { DashlaneAuthenticator: "AuthenticatorPushFailed" } }) ||
                    e.matches({ DeviceRegistration: { DashlaneAuthenticator: "AuthenticatorPushValidated" } })
                  ? it(e)
                  : e.matches({ TwoFactorAuthentication: "WaitingForTotp" }) ||
                    e.matches({ TwoFactorAuthentication: "WaitingForBackupCode" }) ||
                    e.matches({ TwoFactorAuthentication: "ValidatingTwoFactorAuthenticationOtp" }) ||
                    e.matches({ TwoFactorAuthentication: "FinishingTwoFactorAuthenticationOtp" })
                  ? ot(e)
                  : e.matches({ WebAuthn: "InitWebAuthnAuthentication" }) ||
                    e.matches({ WebAuthn: "WebAuthnAuthenticationFailed" }) ||
                    e.matches({ WebAuthn: "WebAuthnAuthenticationValidated" })
                  ? ct(e)
                  : e.matches("SSORedirectionToIdp")
                  ? ut(e)
                  : e.matches({ DeviceToDeviceAuthentication: "WaitingForTransferRequest" })
                  ? et(e)
                  : e.matches({ DeviceToDeviceAuthentication: "DisplayInstructions" })
                  ? tt(e)
                  : e.matches({ DeviceToDeviceAuthentication: "GeneratePassphrase" }) ||
                    e.matches({ DeviceToDeviceAuthentication: "StartTransfer" })
                  ? rt(e)
                  : e.matches({ DeviceToDeviceAuthentication: "DeviceTransferError" })
                  ? st(e)
                  : e.matches({ DeviceToDeviceAuthentication: "DeviceRegistered" })
                  ? at(e)
                  : e.matches("AuthenticationDone")
                  ? lt(e)
                  : e.matches({ MasterPassword: "CheckingAccountRecoveryStatus" }) ||
                    e.matches({ MasterPassword: "WaitingForMasterPassword" }) ||
                    e.matches({ MasterPassword: "ValidatingMasterPassword" }) ||
                    e.matches({ MasterPassword: "OpeningSessionWithMasterpassword" }) ||
                    e.matches({ MasterPassword: "CheckingMigrationNeeded" }) ||
                    e.matches({ MasterPassword: "OpeningSessionWithMasterpassword" })
                  ? dt(e)
                  : void console.warn("[Auth] - No view associated to state ", JSON.stringify(e.value));
              })(e)
            )
          ),
        mt = (e) => e.pipe((0, Je.z)(ht));
      var yt = r(30045);
      let gt = class {
        constructor(e, t) {
          (this.authenticationFlow = e), (this.loginMachineStore = t);
        }
        execute() {
          return ((e = this.loginMachineStore), e.state$.pipe((0, m.U)((e) => (e ? l.ZM.create(JSON.parse(e)) : void 0)))).pipe(
            (0, le.h)(Boolean),
            (0, $e.x)((e, t) =>
              ((e, t) => {
                const r = t.matches(e.value),
                  s = (0, yt.Z)(e.context, t.context);
                return r && s;
              })(e, t)
            ),
            mt
          );
          var e;
        }
      };
      gt = (0, s.__decorate)([(0, Qe.e)(Ye.DW), (0, s.__metadata)("design:paramtypes", [ve, g])], gt);
      let vt = class {
        constructor(e) {
          (this.ssoUserSettingsStore = e), (this.ssoUserSettingsStore = e);
        }
        execute() {
          return this.ssoUserSettingsStore.state$.pipe(
            (0, m.U)((e) => (0, b.Vp)({ rememberMeForSSOPreference: e.rememberMeForSSOPreference }))
          );
        }
      };
      vt = (0, s.__decorate)([(0, Qe.e)(Ye.Dc), (0, s.__metadata)("design:paramtypes", [S])], vt);
      let ft = class {
        constructor(e) {
          (this.ssoProviderInfoStore = e), (this.ssoProviderInfoStore = e);
        }
        execute() {
          return this.ssoProviderInfoStore.state$.pipe(
            (0, m.U)((e) =>
              (0, b.Vp)({ serviceProviderUrl: e.serviceProviderUrl, isNitroProvider: e.isNitroProvider, migrationType: e.migrationType })
            )
          );
        }
      };
      ft = (0, s.__decorate)([(0, Qe.e)(Ye.L2), (0, s.__metadata)("design:paramtypes", [_])], ft);
      const wt = (e) => !0;
      class St extends (0, h.Q)({
        initialValue: void 0,
        persist: !1,
        scope: p.F.Device,
        storeName: "device-registration-flow-store",
        storeTypeGuard: wt
      }) {}
      var Et = r(3786);
      let _t = class {};
      _t = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: c.V,
            handlers: {
              commands: {
                changeLogin: fe,
                changeTwoFactorAuthenticationOtpType: we,
                clearError: Se,
                cancelDeviceTransferRequest: Ee,
                resendEmailToken: _e,
                resendPushNotification: be,
                sendAccountEmail: Te,
                sendMasterPassword: Ae,
                submitBackupCode: Ce,
                submitEmailToken: Re,
                submitTotp: Ie,
                switchToDashlaneAuthenticator: xe,
                switchToEmailToken: Pe,
                retryWebAuthnAuthentication: De,
                useMasterPassword: Ue,
                webAuthnAuthenticationFail: Fe,
                logout: Ne,
                lockSession: ke,
                loginViaSSO: Le,
                initiateLoginWithSSO: qe,
                initiateAutologinWithSSO: Be
              },
              events: { ...(0, a.g)(o.carbonLegacyApi, { carbonLegacy: He }) },
              queries: { authenticationFlowStatus: gt, getSsoUserSettings: vt, getProviderInfo: ft }
            },
            configurations: { authenticationFlowContextInfrastructure: { token: je } },
            providers: [
              H,
              X,
              Q,
              J,
              W,
              ee,
              de,
              ...(0, n.H)(ve, {
                inject: [ge, g, o.CarbonLegacyClient, i.J],
                asyncFactory: async (e, t, r, s) => {
                  const a = new ve(e, t, r, s);
                  return await a.prepare(), a;
                }
              }),
              ge,
              pe,
              he,
              k,
              q,
              z,
              $,
              N,
              Z,
              ye,
              B,
              me,
              ae,
              K,
              ie,
              ue,
              oe,
              ne.q,
              se.C,
              ce.Kp,
              ce.Ny
            ],
            stores: [g, St, S, _],
            imports: [u.n, d.i, Et.I]
          })
        ],
        _t
      );
    },
    10430: (e, t, r) => {
      "use strict";
      r.d(t, { z: () => s });
      class s extends Error {
        constructor(e, t) {
          super(e), (this.code = t);
        }
      }
    },
    59550: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => g });
      var s = r(88802),
        a = r(60399),
        n = r(87065),
        i = r(53576),
        o = r(28489),
        c = r(87279),
        u = r(57924);
      function d(e) {
        const t = e.split("-");
        if (t.length > 0) {
          const [r] = t;
          return { accessKey: r, secretKey: e };
        }
        throw new Error("Invalid UKI format");
      }
      function l(e) {
        return (
          !!(e && "object" == typeof e && (0, o.l$)(e, "accessKey") && (0, o.l$)(e, "secretKey")) &&
          "string" == typeof e.accessKey &&
          "string" == typeof e.secretKey
        );
      }
      function p(e) {
        return "string" == typeof e;
      }
      const h = "authentication.currentUser.deviceKeys",
        m = "userSession.localSettings.uki",
        y = "userSession.account.login";
      let g = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        getDeviceCredentialsForUser(e) {
          const {
            queries: { carbonStateList: t }
          } = this.carbonLegacyClient;
          return (0, a.z)(
            t({ paths: [h, m, y] }).pipe(
              (0, n.U)((e) => {
                if ((0, c.hx)(e)) throw new Error("Failed to get credentials from carbon");
                return (0, c.db)(e);
              }),
              (0, n.U)(this.carbonStateToRequestUserDeviceCredentials(e))
            )
          );
        }
        getSessionCredentialsForUser(e) {
          const {
            queries: { carbonStateList: t }
          } = this.carbonLegacyClient;
          return (0, a.z)(
            t({ paths: [h, m, y, "userSession.session.sessionKeys"] }).pipe(
              (0, n.U)((e) => {
                if ((0, c.hx)(e)) throw new Error("Failed to get credentials from carbon");
                return (0, c.db)(e);
              }),
              (0, n.U)(this.carbonStateToRequestUserSessionCredentials(e))
            )
          );
        }
        carbonStateToRequestUserDeviceCredentials(e) {
          return ([t, r, s]) => {
            if ((!t && !r) || s !== e) throw new Error("No user device credentials available for active user");
            let a;
            if (r) {
              if (!p(r)) throw new Error("Unexpected UKI state shape received from carbon");
              a = d(r);
            } else {
              if (!l(t)) throw new Error("Unexpected user device state shape received from carbon");
              a = t;
            }
            return { login: e, deviceAccessKey: a.accessKey, deviceSecretKey: a.secretKey };
          };
        }
        carbonStateToRequestUserSessionCredentials(e) {
          return ([t, r, s, a]) => {
            if ((!t && !r) || s !== e) throw new Error("No user device credentials available for active user");
            if (!a) throw new Error("No session credentials available for active user");
            let n;
            if (r) {
              if (!p(r)) throw new Error("Unexpected UKI state shape received from carbon");
              n = d(r);
            } else {
              if (!l(t)) throw new Error("Unexpected user device state shape received from carbon");
              n = t;
            }
            if (
              !(
                (i = a) &&
                "object" == typeof i &&
                "accessKey" in i &&
                "secretKey" in i &&
                "expirationTimeSeconds" in i &&
                "string" == typeof i.accessKey &&
                "string" == typeof i.secretKey &&
                "number" == typeof i.expirationTimeSeconds
              )
            )
              throw new Error("Unexpected session keys state shape received from carbon");
            var i;
            return { login: e, deviceAccessKey: n.accessKey, sessionAccessKey: a.accessKey, sessionSecretKey: a.secretKey };
          };
        }
      };
      g = (0, s.__decorate)([(0, u.GS)(), (0, s.__metadata)("design:paramtypes", [i.CarbonLegacyClient])], g);
    },
    65871: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => o, V: () => c });
      var s = r(88802),
        a = r(56695),
        n = r.n(a),
        i = r(57924);
      let o = class {
        constructor(e) {
          this.sodium = e;
        }
        generateNonce() {
          return this.sodium.randombytes_buf(this.sodium.crypto_box_NONCEBYTES);
        }
        generateKeyPair() {
          return this.sodium.crypto_kx_keypair();
        }
        hash(e, t) {
          return this.sodium.crypto_generichash(this.sodium.crypto_secretbox_KEYBYTES, e, t);
        }
        compare(e, t) {
          return this.sodium.memcmp(e, t);
        }
        generateClientSharedSecret(e, t, r) {
          return this.sodium.crypto_kx_client_session_keys(e, t, r);
        }
        generateServerSharedSecret(e, t, r) {
          return this.sodium.crypto_kx_server_session_keys(e, t, r);
        }
        encrypt(e, t, r) {
          return this.sodium.crypto_secretbox_easy(e, t, r);
        }
        decrypt(e, t, r) {
          return this.sodium.crypto_secretbox_open_easy(e, t, r);
        }
      };
      function c() {
        return {
          token: o,
          asyncFactory: async () => {
            await n().ready;
            const e = n();
            return new o(e);
          }
        };
      }
      o = (0, s.__decorate)([(0, i.GS)(), (0, s.__metadata)("design:paramtypes", [Object])], o);
    },
    3786: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => ee });
      var s = r(88802),
        a = r(6218),
        n = r(99634),
        i = r(38679),
        o = r(1824),
        c = r(65871),
        u = r(26290),
        d = r(87065),
        l = r(25029),
        p = r(95681);
      const h = (e) => !0;
      class m extends (0, p.Q)({
        initialValue: void 0,
        persist: !1,
        scope: l.F.Device,
        storeName: "trusted-device-flow-machine",
        storeTypeGuard: h
      }) {}
      var y = r(64472),
        g = r(24966),
        v = r(57924),
        f = r(31948),
        w = r(5331),
        S = r(70486),
        E = r(87279),
        _ = r(16053);
      let b = class {
        constructor(e) {
          this.d2dAuthenticationService = e;
        }
        async execute() {
          const e = await this.d2dAuthenticationService.getKeyExchangeTransferInfo();
          if ((0, E.hx)(e)) throw new S.dJ("Error with getKeyExchangeTransferInfo", S.SA.GENERIC_ERROR);
          const { transfer: t } = e.data;
          return t
            ? Promise.resolve({
                transferId: t.transferId,
                requestTimestamp: t.receiver.requestedAtDateUnix,
                untrustedDeviceName: t.receiver.deviceName,
                untrustedDeviceLocation: `${t.receiver.city}, ${t.receiver.countryCode}`,
                untrustedDeviceHashedPublicKey: t.receiver.hashedPublicKey
              })
            : Promise.resolve({ transferId: void 0 });
        }
      };
      b = (0, s.__decorate)([(0, v.GS)(), (0, s.__metadata)("design:paramtypes", [_.C])], b);
      var T = r(15652),
        A = r(69605);
      let C = class {
        constructor(e, t, r) {
          (this.d2dCryptoService = e), (this.d2dAuthenticationService = t), (this.passphraseService = r);
        }
        async execute(e) {
          const { privateKey: t, publicKey: r } = this.d2dCryptoService.generateKeyPair(),
            s = await this.d2dAuthenticationService.startSenderKeyExchange(r);
          if ((0, E.hx)(s)) throw new S.dJ("Error with start sender key exchange", S.SA.GENERIC_ERROR);
          const { receiverPublicKey: a } = s.data,
            n = e.untrustedDeviceHashedPublicKey;
          if (!this.d2dCryptoService.verifyUntrustedDevicePublicKey(n, a))
            throw new S.dJ("Receiver public key doesn't match", S.SA.GENERIC_ERROR);
          const i = this.d2dCryptoService.generateSenderSharedSecret(r, t, a),
            o = await this.d2dAuthenticationService.getCurrentUserLogin();
          if ((0, E.hx)(o) || !o.data || !e.transferId) throw new S.dJ("No user login or transferId in context", S.SA.GENERIC_ERROR);
          const c = this.d2dCryptoService.generateVisualCheckSeed(o.data, e.transferId, i),
            { passphrase: u, missingWordIndex: d } = await this.passphraseService.generatePassphraseChallenge(c);
          return { sharedSecret: i, passphrase: u, passhraseMissingWordIndex: d };
        }
      };
      C = (0, s.__decorate)([(0, v.GS)(), (0, s.__metadata)("design:paramtypes", [T.q, _.C, A.Kp])], C);
      let R = class {
        constructor(e, t, r) {
          (this.passphraseService = e), (this.d2dCryptoService = t), (this.d2dAuthenticationService = r);
        }
        async execute(e) {
          if (!this.passphraseService.verifyChallenge(e.passphrase, e.passphraseGuess))
            throw new S.dJ("Passphrase incorrect", S.SA.INVALID_PASSPHRASE);
          const t = await this.d2dAuthenticationService.getCurrentUserLogin();
          if ((0, E.hx)(t) || !t.data || !e.transferId) throw new S.dJ("No user login or no transferId", S.SA.GENERIC_ERROR);
          const r = await this.d2dAuthenticationService.getUserInvisibleMasterPassword(),
            s = await this.d2dAuthenticationService.requestAuthTicket();
          if ((0, E.hx)(s)) throw new S.dJ("Couldn't get authTicket", S.SA.GENERIC_ERROR);
          const { encryptedData: a, nonce: n } = this.d2dCryptoService.encryptInvisibleMasterPassword(
              t.data,
              s.data,
              r,
              e.transferId,
              e.sharedSecret
            ),
            i = await this.d2dAuthenticationService.completeTransfer(a, n, e.transferId);
          if ((0, E.hx)(i)) throw new S.dJ("Error with completeTransfer", S.SA.GENERIC_ERROR);
          return Promise.resolve();
        }
      };
      R = (0, s.__decorate)([(0, v.GS)(), (0, s.__metadata)("design:paramtypes", [A.Kp, T.q, _.C])], R);
      let I = class {
        constructor(e, t, r) {
          (this.getPendingDeviceTransferRequestService = e),
            (this.approveDeviceTransferRequestService = t),
            (this.verifyPassphraseChallengeService = r);
        }
        create() {
          return (0, f.C)(
            {
              predictableActionArguments: !0,
              schema: { events: {}, context: {} },
              initial: "WaitingForNewDeviceTransferRequest",
              id: "TrustedDeviceFlowMachine",
              context: {
                transferId: void 0,
                untrustedDeviceName: "",
                untrustedDeviceHashedPublicKey: "",
                untrustedDeviceLocation: "",
                sharedSecret: "",
                passphrase: "",
                passphraseGuess: "",
                passphraseMissingWordIndex: -1
              },
              states: {
                Idle: { on: { REFRESH_REQUEST: { target: "WaitingForNewDeviceTransferRequest" } } },
                WaitingForNewDeviceTransferRequest: {
                  invoke: {
                    src: "getPendingDeviceTransferRequest",
                    onDone: [
                      {
                        actions: ["assignUntrustedDeviceData"],
                        cond: "isDeviceTransferRequestAvailable",
                        target: "NewDeviceTransferRequest"
                      },
                      { target: "Idle" }
                    ],
                    onError: { actions: ["assignTrustedDeviceFlowError"], target: "Idle" }
                  }
                },
                NewDeviceTransferRequest: {
                  on: { APPROVE_REQUEST: { target: "HandlingDeviceTransferRequest" }, REJECT_REQUEST: { target: "DeviceTransferRejected" } }
                },
                HandlingDeviceTransferRequest: {
                  invoke: {
                    src: "approveDeviceTransferRequest",
                    onDone: { actions: ["assignPassphraseChallengeData"], target: "DisplayPassphraseChallenge" },
                    onError: { actions: ["assignTrustedDeviceFlowError"], target: "TrustedDeviceFlowError" }
                  }
                },
                DisplayPassphraseChallenge: {
                  on: {
                    SUBMIT_PASSPHRASE_CHALLENGE: { actions: ["assignPassphraseGuess"], target: "VerifyingPassphraseChallenge" },
                    CANCEL_REQUEST: { actions: ["clearContext"], target: "Idle" }
                  }
                },
                VerifyingPassphraseChallenge: {
                  invoke: {
                    src: "verifyPassphraseChallenge",
                    onDone: { target: "DeviceTransferComplete" },
                    onError: { actions: ["assignTrustedDeviceFlowError"], target: "DisplayPassphraseChallenge" }
                  }
                },
                DeviceTransferComplete: { on: { RETURN_TO_DEVICE_SETUP: { actions: ["clearContext"], target: "Idle" } } },
                DeviceTransferRejected: { on: { RETURN_TO_DEVICE_SETUP: { actions: ["clearContext"], target: "Idle" } } },
                TrustedDeviceFlowError: { on: { CANCEL_REQUEST: { actions: ["clearContext"], target: "Idle" } } }
              }
            },
            {
              actions: {
                assignUntrustedDeviceData: (0, w.f0)({
                  transferId: (e, t) => t.data.transferId,
                  untrustedDeviceName: (e, t) => t.data.untrustedDeviceName,
                  untrustedDeviceHashedPublicKey: (e, t) => t.data.untrustedDeviceHashedPublicKey,
                  untrustedDeviceLocation: (e, t) => t.data.untrustedDeviceLocation,
                  requestTimestamp: (e, t) => t.data.requestTimestamp
                }),
                clearContext: (0, w.f0)({ transferId: () => {}, untrustedDeviceName: () => "", untrustedDeviceHashedPublicKey: () => "" }),
                assignTrustedDeviceFlowError: (0, w.f0)({ error: (e, t) => (t.data instanceof S.dJ ? t.data.code : S.SA.GENERIC_ERROR) }),
                assignPassphraseChallengeData: (0, w.f0)({
                  sharedSecret: (e, t) => t.data.sharedSecret,
                  passphrase: (e, t) => t.data.passphrase,
                  passphraseMissingWordIndex: (e, t) => t.data.passhraseMissingWordIndex
                }),
                assignPassphraseGuess: (0, w.f0)({ passphraseGuess: (e, t) => t.passphraseChallenge })
              },
              services: {
                getPendingDeviceTransferRequest: () => this.getPendingDeviceTransferRequestService.execute(),
                approveDeviceTransferRequest: (e) => this.approveDeviceTransferRequestService.execute(e),
                verifyPassphraseChallenge: (e) => this.verifyPassphraseChallengeService.execute(e)
              },
              guards: { isDeviceTransferRequestAvailable: (e, t) => !!t.data.transferId }
            }
          );
        }
      };
      I = (0, s.__decorate)([(0, v.GS)(), (0, s.__metadata)("design:paramtypes", [b, C, R])], I);
      let x = class {
        constructor(e, t) {
          this.trustedDeviceMachineStore = t;
          const r = e.create();
          this.interpreter = y.kJ(r).onTransition(async (e) => {
            e.changed ||
              "xstate.init" === e.event.type ||
              console.warn(
                `[D2D Trusted Device Flow] State is unchanged. Unexpected transition on ${JSON.stringify(e.value)} with event ${
                  e.event.type
                } `
              );
            try {
              const e = this.interpreter?.getSnapshot();
              e &&
                (await (async (e, t) => {
                  await e.set(JSON.stringify(t));
                })(this.trustedDeviceMachineStore, e));
            } catch (e) {
              console.warn("[D2D Trusted Device Flow] Unable to get snapshot", e);
            }
          });
        }
        async prepare() {
          if (this.interpreter)
            try {
              const e = await (async (e) => {
                const t = await e.getState();
                return t ? u.ZM.create(JSON.parse(t)) : void 0;
              })(this.trustedDeviceMachineStore);
              try {
                this.interpreter.start(e);
              } catch (e) {
                console.error("[D2D Trusted Device Flow] Unable to reuse the stored state: ", e), this.interpreter.start();
              }
            } catch (e) {
              console.error("[D2D Trusted Device Flow] Unable to start machine", e);
            }
        }
        ready() {
          return new g.X(!0);
        }
        continue(e) {
          if (!this.interpreter) throw new Error("TrustedDevice flow not started");
          this.interpreter.send(e);
        }
        stop() {
          this.isStarted() && (this.interpreter = void 0);
        }
        isStarted() {
          return Boolean(this.interpreter);
        }
      };
      x = (0, s.__decorate)([(0, v.GS)(), (0, s.__metadata)("design:paramtypes", [I, m])], x);
      var P = r(85390),
        D = r(30523),
        U = r(6136),
        F = r(20754),
        O = r(53835),
        N = r(69885),
        k = r(6220);
      const L = (e) =>
          (0, N.of)(
            (0, E.Vp)(
              (function (e) {
                if (e.matches("Idle") || e.matches("WaitingForNewDeviceTransferRequest")) return { step: S.Te.WaitingForNewDeviceRequest };
                if (e.matches("NewDeviceTransferRequest") || e.matches("HandlingDeviceTransferRequest"))
                  return {
                    step: S.Te.NewDeviceRequestAvailable,
                    untrustedDeviceName: e.context.untrustedDeviceName,
                    untrustedDeviceLocation: e.context.untrustedDeviceLocation,
                    requestTimestamp: e.context.requestTimestamp
                  };
                if (e.matches("DisplayPassphraseChallenge") || e.matches("VerifyingPassphraseChallenge")) {
                  const { passphrase: t, passphraseMissingWordIndex: r, untrustedDeviceName: s, error: a } = e.context,
                    n = t.split(A.iy).map((e, t) => (t === r ? "" : e));
                  return { step: S.Te.DisplayPassphraseChallenge, untrustedDeviceName: s, passphrase: n, error: a };
                }
                if (e.matches("DeviceTransferComplete"))
                  return { step: S.Te.DeviceTransferComplete, untrustedDeviceName: e.context.untrustedDeviceName };
                if (e.matches("DeviceTransferRejected"))
                  return { step: S.Te.DeviceTransferRejected, untrustedDeviceName: e.context.untrustedDeviceName };
                if (e.matches("TrustedDeviceFlowError")) return { step: S.Te.Error };
                throw new Error("[D2D Trusted Device] - No view associated to state");
              })(e)
            )
          ),
        M = (e) => e.pipe((0, k.z)(L));
      var V = r(69126);
      let G = class {
        constructor(e, t) {
          (this.trustedDeviceFlow = e), (this.trustedDeviceFlowMachineStore = t);
        }
        execute() {
          return (0, P.a)(
            [
              ((e = this.trustedDeviceFlowMachineStore), e.state$.pipe((0, d.U)((e) => (e ? u.ZM.create(JSON.parse(e)) : void 0)))),
              this.trustedDeviceFlow.ready()
            ],
            (e, t) => {
              if (e && t) return e;
            }
          ).pipe(
            (0, D.h)(Boolean),
            (0, U.x)((e, t) => (0, V.Ei)(e, t)),
            M
          );
          var e;
        }
      };
      G = (0, s.__decorate)([(0, F.e)(O.N), (0, s.__metadata)("design:paramtypes", [x, m])], G);
      var j = r(63663),
        q = r(87041);
      let K = class {
        constructor(e) {
          (this.trustedDeviceFlow = e), (this.trustedDeviceFlow = e);
        }
        execute() {
          return this.trustedDeviceFlow.continue({ type: "APPROVE_REQUEST" }), Promise.resolve((0, E.Vp)(void 0));
        }
      };
      K = (0, s.__decorate)([(0, j.W)(q.G), (0, s.__metadata)("design:paramtypes", [x])], K);
      var W = r(33969);
      let B = class {
        constructor(e) {
          (this.trustedDeviceFlow = e), (this.trustedDeviceFlow = e);
        }
        execute() {
          return this.trustedDeviceFlow.continue({ type: "REFRESH_REQUEST" }), Promise.resolve((0, E.Vp)(void 0));
        }
      };
      B = (0, s.__decorate)([(0, j.W)(W.V), (0, s.__metadata)("design:paramtypes", [x])], B);
      var z = r(55870);
      let H = class {
        constructor(e) {
          (this.trustedDeviceFlow = e), (this.trustedDeviceFlow = e);
        }
        execute() {
          return this.trustedDeviceFlow.continue({ type: "REJECT_REQUEST" }), Promise.resolve((0, E.Vp)(void 0));
        }
      };
      H = (0, s.__decorate)([(0, j.W)(z.a), (0, s.__metadata)("design:paramtypes", [x])], H);
      var $ = r(97891);
      let Q = class {
        constructor(e) {
          (this.trustedDeviceFlow = e), (this.trustedDeviceFlow = e);
        }
        execute() {
          return this.trustedDeviceFlow.continue({ type: "CANCEL_REQUEST" }), Promise.resolve((0, E.Vp)(void 0));
        }
      };
      Q = (0, s.__decorate)([(0, j.W)($.b), (0, s.__metadata)("design:paramtypes", [x])], Q);
      var Y = r(48214);
      let X = class {
        constructor(e) {
          (this.trustedDeviceFlow = e), (this.trustedDeviceFlow = e);
        }
        execute(e) {
          const { passphraseChallenge: t } = e.body;
          return (
            this.trustedDeviceFlow.continue({ type: "SUBMIT_PASSPHRASE_CHALLENGE", passphraseChallenge: t }),
            Promise.resolve((0, E.Vp)(void 0))
          );
        }
      };
      X = (0, s.__decorate)([(0, j.W)(Y.I), (0, s.__metadata)("design:paramtypes", [x])], X);
      var J = r(81540);
      let Z = class {
        constructor(e) {
          (this.trustedDeviceFlow = e), (this.trustedDeviceFlow = e);
        }
        execute() {
          return this.trustedDeviceFlow.continue({ type: "RETURN_TO_DEVICE_SETUP" }), Promise.resolve((0, E.Vp)(void 0));
        }
      };
      Z = (0, s.__decorate)([(0, j.W)(J.n), (0, s.__metadata)("design:paramtypes", [x])], Z);
      let ee = class {};
      ee = (0, s.__decorate)(
        [
          (0, n.Y)({
            api: a.F,
            stores: [m],
            imports: [o.n],
            exports: [T.q, c.E],
            providers: [
              (0, c.V)(),
              ...(0, i.H)(x, {
                inject: [I, m],
                asyncFactory: async (e, t) => {
                  const r = new x(e, t);
                  return await r.prepare(), r;
                }
              }),
              c.E,
              A.Kp,
              T.q,
              _.C,
              b,
              C,
              R,
              I,
              A.Ny
            ],
            handlers: {
              commands: {
                approveRequest: K,
                refreshRequest: B,
                rejectRequest: H,
                cancelRequest: Q,
                submitPassphraseChallenge: X,
                returnToDeviceSetup: Z
              },
              events: {},
              queries: { trustedDeviceFlowStatus: G }
            }
          })
        ],
        ee
      );
    },
    16053: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => v });
      var s = r(88802),
        a = r(60399),
        n = r(10551),
        i = r(53576),
        o = r(61501),
        c = r(57924),
        u = r(48844),
        d = r(87279),
        l = r(18533),
        p = r(20195),
        h = r(89358),
        m = r(95109),
        y = r(69126),
        g = r(10430);
      let v = class {
        constructor(e, t, r) {
          (this.serverApiClient = e), (this.sessionClient = t), (this.carbon = r);
        }
        async getCurrentUserLogin() {
          return await (0, a.z)(
            this.sessionClient.queries.selectedOpenedSession().pipe(
              (0, u.DZ)(() => (0, d.Rn)(new Error("No user login found"))),
              (0, u.lk)((e) => (0, d.Vp)(e))
            )
          );
        }
        getUserInvisibleMasterPassword() {
          const { carbonState: e } = this.carbon.queries;
          return (0, a.z)(
            e({ path: "userSession.session.masterPassword" }).pipe(
              (0, u.nb)({
                success: (e) => e,
                failure: () => {
                  throw new Error("Failure getting user invisible master password info");
                }
              })
            )
          );
        }
        async requestAuthTicket() {
          return await (0, a.z)(
            this.serverApiClient.v1.authentication.requestExtraDeviceRegistration({ tokenType: "googleAccountNewDevice" }).pipe(
              (0, u.DZ)((e) =>
                (0, l.EQ)(e, {
                  BusinessError: () => (0, d.Rn)(e),
                  FetchFailedError: () => (0, d.Rn)(e),
                  UnspecifiedBadStatus: () => (0, d.Rn)(e),
                  InternalServerError: p.j,
                  InvalidRequest: p.j,
                  RateLimited: p.j,
                  ServiceUnavailable: p.j
                })
              ),
              (0, u.lk)((e) => (0, d.Vp)(e.data.token))
            )
          );
        }
        async getKeyExchangeTransferInfo() {
          return await (0, a.z)(
            this.serverApiClient.v1.secretTransfer.getKeyExchangeTransferInfo({}).pipe(
              (0, u.DZ)((e) =>
                (0, l.EQ)(e, {
                  BusinessError: () => (0, d.Rn)(e),
                  FetchFailedError: () => (0, d.Rn)(e),
                  UnspecifiedBadStatus: () => (0, d.Rn)(e),
                  InternalServerError: p.j,
                  InvalidRequest: p.j,
                  RateLimited: p.j,
                  ServiceUnavailable: p.j
                })
              ),
              (0, u.lk)((e) => (0, d.Vp)(e.data))
            )
          );
        }
        async startReceiverKeyExchange(e, t) {
          return await (0, a.z)(
            this.serverApiClient.v1.secretTransfer.startReceiverKeyExchange({ transferId: e, receiverHashedPublicKey: t }).pipe(
              (0, u.DZ)((e) =>
                (0, l.EQ)(e, {
                  BusinessError: () => (0, d.Rn)(e),
                  FetchFailedError: () => (0, d.Rn)(e),
                  UnspecifiedBadStatus: () => (0, d.Rn)(e),
                  InternalServerError: p.j,
                  InvalidRequest: p.j,
                  RateLimited: p.j,
                  ServiceUnavailable: p.j
                })
              ),
              (0, u.lk)((e) => (0, d.Vp)(e.data))
            )
          );
        }
        async completeKeyExchange(e, t) {
          return await (0, a.z)(
            this.serverApiClient.v1.secretTransfer.completeKeyExchange({ receiverPublicKey: t, transferId: e }).pipe(
              (0, u.DZ)((e) =>
                (0, l.EQ)(e, {
                  BusinessError: () => (0, d.Rn)(e),
                  FetchFailedError: () => (0, d.Rn)(e),
                  UnspecifiedBadStatus: () => (0, d.Rn)(e),
                  InternalServerError: p.j,
                  InvalidRequest: p.j,
                  RateLimited: p.j,
                  ServiceUnavailable: p.j
                })
              ),
              (0, u.lk)((e) => (0, d.Vp)(e.data))
            )
          );
        }
        async startTransfer(e) {
          return await (0, a.z)(
            this.serverApiClient.v1.secretTransfer.startTransfer({ transferId: e, transferType: "universal" }).pipe(
              (0, u.DZ)((e) =>
                (0, l.EQ)(e, {
                  BusinessError: () => (0, d.Rn)(e),
                  FetchFailedError: () => (0, d.Rn)(e),
                  UnspecifiedBadStatus: () => (0, d.Rn)(e),
                  InternalServerError: p.j,
                  InvalidRequest: p.j,
                  RateLimited: p.j,
                  ServiceUnavailable: p.j
                })
              ),
              (0, u.lk)((e) => (0, d.Vp)(e.data))
            )
          );
        }
        async requestTransfer(e, t) {
          return await (0, a.z)(
            this.serverApiClient.v1.secretTransfer
              .requestTransfer({ transfer: { login: e, receiverDeviceName: t, transferType: "universal" } })
              .pipe(
                (0, u.DZ)((e) =>
                  (0, l.EQ)(e, {
                    BusinessError: () => {
                      throw new Error("[D2D]: Business Error");
                    },
                    FetchFailedError: () => {
                      throw new Error("[D2D]: Network error");
                    },
                    UnspecifiedBadStatus: p.j,
                    InternalServerError: p.j,
                    InvalidRequest: p.j,
                    RateLimited: p.j,
                    ServiceUnavailable: p.j
                  })
                ),
                (0, u.lk)((e) => (0, d.Vp)(e.data))
              )
          );
        }
        async startSenderKeyExchange(e) {
          return await (0, a.z)(
            this.serverApiClient.v1.secretTransfer.startSenderKeyExchange({ senderPublicKey: e }).pipe(
              (0, u.DZ)((e) =>
                (0, l.EQ)(e, {
                  BusinessError: () => {
                    throw new Error("[D2D]: Business Error");
                  },
                  FetchFailedError: () => {
                    throw new Error("[D2D]: Network error");
                  },
                  UnspecifiedBadStatus: p.j,
                  InternalServerError: p.j,
                  InvalidRequest: p.j,
                  RateLimited: p.j,
                  ServiceUnavailable: p.j
                })
              ),
              (0, u.lk)((e) => (0, d.Vp)(e.data))
            )
          );
        }
        async completeTransfer(e, t, r) {
          return await (0, a.z)(
            this.serverApiClient.v1.secretTransfer
              .completeTransfer({ transfer: { encryptedData: e, nonce: t, transferId: r, transferType: "universal" } })
              .pipe(
                (0, u.DZ)((e) =>
                  (0, l.EQ)(e, {
                    BusinessError: () => {
                      throw new Error("[D2D]: Business Error");
                    },
                    FetchFailedError: () => {
                      throw new Error("[D2D]: Network error");
                    },
                    UnspecifiedBadStatus: p.j,
                    InternalServerError: p.j,
                    InvalidRequest: p.j,
                    RateLimited: p.j,
                    ServiceUnavailable: p.j
                  })
                ),
                (0, u.lk)((e) => (0, d.Vp)(e.data))
              )
          );
        }
        async openSession(e, t, r, s) {
          const o = await (0, a.z)(this.serverApiClient.v1.authentication.performExtraDeviceVerification({ login: e, token: t }));
          if (!(0, d.d6)(o)) throw new g.z("Perform extra device verification failed", m.UY.ACCOUNT_ERROR);
          const { authTicket: c } = o.data.data,
            u = await (0, a.z)(this.carbon.queries.getPlatformInfo());
          if (!(0, d.d6)(u)) throw new g.z("No platform info available", m.UY.ACCOUNT_ERROR);
          const l = u.data,
            p = {
              deviceName: (0, y.$f)(s || n.getDefaultDeviceName()),
              appVersion: l.appVersion,
              platform: l.platformName,
              osCountry: (0, y.Yb)(l.country),
              osLanguage: (0, y._$)(l.lang),
              temporary: !1
            },
            h = await (0, a.z)(
              this.serverApiClient.v1.authentication.completeDeviceRegistrationWithAuthTicket({ authTicket: c, login: e, device: p })
            );
          if (!(0, d.d6)(h)) throw new g.z("Device registration with authTicket failed", m.UY.ACCOUNT_ERROR);
          const {
            deviceAccessKey: v,
            deviceAnalyticsId: f,
            deviceSecretKey: w,
            settings: S,
            serverKey: E,
            publicUserId: _,
            userAnalyticsId: b
          } = h.data.data;
          await this.carbon.commands.registerDevice({
            deviceAccessKey: v,
            deviceAnalyticsId: f,
            deviceSecretKey: w,
            settings: S,
            serverKey: E,
            publicUserId: _,
            userAnalyticsId: b,
            isDataPersisted: i.PersistData.PERSIST_DATA_YES
          });
          const T = await this.carbon.commands.carbonLegacyLeeloo({
            name: "openSessionWithMasterPassword",
            arg: [{ login: e, password: r, rememberPassword: !0, requiredPermissions: void 0, serverKey: "" }]
          });
          if (!(0, d.d6)(T)) throw new g.z("Open session with deciphered password failed", m.UY.ACCOUNT_ERROR);
        }
      };
      v = (0, s.__decorate)([(0, c.GS)(), (0, s.__metadata)("design:paramtypes", [o.l, h.x, i.CarbonLegacyClient])], v);
    },
    15652: (e, t, r) => {
      "use strict";
      r.d(t, { q: () => c });
      var s = r(88802),
        a = r(10370),
        n = r(57924),
        i = r(65871),
        o = r(69126);
      let c = class {
        constructor(e) {
          this.cryptoToolboxService = e;
        }
        verifyUntrustedDevicePublicKey(e, t) {
          return this.cryptoToolboxService.compare((0, o.tp)(e), (0, o.tp)(this.hash(t)));
        }
        generateReceiverSharedSecret(e, t, r) {
          return (0, a.s)(this.cryptoToolboxService.generateClientSharedSecret((0, o.tp)(e), (0, o.tp)(t), (0, o.tp)(r)).sharedRx);
        }
        generateSenderSharedSecret(e, t, r) {
          return (0, a.s)(this.cryptoToolboxService.generateServerSharedSecret((0, o.tp)(e), (0, o.tp)(t), (0, o.tp)(r)).sharedTx);
        }
        generateSymmetricKey(e, t, r) {
          return (0, a.s)(this.cryptoToolboxService.hash(`DASHLANE_D2D_SYMMETRIC_KEY${e.length}${e}${t}`, (0, o.tp)(r)));
        }
        hash(e) {
          return (0, a.s)(this.cryptoToolboxService.hash(e));
        }
        generateKeyPair() {
          const e = this.cryptoToolboxService.generateKeyPair();
          return { publicKey: (0, a.s)(e.publicKey), privateKey: (0, a.s)(e.privateKey) };
        }
        generateVisualCheckSeed(e, t, r) {
          return (0, a.s)(this.cryptoToolboxService.hash(`DASHLANE_D2D_SAS_SEED${e.length}${e}${t}`, (0, o.tp)(r)));
        }
        encryptInvisibleMasterPassword(e, t, r, s, n) {
          const i = ((e) => new TextEncoder().encode(JSON.stringify(e)))({
              login: e,
              key: { type: "invisible_master_password", value: r },
              token: t,
              version: 1
            }),
            c = this.generateSymmetricKey(e, s, n),
            u = this.cryptoToolboxService.generateNonce(),
            d = this.cryptoToolboxService.encrypt(i, u, (0, o.tp)(c));
          return { encryptedData: (0, a.s)(d), nonce: (0, a.s)(u) };
        }
        decryptInvisibleMasterPassword(e, t, r) {
          const s = this.cryptoToolboxService.decrypt((0, o.tp)(e), (0, o.tp)(t), (0, o.tp)(r)),
            a = new TextDecoder("utf-8").decode(s);
          return JSON.parse(a);
        }
      };
      c = (0, s.__decorate)([(0, n.GS)(), (0, s.__metadata)("design:paramtypes", [i.E])], c);
    },
    69605: (e, t, r) => {
      "use strict";
      r.d(t, { Kp: () => l, Ny: () => d, iy: () => c });
      var s = r(88802),
        a = r(67978),
        n = r(57924),
        i = r(75994),
        o = r(69126);
      const c = " ",
        u = Math.pow(2, 32) - 1;
      let d = class extends a.K {
        constructor(e) {
          super("assets/eff_large_wordlist.json", e);
        }
        loadResource(e) {
          if (!e || !Array.isArray(e)) throw new Error("Failed to load word list");
          return e;
        }
      };
      d = (0, s.__decorate)([(0, n.GS)(), (0, s.__metadata)("design:paramtypes", [i.X])], d);
      let l = class {
        constructor(e) {
          this.fetcher = e;
        }
        getWordList() {
          return this.fetcher.get();
        }
        async generatePassphraseChallenge(e) {
          const t = await this.getWordList(),
            r = [],
            s = Math.floor(u / t.length) * t.length;
          for (let a = 0; a < e.length; a += 4) {
            const { buffer: n, byteOffset: i } = new Uint8Array((0, o.tp)(e).slice(a, a + 4)),
              c = new DataView(n).getUint32(i, !0);
            if (c < s) {
              const e = t[c % t.length];
              r.push(e);
            }
            if (5 === r.length) break;
          }
          return { passphrase: r.join(c), missingWordIndex: Math.floor(5 * Math.random()) };
        }
        verifyChallenge(e, t) {
          if (!e) throw new Error("[DEVICE-TRANSFER]: Passphrase challenge not generated yet");
          if (!t) throw new Error("[DEVICE-TRANSFER]: Passphrase guess not saved to machine context");
          return e === t;
        }
      };
      l = (0, s.__decorate)([(0, n.GS)(), (0, s.__metadata)("design:paramtypes", [d])], l);
    },
    69126: (e, t, r) => {
      "use strict";
      r.d(t, { $f: () => l, Ei: () => n, Yb: () => c, _$: () => d, tp: () => i });
      var s = r(30045),
        a = r(66122);
      const n = (e, t) => {
          const r = t.matches(e.value),
            a = (0, s.Z)(e.context, t.context);
          return r && a;
        },
        i = (e) => new Uint8Array((0, a.R)(e)),
        o = "ZZ";
      function c(e) {
        return !e || e.length < 2 || e.length > 5 ? o : e;
      }
      const u = "und";
      function d(e) {
        return !e || e.length < 2 || e.length > 5 ? u : e;
      }
      function l(e) {
        return e ? e.replace(/https?:\/\//g, " ") : e;
      }
    },
    99600: (e, t, r) => {
      "use strict";
      r.d(t, { f: () => Pe });
      var s,
        a,
        n,
        i,
        o,
        c = r(88802),
        u = r(99634),
        d = r(38679),
        l = r(1824),
        p = r(11433),
        h = r(57924),
        m = r(5331),
        y = r(31948),
        g = r(87279),
        v = r(60399),
        f = r(61501),
        w = r(48844),
        S = r(18533),
        E = r(95087),
        _ = r(20195),
        b = r(96168);
      !(function (e) {
        (e.VERIFICATION_FAILED = "verification_failed"),
          (e.VERIFICATION_TIMEOUT = "verification_timeout"),
          (e.VERIFICATION_REQUIRES_REQUEST = "verification_requires_request"),
          (e.ACCOUNT_BLOCKED_CONTACT_SUPPORT = "account_blocked_contact_support"),
          (e.INVALID_OTP_ALREADY_USED = "invalid_otp_already_used"),
          (e.INVALID_OTP_BLOCKED = "invalid_otp_blocked");
      })(s || (s = {}));
      class T extends (0, b.Hu)(s.VERIFICATION_FAILED, "") {}
      class A extends (0, b.Hu)(s.VERIFICATION_TIMEOUT, "") {}
      class C extends (0, b.Hu)(s.VERIFICATION_REQUIRES_REQUEST, "") {}
      class R extends (0, b.Hu)(s.ACCOUNT_BLOCKED_CONTACT_SUPPORT, "") {}
      class I extends (0, b.Hu)(s.INVALID_OTP_ALREADY_USED, "") {}
      class x extends (0, b.Hu)(s.INVALID_OTP_BLOCKED, "") {}
      class P extends (0, b.Hu)("network_error", "") {}
      !(function (e) {
        (e.TOKEN_NOT_VALID = "TOKEN_NOT_VALID"),
          (e.TOKEN_EXPIRED = "TOKEN_EXPIRED"),
          (e.TOKEN_TOO_MANY_ATTEMPTS = "TOKEN_TOO_MANY_ATTEMPTS"),
          (e.TOKEN_ACCOUNT_LOCKED = "TOKEN_ACCOUNT_LOCKED");
      })(a || (a = {})),
        (function (e) {
          (e.OTP_NOT_VALID = "OTP_NOT_VALID"),
            (e.OTP_TOO_MANY_ATTEMPTS = "OTP_TOO_MANY_ATTEMPTS"),
            (e.OTP_ALREADY_USED = "OTP_ALREADY_USED"),
            (e.BACKUP_CODE_NOT_VALID = "BACKUP_CODE_NOT_VALID");
        })(n || (n = {})),
        (function (e) {
          (e.DASHLANE_AUTHENTICATOR_PUSH_NOTIFICATION_DENIED = "DASHLANE_AUTHENTICATOR_PUSH_NOTIFICATION_DENIED"),
            (e.TOKEN_EXPIRED = "TOKEN_EXPIRED");
        })(i || (i = {})),
        (function (e) {
          (e.NETWORK_ERROR = "NETWORK_ERROR"), (e.UNKNOWN_ERROR = "UNKNOWN_ERROR");
        })(o || (o = {}));
      let D = class {
        constructor(e) {
          this.serverApiClient = e;
        }
        async performEmailTokenVerification(e, t) {
          return await (0, v.z)(
            this.serverApiClient.v1.authentication.performEmailTokenVerification({ login: e, token: t }).pipe(
              (0, w.DZ)((e) =>
                (0, S.EQ)(e, {
                  BusinessError: (e) => {
                    switch (e.code) {
                      case s.VERIFICATION_FAILED:
                        return new T();
                      case s.VERIFICATION_TIMEOUT:
                        return new A();
                      case s.VERIFICATION_REQUIRES_REQUEST:
                        return new C();
                      case s.ACCOUNT_BLOCKED_CONTACT_SUPPORT:
                        return new R();
                      default:
                        (0, E.U)(e.code);
                    }
                  },
                  FetchFailedError: () => new P(),
                  UnspecifiedBadStatus: _.j,
                  InternalServerError: _.j,
                  InvalidRequest: _.j,
                  RateLimited: _.j,
                  ServiceUnavailable: _.j
                })
              ),
              (0, w.lk)((e) => (0, g.Vp)(e.data.authTicket))
            )
          );
        }
        async performTotpVerification(e, t) {
          return await (0, v.z)(
            this.serverApiClient.v1.authentication.performTotpVerification({ login: e, otp: t }).pipe(
              (0, w.DZ)((e) =>
                (0, S.EQ)(e, {
                  BusinessError: (e) => {
                    switch (e.code) {
                      case s.VERIFICATION_FAILED:
                        return new T();
                      case s.INVALID_OTP_ALREADY_USED:
                        return new I();
                      case s.INVALID_OTP_BLOCKED:
                        return new x();
                      default:
                        (0, E.U)(e.code);
                    }
                  },
                  FetchFailedError: () => new P(),
                  UnspecifiedBadStatus: _.j,
                  InternalServerError: _.j,
                  InvalidRequest: _.j,
                  RateLimited: _.j,
                  ServiceUnavailable: _.j
                })
              ),
              (0, w.lk)((e) => (0, g.Vp)(e.data.authTicket))
            )
          );
        }
        async performDashlaneAuthenticatorValidation(e, t) {
          return await (0, v.z)(
            this.serverApiClient.v1.authentication.performDashlaneAuthenticatorVerification({ login: e, deviceName: t }).pipe(
              (0, w.DZ)((e) =>
                (0, S.EQ)(e, {
                  BusinessError: (e) => {
                    switch (e.code) {
                      case s.VERIFICATION_FAILED:
                        return new T();
                      case s.VERIFICATION_TIMEOUT:
                        return new A();
                      default:
                        (0, E.U)(e.code);
                    }
                  },
                  FetchFailedError: () => new P(),
                  UnspecifiedBadStatus: _.j,
                  InternalServerError: _.j,
                  InvalidRequest: _.j,
                  RateLimited: _.j,
                  ServiceUnavailable: _.j
                })
              ),
              (0, w.lk)((e) => (0, g.Vp)(e.data.authTicket))
            )
          );
        }
        async askServerToSendToken(e) {
          return await (0, v.z)(
            this.serverApiClient.v1.authentication.requestEmailTokenVerification({ login: e }).pipe(
              (0, w.DZ)((e) => {
                throw e;
              }),
              (0, w.lk)(() => (0, g.Vp)(void 0))
            )
          );
        }
      };
      D = (0, c.__decorate)([(0, h.GS)(), (0, c.__metadata)("design:paramtypes", [f.l])], D);
      let U = class {
        constructor(e) {
          (this.identityVerificationService = e), (this.identityVerificationService = e);
        }
        async execute({ login: e }) {
          if (e) {
            const t = await this.identityVerificationService.askServerToSendToken(e);
            if ((0, g.hx)(t)) return Promise.reject(t.error);
          }
          Promise.resolve(void 0);
        }
      };
      U = (0, c.__decorate)([(0, h.GS)(), (0, c.__metadata)("design:paramtypes", [D])], U);
      var F = r(81459);
      let O = class extends F.f {};
      O = (0, c.__decorate)([(0, h.GS)()], O);
      let N = class {
        constructor(e, t) {
          (this.identityVerificationService = e), (this.eventEmitter = t);
        }
        mapFunctionalErrorToErrorCode(e) {
          switch (e.tag) {
            case s.VERIFICATION_FAILED:
              return i.DASHLANE_AUTHENTICATOR_PUSH_NOTIFICATION_DENIED;
            case s.VERIFICATION_TIMEOUT:
              return i.TOKEN_EXPIRED;
            default:
              return o.UNKNOWN_ERROR;
          }
        }
        async execute({ login: e }) {
          if (!e) throw new Error("Something went wrong");
          const t = await this.identityVerificationService.performDashlaneAuthenticatorValidation(e, "");
          if ((0, g.hx)(t)) {
            const e = this.mapFunctionalErrorToErrorCode(t.error);
            return Promise.reject(e);
          }
          return this.eventEmitter.sendEvent("identityVerificationCompleted", { authTicket: t.data }), Promise.resolve();
        }
      };
      N = (0, c.__decorate)([(0, h.GS)(), (0, c.__metadata)("design:paramtypes", [D, O])], N);
      let k = class {
        constructor(e, t) {
          (this.dashlaneAuthenticatorService = e), (this.sendEmailToken = t);
        }
        desc() {
          return {
            config: {
              predictableActionArguments: !0,
              schema: { events: {}, context: {} },
              id: "AuthenticatorMachine",
              context: { isDashlaneAuthenticatorAvailable: !1 },
              initial: "RequestingServerPush",
              states: {
                RequestingServerPush: {
                  entry: ["updateDashlaneAuthenticatorAvailability"],
                  invoke: {
                    src: "authenticateWithDashlaneAuthenticator",
                    onDone: { target: "AuthenticatorPushValidated" },
                    onError: { actions: ["assignError", "updateDashlaneAuthenticatorAvailability"] }
                  },
                  on: {
                    RESEND_PUSH_NOTIFICATION: { target: "RequestingServerPush", actions: ["clearError"] },
                    SWITCH_TO_EMAIL_TOKEN: { actions: ["clearError"], target: "EmailTokenRequested" }
                  }
                },
                AuthenticatorPushValidated: { type: "final", data: { switchToEmailToken: !1 } },
                EmailTokenRequested: { entry: ["sendEmailToken"], type: "final", data: { switchToEmailToken: !0 } }
              }
            },
            options: {
              actions: {
                clearError: (0, m.f0)({ error: () => {} }),
                assignError: (0, m.f0)({ error: (e, t) => t.data }),
                switchToEmailToken: (0, m.f0)({ switchToEmailToken: () => !0 }),
                updateDashlaneAuthenticatorAvailability: (0, m.f0)({ isDashlaneAuthenticatorAvailable: !0 }),
                sendEmailToken: (e) => {
                  const { login: t } = e;
                  this.sendEmailToken.execute({ login: t });
                }
              },
              services: {
                authenticateWithDashlaneAuthenticator: (e) => {
                  const { login: t } = e;
                  return this.dashlaneAuthenticatorService.execute({ login: t });
                }
              },
              guards: {}
            }
          };
        }
        create() {
          const { config: e, options: t } = this.desc();
          return (0, y.C)(e, t);
        }
      };
      k = (0, c.__decorate)([(0, h.GS)(), (0, c.__metadata)("design:paramtypes", [N, U])], k);
      const L = /^\d{6}$/;
      let M = class {
        constructor(e, t) {
          (this.identityVerificationService = e), (this.eventEmitter = t);
        }
        mapFunctionalErrorToErrorCode(e) {
          switch (e.tag) {
            case s.VERIFICATION_FAILED:
              return a.TOKEN_NOT_VALID;
            case s.VERIFICATION_TIMEOUT:
              return a.TOKEN_EXPIRED;
            case s.VERIFICATION_REQUIRES_REQUEST:
              return a.TOKEN_TOO_MANY_ATTEMPTS;
            case s.ACCOUNT_BLOCKED_CONTACT_SUPPORT:
              return a.TOKEN_ACCOUNT_LOCKED;
            default:
              return o.UNKNOWN_ERROR;
          }
        }
        async executeWithParams(e) {
          if (!e.login || !e.emailToken || 0 === e.emailToken.length || !L.test(e.emailToken)) return Promise.reject(o.UNKNOWN_ERROR);
          const t = await this.identityVerificationService.performEmailTokenVerification(e.login, e.emailToken);
          if ((0, g.hx)(t)) {
            const e = this.mapFunctionalErrorToErrorCode(t.error);
            return Promise.reject(e);
          }
          const r = t.data;
          return this.eventEmitter.sendEvent("identityVerificationCompleted", { authTicket: r }), Promise.resolve();
        }
      };
      M = (0, c.__decorate)([(0, h.GS)(), (0, c.__metadata)("design:paramtypes", [D, O])], M);
      let V = class {
        constructor(e, t) {
          (this.authenticateWithEmailToken = e), (this.sendEmailToken = t);
        }
        desc() {
          return {
            config: {
              predictableActionArguments: !0,
              schema: { events: {}, context: {} },
              id: "EmailTokenMachine",
              context: { login: "", emailToken: "", deviceName: "" },
              initial: "SendEmailToken",
              states: {
                SendEmailToken: {
                  invoke: { src: "sendEmailToken", onError: { target: "WaitingForEmailToken" }, onDone: { target: "WaitingForEmailToken" } }
                },
                WaitingForEmailToken: {
                  on: {
                    INPUT_EMAIL_TOKEN: { target: "ValidatingEmailToken", actions: ["assignEmailToken"] },
                    RESEND_EMAIL_TOKEN: { target: "SendEmailToken", actions: ["clearError"] }
                  }
                },
                ValidatingEmailToken: {
                  invoke: {
                    src: "authenticateWithEmailToken",
                    onDone: { target: "FinishingEmailToken" },
                    onError: { target: "WaitingForEmailToken", actions: ["assignError"] }
                  }
                },
                FinishingEmailToken: { type: "final", data: { switchToDashlaneAuthenticator: !1 } },
                DashlaneAuthenticatorRequested: { type: "final", data: { switchToDashlaneAuthenticator: !0 } }
              },
              on: { SWITCH_TO_DASHLANE_AUTHENTICATOR: { target: ".DashlaneAuthenticatorRequested", internal: !0, actions: ["clearError"] } }
            },
            options: {
              actions: {
                assignError: (0, m.f0)({ error: (e, t) => t.data }),
                clearError: (0, m.f0)({ error: () => {} }),
                assignEmailToken: (0, m.f0)({ emailToken: (e, t) => t.emailToken })
              },
              services: {
                sendEmailToken: (e) => {
                  const { login: t } = e;
                  return this.sendEmailToken.execute({ login: t });
                },
                authenticateWithEmailToken: (e) => {
                  const { deviceName: t, emailToken: r, login: s } = e;
                  return this.authenticateWithEmailToken.executeWithParams({ deviceName: t, emailToken: r, login: s });
                }
              },
              guards: {}
            }
          };
        }
        create() {
          const { config: e, options: t } = this.desc();
          return (0, y.C)(e, t);
        }
      };
      V = (0, c.__decorate)([(0, h.GS)(), (0, c.__metadata)("design:paramtypes", [M, U])], V);
      const G = (e) => ({ initial: e.initial, states: e.states, on: e.on ?? {} });
      let j = class {
        constructor(e, t) {
          (this.authenticatorMachine = e), (this.emailTokenMachine = t);
        }
        desc() {
          return {
            config: {
              predictableActionArguments: !0,
              schema: { events: {}, context: {}, guards: {} },
              id: "DeviceRegistrationMachine",
              context: {
                ...this.authenticatorMachine.desc().config.context,
                ...this.emailTokenMachine.desc().config.context,
                registrationMethod: void 0
              },
              initial: "StartDeviceRegistration",
              states: {
                StartDeviceRegistration: {
                  always: [
                    { target: "EmailToken", cond: "isRegistrationMethodEmailToken" },
                    { target: "DashlaneAuthenticator", cond: "isRegistrationMethodAuthenticator" },
                    { target: "TwoFactorAuthentication", cond: "isRegistrationMethodOTP" }
                  ]
                },
                DashlaneAuthenticator: {
                  ...G(this.authenticatorMachine.desc().config),
                  onDone: [{ target: "EmailToken", cond: "shouldSwitchToEmailToken" }, { target: "DeviceRegistrationDone" }]
                },
                EmailToken: {
                  ...G(this.emailTokenMachine.desc().config),
                  onDone: [{ target: "DashlaneAuthenticator", cond: "shouldSwitchToAuthenticator" }, { target: "DeviceRegistrationDone" }]
                },
                TwoFactorAuthentication: { onDone: { target: "DeviceRegistrationDone" } },
                DeviceRegistrationDone: { type: "final" }
              }
            },
            options: {
              actions: {
                ...this.authenticatorMachine.desc().options.actions,
                ...this.emailTokenMachine.desc().options.actions,
                assignUnknownDeviceRegistrationError: (0, m.f0)({
                  error: () => ({ code: "unknown_error", data: { message: "Unknown device registration error" } })
                })
              },
              services: { ...this.authenticatorMachine.desc().options.services, ...this.emailTokenMachine.desc().options.services },
              guards: {
                ...this.authenticatorMachine.desc().options.guards,
                ...this.emailTokenMachine.desc().options.guards,
                isRegistrationMethodEmailToken: (e) => "email_token" === e.registrationMethod,
                isRegistrationMethodOTP: (e) => "otp" === e.registrationMethod,
                isRegistrationMethodAuthenticator: (e) => "dashlane_authenticator" === e.registrationMethod,
                shouldSwitchToEmailToken: (e, t) => t.data.switchToEmailToken,
                shouldSwitchToAuthenticator: (e, t) => t.data.switchToDashlaneAuthenticator
              }
            }
          };
        }
        create() {
          const { config: e, options: t } = this.desc();
          return (0, y.C)(e, t);
        }
      };
      j = (0, c.__decorate)([(0, h.GS)(), (0, c.__metadata)("design:paramtypes", [k, V])], j);
      var q = r(25029),
        K = r(95681);
      const W = (e) => !0;
      class B extends (0, K.Q)({
        initialValue: void 0,
        persist: !1,
        scope: q.F.Device,
        storeName: "device-registration-flow-store",
        storeTypeGuard: W
      }) {}
      let z = class {
        constructor(e, t) {
          (this.identityVerificationService = e), (this.eventEmitter = t);
        }
        mapFunctionalErrorToErrorCode(e) {
          switch (e.tag) {
            case s.VERIFICATION_FAILED:
              return n.OTP_NOT_VALID;
            case s.INVALID_OTP_ALREADY_USED:
              return n.OTP_ALREADY_USED;
            case s.INVALID_OTP_BLOCKED:
              return n.OTP_TOO_MANY_ATTEMPTS;
            default:
              return o.UNKNOWN_ERROR;
          }
        }
        async executeWithParams(e) {
          if (!e.login || !e.otp || 0 === e.otp.length || ("totp" === e.twoFactorAuthenticationOtpType && !L.test(e.otp)))
            return Promise.reject(o.UNKNOWN_ERROR);
          const t = await this.identityVerificationService.performTotpVerification(e.login, e.otp);
          if ((0, g.hx)(t)) {
            const e = this.mapFunctionalErrorToErrorCode(t.error);
            return Promise.reject(e);
          }
          return this.eventEmitter.sendEvent("identityVerificationCompleted", { authTicket: t.data }), Promise.resolve();
        }
      };
      z = (0, c.__decorate)([(0, h.GS)(), (0, c.__metadata)("design:paramtypes", [D, O])], z);
      let H = class {
        constructor(e) {
          this.twoFactorAuthenticationService = e;
        }
        desc() {
          return {
            config: {
              predictableActionArguments: !0,
              schema: { events: {}, context: {} },
              id: "TwoFactorAuthenticationMachine",
              context: { twoFactorAuthenticationOtpType: "totp" },
              initial: "WaitingForTotp",
              states: {
                WaitingForTotp: {
                  on: {
                    INPUT_TOTP: { target: "ValidatingTwoFactorAuthenticationOtp", actions: ["assignTwoFactorAuthenticationOtpValue"] },
                    SWITCH_TWO_FACTOR_AUTHENTICATION_TYPE: {
                      target: "WaitingForBackupCode",
                      actions: ["assignTwoFactorAuthenticationOtpType", "clearError"]
                    }
                  }
                },
                WaitingForBackupCode: {
                  on: {
                    INPUT_BACKUP_CODE: {
                      target: "ValidatingTwoFactorAuthenticationOtp",
                      actions: ["assignTwoFactorAuthenticationOtpValue"]
                    },
                    SWITCH_TWO_FACTOR_AUTHENTICATION_TYPE: {
                      target: "WaitingForTotp",
                      actions: ["assignTwoFactorAuthenticationOtpType", "clearError"]
                    }
                  }
                },
                ValidatingTwoFactorAuthenticationOtp: {
                  invoke: {
                    src: "authenticateWithTwoFactorAuthentication",
                    onDone: { target: "TwoFactorAuthenticationDone" },
                    onError: [
                      { target: "WaitingForBackupCode", cond: "isBackupCode", actions: ["assignError"] },
                      { target: "WaitingForTotp", actions: ["assignError"] }
                    ]
                  }
                },
                TwoFactorAuthenticationDone: { type: "final" }
              }
            },
            options: {
              actions: {
                assignError: (0, m.f0)({ error: (e, t) => t.data }),
                clearError: (0, m.f0)({ error: () => {} }),
                assignTwoFactorAuthenticationOtpValue: (0, m.f0)({
                  twoFactorAuthenticationOtpValue: (e, t) => t.twoFactorAuthenticationOtpValue
                }),
                assignTwoFactorAuthenticationOtpType: (0, m.f0)({
                  twoFactorAuthenticationOtpType: (e, t) => t.twoFactorAuthenticationOtpType
                })
              },
              services: {
                authenticateWithTwoFactorAuthentication: (e) => {
                  const t = {
                    login: e.login ?? "",
                    masterPassword: e.masterPassword ?? null,
                    otp: e.twoFactorAuthenticationOtpValue,
                    twoFactorAuthenticationOtpType: e.twoFactorAuthenticationOtpType,
                    persistData: !0,
                    otpVerificationMode: e.otpVerificationMode,
                    deviceName: e.deviceName
                  };
                  return this.twoFactorAuthenticationService.executeWithParams(t);
                }
              },
              guards: { isBackupCode: (e) => "backupCode" === e.twoFactorAuthenticationOtpType }
            }
          };
        }
        create() {
          const { config: e, options: t } = this.desc();
          return (0, y.C)(e, t);
        }
      };
      H = (0, c.__decorate)([(0, h.GS)(), (0, c.__metadata)("design:paramtypes", [z])], H);
      let $ = class {
        constructor(e, t) {
          (this.deviceRegistrationMachine = e), (this.twoFactorAuthenticationMachine = t);
        }
        desc() {
          return {
            config: {
              predictableActionArguments: !0,
              schema: { events: {}, context: {} },
              initial: "Starting",
              id: "IdentityVerificationFlowMachine",
              context: {
                ...this.deviceRegistrationMachine.desc().config.context,
                ...this.twoFactorAuthenticationMachine.desc().config.context,
                ready: !1,
                shouldAskOTP: !1
              },
              states: {
                Starting: { entry: ["assignInitializationResults"] },
                DeviceRegistration: { ...G(this.deviceRegistrationMachine.desc().config) },
                TwoFactorAuthentication: {
                  ...G(this.twoFactorAuthenticationMachine.desc().config),
                  onDone: { target: "AuthenticationDone" }
                },
                AuthenticationDone: { type: "final" }
              },
              on: {
                VERIFY_IDENTITY_WITH_TOKEN: { target: "DeviceRegistration.EmailToken", actions: ["assignAccountEmail"] },
                VERIFY_IDENTITY_WITH_DASHLANE_AUTHENTICATOR: {
                  target: "DeviceRegistration.DashlaneAuthenticator",
                  actions: ["assignAccountEmail"]
                },
                VERIFY_IDENTITY_WITH_TOTP: { target: "TwoFactorAuthentication", actions: ["assignAccountEmail"] },
                CANCEL_IDENTITY_VERIFICATION: { target: "Starting", actions: ["clearContext"] },
                CLEAR_ERROR: { actions: ["clearError"] }
              }
            },
            options: {
              actions: {
                ...this.deviceRegistrationMachine.desc().options.actions,
                ...this.twoFactorAuthenticationMachine.desc().options.actions,
                assignInitializationResults: (0, m.f0)({ ready: () => !0 }),
                assignAccountEmail: (0, m.f0)({ login: (e, t) => t.login }),
                clearContext: (0, m.f0)({
                  login: () => "",
                  shouldAskOTP: () => !1,
                  twoFactorAuthenticationOtpType: () => "totp",
                  registrationMethod: () => {},
                  emailToken: () => "",
                  deviceName: () => "",
                  isDashlaneAuthenticatorAvailable: () => !1
                }),
                clearError: (0, m.f0)({ error: () => {} })
              },
              services: {
                ...this.deviceRegistrationMachine.desc().options.services,
                ...this.twoFactorAuthenticationMachine.desc().options.services
              },
              guards: {
                ...this.deviceRegistrationMachine.desc().options.guards,
                ...this.twoFactorAuthenticationMachine.desc().options.guards,
                isGrapheneDeviceRegistrationFlow: (e) => !!e.login && e.login.includes("kw_test_newdevice")
              }
            }
          };
        }
        create() {
          const { config: e, options: t } = this.desc();
          return (0, y.C)(e, t);
        }
      };
      $ = (0, c.__decorate)([(0, h.GS)(), (0, c.__metadata)("design:paramtypes", [j, H])], $);
      var Q = r(85390),
        Y = r(30523),
        X = r(6136),
        J = r(20754),
        Z = r(41025),
        ee = r(69885),
        te = r(6220);
      const re = (e) => ({
          step: "EmailTokenStep",
          isLoading: e.matches({ DeviceRegistration: { EmailToken: "ValidatingEmailToken" } }) && !e.context.error,
          error: e.context.error,
          emailToken: e.context.emailToken,
          isDashlaneAuthenticatorAvailable: e.context.isDashlaneAuthenticatorAvailable
        }),
        se = (e) => ({
          step: "DashlaneAuthenticatorStep",
          isLoading: e.matches({ DeviceRegistration: { DashlaneAuthenticator: "RequestingServerPush" } }) && !e.context.error,
          error: e.context.error
        }),
        ae = (e) => ({
          step: "TwoFactorAuthenticationOtpStep",
          isLoading: e.matches({ TwoFactorAuthentication: "ValidatingTwoFactorAuthenticationOtp" }) && !e.context.error,
          error: e.context.error,
          twoFactorAuthenticationOtpValue: e.context.twoFactorAuthenticationOtpValue,
          twoFactorAuthenticationOtpType: e.context.twoFactorAuthenticationOtpType
        });
      const ne = (e) =>
          (0, ee.of)(
            (0, g.Vp)(
              (function (e) {
                return e.matches("Starting")
                  ? { step: "StartingStep" }
                  : e.matches({ DeviceRegistration: { EmailToken: "SendEmailToken" } }) ||
                    e.matches({ DeviceRegistration: { EmailToken: "WaitingForEmailToken" } }) ||
                    e.matches({ DeviceRegistration: { EmailToken: "ValidatingEmailToken" } }) ||
                    e.matches({ DeviceRegistration: { EmailToken: "FinishingEmailToken" } })
                  ? re(e)
                  : e.matches({ DeviceRegistration: { DashlaneAuthenticator: "RequestingServerPush" } }) ||
                    e.matches({ DeviceRegistration: { DashlaneAuthenticator: "AuthenticatorPushFailed" } }) ||
                    e.matches({ DeviceRegistration: { DashlaneAuthenticator: "AuthenticatorPushValidated" } })
                  ? se(e)
                  : e.matches({ TwoFactorAuthentication: "WaitingForTotp" }) ||
                    e.matches({ TwoFactorAuthentication: "WaitingForBackupCode" }) ||
                    e.matches({ TwoFactorAuthentication: "ValidatingTwoFactorAuthenticationOtp" }) ||
                    e.matches({ TwoFactorAuthentication: "FinishingTwoFactorAuthenticationOtp" })
                  ? ae(e)
                  : void console.warn("[Auth Ticket] - No view associated to state ", JSON.stringify(e.value));
              })(e)
            )
          ),
        ie = (e) => e.pipe((0, te.z)(ne));
      var oe = r(26290),
        ce = r(87065);
      const ue = (e) => !0;
      class de extends (0, K.Q)({
        initialValue: void 0,
        persist: !1,
        scope: q.F.Device,
        storeName: "identity-verification-flow-machine",
        storeTypeGuard: ue
      }) {}
      var le = r(30045);
      var pe = r(24966),
        he = r(64472),
        me = r(11746);
      let ye = class {
        constructor(e, t) {
          (this.identityVerificationMachineStore = t), (this.initFlag = new pe.X(!1));
          const r = e.create();
          (this.delayedEvents = []),
            (this.interpreter = he.kJ(r).onTransition(async (e) => {
              e.changed ||
                "xstate.init" === e.event.type ||
                console.warn(
                  `[Auth Ticket] State is unchanged. Unexpected transition on ${JSON.stringify(e.value)} with event ${e.event.type} `
                );
              try {
                const e = this.interpreter?.getSnapshot();
                e &&
                  (await (async (e, t) => {
                    await e.set(JSON.stringify(t));
                  })(this.identityVerificationMachineStore, e));
              } catch (e) {
                console.warn("[Auth Ticket] Unable to get snapshot", e);
              }
            }));
        }
        async prepare() {
          if (this.interpreter)
            try {
              const e = await (async (e) => {
                const t = await e.getState();
                return t ? oe.ZM.create(JSON.parse(t)) : void 0;
              })(this.identityVerificationMachineStore);
              let t;
              try {
                t = this.interpreter.start(e);
              } catch (e) {
                console.error("[Auth Ticket] Unable to reuse the stored state: ", e), (t = this.interpreter.start());
              }
              await (0, me.x)(t, (e) => e.context.ready),
                this.interpreter.send(this.delayedEvents),
                (this.delayedEvents = []),
                this.initFlag.next(!0);
            } catch (e) {
              console.error("[Auth Ticket] Unable to start machine", e);
            }
        }
        ready() {
          return this.initFlag;
        }
        continue(e) {
          if (!this.interpreter) throw new Error("Authentication flow not started");
          this.interpreter.getSnapshot().context.ready ? this.interpreter.send(e) : this.delayedEvents.push(e);
        }
        stop() {
          this.isStarted() && (this.interpreter = void 0);
        }
        isStarted() {
          return Boolean(this.interpreter);
        }
      };
      ye = (0, c.__decorate)([(0, h.GS)(), (0, c.__metadata)("design:paramtypes", [$, de])], ye);
      let ge = class {
        constructor(e, t) {
          (this.identityVerificationFlow = e), (this.identityVerificationMachineStore = t);
        }
        execute() {
          return (0, Q.a)(
            [
              ((e = this.identityVerificationMachineStore), e.state$.pipe((0, ce.U)((e) => (e ? oe.ZM.create(JSON.parse(e)) : void 0)))),
              this.identityVerificationFlow.ready()
            ],
            (e, t) => {
              if (e && t) return e;
            }
          ).pipe(
            (0, Y.h)(Boolean),
            (0, X.x)((e, t) =>
              ((e, t) => {
                const r = t.matches(e.value),
                  s = (0, le.Z)(e.context, t.context);
                return r && s;
              })(e, t)
            ),
            ie
          );
          var e;
        }
      };
      ge = (0, c.__decorate)([(0, J.e)(Z.O), (0, c.__metadata)("design:paramtypes", [ye, de])], ge);
      var ve = r(63663),
        fe = r(13744);
      let we = class {
        constructor(e) {
          this.identityVerificationFlow = e;
        }
        execute(e) {
          const { twoFactorAuthenticationOtpType: t } = e.body;
          return (
            this.identityVerificationFlow.continue({ type: "SWITCH_TWO_FACTOR_AUTHENTICATION_TYPE", twoFactorAuthenticationOtpType: t }),
            Promise.resolve((0, g.Vp)(void 0))
          );
        }
      };
      we = (0, c.__decorate)([(0, ve.W)(fe.eG), (0, c.__metadata)("design:paramtypes", [ye])], we);
      let Se = class {
        constructor(e) {
          this.identityVerificationFlow = e;
        }
        execute() {
          return this.identityVerificationFlow.continue({ type: "CLEAR_ERROR" }), Promise.resolve((0, g.Vp)(void 0));
        }
      };
      Se = (0, c.__decorate)([(0, ve.W)(fe.$5), (0, c.__metadata)("design:paramtypes", [ye])], Se);
      let Ee = class {
        constructor(e) {
          this.identityVerificationFlow = e;
        }
        execute() {
          return this.identityVerificationFlow.continue({ type: "RESEND_EMAIL_TOKEN" }), Promise.resolve((0, g.Vp)(void 0));
        }
      };
      Ee = (0, c.__decorate)([(0, ve.W)(fe.Gc), (0, c.__metadata)("design:paramtypes", [ye])], Ee);
      let _e = class {
        constructor(e) {
          this.identityVerificationFlow = e;
        }
        execute() {
          return this.identityVerificationFlow.continue({ type: "RESEND_PUSH_NOTIFICATION" }), Promise.resolve((0, g.Vp)(void 0));
        }
      };
      _e = (0, c.__decorate)([(0, ve.W)(fe.rF), (0, c.__metadata)("design:paramtypes", [ye])], _e);
      let be = class {
        constructor(e) {
          this.identityVerificationFlow = e;
        }
        execute(e) {
          const { twoFactorAuthenticationOtpValue: t } = e.body;
          return (
            this.identityVerificationFlow.continue({ type: "INPUT_BACKUP_CODE", twoFactorAuthenticationOtpValue: t }),
            Promise.resolve((0, g.Vp)(void 0))
          );
        }
      };
      be = (0, c.__decorate)([(0, ve.W)(fe.sH), (0, c.__metadata)("design:paramtypes", [ye])], be);
      let Te = class {
        constructor(e) {
          this.identityVerificationFlow = e;
        }
        execute(e) {
          const { emailToken: t, deviceName: r } = e.body;
          return (
            this.identityVerificationFlow.continue({ type: "INPUT_EMAIL_TOKEN", emailToken: t, deviceName: r }),
            Promise.resolve((0, g.Vp)(void 0))
          );
        }
      };
      Te = (0, c.__decorate)([(0, ve.W)(fe.XH), (0, c.__metadata)("design:paramtypes", [ye])], Te);
      let Ae = class {
        constructor(e) {
          this.identityVerificationFlow = e;
        }
        execute(e) {
          const { twoFactorAuthenticationOtpValue: t } = e.body;
          return (
            this.identityVerificationFlow.continue({ type: "INPUT_TOTP", twoFactorAuthenticationOtpValue: t }),
            Promise.resolve((0, g.Vp)(void 0))
          );
        }
      };
      Ae = (0, c.__decorate)([(0, ve.W)(fe.ad), (0, c.__metadata)("design:paramtypes", [ye])], Ae);
      let Ce = class {
        constructor(e) {
          this.identityVerificationFlow = e;
        }
        execute() {
          return this.identityVerificationFlow.continue({ type: "SWITCH_TO_DASHLANE_AUTHENTICATOR" }), Promise.resolve((0, g.Vp)(void 0));
        }
      };
      Ce = (0, c.__decorate)([(0, ve.W)(fe.K1), (0, c.__metadata)("design:paramtypes", [ye])], Ce);
      let Re = class {
        constructor(e) {
          this.identityVerificationFlow = e;
        }
        execute() {
          return this.identityVerificationFlow.continue({ type: "SWITCH_TO_EMAIL_TOKEN" }), Promise.resolve((0, g.Vp)(void 0));
        }
      };
      Re = (0, c.__decorate)([(0, ve.W)(fe.v5), (0, c.__metadata)("design:paramtypes", [ye])], Re);
      let Ie = class {
        constructor(e) {
          this.identityVerificationFlow = e;
        }
        execute(e) {
          const { login: t, verificationMethod: r } = e.body;
          switch (r) {
            case "email_token":
              this.identityVerificationFlow.continue({ type: "VERIFY_IDENTITY_WITH_TOKEN", login: t });
              break;
            case "totp":
              this.identityVerificationFlow.continue({ type: "VERIFY_IDENTITY_WITH_TOTP", login: t });
              break;
            case "dashlane_authenticator":
              this.identityVerificationFlow.continue({ type: "VERIFY_IDENTITY_WITH_DASHLANE_AUTHENTICATOR", login: t });
          }
          return Promise.resolve((0, g.Vp)(void 0));
        }
      };
      Ie = (0, c.__decorate)([(0, ve.W)(fe.qw), (0, c.__metadata)("design:paramtypes", [ye])], Ie);
      let xe = class {
        constructor(e) {
          this.identityVerificationFlow = e;
        }
        execute() {
          return this.identityVerificationFlow.continue({ type: "CANCEL_IDENTITY_VERIFICATION" }), Promise.resolve((0, g.Vp)(void 0));
        }
      };
      xe = (0, c.__decorate)([(0, ve.W)(fe.Vs), (0, c.__metadata)("design:paramtypes", [ye])], xe);
      let Pe = class {};
      Pe = (0, c.__decorate)(
        [
          (0, u.Y)({
            api: p.i,
            handlers: {
              commands: {
                changeTwoFactorAuthenticationOtpType: we,
                clearError: Se,
                resendEmailToken: Ee,
                resendPushNotification: _e,
                submitBackupCode: be,
                submitEmailToken: Te,
                submitTotp: Ae,
                switchToDashlaneAuthenticator: Ce,
                switchToEmailToken: Re,
                startIdentityVerification: Ie,
                cancelIdentityVerification: xe
              },
              events: {},
              queries: { identityVerificationFlowStatus: ge }
            },
            providers: [
              j,
              k,
              N,
              V,
              H,
              ...(0, d.H)(ye, {
                inject: [$, de],
                asyncFactory: async (e, t) => {
                  const r = new ye(e, t);
                  return await r.prepare(), r;
                }
              }),
              $,
              M,
              z,
              U,
              D,
              O
            ],
            imports: [l.n],
            exports: [ye],
            stores: [de, B]
          })
        ],
        Pe
      );
    },
    93202: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => A });
      var s = r(88802),
        a = r(69401),
        n = r(99634),
        i = r(1824),
        o = r(59550);
      let c = class {};
      c = (0, s.__decorate)([(0, n.Y)({ sharedModuleName: "authentication", providers: [o.Q], exports: [o.Q] })], c);
      var u = r(11088),
        d = r(63663),
        l = r(63281),
        p = r(87279),
        h = r(89358),
        m = r(60399);
      let y = class {
        constructor(e, t, r) {
          (this.contextLessServerApiClient = e), (this.authWSRepository = t), (this.sessionClient = r);
        }
        async execute(e) {
          const t = await (0, m.z)(this.sessionClient.queries.selectedOpenedSession()),
            r = (0, p.d6)(t) ? (0, p.db)(t) : e.body.login;
          if (void 0 === r) throw new Error("Logged out and no login specified");
          const { id: s, type: a, rawId: n, response: i } = e.body.assertion;
          if ("public-key" !== a) throw new Error("Invalid parameter assertion.type");
          const o = await (0, m.z)(
            this.contextLessServerApiClient.v1.authentication.completeRememberMeOpenSession(
              await this.authWSRepository.getSessionCredentialsForUser(r),
              { authenticator: { authenticationType: "webauthn.get", credential: { type: a, id: s, rawId: n, response: i } } }
            )
          );
          if ((0, p.hx)(o)) throw new Error(`Assertion could not be validated: ${o.error.name}`);
          return (0, p.Vp)(void 0);
        }
      };
      y = (0, s.__decorate)([(0, d.W)(u.L), (0, s.__metadata)("design:paramtypes", [l.B, o.Q, h.x])], y);
      var g = r(20195);
      const v = {
        FetchFailedError: (f = () => (0, g.j)("Error calling server API")),
        InternalServerError: f,
        InvalidRequest: f,
        RateLimited: f,
        ServiceUnavailable: f,
        UnspecifiedBadStatus: f
      };
      var f,
        w = r(61501),
        S = r(18533),
        E = r(25535),
        _ = r(83853);
      function b(e) {
        return () => (0, p.Rn)({ tag: e });
      }
      let T = class {
        constructor(e) {
          this.server = e;
        }
        async execute({ body: { email: e } }) {
          const t = await (0, m.z)(this.server.v1.authentication.requestOtpRecoveryCodesByPhone({ login: e }));
          return (0, S.EQ)(t, {
            success: () => (0, p.Vp)(void 0),
            failure: (e) =>
              (0, S.EQ)(e.error, {
                ...v,
                FetchFailedError: b(_.A.NetworkError),
                BusinessError: (e) =>
                  (0, E.G)(e.code, {
                    INVALID_RECOVERY_PHONE: b(_.A.AccountNotEligible),
                    SMS_ERROR: () => (0, g.j)("Dashlane servers failed to send SMS"),
                    SMS_OPT_OUT: b(_.A.AccountNotEligible),
                    USER_NOT_FOUND: b(_.A.AccountNotEligible),
                    WRONG_OTP_STATUS: b(_.A.AccountNotEligible)
                  })
              })
          });
        }
      };
      T = (0, s.__decorate)([(0, d.W)(u.x), (0, s.__metadata)("design:paramtypes", [w.l])], T);
      let A = class {};
      A = (0, s.__decorate)(
        [
          (0, n.Y)({
            api: a.M,
            handlers: { commands: { validateWebauthnAssertion: y, request2FaCodesByPhone: T }, events: {}, queries: {} },
            imports: [i.n, c]
          })
        ],
        A
      );
    },
    17556: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => s });
      class s {
        redirectUserToExternalUrl(e) {
          !(async function () {
            try {
              await chrome.tabs.create({ url: e.externalUrl, active: e.tabFocus });
            } catch (t) {
              console.warn("[Auto-SSO] No window available. Delaying tab creation");
              const r = () => {
                chrome.tabs.create({ url: e.externalUrl, active: e.tabFocus }), chrome.windows.onCreated.removeListener(r);
              };
              chrome.windows.onCreated.addListener(r);
            }
          })();
        }
      }
    },
    15403: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => s });
      const s = (0, r(86952).Q)({ name: "autofillData", commands: {}, events: {}, queries: {} });
    },
    92018: (e, t, r) => {
      "use strict";
      r.d(t, { Y: () => i });
      var s = r(86952),
        a = r(11564),
        n = r(73581);
      const i = (0, s.Q)({
        name: "autofillTracking",
        commands: { temporaryEmitPasswordAutofillPerformedEvent: n.q },
        events: { passwordAutofillPerformedEvent: a.p },
        queries: {}
      });
    },
    73581: (e, t, r) => {
      "use strict";
      r.d(t, { q: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    11564: (e, t, r) => {
      "use strict";
      r.d(t, { p: () => n });
      var s = r(88885),
        a = r(25029);
      class n extends (0, s.d)({ scope: a.F.User }) {}
    },
    46154: (e, t, r) => {
      "use strict";
      r.d(t, { Pw: () => i, q_: () => a, rF: () => o, up: () => s });
      const s = [
          "KWAddress",
          "KWBankStatement",
          "KWCompany",
          "KWDriverLicence",
          "KWEmail",
          "KWFiscalStatement",
          "KWIDCard",
          "KWIdentity",
          "KWMerchand",
          "KWPassport",
          "KWPaymentMean_creditCard",
          "KWPaymentMean_paypal",
          "KWPersonalWebsite",
          "KWPhone",
          "KWSecureNote",
          "KWSecureNoteCategory",
          "KWSocialSecurityStatement"
        ],
        a = ["KWAuthentifiant", "KWGeneratedPassword", "KWPasskey"],
        n = [...s, ...a],
        i = (e) => !!e && "string" == typeof e && n.includes(e),
        o = (e) => !!e && "object" == typeof e && Array.isArray(e) && e.every(i);
    },
    3124: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => s, w: () => a });
      const s = (e) =>
          e instanceof Array &&
          !e.find((e) => {
            return !("object" == typeof (t = e) && null !== t && "id" in t && "fieldIdentifier" in t && "domain" in t);
            var t;
          }),
        a = (e) => "none" === e.correctedDataSource;
    },
    52434: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { M: () => s }),
        (function (e) {
          (e[(e.CannotDisable = 0)] = "CannotDisable"),
            (e[(e.DisableSpecificVaultItem = 1)] = "DisableSpecificVaultItem"),
            (e[(e.DisableGeneralSetting = 2)] = "DisableGeneralSetting");
        })(s || (s = {}));
    },
    78364: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { k: () => s }),
        (function (e) {
          (e.Address = "Address"),
            (e.BankAccount = "BankAccount"),
            (e.Company = "Company"),
            (e.Credential = "Credential"),
            (e.CredentialCategory = "CredentialCategory"),
            (e.DriverLicense = "DriverLicense"),
            (e.Email = "Email"),
            (e.FiscalId = "FiscalId"),
            (e.GeneratedPassword = "GeneratedPassword"),
            (e.IdCard = "IdCard"),
            (e.Identity = "Identity"),
            (e.NoteCategory = "NoteCategory"),
            (e.Note = "Note"),
            (e.Passport = "Passport"),
            (e.Passkey = "Passkey"),
            (e.PaymentCard = "PaymentCard"),
            (e.PersonalWebsite = "PersonalWebsite"),
            (e.Phone = "Phone"),
            (e.SocialSecurityId = "SocialSecurityId");
        })(s || (s = {}));
    },
    92202: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          AddDisabledSourceTypesCommand: () => I.g,
          AnalysisStatus: () => A._,
          CREDENTIAL_DATA_MODELS: () => p.q_,
          CountriesForAutofill: () => o,
          DisableAnalysisCommand: () => x.u,
          DisableAutofillOnFormsCommand: () => D.t,
          DisableAutofillOnLoginsCommand: () => U.f,
          DisableAutologinCommand: () => P.T,
          DisableFollowUpNotificationCommand: () => F.y,
          DisablePhishingPreventionForUrlCommand: () => b.z,
          EnableAnalysisCommand: () => O.c,
          EnableAutofillOnFormsCommand: () => k.a,
          EnableAutofillOnLoginsCommand: () => L.I,
          EnableAutologinCommand: () => N.i,
          EnableFollowUpNotificationCommand: () => M.B,
          FORM_DATA_MODELS: () => p.up,
          GetAnalysisStatusOnUrlQuery: () => A.h,
          GetAutofillDisabledOnLoginsAndFormsNotificationStatusQuery: () => v.z,
          GetAutofillProtectionContextQuery: () => w.u,
          GetAutofillSettingsQuery: () => C.T,
          GetDashlaneDefinedLinkedWebsitesQuery: () => K.J,
          GetUserAutofillCorrectionsQuery: () => R.w,
          OtherSourceType: () => c,
          PasswordAutofillPerformedEvent: () => n.p,
          PhishingPreventionDisabledForUrlQuery: () => E.v,
          PhishingPreventionEnabledQuery: () => S.i,
          RemoveDisabledSourceTypesCommand: () => V.v,
          ResetProtectedItemAutofillTimerCommand: () => _.y,
          SetAutofillDisabledOnLoginsAndFormsNotificationStatusCommand: () => g.a,
          SetUserAutofillCorrectionsCommand: () => j.S,
          TemporaryEmitPasswordAutofillPerformedEventCommand: () => i.q,
          ToggleDashlaneCommand: () => G.r,
          UpdateLinkedWebsitesCommand: () => W.A,
          VaultItemDisableProtectionMode: () => m.M,
          VaultSourceType: () => u.k,
          autofillDataApi: () => s.c,
          autofillNotificationsApi: () => y._,
          autofillSecurityApi: () => f.V,
          autofillSettingsApi: () => T.I,
          autofillTrackingApi: () => a.Y,
          isArrayOfAutofillableDataModel: () => p.rF,
          isArrayOfUserAutofillCorrections: () => h.P,
          isAutofillableDataModel: () => p.Pw,
          isDashlaneDisabledPermanently: () => h.w,
          isOtherSourceType: () => d,
          isVaultSourceType: () => l,
          linkedWebsitesApi: () => q.G
        });
      var s = r(15403),
        a = r(92018),
        n = r(11564),
        i = r(73581);
      const o = Object.freeze({
        NO_TYPE: "NO_TYPE",
        UNIVERSAL: "UNIVERSAL",
        AD: "AD",
        AE: "AE",
        AF: "AF",
        AG: "AG",
        AI: "AI",
        AL: "AL",
        AM: "AM",
        AO: "AO",
        AR: "AR",
        AS: "AS",
        AT: "AT",
        AU: "AU",
        AW: "AW",
        AZ: "AZ",
        BA: "BA",
        BB: "BB",
        BD: "BD",
        BE: "BE",
        BF: "BF",
        BG: "BG",
        BH: "BH",
        BI: "BI",
        BJ: "BJ",
        BL: "BL",
        BM: "BM",
        BN: "BN",
        BO: "BO",
        BR: "BR",
        BS: "BS",
        BT: "BT",
        BW: "BW",
        BY: "BY",
        BZ: "BZ",
        CA: "CA",
        CD: "CD",
        CF: "CF",
        CG: "CG",
        CH: "CH",
        CI: "CI",
        CK: "CK",
        CL: "CL",
        CM: "CM",
        CN: "CN",
        CO: "CO",
        CR: "CR",
        CU: "CU",
        CV: "CV",
        CY: "CY",
        CZ: "CZ",
        DE: "DE",
        DJ: "DJ",
        DK: "DK",
        DM: "DM",
        DO: "DO",
        DZ: "DZ",
        EC: "EC",
        EE: "EE",
        EG: "EG",
        ER: "ER",
        ES: "ES",
        ET: "ET",
        FI: "FI",
        FJ: "FJ",
        FK: "FK",
        FM: "FM",
        FO: "FO",
        FR: "FR",
        GA: "GA",
        GB: "GB",
        GD: "GD",
        GE: "GE",
        GF: "GF",
        GG: "GG",
        GH: "GH",
        GI: "GI",
        GL: "GL",
        GM: "GM",
        GN: "GN",
        GP: "GP",
        GQ: "GQ",
        GR: "GR",
        GT: "GT",
        GU: "GU",
        GW: "GW",
        GY: "GY",
        HK: "HK",
        HN: "HN",
        HR: "HR",
        HT: "HT",
        HU: "HU",
        ID: "ID",
        IE: "IE",
        IL: "IL",
        IM: "IM",
        IN: "IN",
        IO: "IO",
        IQ: "IQ",
        IR: "IR",
        IS: "IS",
        IT: "IT",
        JE: "JE",
        JM: "JM",
        JO: "JO",
        JP: "JP",
        KE: "KE",
        KG: "KG",
        KH: "KH",
        KI: "KI",
        KM: "KM",
        KN: "KN",
        KP: "KP",
        KR: "KR",
        KW: "KW",
        KY: "KY",
        KZ: "KZ",
        LA: "LA",
        LB: "LB",
        LC: "LC",
        LI: "LI",
        LK: "LK",
        LR: "LR",
        LS: "LS",
        LT: "LT",
        LU: "LU",
        LV: "LV",
        LY: "LY",
        MA: "MA",
        MC: "MC",
        MD: "MD",
        ME: "ME",
        MF: "MF",
        MG: "MG",
        MH: "MH",
        MK: "MK",
        ML: "ML",
        MM: "MM",
        MN: "MN",
        MO: "MO",
        MP: "MP",
        MQ: "MQ",
        MR: "MR",
        MS: "MS",
        MT: "MT",
        MU: "MU",
        MV: "MV",
        MW: "MW",
        MX: "MX",
        MY: "MY",
        MZ: "MZ",
        NA: "NA",
        NC: "NC",
        NE: "NE",
        NF: "NF",
        NG: "NG",
        NI: "NI",
        NL: "NL",
        NO: "NO",
        NP: "NP",
        NR: "NR",
        NU: "NU",
        NZ: "NZ",
        OM: "OM",
        PA: "PA",
        PE: "PE",
        PF: "PF",
        PG: "PG",
        PH: "PH",
        PK: "PK",
        PL: "PL",
        PM: "PM",
        PR: "PR",
        PS: "PS",
        PT: "PT",
        PW: "PW",
        PY: "PY",
        QA: "QA",
        RE: "RE",
        RO: "RO",
        RS: "RS",
        RU: "RU",
        RW: "RW",
        SA: "SA",
        SB: "SB",
        SC: "SC",
        SD: "SD",
        SE: "SE",
        SG: "SG",
        SH: "SH",
        SI: "SI",
        SK: "SK",
        SL: "SL",
        SM: "SM",
        SN: "SN",
        SO: "SO",
        SR: "SR",
        ST: "ST",
        SV: "SV",
        SY: "SY",
        SZ: "SZ",
        TC: "TC",
        TD: "TD",
        TF: "TF",
        TG: "TG",
        TH: "TH",
        TJ: "TJ",
        TK: "TK",
        TL: "TL",
        TM: "TM",
        TN: "TN",
        TO: "TO",
        TR: "TR",
        TT: "TT",
        TV: "TV",
        TW: "TW",
        TZ: "TZ",
        UA: "UA",
        UG: "UG",
        US: "US",
        UY: "UY",
        UZ: "UZ",
        VA: "VA",
        VC: "VC",
        VE: "VE",
        VG: "VG",
        VI: "VI",
        VN: "VN",
        VU: "VU",
        WF: "WF",
        WS: "WS",
        XK: "XK",
        YE: "YE",
        YT: "YT",
        ZA: "ZA",
        ZM: "ZM",
        ZW: "ZW",
        AQ: "AQ",
        AX: "AX",
        BV: "BV",
        CC: "CC",
        CX: "CX",
        EH: "EH",
        GS: "GS",
        HM: "HM",
        PN: "PN",
        SJ: "SJ",
        UM: "UM"
      });
      var c,
        u = r(78364);
      !(function (e) {
        (e.NewPassword = "newPassword"), (e.SubmitButton = "submitButton"), (e.WebauthnConditionalUI = "WebauthnConditionalUI");
      })(c || (c = {}));
      const d = (e) => Object.values(c).includes(e),
        l = (e) => e in u.k;
      var p = r(46154),
        h = r(3124),
        m = r(52434),
        y = r(45714),
        g = r(61933),
        v = r(63208),
        f = r(38554),
        w = r(51730),
        S = r(5282),
        E = r(63212),
        _ = r(93555),
        b = r(94370),
        T = r(69029),
        A = r(68573),
        C = r(63267),
        R = r(3414),
        I = r(99682),
        x = r(3909),
        P = r(34962),
        D = r(65791),
        U = r(56e3),
        F = r(11232),
        O = r(54405),
        N = r(4924),
        k = r(38018),
        L = r(69643),
        M = r(82796),
        V = r(46918),
        G = r(50163),
        j = r(29641),
        q = r(46097),
        K = r(66608),
        W = r(9446);
    },
    46097: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => i });
      var s = r(86952),
        a = r(66608),
        n = r(9446);
      const i = (0, s.Q)({
        name: "linkedWebsites",
        commands: { updateLinkedWebsites: n.A },
        events: {},
        queries: { getDashlaneDefinedLinkedWebsites: a.J }
      });
    },
    9446: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    66608: (e, t, r) => {
      "use strict";
      r.d(t, { J: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    45714: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => i });
      var s = r(86952),
        a = r(61933),
        n = r(63208);
      const i = (0, s.Q)({
        name: "autofillNotifications",
        commands: { setAutofillDisabledOnLoginsAndFormsNotificationStatus: a.a },
        events: {},
        queries: { getAutofillDisabledOnLoginsAndFormsNotificationStatus: n.z }
      });
    },
    61933: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    63208: (e, t, r) => {
      "use strict";
      r.d(t, { z: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    38554: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => u });
      var s = r(86952),
        a = r(51730),
        n = r(5282),
        i = r(63212),
        o = r(94370),
        c = r(93555);
      const u = (0, s.Q)({
        name: "autofillSecurity",
        commands: { disablePhishingPreventionForUrl: o.z, resetProtectedItemAutofillTimer: c.y },
        events: {},
        queries: { getAutofillProtectionContext: a.u, isPhishingPreventionCapabilityEnabled: n.i, isPhishingPreventionDisabledForUrl: i.v }
      });
    },
    94370: (e, t, r) => {
      "use strict";
      r.d(t, { z: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    93555: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.Device }) {}
    },
    51730: (e, t, r) => {
      "use strict";
      r.d(t, { u: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    5282: (e, t, r) => {
      "use strict";
      r.d(t, { i: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    63212: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    69029: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => E });
      var s = r(86952),
        a = r(46918),
        n = r(99682),
        i = r(50163),
        o = r(68573),
        c = r(63267),
        u = r(3414),
        d = r(54405),
        l = r(4924),
        p = r(38018),
        h = r(69643),
        m = r(82796),
        y = r(3909),
        g = r(34962),
        v = r(65791),
        f = r(56e3),
        w = r(11232),
        S = r(29641);
      const E = (0, s.Q)({
        name: "autofillSettings",
        commands: {
          toggleDashlane: i.r,
          enableAnalysis: d.c,
          enableAutologin: l.i,
          enableAutofillOnForms: p.a,
          enableAutofillOnLogins: h.I,
          enableFollowUpNotification: m.B,
          disableAnalysis: y.u,
          disableAutologin: g.T,
          disableAutofillOnForms: v.t,
          disableAutofillOnLogins: f.f,
          disableFollowUpNotification: w.y,
          addDisabledSourceTypes: n.g,
          removeDisabledSourceTypes: a.v,
          setUserAutofillCorrections: S.S
        },
        events: {},
        queries: { getAnalysisStatusOnUrl: o.h, getAutofillSettings: c.T, getUserAutofillCorrections: u.w }
      });
    },
    99682: (e, t, r) => {
      "use strict";
      r.d(t, { g: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    3909: (e, t, r) => {
      "use strict";
      r.d(t, { u: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    65791: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    56e3: (e, t, r) => {
      "use strict";
      r.d(t, { f: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    34962: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    11232: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    54405: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    38018: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    69643: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    4924: (e, t, r) => {
      "use strict";
      r.d(t, { i: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    82796: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    46918: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    29641: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    50163: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    68573: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => s, h: () => i });
      var s,
        a = r(99059),
        n = r(25029);
      !(function (e) {
        (e.ANALYSIS_ENABLED = "ANALYSIS_ENABLED"),
          (e.ANALYSIS_DISABLED_BY_USER = "ANALYSIS_DISABLED_BY_USER"),
          (e.ANALYSIS_DISABLED_BY_B2B_ADMIN = "ANALYSIS_DISABLED_BY_B2B_ADMIN"),
          (e.ANALYSIS_DISABLED_BY_KILLSWITCH = "ANALYSIS_DISABLED_BY_KILLSWITCH"),
          (e.ANALYSIS_DISABLED_BY_2FA_ENFORCEMENT = "ANALYSIS_DISABLED_BY_2FA_ENFORCEMENT");
      })(s || (s = {}));
      class i extends (0, a.k)({ scope: n.F.Device }) {}
    },
    63267: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    3414: (e, t, r) => {
      "use strict";
      r.d(t, { w: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    29125: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => i });
      var s = r(88802),
        a = r(99634),
        n = r(15403);
      let i = class {};
      i = (0, s.__decorate)([(0, a.Y)({ api: n.c, handlers: { commands: {}, events: {}, queries: {} }, providers: [] })], i);
    },
    59123: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => h });
      var s = r(88802),
        a = r(99634),
        n = r(92018),
        i = r(81459),
        o = r(57924);
      let c = class extends i.f {};
      c = (0, s.__decorate)([(0, o.GS)()], c);
      var u = r(63663),
        d = r(87279),
        l = r(73581);
      let p = class {
        constructor(e) {
          this.autofillTrackingEventsEmitter = e;
        }
        execute({ body: e }) {
          const { credentialId: t } = e;
          return (
            t && this.autofillTrackingEventsEmitter.sendEvent("passwordAutofillPerformed", { credentialId: t }),
            Promise.resolve((0, d.Vp)(void 0))
          );
        }
      };
      p = (0, s.__decorate)([(0, u.W)(l.q), (0, s.__metadata)("design:paramtypes", [c])], p);
      let h = class {};
      h = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.Y,
            handlers: { commands: { temporaryEmitPasswordAutofillPerformedEvent: p }, events: {}, queries: {} },
            providers: [c]
          })
        ],
        h
      );
    },
    33084: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { G: () => s }),
        (function (e) {
          (e.AutofillWebOneClickFormFill = "autofill_web_oneClickFormFill"),
            (e.AutofillWebAskBeforeAutologin = "autofill_web_askBeforeAutologin"),
            (e.AutofillWebNewSubdomainManagement = "autofill_web_newSubdomainManagement"),
            (e.AutofillWebInjectScriptOnStartDev = "autofill_web_injectScriptOnStart_dev"),
            (e.ReplaceInputListeners = "autofill_web_replaceInputListeners"),
            (e.ReplaceInputListenersDev = "autofill_web_replaceInputListeners_dev"),
            (e.PasskeySupport = "autofill_web_passkey_support"),
            (e.PhishingPreventionOnPasteDev = "autofill_web_phishing_prevention_on_paste_dev"),
            (e.PhishingPreventionOnPaste = "autofill_web_phishing_prevention_on_paste_2"),
            (e.ImproveImpalaVisibility = "autofill_web_improveImpalaVisibility"),
            (e.ImproveImpalaVisibilityDev = "autofill_web_improveImpalaVisibility_dev"),
            (e.DisableAutologin = "autofill_web_disableAutologin"),
            (e.AdminTabDev = "ace_admin_tab_dev"),
            (e.AdminTab = "ace_admin_tab"),
            (e.BiometricPasskeyDev = "ace_web_biometric_passkey_dev"),
            (e.BiometricPasskey = "ace_web_biometric_passkey"),
            (e.DisableEmailPasswordWarningDev = "ace_disable_email_password_warning_dev"),
            (e.DisableEmailPasswordWarning = "ace_disable_email_password_warning"),
            (e.RestrictPasswordFreePlanPhase1 = "b2c_web_restrict_password_free_plan_phase1"),
            (e.RestrictPasswordFreePlanPhase2 = "b2c_web_restrict_password_free_plan_phase2");
        })(s || (s = {}));
    },
    26399: (e, t, r) => {
      "use strict";
      r.d(t, { J: () => C });
      var s = r(88802),
        a = r(99634),
        n = r(46097),
        i = r(60399),
        o = r(87065),
        c = r(69885),
        u = r(53576),
        d = r(64718),
        l = r(57924),
        p = r(87279),
        h = r(68925),
        m = r(32089),
        y = r(3991);
      const g = (e) => Object.keys(e).map((t) => [t].concat(e[t])),
        v = (e) => [...e].sort();
      var f = r(53998);
      let w = class {
        constructor(e) {
          (this.carbonLegacyClient = e),
            (this.updateLinkedWebsites = async (e, t) => {
              const r = await this.getCredentialById(t),
                s = this.getUserAddedLinkedWebsiteDomains(r),
                a = [...new Set(e)].filter(Boolean);
              var n, i;
              if (((i = a), (n = s).length === i.length && v(n).join("") === v(i).join(""))) return;
              const o = 0 === a.length ? [] : this.mergeLinkedWebsites(r, s, a),
                c = { ...r.LinkedServices, associated_domains: o },
                u = await this.carbonLegacyClient.commands.carbon({
                  name: "updateCredential",
                  args: [{ id: t, update: { linkedServices: c } }]
                });
              if ((0, p.hx)(u)) throw new Error("Error when updating linked websites using updateCredential query from Carbon");
            }),
            (this.populateDashlaneDefinedLinkedWebsitesIndex = (e) => {
              const t = {};
              return (
                e.forEach((e) => {
                  e.forEach((r) => {
                    t[r] = e;
                  });
                }),
                t
              );
            }),
            (this.mergeLinkedDomainsIntoList = (e, t) => {
              const r = [],
                s = [];
              e.forEach((e) => {
                return (a = t), e.some((e) => a.includes(e)) ? r.push(e) : s.push(e);
                var a;
              });
              const a = r.concat([t]).flat();
              return s.concat([a]);
            }),
            (this.reduceLinkedDomainsLists = (e, t, r) => e.concat(t, r).reduce(this.mergeLinkedDomainsIntoList, [])),
            (this._getDashlaneDefinedLinkedWebsites = (e) => {
              const t = new d.Y(e).getRootDomain();
              return t ? this.allDashlaneDefinedLinkedWebsitesIndex[t] || [t] : [];
            }),
            (this.getCredentialById = (e) => {
              const { carbonState: t } = this.carbonLegacyClient.queries;
              return (0, i.z)(
                t({ path: "userSession.personalData.credentials" }).pipe(
                  (0, o.U)((t) => {
                    if (!(0, p.d6)(t) || !(0, f.A)(t.data)) throw new Error("Bad credential format");
                    const r = t.data.find((t) => t.Id === e);
                    if (r) return r;
                    throw new Error("Cannot find credential");
                  })
                )
              );
            }),
            (this.getUserAddedLinkedWebsiteDomains = (e) =>
              e.LinkedServices?.associated_domains?.flatMap(({ domain: e }) => (Boolean(e) ? e : [])) ?? []),
            (this.getNewLinkedWebsitesToAdd$ = (e, t) =>
              t.filter((t) => !e.includes(t)).map((e) => ({ domain: e, source: u.LinkedWebsiteSource.Manual }))),
            (this.mergeLinkedWebsites = (e, t, r) => [
              ...(e.LinkedServices?.associated_domains ?? []).filter((e) => r.includes(e.domain)),
              ...this.getNewLinkedWebsitesToAdd$(t, r)
            ]),
            (this.allDashlaneDefinedLinkedWebsitesIndex = this.populateDashlaneDefinedLinkedWebsitesIndex(
              this.reduceLinkedDomainsLists(h, g(y), g(m)).map((e) => [...new Set(e)])
            ));
        }
        getDashlaneDefinedLinkedWebsites$(e) {
          return (0, c.of)(this._getDashlaneDefinedLinkedWebsites(e)).pipe((0, o.U)(p.Vp));
        }
      };
      w = (0, s.__decorate)([(0, l.GS)(), (0, s.__metadata)("design:paramtypes", [u.CarbonLegacyClient])], w);
      var S = r(20754),
        E = r(66608);
      let _ = class {
        constructor(e) {
          this.linkedWebsites = e;
        }
        execute({ body: { url: e = "" } }) {
          return this.linkedWebsites.getDashlaneDefinedLinkedWebsites$(e);
        }
      };
      _ = (0, s.__decorate)([(0, S.e)(E.J), (0, s.__metadata)("design:paramtypes", [w])], _);
      var b = r(63663),
        T = r(9446);
      let A = class {
        constructor(e) {
          this.linkedWebsites = e;
        }
        async execute({ body: { credentialId: e, updatedLinkedWebsitesList: t } }) {
          try {
            return await this.linkedWebsites.updateLinkedWebsites(t, e), (0, p.Vp)(void 0);
          } catch (e) {
            return (0, p.Rn)({ tag: "", error: e instanceof Error ? e : new Error("Update linked websites command failed") });
          }
        }
      };
      A = (0, s.__decorate)([(0, b.W)(T.A), (0, s.__metadata)("design:paramtypes", [w])], A);
      let C = class {};
      C = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.G,
            handlers: { commands: { updateLinkedWebsites: A }, events: {}, queries: { getDashlaneDefinedLinkedWebsites: _ } },
            providers: [w]
          })
        ],
        C
      );
    },
    80034: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => b });
      var s = r(88802),
        a = r(99634),
        n = r(45714),
        i = r(33084),
        o = r(95681),
        c = r(23347),
        u = r(25029),
        d = r(10722);
      const l = (e) => void 0 !== e && "boolean" == typeof e;
      class p extends (0, o.Q)({
        persist: !0,
        storage: { initialValue: !1, typeGuard: l, schemaVersion: 1 },
        scope: u.F.User,
        storeName: "autofill-disabled-notification",
        capacity: c.Y._001KB,
        codec: d.E
      }) {}
      var h = r(57924);
      let m = class {
        constructor(e) {
          this.store = e;
        }
        get autofillDisabledOnLoginsAndFormsNotificationStatus() {
          return {
            get$: this._getAutofillDisabledOnLoginsAndFormsNotificationStatus$,
            set: this._setAutofillDisabledOnLoginsAndFormsNotificationStatus.bind(this)
          };
        }
        get _getAutofillDisabledOnLoginsAndFormsNotificationStatus$() {
          return this.store.state$;
        }
        async _setAutofillDisabledOnLoginsAndFormsNotificationStatus(e) {
          try {
            await this.store.set(e);
          } catch {
            throw new Error("SetAutofillDisabledOnLoginsAndFormsNotificationStatus command from autofill-core failed");
          }
        }
      };
      m = (0, s.__decorate)([(0, h.GS)(), (0, s.__metadata)("design:paramtypes", [p])], m);
      var y = r(63663),
        g = r(87279),
        v = r(61933);
      let f = class {
        constructor(e) {
          this.autofillDisabledNotificationRepository = e;
        }
        async execute({ body: e }) {
          const { status: t } = e;
          return (
            await this.autofillDisabledNotificationRepository.autofillDisabledOnLoginsAndFormsNotificationStatus.set(t), (0, g.Vp)(void 0)
          );
        }
      };
      f = (0, s.__decorate)([(0, y.W)(v.a), (0, s.__metadata)("design:paramtypes", [m])], f);
      var w = r(87065),
        S = r(20754),
        E = r(63208);
      let _ = class {
        constructor(e) {
          this.repository = e;
        }
        execute() {
          return this.repository.autofillDisabledOnLoginsAndFormsNotificationStatus.get$.pipe((0, w.U)(g.Vp));
        }
      };
      _ = (0, s.__decorate)([(0, S.e)(E.z), (0, s.__metadata)("design:paramtypes", [m])], _);
      let b = class {};
      b = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n._,
            handlers: {
              commands: { setAutofillDisabledOnLoginsAndFormsNotificationStatus: f },
              events: {},
              queries: { getAutofillDisabledOnLoginsAndFormsNotificationStatus: _ }
            },
            stores: [p],
            providers: [m],
            requiredFeatureFlips: Object.values(i.G)
          })
        ],
        b
      );
    },
    61845: (e, t, r) => {
      "use strict";
      r.d(t, { k: () => L });
      var s = r(88802),
        a = r(99634),
        n = r(38554),
        i = r(63663),
        o = r(93555),
        c = r(87279),
        u = r(53576);
      let d = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        async execute() {
          const { carbon: e } = this.carbonLegacyClient.commands,
            t = await e({ name: "resetProtectedItemAutofillTimer", args: [] });
          return (0, c.hx)(t)
            ? (0, c.Rn)({ tag: "ResetProtectedItemAutofillTimer command from autofill/security failed" })
            : (0, c.Vp)(void 0);
        }
      };
      d = (0, s.__decorate)([(0, i.W)(o.y), (0, s.__metadata)("design:paramtypes", [u.CarbonLegacyClient])], d);
      var l = r(87065),
        p = r(85390),
        h = r(69885),
        m = r(60399),
        y = r(57924),
        g = r(78364),
        v = r(52434),
        f = r(95681),
        w = r(23347),
        S = r(25029),
        E = r(10722),
        _ = r(64718);
      const b = (e) =>
        !!e &&
        "object" == typeof e &&
        Object.values(e).every((e) => Array.isArray(e)) &&
        Object.keys(e).every((e) => new _.Y(e).isUrlValid());
      class T extends (0, f.Q)({
        persist: !0,
        storage: { initialValue: {}, typeGuard: b, schemaVersion: 1 },
        scope: S.F.User,
        storeName: "phishing-prevention-optouts",
        capacity: w.Y._010KB,
        codec: E.E
      }) {}
      var A = r(53998);
      let C = class {
        constructor(e, t) {
          (this.carbonLegacyClient = e),
            (this.store = t),
            (this._isPhishingPreventionEnabled = () => {
              const { carbonState: e } = this.carbonLegacyClient.queries;
              return e({ path: "userSession.localSettings.nodePremiumStatus" }).pipe(
                (0, l.U)((e) => {
                  if (!(0, c.d6)(e)) throw new Error("Cannot retrieve premium status");
                  const t = e.data;
                  return t.capabilities?.autofillWithPhishingPrevention.enabled ?? !1;
                })
              );
            }),
            (this.isUserSSO = () => {
              const { carbonState: e } = this.carbonLegacyClient.queries;
              return e({ path: "userSession.localSettings.premiumStatus" }).pipe(
                (0, l.U)((e) => {
                  if (!(0, c.d6)(e)) throw new Error("Cannot retrieve premium status");
                  return e.spaces;
                }),
                (0, l.U)((e) => e?.[0].isSSOUser ?? !1)
              );
            }),
            (this.areProtectedItemsUnlocked = () => {
              const { carbonState: e } = this.carbonLegacyClient.queries;
              return (0, p.a)([e({ path: "userSession.session.lastMasterPasswordCheck" }), e({ path: "userSession.account.login" })]).pipe(
                (0, l.U)(([e, t]) => {
                  if (!(0, c.d6)(e) || "number" != typeof e.data) throw new Error("Cannot retrieve last master password check");
                  if (!(0, c.d6)(t) || "string" != typeof t.data) throw new Error("No active login");
                  const r = e.data,
                    s = t.data;
                  return Date.now() - r < (/^kw_test_auto_fmpc_.*/.test(s) ? 5e3 : 3e5);
                })
              );
            }),
            (this.isItemUnlocked = () => (0, p.a)([this.areProtectedItemsUnlocked(), this.isUserSSO()]).pipe((0, l.U)(([e, t]) => e || t))),
            (this.isGlobalCredentialProtectionSettingOn = () => {
              const { carbonState: e } = this.carbonLegacyClient.queries;
              return e({ path: "userSession.personalSettings.ProtectPasswords" }).pipe(
                (0, l.U)((e) => {
                  if (!(0, c.d6)(e) || "boolean" != typeof e.data) throw new Error("No global setting found");
                  return e.data;
                })
              );
            }),
            (this.getCredentialProtectionStatus = (e) => {
              const { carbonState: t } = this.carbonLegacyClient.queries;
              return t({ path: "userSession.personalData.credentials" }).pipe(
                (0, l.U)((t) => {
                  if (!(0, c.d6)(t) || !(0, A.A)(t.data)) throw new Error("Bad credential format");
                  const r = t.data;
                  return r.find((t) => t.Id === e)?.AutoProtected ?? !1;
                })
              );
            }),
            (this.getIsMPRequiredForCreditCardOrSocialSecurityId = () => {
              const { carbonState: e } = this.carbonLegacyClient.queries;
              return e({ path: "userSession.personalSettings.SecuredDataAutofillCreditcard" }).pipe(
                (0, l.U)((e) => !(0, c.d6)(e) || "boolean" != typeof e.data || e.data)
              );
            }),
            (this._isVaultItemProtected = (e, t) =>
              e === g.k.PaymentCard || e === g.k.SocialSecurityId
                ? (0, p.a)([this.isItemUnlocked(), this.getIsMPRequiredForCreditCardOrSocialSecurityId()]).pipe(
                    (0, l.U)(([e, t]) => ({ disableMode: v.M.CannotDisable, isProtected: t && !e }))
                  )
                : e === g.k.Credential
                ? (0, p.a)([
                    this.isItemUnlocked(),
                    this.isGlobalCredentialProtectionSettingOn(),
                    this.getCredentialProtectionStatus(t)
                  ]).pipe(
                    (0, l.U)(([e, t, r]) =>
                      t
                        ? { disableMode: v.M.DisableGeneralSetting, isProtected: !e }
                        : { disableMode: v.M.DisableSpecificVaultItem, isProtected: r && !e }
                    )
                  )
                : (0, h.of)({ disableMode: v.M.CannotDisable, isProtected: !1 }));
        }
        getIsVaultItemProtected$(e, t) {
          return this._isVaultItemProtected(e, t).pipe((0, l.U)(c.Vp));
        }
        getIsPhishingPreventionEnabled$() {
          return this._isPhishingPreventionEnabled().pipe((0, l.U)(c.Vp));
        }
        get phishingPreventionOptOuts() {
          return { get$: this._getPhishingPreventionOptOuts$, set$: this._setPhishingPreventionOptOut.bind(this) };
        }
        async disablePhishingPreventionForUrl(e, t) {
          const r = await (0, m.z)(this._getPhishingPreventionOptOuts$),
            s = { ...r, [e]: Array.from(new Set(r[e] ?? []).add(t)) };
          await this._setPhishingPreventionOptOut(s);
        }
        get _getPhishingPreventionOptOuts$() {
          return this.store.state$;
        }
        async _setPhishingPreventionOptOut(e) {
          try {
            await this.store.set(e);
          } catch {
            throw new Error("SetPhishingPreventionOptOut command from autofill-core has failed");
          }
        }
      };
      C = (0, s.__decorate)([(0, y.GS)(), (0, s.__metadata)("design:paramtypes", [u.CarbonLegacyClient, T])], C);
      var R = r(20754),
        I = r(51730);
      let x = class {
        constructor(e) {
          this.autofillSecurity = e;
        }
        execute({ body: e }) {
          const { vaultItemId: t, vaultType: r } = e;
          return this.autofillSecurity.getIsVaultItemProtected$(r, t);
        }
      };
      x = (0, s.__decorate)([(0, R.e)(I.u), (0, s.__metadata)("design:paramtypes", [C])], x);
      var P = r(5282);
      let D = class {
        constructor(e) {
          this.autofillSecurity = e;
        }
        execute() {
          return this.autofillSecurity.getIsPhishingPreventionEnabled$();
        }
      };
      D = (0, s.__decorate)([(0, R.e)(P.i), (0, s.__metadata)("design:paramtypes", [C])], D);
      var U = r(94370);
      let F = class {
        constructor(e) {
          this.autofillSecurityRepository = e;
        }
        async execute({ body: { credentialUrl: e, pasteDestinationUrl: t } }) {
          return await this.autofillSecurityRepository.disablePhishingPreventionForUrl(e, t), (0, c.Vp)(void 0);
        }
      };
      F = (0, s.__decorate)([(0, i.W)(U.z), (0, s.__metadata)("design:paramtypes", [C])], F);
      var O = r(63212);
      let N = class {
        constructor(e) {
          this.autofillSecurity = e;
        }
        execute({ body: { credentialUrl: e, pasteDestinationUrl: t } }) {
          return this.autofillSecurity.phishingPreventionOptOuts.get$.pipe(
            (0, l.U)((r) => e in r && (r[e] ?? []).includes(t)),
            (0, l.U)(c.Vp)
          );
        }
      };
      N = (0, s.__decorate)([(0, R.e)(O.v), (0, s.__metadata)("design:paramtypes", [C])], N);
      var k = r(33084);
      let L = class {};
      L = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.V,
            handlers: {
              commands: { resetProtectedItemAutofillTimer: d, disablePhishingPreventionForUrl: F },
              events: {},
              queries: { getAutofillProtectionContext: x, isPhishingPreventionCapabilityEnabled: D, isPhishingPreventionDisabledForUrl: N }
            },
            stores: [T],
            providers: [C],
            requiredFeatureFlips: Object.values(k.G)
          })
        ],
        L
      );
    },
    53998: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => s });
      const s = (e) => Array.isArray(e);
    },
    29748: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => me });
      var s = r(88802),
        a = r(99634),
        n = r(69029),
        i = r(33084),
        o = r(63663),
        c = r(50163),
        u = r(87279),
        d = r(53576);
      let l = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        async execute({ body: e }) {
          const { isAutofillEnabled: t, url: r } = e,
            { carbon: s } = this.carbonLegacyClient.commands,
            a = await s({ name: "toggleDashlane", args: [{ where: "site", autofill: t, autologin: t, url: r }] });
          if ((0, u.hx)(a)) throw new Error("Toggle Dashlane command from core-autofill failed");
          return (0, u.Vp)(void 0);
        }
      };
      l = (0, s.__decorate)([(0, o.W)(c.r), (0, s.__metadata)("design:paramtypes", [d.CarbonLegacyClient])], l);
      var p = r(87065),
        h = r(85390),
        m = r(43978),
        y = r(20754),
        g = r(64718),
        v = r(68573),
        f = r(28489);
      var w, S, E;
      !(function (e) {
        e[(e.UNKNOWN_ERROR = 0)] = "UNKNOWN_ERROR";
      })(w || (w = {})),
        (function (e) {
          (e.EMAIL_TOKEN = "email_token"), (e.DEVICE_REGISTRATION = "totp_device_registration"), (e.LOGIN = "totp_login"), (e.SSO = "sso");
        })(S || (S = {})),
        (function (e) {
          (e[(e.UNKNOWN = 0)] = "UNKNOWN"), (e[(e.PENDING = 1)] = "PENDING"), (e[(e.ERROR = 2)] = "ERROR"), (e[(e.READY = 3)] = "READY");
        })(E || (E = {}));
      const _ = (e) => {
          if (!(t = e) || "object" != typeof t || !(0, f.l$)(t, "status") || "number" != typeof t.status)
            throw new Error("twoFactorAuthentication is not of the expected type");
          var t;
          return e.status === E.READY && e.shouldEnforceTwoFactorAuthentication;
        },
        b = (e) => !!e && "object" == typeof e && Array.isArray(e) && e.every((e) => "string" == typeof e);
      var T = r(60399),
        A = r(97280),
        C = r(57924),
        R = r(46154);
      let I = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        get isAutofillDisabled() {
          return { get$: this._getIsAutofillDisabled$, set: this._setIsAutofillDisabled.bind(this) };
        }
        get isAutologinDisabled() {
          return { get$: this._getIsAutologinDisabled$, set: this._setIsAutologinDisabled.bind(this) };
        }
        get disabledDomains() {
          return {
            get$: this._getDisabledDomains$,
            set: this._setDisabledDomains.bind(this),
            add: this._addDisabledDomains.bind(this),
            remove: this._removeDisabledDomains.bind(this)
          };
        }
        get disabledSourceTypes() {
          return {
            get$: this._getDisabledSourceTypes$,
            set: this._setDisabledSourceTypes.bind(this),
            add: this._addDisabledSourceTypes.bind(this),
            remove: this._removeDisabledSourceTypes.bind(this)
          };
        }
        get isFollowUpNotificationEnabled() {
          return { get$: this._getIsFollowUpNotificationEnabled$, set: this._setIsFollowUpNotificationEnabled.bind(this) };
        }
        async _updateSettings(e) {
          const t = e.isAutofillDisabled ?? (await (0, T.z)(this._getIsAutofillDisabled$)),
            r = e.isAutologinDisabled ?? (await (0, T.z)(this._getIsAutologinDisabled$)),
            s = e.disabledDomains ?? (await (0, T.z)(this._getDisabledDomains$)),
            a = e.disabledSourceTypes ?? (await (0, T.z)(this._getDisabledSourceTypes$)),
            n = e.isFollowUpNotificationEnabled ?? (await (0, T.z)(this._getIsFollowUpNotificationEnabled$)),
            i = await this.carbonLegacyClient.commands.carbon({
              name: "updateAutofillSettings",
              args: [
                {
                  AutofillSettings: {
                    disabledDomains: s,
                    disabledSourceTypes: a,
                    isAutofillDisabled: t,
                    isAutologinDisabled: r,
                    isFollowUpNotificationEnabled: n
                  }
                }
              ]
            });
          if ((0, u.hx)(i)) throw new Error("Error when updating autofill settings using updateAutofillSettings query from Carbon");
        }
        get _getAutofillSettings$() {
          const { carbonState: e } = this.carbonLegacyClient.queries;
          return e({ path: "userSession.personalSettings.AutofillSettings" }).pipe(
            (0, p.U)((e) => {
              if (
                !(0, u.d6)(e) ||
                !((e) =>
                  !!e &&
                  "object" == typeof e &&
                  (0, f.l$)(e, "isAutofillDisabled") &&
                  "boolean" == typeof e.isAutofillDisabled &&
                  (0, f.l$)(e, "isAutologinDisabled") &&
                  "boolean" == typeof e.isAutologinDisabled &&
                  (0, f.l$)(e, "disabledSourceTypes") &&
                  (0, R.rF)(e.disabledSourceTypes) &&
                  (0, f.l$)(e, "disabledDomains") &&
                  Array.isArray(e.disabledDomains) &&
                  e.disabledDomains.every((e) => "string" == typeof e) &&
                  (0, f.l$)(e, "isFollowUpNotificationEnabled") &&
                  "boolean" == typeof e.isFollowUpNotificationEnabled)(e.data)
              )
                throw new Error("AutofillSettings is not of the expected type");
              return e.data;
            }),
            (0, A.d)(1)
          );
        }
        get _getIsAutofillDisabled$() {
          return this._getAutofillSettings$.pipe((0, p.U)(({ isAutofillDisabled: e }) => e));
        }
        _setIsAutofillDisabled(e) {
          return this._updateSettings({ isAutofillDisabled: e });
        }
        get _getIsAutologinDisabled$() {
          return this._getAutofillSettings$.pipe((0, p.U)(({ isAutologinDisabled: e }) => e));
        }
        _setIsAutologinDisabled(e) {
          return this._updateSettings({ isAutologinDisabled: e });
        }
        _setIsFollowUpNotificationEnabled(e) {
          return this._updateSettings({ isFollowUpNotificationEnabled: e });
        }
        get _getDisabledDomains$() {
          return this._getAutofillSettings$.pipe((0, p.U)(({ disabledDomains: e }) => e));
        }
        _setDisabledDomains(e) {
          return this._updateSettings({ disabledDomains: e });
        }
        async _addDisabledDomains(e) {
          const t = await (0, T.z)(this._getDisabledDomains$);
          return this._setDisabledDomains([...new Set([...t, ...e])]);
        }
        async _removeDisabledDomains(e) {
          const t = await (0, T.z)(this._getDisabledDomains$);
          return this._setDisabledDomains(t.filter((t) => !e.includes(t)));
        }
        get _getDisabledSourceTypes$() {
          return this._getAutofillSettings$.pipe((0, p.U)(({ disabledSourceTypes: e }) => e));
        }
        _setDisabledSourceTypes(e) {
          return this._updateSettings({ disabledSourceTypes: e });
        }
        async _addDisabledSourceTypes(e) {
          const t = await (0, T.z)(this._getDisabledSourceTypes$);
          return this._setDisabledSourceTypes([...new Set([...t, ...e])]);
        }
        async _removeDisabledSourceTypes(e) {
          const t = await (0, T.z)(this._getDisabledSourceTypes$);
          return this._setDisabledSourceTypes(t.filter((t) => !e.includes(t)));
        }
        get _getIsFollowUpNotificationEnabled$() {
          return this._getAutofillSettings$.pipe((0, p.U)(({ isFollowUpNotificationEnabled: e }) => e));
        }
      };
      I = (0, s.__decorate)([(0, C.GS)(), (0, s.__metadata)("design:paramtypes", [d.CarbonLegacyClient])], I);
      let x = class {
        constructor(e, t) {
          (this.carbonLegacyClient = e), (this.settings = t);
        }
        execute({ body: { url: e } }) {
          const { carbonState: t } = this.carbonLegacyClient.queries,
            r = new g.Y(e),
            s = r.getRootDomain(),
            a = r.getHost(),
            n = t({ path: "device.killswitch.disableAutofill" }).pipe(
              (0, p.U)((e) => {
                if (!(0, u.d6)(e) || !((e) => "boolean" == typeof e)(e.data))
                  throw new Error("Error when fetching killswitch.disableAutofill");
                return e.data;
              })
            ),
            i = (0, h.a)({
              isAutofillDisabled: this.settings.isAutofillDisabled.get$,
              disabledDomains: this.settings.disabledDomains.get$
            }).pipe((0, m.w)(async ({ isAutofillDisabled: e, disabledDomains: t }) => e || t.includes(await s))),
            o = t({ path: "userSession.spaceData.spaces" }).pipe(
              (0, m.w)(async (e) => {
                if (
                  !(0, u.d6)(e) ||
                  !((e) =>
                    !!e &&
                    "object" == typeof e &&
                    Array.isArray(e) &&
                    e.every((e) => (0, f.l$)(e, "details") && (0, f.l$)(e.details, "info")))(e.data)
                )
                  throw new Error("Error when fetching spaceData.spaces");
                const t = e.data.reduce((e, t) => {
                    const r = t.details.info.autologinDomainDisabledArray;
                    return [...e, ...(b(r) ? r : [])];
                  }, []),
                  r = await a;
                return t.some((e) => {
                  const t = new g.Y(e).getHost();
                  return t === r || r.endsWith(`.${t}`);
                });
              })
            ),
            c = t({ path: "authentication.twoFactorAuthentication" }).pipe(
              (0, p.U)((e) => {
                if (!(0, u.d6)(e)) throw new Error("Error when fetching authentication.twoFactorAuthentication");
                return _(e.data);
              })
            );
          return (0, h.a)({
            isAutofillDisabledByB2BAdmin: o,
            isAutofillDisabledByKillswitch: n,
            isAutofillDisabledByUser: i,
            isAutofillDisabledBy2FAEnforcement: c
          }).pipe(
            (0, p.U)(
              ({
                isAutofillDisabledBy2FAEnforcement: e,
                isAutofillDisabledByB2BAdmin: t,
                isAutofillDisabledByKillswitch: r,
                isAutofillDisabledByUser: s
              }) => {
                let a = v._.ANALYSIS_ENABLED;
                return (
                  r
                    ? (a = v._.ANALYSIS_DISABLED_BY_KILLSWITCH)
                    : t
                    ? (a = v._.ANALYSIS_DISABLED_BY_B2B_ADMIN)
                    : s
                    ? (a = v._.ANALYSIS_DISABLED_BY_USER)
                    : e && (a = v._.ANALYSIS_DISABLED_BY_2FA_ENFORCEMENT),
                  (0, u.Vp)({ analysisStatus: a })
                );
              }
            )
          );
        }
      };
      x = (0, s.__decorate)([(0, y.e)(v.h), (0, s.__metadata)("design:paramtypes", [d.CarbonLegacyClient, I])], x);
      var P = r(63267);
      let D = class {
        constructor(e) {
          this.settings = e;
        }
        execute() {
          return (0, h.a)({
            disabledDomains: this.settings.disabledDomains.get$,
            disabledSourceTypes: this.settings.disabledSourceTypes.get$,
            isAutofillDisabled: this.settings.isAutofillDisabled.get$,
            isAutologinDisabled: this.settings.isAutologinDisabled.get$,
            isFollowUpNotificationEnabled: this.settings.isFollowUpNotificationEnabled.get$
          }).pipe((0, p.U)(u.Vp));
        }
      };
      D = (0, s.__decorate)([(0, y.e)(P.T), (0, s.__metadata)("design:paramtypes", [I])], D);
      var U = r(99682);
      let F = class {
        constructor(e) {
          this.settings = e;
        }
        async execute({ body: { sourceTypes: e } }) {
          return await this.settings.disabledSourceTypes.add(e), (0, u.Vp)(void 0);
        }
      };
      F = (0, s.__decorate)([(0, o.W)(U.g), (0, s.__metadata)("design:paramtypes", [I])], F);
      var O = r(46918);
      let N = class {
        constructor(e) {
          this.settings = e;
        }
        async execute({ body: { sourceTypes: e } }) {
          return await this.settings.disabledSourceTypes.remove(e), (0, u.Vp)(void 0);
        }
      };
      N = (0, s.__decorate)([(0, o.W)(O.v), (0, s.__metadata)("design:paramtypes", [I])], N);
      var k = r(54405);
      let L = class {
        constructor(e) {
          this.settings = e;
        }
        async execute() {
          return await this.settings.isAutofillDisabled.set(!1), (0, u.Vp)(void 0);
        }
      };
      L = (0, s.__decorate)([(0, o.W)(k.c), (0, s.__metadata)("design:paramtypes", [I])], L);
      var M = r(3909);
      let V = class {
        constructor(e) {
          this.settings = e;
        }
        async execute() {
          return await this.settings.isAutofillDisabled.set(!0), (0, u.Vp)(void 0);
        }
      };
      V = (0, s.__decorate)([(0, o.W)(M.u), (0, s.__metadata)("design:paramtypes", [I])], V);
      var G = r(4924);
      let j = class {
        constructor(e) {
          this.settings = e;
        }
        async execute() {
          return await this.settings.isAutologinDisabled.set(!1), (0, u.Vp)(void 0);
        }
      };
      j = (0, s.__decorate)([(0, o.W)(G.i), (0, s.__metadata)("design:paramtypes", [I])], j);
      var q = r(34962);
      let K = class {
        constructor(e) {
          this.settings = e;
        }
        async execute() {
          return await this.settings.isAutologinDisabled.set(!0), (0, u.Vp)(void 0);
        }
      };
      K = (0, s.__decorate)([(0, o.W)(q.T), (0, s.__metadata)("design:paramtypes", [I])], K);
      var W = r(38018);
      let B = class {
        constructor(e) {
          this.settings = e;
        }
        async execute() {
          return await this.settings.disabledSourceTypes.remove([...R.up]), (0, u.Vp)(void 0);
        }
      };
      B = (0, s.__decorate)([(0, o.W)(W.a), (0, s.__metadata)("design:paramtypes", [I])], B);
      var z = r(69643);
      let H = class {
        constructor(e) {
          this.settings = e;
        }
        async execute() {
          return await this.settings.disabledSourceTypes.remove([...R.q_]), (0, u.Vp)(void 0);
        }
      };
      H = (0, s.__decorate)([(0, o.W)(z.I), (0, s.__metadata)("design:paramtypes", [I])], H);
      var $ = r(82796);
      let Q = class {
        constructor(e) {
          this.settings = e;
        }
        async execute() {
          return await this.settings.isFollowUpNotificationEnabled.set(!0), (0, u.Vp)(void 0);
        }
      };
      Q = (0, s.__decorate)([(0, o.W)($.B), (0, s.__metadata)("design:paramtypes", [I])], Q);
      var Y = r(65791);
      let X = class {
        constructor(e) {
          this.settings = e;
        }
        async execute() {
          return await this.settings.disabledSourceTypes.add([...R.up]), (0, u.Vp)(void 0);
        }
      };
      X = (0, s.__decorate)([(0, o.W)(Y.t), (0, s.__metadata)("design:paramtypes", [I])], X);
      var J = r(56e3);
      let Z = class {
        constructor(e) {
          this.settings = e;
        }
        async execute() {
          return await this.settings.disabledSourceTypes.add([...R.q_]), (0, u.Vp)(void 0);
        }
      };
      Z = (0, s.__decorate)([(0, o.W)(J.f), (0, s.__metadata)("design:paramtypes", [I])], Z);
      var ee = r(11232);
      let te = class {
        constructor(e) {
          this.settings = e;
        }
        async execute() {
          return await this.settings.isFollowUpNotificationEnabled.set(!1), (0, u.Vp)(void 0);
        }
      };
      te = (0, s.__decorate)([(0, o.W)(ee.y), (0, s.__metadata)("design:paramtypes", [I])], te);
      var re = r(29641),
        se = r(3124),
        ae = r(95681),
        ne = r(23347),
        ie = r(25029),
        oe = r(10722);
      const ce = (e) => !!e && (0, se.P)(e);
      class ue extends (0, ae.Q)({
        persist: !0,
        storage: { initialValue: [], typeGuard: ce, schemaVersion: 1 },
        scope: ie.F.Device,
        storeName: "user-autofill-corrections",
        capacity: ne.Y._100KB,
        codec: oe.E
      }) {}
      let de = class {
        constructor(e) {
          this.store = e;
        }
        get userAutofillCorrections() {
          return { get$: this._getUserAutofillCorrections$, set: this._setUserAutofillCorrections.bind(this) };
        }
        get _getUserAutofillCorrections$() {
          return this.store.state$;
        }
        async _setUserAutofillCorrections(e) {
          try {
            await this.store.set(e);
          } catch {
            throw new Error("SetUserAutofillCorrections command from core-autofill failed");
          }
        }
      };
      de = (0, s.__decorate)([(0, C.GS)(), (0, s.__metadata)("design:paramtypes", [ue])], de);
      let le = class {
        constructor(e) {
          this.correctionsRepository = e;
        }
        async execute({ body: e }) {
          const { corrections: t } = e;
          return await this.correctionsRepository.userAutofillCorrections.set(t), (0, u.Vp)(void 0);
        }
      };
      le = (0, s.__decorate)([(0, o.W)(re.S), (0, s.__metadata)("design:paramtypes", [de])], le);
      var pe = r(3414);
      let he = class {
        constructor(e) {
          this.settings = e;
        }
        execute() {
          return this.settings.userAutofillCorrections.get$.pipe((0, p.U)(u.Vp));
        }
      };
      he = (0, s.__decorate)([(0, y.e)(pe.w), (0, s.__metadata)("design:paramtypes", [de])], he);
      let me = class {};
      me = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.I,
            handlers: {
              commands: {
                toggleDashlane: l,
                enableAnalysis: L,
                enableAutologin: j,
                enableAutofillOnForms: B,
                enableAutofillOnLogins: H,
                enableFollowUpNotification: Q,
                disableAnalysis: V,
                disableAutologin: K,
                disableAutofillOnForms: X,
                disableAutofillOnLogins: Z,
                disableFollowUpNotification: te,
                addDisabledSourceTypes: F,
                removeDisabledSourceTypes: N,
                setUserAutofillCorrections: le
              },
              events: {},
              queries: { getAnalysisStatusOnUrl: x, getAutofillSettings: D, getUserAutofillCorrections: he }
            },
            stores: [ue],
            providers: [I, de],
            requiredFeatureFlips: Object.values(i.G)
          })
        ],
        me
      );
    },
    92137: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          DismissMasterPasswordNotificationCommand: () => a.T,
          IsMasterPasswordLeakedQuery: () => c.B,
          IsMasterPasswordNotificationDismissedQuery: () => u.F,
          IsMasterPasswordWeakQuery: () => d.D,
          TemporaryCheckMasterPasswordCommand: () => n.T,
          TemporaryCheckMasterPasswordWeakCommand: () => o.B,
          TemporaryResetMasterPasswordLeakedCommand: () => i.j,
          masterPasswordSecurityApi: () => s.J
        });
      var s = r(75962),
        a = r(80673),
        n = r(88030),
        i = r(30600),
        o = r(5105),
        c = r(22730),
        u = r(23913),
        d = r(86695);
    },
    75962: (e, t, r) => {
      "use strict";
      r.d(t, { J: () => l });
      var s = r(86952),
        a = r(80673),
        n = r(88030),
        i = r(30600),
        o = r(5105),
        c = r(22730),
        u = r(86695),
        d = r(23913);
      const l = (0, s.Q)({
        name: "masterPasswordSecurity",
        commands: {
          dismissMasterPasswordNotification: a.T,
          temporaryCheckMasterPassword: n.T,
          temporaryResetMasterPasswordLeaked: i.j,
          temporaryCheckMasterPasswordWeak: o.B
        },
        events: {},
        queries: { isMasterPasswordLeaked: c.B, isMasterPasswordWeak: u.D, isMasterPasswordNotificationDismissed: d.F }
      });
    },
    80673: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    5105: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    88030: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    30600: (e, t, r) => {
      "use strict";
      r.d(t, { j: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    22730: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => a });
      var s = r(99059);
      class a extends (0, s.k)() {}
    },
    23913: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => a });
      var s = r(99059);
      class a extends (0, s.k)() {}
    },
    86695: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => a });
      var s = r(99059);
      class a extends (0, s.k)() {}
    },
    97500: (e, t, r) => {
      "use strict";
      r.d(t, { f: () => Ue });
      var s = r(99634),
        a = r(75962),
        n = r(37935),
        i = r(1824),
        o = r(70305),
        c = r(20754),
        u = r(22730),
        d = r(25029),
        l = r(95681),
        p = r(23347),
        h = r(10722),
        m = r(7165);
      const y = m.z.object({
          isMasterPasswordLeaked: m.z.boolean(),
          isMasterPasswordNotificationDismissed: m.z.boolean(),
          isMasterPasswordWeak: m.z.boolean(),
          lastCheckTimestamp: m.z.number()
        }),
        g = (e) => y.safeParse(e).success;
      class v extends (0, l.Q)({
        persist: !0,
        storage: {
          initialValue: {
            isMasterPasswordWeak: !1,
            isMasterPasswordLeaked: !1,
            isMasterPasswordNotificationDismissed: !1,
            lastCheckTimestamp: 0
          },
          typeGuard: g,
          schemaVersion: 1
        },
        scope: d.F.User,
        isCache: !0,
        storeName: "master-password-security",
        codec: h.E,
        capacity: p.Y._001KB
      }) {}
      var f = r(87279),
        w = r(87065),
        S = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        E = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let _ = class {
        constructor(e) {
          this.masterPasswordSecurityStore = e;
        }
        execute() {
          return this.masterPasswordSecurityStore.state$.pipe((0, w.U)((e) => (0, f.Vp)(e.isMasterPasswordLeaked)));
        }
      };
      _ = S([(0, c.e)(u.B), E("design:paramtypes", [v])], _);
      var b = r(86695),
        T = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        A = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let C = class {
        constructor(e) {
          this.masterPasswordSecurityStore = e;
        }
        execute() {
          return this.masterPasswordSecurityStore.state$.pipe((0, w.U)((e) => (0, f.Vp)(e.isMasterPasswordWeak)));
        }
      };
      C = T([(0, c.e)(b.D), A("design:paramtypes", [v])], C);
      var R = r(23913),
        I = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        x = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let P = class {
        constructor(e) {
          this.masterPasswordSecurityStore = e;
        }
        execute() {
          return this.masterPasswordSecurityStore.state$.pipe((0, w.U)((e) => (0, f.Vp)(e.isMasterPasswordNotificationDismissed)));
        }
      };
      P = I([(0, c.e)(R.F), x("design:paramtypes", [v])], P);
      var D = r(63663),
        U = r(80673),
        F = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        O = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let N = class {
        constructor(e) {
          this.masterPasswordSecurityStore = e;
        }
        async execute() {
          const e = await this.masterPasswordSecurityStore.getState();
          return (
            await this.masterPasswordSecurityStore.set({ ...e, isMasterPasswordNotificationDismissed: !0 }),
            Promise.resolve((0, f.Vp)(void 0))
          );
        }
      };
      N = F([(0, D.W)(U.T), O("design:paramtypes", [v])], N);
      var k = r(88030),
        L = r(57924),
        M = r(61501),
        V = r(60399),
        G = r(79256),
        j = r(96303),
        q = r(54066),
        K = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        W = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let B = class {
        constructor(e) {
          this.argon2dDeriver = e;
        }
        async hash(e) {
          return (0, j.k)(
            await this.argon2dDeriver.derive((0, q.u)(e), (0, q.u)("z8CXohryCcGAa7CESNHYnedqbDyp"), {
              tCost: 3,
              mCost: 32768,
              parallelism: 2
            })
          );
        }
      };
      B = K([(0, L.GS)(), W("design:paramtypes", [G.y])], B);
      var z = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        H = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let $ = class {
        constructor(e, t, r) {
          (this.serverApiClient = e), (this.masterPasswordSecurityStore = t), (this.passwordHasher = r);
        }
        shouldBeChecked() {
          return (0, V.z)(
            this.masterPasswordSecurityStore.state$.pipe(
              (0, w.U)((e) => !e.isMasterPasswordLeaked && e.lastCheckTimestamp + 864e5 <= Date.now())
            )
          );
        }
        async check(e) {
          const t = await this.passwordHasher.hash(e),
            r = await (0, V.z)(this.serverApiClient.v1.pwleak.getHashes({ hashPrefix: t.substring(0, 6) }));
          if ((0, f.hx)(r)) throw new Error("Error while retrieving list of hashes for MP checking");
          const s = r.data.data.includes(t),
            a = await this.masterPasswordSecurityStore.getState();
          return await this.masterPasswordSecurityStore.set({ ...a, isMasterPasswordLeaked: s, lastCheckTimestamp: Date.now() });
        }
      };
      $ = z([(0, L.GS)(), H("design:paramtypes", [M.l, v, B])], $);
      var Q = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        Y = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let X = class {
        constructor(e) {
          this.masterPasswordSecurityStore = e;
        }
        async reset() {
          const e = await this.masterPasswordSecurityStore.getState();
          return await this.masterPasswordSecurityStore.set({ ...e, isMasterPasswordNotificationDismissed: !1 });
        }
      };
      X = Q([(0, L.GS)(), Y("design:paramtypes", [v])], X);
      var J = r(94189),
        Z = r(20587),
        ee = r(60765),
        te = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        re = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let se = class {
        constructor(e, t) {
          (this.masterPasswordSecurityStore = e), (this.cqrsClient = t);
        }
        async send() {
          const {
              commands: { trackEvent: e }
            } = this.cqrsClient.getClient(Z.Yu),
            t = await this.masterPasswordSecurityStore.getState();
          await e({ event: new ee.AnonymousMasterPasswordHealthReportEvent({ isLeaked: t.isMasterPasswordLeaked }) });
        }
      };
      se = te([(0, L.GS)(), re("design:paramtypes", [v, J.w])], se);
      var ae = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        ne = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let ie = class {
        constructor(e, t, r) {
          (this.checkMasterPasswordService = e),
            (this.resetMasterPasswordNotification = t),
            (this.anonymousMasterPasswordLeakedTrackingEventSender = r);
        }
        async execute({ body: e }) {
          return (
            await this.resetMasterPasswordNotification.reset(),
            (await this.checkMasterPasswordService.shouldBeChecked())
              ? (await this.checkMasterPasswordService.check(e.password),
                this.anonymousMasterPasswordLeakedTrackingEventSender.send(),
                Promise.resolve((0, f.Vp)(void 0)))
              : Promise.resolve((0, f.Vp)(void 0))
          );
        }
      };
      ie = ae([(0, D.W)(k.T), ne("design:paramtypes", [$, X, se])], ie);
      var oe = r(30600),
        ce = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        ue = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let de = class {
        constructor(e) {
          this.masterPasswordSecurityStore = e;
        }
        async execute() {
          const e = await this.masterPasswordSecurityStore.getState();
          return (
            await this.masterPasswordSecurityStore.set({
              ...e,
              lastCheckTimestamp: 0,
              isMasterPasswordLeaked: !1,
              isMasterPasswordNotificationDismissed: !1
            }),
            Promise.resolve((0, f.Vp)(void 0))
          );
        }
      };
      de = ce([(0, D.W)(oe.j), ue("design:paramtypes", [v])], de);
      var le = r(5105),
        pe = r(85465);
      const he = async (e) => {
        if (e) return (await (async (e) => (await (0, pe.evaluate)(e)).score)(e)) / 25;
      };
      var me = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        ye = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let ge = class {
        constructor(e) {
          this.masterPasswordSecurityStore = e;
        }
        async check(e) {
          const t = ((await he(e)) ?? 5) < 3,
            r = await this.masterPasswordSecurityStore.getState();
          return await this.masterPasswordSecurityStore.set({ ...r, isMasterPasswordWeak: t });
        }
      };
      ge = me([(0, L.GS)(), ye("design:paramtypes", [v])], ge);
      var ve = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        fe = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let we = class {
        constructor(e, t) {
          (this.masterPasswordSecurityStore = e), (this.cqrsClient = t);
        }
        async send() {
          const {
              commands: { trackEvent: e }
            } = this.cqrsClient.getClient(Z.Yu),
            t = await this.masterPasswordSecurityStore.getState();
          await e({ event: new ee.AnonymousMasterPasswordHealthReportEvent({ isWeak: t.isMasterPasswordWeak }) });
        }
      };
      we = ve([(0, L.GS)(), fe("design:paramtypes", [v, J.w])], we);
      var Se = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        Ee = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let _e = class {
        constructor(e, t, r) {
          (this.checkMasterPasswordWeakService = e),
            (this.anonymousMasterPasswordWeakTrackingEventSender = t),
            (this.resetMasterPasswordNotification = r);
        }
        async execute({ body: e }) {
          return (
            await this.resetMasterPasswordNotification.reset(),
            await this.checkMasterPasswordWeakService.check(e.password),
            this.anonymousMasterPasswordWeakTrackingEventSender.send(),
            Promise.resolve((0, f.Vp)(void 0))
          );
        }
      };
      _e = Se([(0, D.W)(le.B), Ee("design:paramtypes", [ge, we, X])], _e);
      var be = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        Te = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let Ae = class {
        constructor(e) {
          this.masterPasswordSecurityStore = e;
        }
        async reset() {
          const e = await this.masterPasswordSecurityStore.getState();
          return await this.masterPasswordSecurityStore.set({ ...e, isMasterPasswordWeak: !1 });
        }
      };
      Ae = be([(0, L.GS)(), Te("design:paramtypes", [v])], Ae);
      var Ce = r(68307),
        Re = r(67490),
        Ie = function (e, t, r, s) {
          var a,
            n = arguments.length,
            i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
          else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
          return n > 3 && i && Object.defineProperty(t, r, i), i;
        },
        xe = function (e, t) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t);
        };
      let Pe = class {
        constructor(e) {
          this.resetMasterPasswordWeak = e;
        }
        handle() {
          return this.resetMasterPasswordWeak.reset(), Promise.resolve(void 0);
        }
      };
      Pe = Ie([(0, Ce.b)(Re.D), xe("design:paramtypes", [Ae])], Pe);
      var De = function (e, t, r, s) {
        var a,
          n = arguments.length,
          i = n < 3 ? t : null === s ? (s = Object.getOwnPropertyDescriptor(t, r)) : s;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, s);
        else for (var o = e.length - 1; o >= 0; o--) (a = e[o]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, r, i) : a(t, r)) || i);
        return n > 3 && i && Object.defineProperty(t, r, i), i;
      };
      let Ue = class {};
      Ue = De(
        [
          (0, s.Y)({
            api: a.J,
            handlers: {
              commands: {
                dismissMasterPasswordNotification: N,
                temporaryCheckMasterPassword: ie,
                temporaryResetMasterPasswordLeaked: de,
                temporaryCheckMasterPasswordWeak: _e
              },
              events: { ...(0, s.g)(o.v, { masterPasswordChanged: Pe }) },
              queries: { isMasterPasswordLeaked: _, isMasterPasswordWeak: C, isMasterPasswordNotificationDismissed: P }
            },
            providers: [$, B, X, ge, se, we, Ae],
            imports: [n.D, i.n],
            stores: [v]
          })
        ],
        Ue
      );
    },
    43894: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => i });
      var s = r(86952),
        a = r(11730),
        n = r(9932);
      const i = (0, s.Q)({
        name: "notifications",
        commands: {},
        events: {},
        queries: { GetPlanPricingQuery: a.c, GetUserMessagesQuery: n.m }
      });
    },
    11730: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    9932: (e, t, r) => {
      "use strict";
      r.d(t, { m: () => i });
      var s,
        a = r(99059),
        n = r(25029);
      !(function (e) {
        (e.DEFAULT = "default"),
          (e.TRIAL_EXPIRED = "trial_expired"),
          (e.WEB_STORE = "web_store"),
          (e.DASHBOARD_UPGRADE = "dashboard_upgrade"),
          (e.SHARING_CENTER_FAMILY = "sharing_center_family"),
          (e.SHARING_CENTER_WORK = "sharing_center_work");
      })(s || (s = {}));
      class i extends (0, a.k)({ scope: n.F.User }) {}
    },
    80260: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => E });
      var s = r(88802),
        a = r(99634),
        n = r(43894),
        i = r(30523),
        o = r(87065),
        c = r(43978),
        u = r(20754),
        d = r(53576),
        l = r(11730),
        p = r(57924),
        h = r(61501),
        m = r(48844),
        y = r(87279);
      let g = class {
        constructor(e) {
          this.serverApiClient = e;
        }
        getPlanPricing({ login: e, userKey: t, couponCode: r, language: s, hasEssentials: a }) {
          return this.serverApiClient.v1.payments
            .getAccessibleWebOffers({ login: e, userKey: t, couponCode: r, language: s, forceFamily: !0, hasEssentials: a })
            .pipe(
              (0, m.DZ)((e) => {
                throw new Error(`GetPlanPricing failed with error: ${e}`);
              }),
              (0, m.lk)((e) => {
                const { plans: t, currency: r } = e.data,
                  { family: s } = t,
                  { offers: a, ...n } = s,
                  i = { plans: { family: { offers: a.map(({ duration: e, ...t }) => ({ billingPeriod: e, ...t })), ...n } }, currency: r };
                return (0, y.Vp)(i);
              })
            );
        }
      };
      g = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [h.l])], g);
      let v = class {
        constructor(e, t) {
          (this.carbonLegacyClient = e), (this.webOffersService = t);
        }
        execute() {
          const { carbonState: e } = this.carbonLegacyClient.queries;
          return e({ path: "userSession.account.login" }).pipe(
            (0, i.h)(y.d6),
            (0, o.U)((e) => e.data),
            (0, c.w)((e) => this.webOffersService.getPlanPricing({ login: e }))
          );
        }
      };
      v = (0, s.__decorate)([(0, u.e)(l.c), (0, s.__metadata)("design:paramtypes", [d.CarbonLegacyClient, g])], v);
      var f = r(9932);
      let w = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        execute() {
          const { carbonState: e } = this.carbonLegacyClient.queries;
          return e({ path: "userSession.localSettings.userMessages" }).pipe((0, m.Qn)((e) => e));
        }
      };
      w = (0, s.__decorate)([(0, u.e)(f.m), (0, s.__metadata)("design:paramtypes", [d.CarbonLegacyClient])], w);
      var S = r(1824);
      let E = class {};
      E = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.B,
            handlers: { commands: {}, events: {}, queries: { getPlanPricing: v, getUserMessages: w } },
            imports: [S.n],
            providers: [g]
          })
        ],
        E
      );
    },
    8122: (e, t, r) => {
      "use strict";
      r.d(t, { J: () => i });
      var s = r(86952),
        a = r(47010),
        n = r(76107);
      const i = (0, s.Q)({
        name: "antiphishing",
        commands: { addAutoRedirectedDomain: n.A },
        events: {},
        queries: { isAutoRedirectedDomain: a.U }
      });
    },
    76107: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    47010: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => a });
      var s = r(99059);
      class a extends (0, s.k)() {}
    },
    71450: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => c });
      var s = r(86952),
        a = r(26254),
        n = r(91619),
        i = r(30240),
        o = r(60135);
      const c = (0, s.Q)({
        name: "breaches",
        commands: { dismissBreach: a.n, markBreachAsSeen: n.Q },
        events: {},
        queries: { breach: i.i, unreadBreachesCount: o.L }
      });
    },
    49186: (e, t, r) => {
      "use strict";
      var s, a;
      r.d(t, { J: () => s, K: () => a }),
        (function (e) {
          (e.PENDING = "PENDING"), (e.VIEWED = "VIEWED"), (e.ACKNOWLEDGED = "ACKNOWLEDGED");
        })(s || (s = {})),
        (function (e) {
          (e.Username = "username"),
            (e.Password = "password"),
            (e.Email = "email"),
            (e.CreditCard = "creditcard"),
            (e.Phone = "phone"),
            (e.Address = "address"),
            (e.SSN = "ssn"),
            (e.IP = "ip"),
            (e.Location = "geolocation"),
            (e.PersonalInfo = "personalinfo"),
            (e.SocialNetwork = "social");
        })(a || (a = {}));
    },
    26254: (e, t, r) => {
      "use strict";
      r.d(t, { n: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    91619: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    30240: (e, t, r) => {
      "use strict";
      r.d(t, { i: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    60135: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    96248: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => u });
      var s = r(86952),
        a = r(9310),
        n = r(21444),
        i = r(94814),
        o = r(9062),
        c = r(36214);
      const u = (0, s.Q)({
        name: "emailMonitoring",
        commands: { dismissOnboardingNotification: a.n, optinEmail: n.P5, optoutEmail: i.Lc },
        events: {},
        queries: { emailList: o.dB, onboardingNotificationState: c.p }
      });
    },
    9310: (e, t, r) => {
      "use strict";
      r.d(t, { n: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    21444: (e, t, r) => {
      "use strict";
      r.d(t, { Dq: () => i, NM: () => d, Ox: () => c, P5: () => p, XX: () => o, l2: () => u, vc: () => l });
      var s = r(74354),
        a = r(25029),
        n = r(96168);
      const i = "OK";
      var o;
      !(function (e) {
        (e.INVALID_EMAIL = "EMAIL_IS_INVALID"),
          (e.ALREADY_SUBSCRIBED = "USER_HAS_ALREADY_AN_ACTIVE_SUBSCRIPTION"),
          (e.TOO_MANY_SUBSCRIPTIONS = "USER_HAS_TOO_MANY_SUBSCRIPTIONS"),
          (e.GENERIC_ERROR = "GENERIC_ERROR");
      })(o || (o = {}));
      class c extends (0, n.Hu)(o.INVALID_EMAIL, "") {}
      class u extends (0, n.Hu)(o.ALREADY_SUBSCRIBED, "") {}
      class d extends (0, n.Hu)(o.TOO_MANY_SUBSCRIPTIONS, "") {}
      class l extends (0, n.Hu)(o.GENERIC_ERROR, "") {}
      class p extends (0, s.g)({ scope: a.F.User }) {}
    },
    94814: (e, t, r) => {
      "use strict";
      r.d(t, { KP: () => o, Lc: () => l, QS: () => i, h1: () => u, uD: () => c, v4: () => d });
      var s = r(74354),
        a = r(25029),
        n = r(96168);
      const i = "OK";
      var o;
      !(function (e) {
        (e.INVALID_EMAIL = "EMAIL_IS_INVALID"), (e.NO_SUBSCRIPTION = "USER_HAS_NO_SUBSCRIPTION"), (e.GENERIC_ERROR = "GENERIC_ERROR");
      })(o || (o = {}));
      class c extends (0, n.Hu)(o.INVALID_EMAIL, "") {}
      class u extends (0, n.Hu)(o.NO_SUBSCRIPTION, "") {}
      class d extends (0, n.Hu)(o.GENERIC_ERROR, "") {}
      class l extends (0, s.g)({ scope: a.F.User }) {}
    },
    57255: (e, t, r) => {
      "use strict";
      var s;
      function a(e) {
        return "UNKNOWN" === e || "SEEN" === e || "NOT_SEEN" === e;
      }
      r.d(t, { M: () => s, U: () => a }),
        (function (e) {
          (e.UNKNOWN = "UNKNOWN"), (e.SEEN = "SEEN"), (e.NOT_SEEN = "NOT_SEEN");
        })(s || (s = {}));
    },
    9062: (e, t, r) => {
      "use strict";
      r.d(t, { a2: () => n, dB: () => i, wp: () => s });
      var s,
        a = r(99059);
      function n(e) {
        return "pending" === e || "active" === e || "disabled" === e;
      }
      !(function (e) {
        (e.PENDING = "pending"), (e.ACTIVE = "active"), (e.DISABLED = "disabled");
      })(s || (s = {}));
      class i extends (0, a.k)() {}
    },
    36214: (e, t, r) => {
      "use strict";
      r.d(t, { p: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    37284: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          AddAutoRedirectedDomainCommand: () => P.A,
          BreachLeakedDataType: () => y.K,
          BreachQuery: () => h.i,
          BreachState: () => y.J,
          CompromisedCredentialsIdsForBreachQuery: () => _.A,
          CompromisedCredentialsQuery: () => S.v,
          CorruptionDataSeverity: () => C.bp,
          CorruptionDataStrength: () => C.ub,
          CredentialHealthDataQuery: () => v.w,
          DarkWebOnboardingState: () => u.M,
          DataLeaksEmailStatus: () => o.wp,
          DismissBreachCommand: () => l.n,
          DismissOnboardingNotificationCommand: () => a.n,
          EmailsListQuery: () => o.dB,
          FilterCredentialsQuery: () => w.Q,
          HealthFilter: () => C._x,
          IsAutoRedirectedDomainQuery: () => x.U,
          MarkBreachAsSeenCommand: () => p.Q,
          OnboardingNotificationStateQuery: () => c.p,
          OptinAlreadySubscribedError: () => n.l2,
          OptinDataLeaksResultErrorCode: () => n.XX,
          OptinDataLeaksResultOkCode: () => n.Dq,
          OptinEmailCommand: () => n.P5,
          OptinGenericError: () => n.vc,
          OptinInvalidEmailError: () => n.Ox,
          OptinTooManySubscriptionsError: () => n.NM,
          OptoutDataLeaksResultErrorCode: () => i.KP,
          OptoutDataLeaksResultOkCode: () => i.QS,
          OptoutEmailCommand: () => i.Lc,
          OptoutGenericError: () => i.v4,
          OptoutInvalidEmailError: () => i.uD,
          OptoutNoSubscriptionError: () => i.h1,
          OtpCodeForSecretOrUrlGenerationError: () => F.k,
          OtpCodeForSecretOrUrlQuery: () => F.S,
          OtpCodeGenerationError: () => U.c,
          OtpCodeQuery: () => U.J,
          PasswordHealthComputationFinishedEvent: () => A.w,
          PasswordHealthReportQuery: () => E.b,
          RecalculatePasswordHealthCommand: () => T.t,
          RiskType: () => C.gI,
          ScoreQuery: () => f.e,
          UnreadBreachesCountQuery: () => m.L,
          UpdateIsCredentialExcludedCommand: () => b.v,
          antiphishingApi: () => I.J,
          breachesApi: () => d.H,
          emailMonitoringApi: () => s.M,
          isDarkWebOnboardingState: () => u.U,
          isDataLeaksEmailStatus: () => o.a2,
          otpApi: () => D.i,
          passwordHealthApi: () => g.d,
          vaultReportApi: () => R.f
        });
      var s = r(96248),
        a = r(9310),
        n = r(21444),
        i = r(94814),
        o = r(9062),
        c = r(36214),
        u = r(57255),
        d = r(71450),
        l = r(26254),
        p = r(91619),
        h = r(30240),
        m = r(60135),
        y = r(49186),
        g = r(57668),
        v = r(99097),
        f = r(75787),
        w = r(53489),
        S = r(65796),
        E = r(7466),
        _ = r(32069),
        b = r(76687),
        T = r(45806),
        A = r(25547),
        C = r(4253),
        R = r(93856),
        I = r(8122),
        x = r(47010),
        P = r(76107),
        D = r(90056),
        U = r(25619),
        F = r(5158);
    },
    90056: (e, t, r) => {
      "use strict";
      r.d(t, { i: () => i });
      var s = r(86952),
        a = r(25619),
        n = r(5158);
      const i = (0, s.Q)({ name: "otp", commands: {}, events: {}, queries: { otpCode: a.J, otpCodeForSecretOrUrl: n.S } });
    },
    25619: (e, t, r) => {
      "use strict";
      r.d(t, { J: () => o, c: () => i });
      var s = r(99059),
        a = r(25029),
        n = r(96168);
      class i extends (0, n.Hu)("Cannot generate OTP code due to no OtpSecret or OtpUrl found for credential", "") {}
      class o extends (0, s.k)({ scope: a.F.User }) {}
    },
    5158: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => o, k: () => i });
      var s = r(99059),
        a = r(25029),
        n = r(96168);
      class i extends (0, n.Hu)("Cannot generate OTP code for secret or url", "") {}
      class o extends (0, s.k)({ scope: a.F.User }) {}
    },
    57668: (e, t, r) => {
      "use strict";
      r.d(t, { d: () => h });
      var s = r(86952),
        a = r(76687),
        n = r(45806),
        i = r(25547),
        o = r(99097),
        c = r(53489),
        u = r(75787),
        d = r(65796),
        l = r(32069),
        p = r(7466);
      const h = (0, s.Q)({
        name: "passwordHealth",
        commands: { updateIsCredentialExcluded: a.v, recalculatePasswordHealth: n.t },
        events: { passwordHealthComputationFinished: i.w },
        queries: {
          credentialHealthData: o.w,
          filterCredentials: c.Q,
          score: u.e,
          compromisedCredentials: d.v,
          compromisedCredentialsIdsForBreach: l.A,
          passwordHealthReport: p.b
        }
      });
    },
    76687: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    45806: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    25547: (e, t, r) => {
      "use strict";
      r.d(t, { w: () => n });
      var s = r(88885),
        a = r(25029);
      class n extends (0, s.d)({ scope: a.F.User }) {}
    },
    4253: (e, t, r) => {
      "use strict";
      var s, a, n, i;
      r.d(t, { _x: () => a, bp: () => i, gI: () => s, ub: () => n }),
        (function (e) {
          (e.Weak = "weak"), (e.Reused = "reused"), (e.Compromised = "compromised"), (e.Excluded = "excluded");
        })(s || (s = {})),
        (function (e) {
          (e.All = "all"), (e.Weak = "weak"), (e.Reused = "reused"), (e.Compromised = "compromised"), (e.Excluded = "excluded");
        })(a || (a = {})),
        (function (e) {
          (e.WEAK = "weak"), (e.EXTREMELY_WEAK = "extremely_weak");
        })(n || (n = {})),
        (function (e) {
          (e.COMMON = "common"), (e.STRONG = "strong");
        })(i || (i = {}));
    },
    32069: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    65796: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    99097: (e, t, r) => {
      "use strict";
      r.d(t, { w: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    53489: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    7466: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    75787: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    93856: (e, t, r) => {
      "use strict";
      r.d(t, { f: () => s });
      const s = (0, r(86952).Q)({ name: "vaultReport", commands: {}, events: {}, queries: {} });
    },
    47032: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => _ });
      var s = r(88802),
        a = r(99634),
        n = r(8122),
        i = r(25029),
        o = r(95681),
        c = r(23347),
        u = r(10722),
        d = r(7165);
      const l = d.z.object({ autoredirection: d.z.record(d.z.boolean()) }),
        p = (e) => l.safeParse(e).success;
      class h extends (0, o.Q)({
        persist: !0,
        storage: { initialValue: { autoredirection: {} }, typeGuard: p, schemaVersion: 1 },
        scope: i.F.Device,
        storeName: "antiphishing",
        codec: u.E,
        capacity: c.Y._001KB
      }) {}
      var m = r(20754),
        y = r(47010),
        g = r(87065),
        v = r(87279);
      let f = class {
        constructor(e) {
          this.antiphishingStore = e;
        }
        execute({ body: e }) {
          return this.antiphishingStore.state$.pipe((0, g.U)((t) => (0, v.Vp)(!!e.domain && !!t.autoredirection[e.domain])));
        }
      };
      f = (0, s.__decorate)([(0, m.e)(y.U), (0, s.__metadata)("design:paramtypes", [h])], f);
      var w = r(63663),
        S = r(76107);
      let E = class {
        constructor(e) {
          this.antiphishingStore = e;
        }
        async execute({ body: e }) {
          const { domain: t } = e;
          if (t) {
            const e = await this.antiphishingStore.getState();
            await this.antiphishingStore.set({ ...e, autoredirection: { ...e.autoredirection, [t]: !0 } });
          }
          return Promise.resolve((0, v.Vp)(void 0));
        }
      };
      E = (0, s.__decorate)([(0, w.W)(S.A), (0, s.__metadata)("design:paramtypes", [h])], E);
      let _ = class {};
      _ = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.J,
            handlers: { commands: { addAutoRedirectedDomain: E }, events: {}, queries: { isAutoRedirectedDomain: f } },
            stores: [h]
          })
        ],
        _
      );
    },
    90364: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => n });
      const s = (e) => void 0 === e || "string" == typeof e,
        a = (e) => void 0 === e || "number" == typeof e,
        n = (e) => {
          if (!e || !Array.isArray(e)) return !1;
          if (0 === e.length) return !0;
          const t = e[0];
          return "string" == typeof t.Id && a(t.LastBackupTime) && s(t.kwType) && s(t.AnonId) && s(t.BreachId) && a(t.ContentRevision);
        };
    },
    1237: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => c, l: () => o });
      var s = r(49186),
        a = r(9811);
      const n = ({ name: e, domains: t }) => {
          if (e) return e;
          if (t.length > 0) {
            const [e] = t;
            return e;
          }
          return "";
        },
        i = (e) => ((0, a.Tc)(e) ? "private" : "public"),
        o = (e) => [
          ...e
            .reduce((e, t) => {
              const r = e.get(t.BreachId);
              return (!r || (r.LastBackupTime && t.LastBackupTime && r.LastBackupTime < t.LastBackupTime)) && e.set(t.BreachId, t), e;
            }, new Map())
            .values()
        ],
        c = (e, t) => {
          const r = o(e.filter(a.rY)).find((e) => e.Id === t);
          if (!r) throw new Error("Breach not found");
          return ((e) => {
            const t = e.Content,
              r = (0, a.Tc)(e) ? e.Content.impactedEmails : [];
            return {
              anonId: e.AnonId ?? "",
              breachId: e.BreachId,
              breachType: i(e),
              domains: t.domains,
              eventDate: t.eventDate,
              id: e.Id,
              impactedEmails: r,
              kwType: e.kwType ?? "KWSecurityBreach",
              leakedData: t.leakedData ?? [],
              leakedPasswords: e.LeakedPasswords ?? [],
              name: n(t),
              status: e.Status ?? s.J.PENDING
            };
          })(r);
        };
    },
    9811: (e, t, r) => {
      "use strict";
      r.d(t, { F7: () => i, Tc: () => o, rY: () => n });
      const s = (e) => "object" == typeof e,
        a = (e) =>
          ((e) => s(e) && "breachModelVersion" in e && "number" == typeof e.breachModelVersion)(e) &&
          1 === e.breachModelVersion &&
          "domains" in e &&
          Array.isArray(e.domains) &&
          "eventDate" in e &&
          "string" == typeof e.eventDate &&
          "id" in e &&
          "string" == typeof e.id,
        n = (e) => {
          return s((t = e)) && "kwType" in t && "string" == typeof t.kwType && "KWSecurityBreach" === t.kwType && a(e.Content);
          var t;
        },
        i = (e) =>
          ((e) => {
            const t = e;
            return "impactedEmails" in t && Array.isArray(t.impactedEmails);
          })(e) && e.impactedEmails.length > 0,
        o = (e) => n(e) && i(e.Content);
    },
    32217: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => T });
      var s = r(88802),
        a = r(99634),
        n = r(71450),
        i = r(63663),
        o = r(87279),
        c = r(49186),
        u = r(26254),
        d = r(53576);
      let l = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        async execute({ body: e }) {
          const {
            commands: { carbon: t }
          } = this.carbonLegacyClient;
          return (
            await t({ name: "updateBreachStatus", args: [{ id: e.id, status: c.J.ACKNOWLEDGED }] }), Promise.resolve((0, o.Vp)(void 0))
          );
        }
      };
      l = (0, s.__decorate)([(0, i.W)(u.n), (0, s.__metadata)("design:paramtypes", [d.CarbonLegacyClient])], l);
      var p = r(91619);
      let h = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        async execute({ body: e }) {
          const {
            commands: { carbon: t }
          } = this.carbonLegacyClient;
          return await t({ name: "updateBreachStatus", args: [{ id: e.id, status: c.J.VIEWED }] }), Promise.resolve((0, o.Vp)(void 0));
        }
      };
      h = (0, s.__decorate)([(0, i.W)(p.Q), (0, s.__metadata)("design:paramtypes", [d.CarbonLegacyClient])], h);
      var m = r(48844),
        y = r(20754),
        g = r(30240),
        v = r(1237),
        f = r(90364);
      let w = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        execute({ body: e }) {
          const { id: t } = e,
            {
              queries: { carbonState: r }
            } = this.carbonLegacyClient;
          return r({ path: "userSession.personalData.securityBreaches" }).pipe(
            (0, m.Qn)((e) => {
              if (!(0, f.b)(e)) throw new Error("Bad Breaches format");
              return e;
            }),
            (0, m.Qn)((e) => (0, v.T)(e, t))
          );
        }
      };
      w = (0, s.__decorate)([(0, y.e)(g.i), (0, s.__metadata)("design:paramtypes", [d.CarbonLegacyClient])], w);
      var S = r(87065),
        E = r(60135),
        _ = r(9811);
      let b = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        execute() {
          const {
            queries: { carbonState: e }
          } = this.carbonLegacyClient;
          return e({ path: "userSession.personalData.securityBreaches" }).pipe(
            (0, m.Qn)((e) => {
              if (!(0, f.b)(e)) throw new Error("Bad Breaches format");
              return e;
            }),
            (0, S.U)((e) => {
              if ((0, o.hx)(e)) throw new Error("Error while fetching data");
              const t = (0, v.l)(e.data.filter(_.rY)).filter((e) => e.Status === c.J.PENDING && (0, _.Tc)(e));
              return (0, o.Vp)({ count: t.length });
            })
          );
        }
      };
      b = (0, s.__decorate)([(0, y.e)(E.L), (0, s.__metadata)("design:paramtypes", [d.CarbonLegacyClient])], b);
      let T = class {};
      T = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.H,
            handlers: { commands: { dismissBreach: l, markBreachAsSeen: h }, events: {}, queries: { breach: w, unreadBreachesCount: b } }
          })
        ],
        T
      );
    },
    59348: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => V });
      var s = r(88802),
        a = r(99634),
        n = r(96248),
        i = r(87065),
        o = r(6136),
        c = r(43978),
        u = r(90171),
        d = r(69885),
        l = r(87279),
        p = r(20754),
        h = r(9062),
        m = r(48844),
        y = r(61501),
        g = r(57924),
        v = r(25029),
        f = r(95681),
        w = r(57255),
        S = r(10722);
      const E = (e) =>
        ((e) => !(!e || "object" != typeof e) && "onboardingStatus" in e && "emails" in e)(e) &&
        (0, w.U)(e.onboardingStatus) &&
        Array.isArray(e.emails);
      class _ extends (0, f.Q)({
        persist: !0,
        storage: { schemaVersion: 1, initialValue: { onboardingStatus: w.M.NOT_SEEN, emails: [] }, typeGuard: E },
        scope: v.F.User,
        storeName: "email-monitoring-state",
        storeTypeGuard: E,
        codec: S.E,
        isCache: !0
      }) {}
      let b = class {
        constructor(e, t) {
          (this.serverApiClient = e),
            (this.store = t),
            (this.execute = () => {
              this.serverApiClient.v1.darkwebmonitoring
                .listRegistrations({})
                .pipe(
                  (0, m.Qn)(({ data: e }) => e.emails.map((e) => ({ email: e.email, state: (0, h.a2)(e.state) ? e.state : h.wp.PENDING }))),
                  (0, m.Qn)((e) => {
                    this.store.update((t) => ({ ...t, emails: e }));
                  }),
                  (0, m.DZ)((e) => {
                    throw e;
                  })
                )
                .subscribe();
            });
        }
      };
      b = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [y.l, _])], b);
      let T = class {
        constructor(e, t) {
          (this.syncMonitoredEmails = e), (this.store = t);
        }
        execute() {
          this.syncMonitoredEmails.execute();
          return this.store.state$
            .pipe(
              (0, i.U)((e) => e.emails),
              (0, o.x)((e, t) => JSON.stringify(e) === JSON.stringify(t)),
              (0, i.U)((e) => (0, l.Vp)(e))
            )
            .pipe(
              (0, c.w)((e) => {
                const t = () => (this.syncMonitoredEmails.execute(), e),
                  r = (e) => (0, u.H)(0, e).pipe((0, c.w)(() => (0, d.of)(t())));
                return (0, l.hx)(e) || e.data.some((e) => e.state === h.wp.PENDING) ? r(3e4) : (0, d.of)(e);
              })
            );
        }
      };
      T = (0, s.__decorate)([(0, p.e)(h.dB), (0, s.__metadata)("design:paramtypes", [b, _])], T);
      var A = r(36214);
      let C = class {
        constructor(e) {
          this.store = e;
        }
        execute() {
          return this.store.state$.pipe((0, i.U)((e) => (0, l.Vp)(e.onboardingStatus)));
        }
      };
      C = (0, s.__decorate)([(0, p.e)(A.p), (0, s.__metadata)("design:paramtypes", [_])], C);
      var R = r(63663),
        I = r(9310);
      function x(e) {
        return { ...e, onboardingStatus: w.M.SEEN };
      }
      let P = class {
        constructor(e) {
          this.store = e;
        }
        async execute() {
          await this.store.update(x);
        }
      };
      P = (0, s.__decorate)([(0, g.GS)(), (0, s.__metadata)("design:paramtypes", [_])], P);
      let D = class {
        constructor(e) {
          this.dismissOnboardingNotificationService = e;
        }
        async execute() {
          return await this.dismissOnboardingNotificationService.execute(), Promise.resolve((0, l.Vp)(void 0));
        }
      };
      D = (0, s.__decorate)([(0, R.W)(I.n), (0, s.__metadata)("design:paramtypes", [P])], D);
      var U = r(21444),
        F = r(60399),
        O = r(95233);
      let N = class {
        constructor(e, t) {
          (this.serverApiClient = e), (this.store = t);
        }
        async execute({ body: { email: e } }) {
          return await (0, F.z)(
            this.serverApiClient.v1.darkwebmonitoring.registerEmail({ email: e }).pipe(
              (0, m.DZ)((e) => {
                throw new Error(e.message);
              }),
              (0, m.lk)((e) =>
                e.data.result === U.Dq
                  ? (0, l.Vp)(void 0)
                  : (0, l.Rn)(
                      ((e) => {
                        switch (e) {
                          case U.XX.INVALID_EMAIL:
                            return new U.Ox();
                          case U.XX.ALREADY_SUBSCRIBED:
                            return new U.l2();
                          case U.XX.TOO_MANY_SUBSCRIPTIONS:
                            return new U.NM();
                          default:
                            return new U.vc();
                        }
                      })(e.data.result)
                    )
              ),
              (0, O.b)(async (t) => {
                (0, l.d6)(t) && (await this.store.update((t) => ({ ...t, emails: [...t.emails, { email: e, state: h.wp.PENDING }] })));
              })
            )
          );
        }
      };
      N = (0, s.__decorate)([(0, R.W)(U.P5), (0, s.__metadata)("design:paramtypes", [y.l, _])], N);
      var k = r(1824),
        L = r(94814);
      let M = class {
        constructor(e, t) {
          (this.serverApiClient = e),
            (this.store = t),
            (this.getFunctionalError = (e) => {
              switch (e) {
                case L.KP.NO_SUBSCRIPTION:
                  return new L.h1();
                case L.KP.INVALID_EMAIL:
                  return new L.uD();
                case L.KP.GENERIC_ERROR:
                default:
                  return new L.v4();
              }
            });
        }
        async execute({ body: { email: e } }) {
          return await (0, F.z)(
            this.serverApiClient.v1.darkwebmonitoring.deregisterEmail({ email: e }).pipe(
              (0, m.DZ)((e) => {
                throw new Error(e.message);
              }),
              (0, m.lk)((e) => (e.data.result === L.QS ? (0, l.Vp)(void 0) : (0, l.Rn)(this.getFunctionalError(e.data.result)))),
              (0, O.b)(async (t) => {
                (0, l.d6)(t) && (await this.store.update((t) => ({ ...t, emails: [...t.emails.filter((t) => t.email !== e)] })));
              })
            )
          );
        }
      };
      M = (0, s.__decorate)([(0, R.W)(L.Lc), (0, s.__metadata)("design:paramtypes", [y.l, _])], M);
      let V = class {};
      V = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.M,
            stores: [_],
            handlers: {
              commands: { dismissOnboardingNotification: D, optinEmail: N, optoutEmail: M },
              events: {},
              queries: { emailList: T, onboardingNotificationState: C }
            },
            imports: [k.n],
            providers: [P, b]
          })
        ],
        V
      );
    },
    54112: (e, t, r) => {
      "use strict";
      r.d(t, { f: () => V });
      var s = r(88802),
        a = r(99634),
        n = r(90056),
        i = r(87065),
        o = r(43978),
        c = r(69885),
        u = r(25619),
        d = r(20754),
        l = r(87279),
        p = r(57924),
        h = r(31222);
      const m = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("").reduce((e, t, r) => ({ ...e, [t]: r }), {});
      function y(e) {
        const t = m[e];
        if (void 0 === t) throw new Error(`Invalid character found: ${e}`);
        return t;
      }
      const g = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9],
        v = async (e, t, r) => {
          const s = ((e) => {
            const t = new Uint8Array(e),
              r = 15 & t[t.length - 1],
              s = t.slice(r, r + 4).reduce((e, t) => e.concat(t.toString(16).toString().padStart(2, "0")), "");
            return 2147483647 & Number.parseInt(s, 16);
          })(
            await e(
              (function (e) {
                const t = new ArrayBuffer(8);
                return new DataView(t).setBigUint64(0, BigInt(e)), t;
              })(t)
            )
          );
          return (s % (r <= 9 ? g[r] : Math.pow(10, r))).toString().padStart(r, "0");
        };
      class f {
        constructor(e, t) {
          (this.signer = e), (this.getStep = t);
        }
        async computeOtpCode({ counter: e, digits: t, period: r }) {
          const s = this.getStep(e, r);
          return await v(this.signer, s, t);
        }
      }
      class w {
        constructor(e) {
          this.hmacSigner = e;
        }
        createCodeGenerator({ secret: e, algorithm: t }) {
          try {
            const r = (function (e) {
              const t = e.replaceAll("=", "").trim().length;
              let r = 0,
                s = 0,
                a = 0;
              const n = new Uint8Array(((5 * t) / 8) | 0);
              for (let i = 0; i < t; i++) (s = (s << 5) | y(e[i])), (r += 5), r >= 8 && ((n[a++] = (s >>> (r - 8)) & 255), (r -= 8));
              return n.buffer;
            })(e);
            return new f((e) => this.hmacSigner.sign(r, e, t), this.getStep);
          } catch (e) {
            return null;
          }
        }
        getNextOtpRefreshTimestamp(e, t) {
          if (e)
            return ((e) => {
              const t = 1e3 * e,
                r = Math.floor(Date.now() / t) * t;
              return new Date(r + t).getTime();
            })(t);
          throw new Error("Not supported for non time based OTP type");
        }
      }
      let S = class extends w {
        constructor(e) {
          super(e);
        }
        getStep(e, t) {
          return ((e, t) => Math.floor(e / t))(e || new Date().getTime(), 1e3 * t);
        }
      };
      S = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [h.q])], S);
      var E = r(53576),
        _ = r(48844);
      const b = (e) => void 0 === e || "string" == typeof e;
      let T = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        getById(e) {
          const {
            queries: { carbonState: t }
          } = this.carbonLegacyClient;
          return t({ path: "state.userSession.personalData.credentials" }).pipe(
            (0, _.Qn)((e) => {
              if (
                !((e) =>
                  !!Array.isArray(e) &&
                  (0 === e.length ||
                    e.every((e) => {
                      const t = e;
                      return "string" == typeof t.Id && b(t.OtpSecret) && b(t.OtpUrl);
                    })))(e)
              )
                throw new Error("Bad credential format");
              return e;
            }),
            (0, i.U)((t) => {
              if ((0, l.hx)(t)) return (0, l.Vp)(null);
              const r = t.data.reduce((t, r) => (r.Id === e ? { Id: r.Id, OtpSecret: r.OtpSecret, OtpUrl: r.OtpUrl } : t), null);
              return (0, l.Vp)(r);
            })
          );
        }
      };
      var A;
      (T = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [E.CarbonLegacyClient])], T)),
        (function (e) {
          (e.SHA1 = "SHA-1"), (e.SHA256 = "SHA-256"), (e.SHA384 = "SHA-384"), (e.SHA512 = "SHA-512");
        })(A || (A = {}));
      const C = ["totp", "hotp"],
        R = (e) => {
          const t = new URL(e),
            r = ((e) => {
              const t = e.hostname ? e.hostname : /\/\/([th]otp)\//.exec(e.pathname)?.[1] ?? "";
              return C.includes(t) ? t : null;
            })(t),
            s = t.searchParams.get("secret")?.toUpperCase();
          if (!r || !s) throw new Error("Corrupted OTP url");
          const a = t.searchParams.get("digits"),
            n = t.searchParams.get("counter"),
            i = t.searchParams.get("period"),
            o = t.searchParams.get("algorithm");
          return {
            secret: s,
            algorithm: o ? A[o] : A.SHA1,
            counter: n ? Number.parseInt(n, 10) : 0,
            digits: a ? Number.parseInt(a, 10) : 6,
            period: i ? Number.parseInt(i, 10) : 30
          };
        },
        I = (e) => ({ secret: e.toUpperCase(), algorithm: A.SHA1, counter: 0, digits: 6, period: 30 }),
        x = (e) => {
          const { secret: t, algorithm: r, digits: s, period: a } = e;
          return `otpauth://totp/?secret=${t.toLowerCase()}&algorithm=${r
            .toUpperCase()
            .replace("-", "")}&digits=${s}&period=${a}&lock=false`;
        };
      var P = r(90171),
        D = r(30523);
      let U = class {
        constructor(e) {
          this.otpGeneratorService = e;
        }
        async withGeneratedCodeAndValidity(e, t) {
          try {
            const r = await t.computeOtpCode(e),
              s = this.otpGeneratorService.getNextOtpRefreshTimestamp(!0, e.period);
            return (0, l.Vp)({ code: r, validityEndDate: s, validityTime: 1e3 * e.period, url: x(e) });
          } catch {
            return (0, l.Rn)(void 0);
          }
        }
        otpCodes$(e, t) {
          return (0, P.H)(0, 1e3).pipe(
            (0, D.h)((t) => {
              if (0 === t) return !0;
              return ((e, t) => e - Date.now() >= 1e3 * t - 1e3)(
                this.otpGeneratorService.getNextOtpRefreshTimestamp(!0, e.period),
                e.period
              );
            }),
            (0, o.w)(() => this.withGeneratedCodeAndValidity(e, t))
          );
        }
      };
      U = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [S])], U);
      let F = class {
        constructor(e, t, r) {
          (this.credentialOTPGetter = e), (this.otpGeneratorService = t), (this.otpCodeService = r);
        }
        withCodeGenerator(e) {
          return { codeGenerator: this.otpGeneratorService.createCodeGenerator(e), params: e };
        }
        execute({ body: e }) {
          const { credentialId: t } = e;
          return this.credentialOTPGetter.getById(t).pipe(
            (0, i.U)((e) => {
              if ((0, l.hx)(e) || !e.data) throw new Error("Credential not found");
              return e.data;
            }),
            (0, i.U)((e) => {
              if (!e.OtpUrl && !e.OtpSecret) return { params: null, codeGenerator: null };
              const t = ((e) => {
                const { OtpSecret: t, OtpUrl: r } = e;
                if (!t && !r) throw new Error("Otp config missing for this credential");
                return r ? R(r) : I(t ?? "");
              })(e);
              return this.withCodeGenerator(t);
            }),
            (0, o.w)(({ params: e, codeGenerator: t }) =>
              null === e || null === t
                ? (0, c.of)((0, l.Rn)(new u.c()))
                : this.otpCodeService
                    .otpCodes$(e, t)
                    .pipe(
                      (0, i.U)((e) =>
                        (0, l.hx)(e) ? (0, l.Vp)({ code: "", validityEndDate: Date.now(), validityTime: Date.now(), url: "" }) : e
                      )
                    )
            )
          );
        }
      };
      F = (0, s.__decorate)([(0, d.e)(u.J), (0, s.__metadata)("design:paramtypes", [T, S, U])], F);
      let O = class extends w {
        constructor(e) {
          super(e);
        }
        getStep(e, t) {
          return e;
        }
      };
      O = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [h.q])], O);
      var N = r(37935);
      let k = class {};
      k = (0, s.__decorate)([(0, a.Y)({ sharedModuleName: "otp-generator", providers: [S, O], exports: [S, O], imports: [N.D] })], k);
      var L = r(5158);
      let M = class {
        constructor(e, t) {
          (this.otpGeneratorService = e), (this.otpCodeService = t);
        }
        execute({ body: e }) {
          const { secretOrUrl: t } = e;
          if (!t) return (0, c.of)((0, l.Rn)(new L.k()));
          const r = ((e) => {
              try {
                return R(e);
              } catch {
                return I(e);
              }
            })(t.replaceAll(" ", "")),
            s = this.otpGeneratorService.createCodeGenerator(r);
          return null === s ? (0, c.of)((0, l.Rn)(new L.k())) : this.otpCodeService.otpCodes$(r, s).pipe((0, _.DZ)(() => new L.k()));
        }
      };
      M = (0, s.__decorate)([(0, d.e)(L.S), (0, s.__metadata)("design:paramtypes", [S, U])], M);
      let V = class {};
      V = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.i,
            handlers: { commands: {}, events: {}, queries: { otpCode: F, otpCodeForSecretOrUrl: M } },
            imports: [k],
            providers: [T, U]
          })
        ],
        V
      );
    },
    59206: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => d });
      var s = r(88802),
        a = r(53576),
        n = r(57924),
        i = r(48844),
        o = r(90364),
        c = r(1237),
        u = r(9811);
      let d = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        getSupportedBreaches() {
          const {
            queries: { carbonState: e }
          } = this.carbonLegacyClient;
          return e({ path: "userSession.personalData.securityBreaches" }).pipe(
            (0, i.Qn)((e) => {
              if (!(0, o.b)(e)) throw new Error("Bad Breaches format");
              return e;
            }),
            (0, i.Qn)((e) => e.filter(u.rY))
          );
        }
        get() {
          const {
            queries: { carbonState: e }
          } = this.carbonLegacyClient;
          return e({ path: "userSession.personalData.securityBreaches" }).pipe(
            (0, i.Qn)((e) => {
              if (!(0, o.b)(e)) throw new Error("Bad Breaches format");
              return e;
            }),
            (0, i.Qn)((e) => (0, c.l)(e.filter(u.rY)))
          );
        }
      };
      d = (0, s.__decorate)([(0, n.GS)(), (0, s.__metadata)("design:paramtypes", [a.CarbonLegacyClient])], d);
    },
    45883: (e, t, r) => {
      "use strict";
      r.d(t, { J: () => h });
      var s = r(88802),
        a = r(53576),
        n = r(57924),
        i = r(48844),
        o = r(87279),
        c = r(64718),
        u = r(61076),
        d = r(87065);
      const l = (e) => void 0 === e || "string" == typeof e,
        p = (e) => void 0 === e || "string" == typeof e || "boolean" == typeof e;
      let h = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        vaultBooleanFormatter(e, t = !1) {
          return void 0 === e ? t : "string" == typeof e ? "true" === e.toLocaleLowerCase() : e;
        }
        get() {
          const {
              queries: { carbonState: e }
            } = this.carbonLegacyClient,
            t = e({ path: "state.userSession.spaceData.spaces" }).pipe(
              (0, i.Qn)((e) => {
                if (
                  !((e) =>
                    !!Array.isArray(e) &&
                    (0 === e.length ||
                      e.every((e) => {
                        const t = e;
                        return "string" == typeof t.teamId && "object" == typeof t.details && "string" == typeof t.details.status;
                      })))(e)
                )
                  throw new Error("Bad space item format");
                return new Set(e.filter((e) => "accepted" === e.details.status).map((e) => e.teamId));
              })
            ),
            r = e({ path: "userSession.sharingData.items" }).pipe(
              (0, i.Qn)((e) => {
                if (
                  !((e) =>
                    !!Array.isArray(e) &&
                    (0 === e.length ||
                      e.every((e) => {
                        const t = e;
                        return "string" == typeof t.content && "string" == typeof t.itemId && "number" == typeof t.timestamp;
                      })))(e)
                )
                  throw new Error("Bad shared items format");
                return e.map((e) => e.itemId);
              })
            );
          return e({ path: "state.userSession.personalData.credentials" }).pipe(
            (0, i.Qn)((e) => {
              if (
                !((e) =>
                  !!Array.isArray(e) &&
                  (0 === e.length ||
                    e.every((e) => {
                      const t = e;
                      return (
                        "string" == typeof t.Id &&
                        p(t.AutoLogin) &&
                        p(t.AutoProtected) &&
                        l(t.Email) &&
                        l(t.Login) &&
                        l(t.OtpSecret) &&
                        l(t.OtpUrl) &&
                        l(t.Password) &&
                        l(t.Title) &&
                        l(t.Url) &&
                        l(t.SpaceId) &&
                        p(t.Checked)
                      );
                    })))(e)
              )
                throw new Error("Bad credential format");
              return e;
            }),
            (0, u.V)(r, t),
            (0, d.U)(([e, t, r]) => {
              const s = {};
              return (
                (0, o.hx)(e) ||
                  (0, o.hx)(r) ||
                  e.data.forEach((e) => {
                    const a = new c.Y(e.Url).getRootDomain();
                    var n;
                    (e.SpaceId && "" !== e.SpaceId && !r.data.has(e.SpaceId)) ||
                      (s[e.Id] = {
                        domains: a ? [a] : [],
                        autoLogin: this.vaultBooleanFormatter(e.AutoLogin),
                        autoProtected: this.vaultBooleanFormatter(e.AutoProtected),
                        email: e.Email ?? "",
                        excluded: this.vaultBooleanFormatter(e.Checked),
                        id: e.Id,
                        login: e.Login ?? "",
                        otpSecret: e.OtpSecret ?? "",
                        otpUrl: e.OtpUrl ?? "",
                        password: e.Password ?? "",
                        spaceId: e.SpaceId ?? "",
                        shared: ((n = e.Id), !(0, o.hx)(t) && t.data.includes(n)),
                        title: e.Title ?? ""
                      });
                  }),
                (0, o.Vp)(s)
              );
            })
          );
        }
      };
      h = (0, s.__decorate)([(0, n.GS)(), (0, s.__metadata)("design:paramtypes", [a.CarbonLegacyClient])], h);
    },
    25951: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => ft });
      var s = r(88802),
        a = r(57668),
        n = r(1824),
        i = r(60733),
        o = r(99634),
        c = r(92018),
        u = r(48430),
        d = r(25029),
        l = r(63663),
        p = r(53576),
        h = r(87279),
        m = r(76687),
        y = r(95681),
        g = r(10722),
        v = r(28489);
      const f = (e) =>
        "object" == typeof e &&
        null !== e &&
        (0, v.l$)(e, "credentialsAtRisk") &&
        (0, v.l$)(e, "index") &&
        "object" == typeof e.credentialsAtRisk &&
        "object" == typeof e.index;
      class w extends (0, y.Q)({
        persist: !0,
        storage: { initialValue: { credentialsAtRisk: {}, index: {} }, typeGuard: f, schemaVersion: 1 },
        scope: d.F.User,
        storeName: "password-health-state",
        storeTypeGuard: f,
        codec: g.E,
        isCache: !0
      }) {}
      var S = r(4253);
      const E = (e) => {
        const t = {};
        if (!Object.keys(e).length) return t;
        for (const r in e) {
          if (!e[r]) continue;
          const s = e[r]?.spaceId ?? "";
          void 0 === t[s] &&
            (t[s] = {
              [S.gI.Reused]: [],
              [S.gI.Weak]: [],
              [S.gI.Compromised]: [],
              [S.gI.Excluded]: [],
              corruptedCount: 0,
              importantCorruptedCount: 0
            }),
            e[r]?.excluded
              ? t[s][S.gI.Excluded].push(r)
              : (t[s].corruptedCount++,
                e[r]?.isImportant && t[s].importantCorruptedCount++,
                e[r]?.risks.forEach((e) => t[s][e.riskType].push(r)));
        }
        return t;
      };
      let _ = class {
        constructor(e, t) {
          (this.store = e), (this.carbonLegacyClient = t);
        }
        async execute({ body: e }) {
          const {
            commands: { carbon: t }
          } = this.carbonLegacyClient;
          return (
            await t({ name: "updateCredential", args: [{ id: e.credentialId, update: { isExcludedFromHealth: e.excluded } }] }),
            this.store.update((t) => {
              const r = { ...t.credentialsAtRisk[e.credentialId], excluded: e.excluded },
                s = { ...t };
              return (s.credentialsAtRisk[e.credentialId] = r), (s.index = E(t.credentialsAtRisk)), s;
            }),
            Promise.resolve((0, h.Vp)(void 0))
          );
        }
      };
      _ = (0, s.__decorate)([(0, l.W)(m.v), (0, s.__metadata)("design:paramtypes", [w, p.CarbonLegacyClient])], _);
      var b = r(45806),
        T = r(57924),
        A = r(7165);
      const C = A.z.object({
          isOutdated: A.z.literal(!0),
          lastUpdateTimestamp: A.z.number(),
          updatedCredentialIds: A.z.record(A.z.string()),
          deletedCredentialIds: A.z.record(A.z.string()),
          hasUpdatedBreaches: A.z.boolean()
        }),
        R = A.z.object({ isOutdated: A.z.literal(!1), lastUpdateTimestamp: A.z.number() }),
        I = A.z.discriminatedUnion("isOutdated", [C, R]),
        x = (e) => I.safeParse(e).success;
      class P extends (0, y.Q)({
        persist: !0,
        storage: { initialValue: { isOutdated: !1, lastUpdateTimestamp: 0 }, typeGuard: x, schemaVersion: 1 },
        scope: d.F.User,
        storeName: "health-cache-state",
        storeTypeGuard: x,
        codec: g.E,
        isCache: !0
      }) {}
      var D = r(64987),
        U = r(94189),
        F = r(70493);
      var O = r(59206),
        N = r(45883),
        k = r(81459);
      let L = class extends k.f {};
      L = (0, s.__decorate)([(0, T.GS)()], L);
      const M = (e) => {
          const t = e.risks.filter((e) => e.riskType === S.gI.Reused);
          return 1 === t.length ? t[0] : void 0;
        },
        V = (e, t) => e?.risks.find((e) => e.riskType === t),
        G = (e, t) => e.risks.filter((e) => e.riskType !== t),
        j = (e, t, r) => [...r, { riskType: S.gI.Reused, credentialIds: [...t.credentialIds].filter((t) => e !== t) }],
        q = (e, t) => {
          const r = M(t);
          return {
            ...t,
            risks: G(t, S.gI.Reused).concat([{ riskType: S.gI.Reused, credentialIds: r ? [...r.credentialIds].concat(e.id) : [e.id] }])
          };
        },
        K = (e) => ({
          id: e.id,
          title: e.title,
          email: e.email,
          excluded: e.excluded,
          login: e.login,
          autoLogin: e.autoLogin,
          autoProtected: e.autoProtected,
          otpSecret: e.otpSecret,
          otpUrl: e.otpUrl,
          spaceId: e.spaceId,
          shared: e.shared,
          domains: e.domains
        }),
        W = (e) => ({ ...K(e), risks: [], isImportant: !1 }),
        B = (e, t, r) => {
          const s = G(t, S.gI.Reused),
            a = r && r.length > 0,
            n = s.length > 0;
          return a || n ? { ...W(e), risks: a ? s.concat([{ riskType: S.gI.Reused, credentialIds: r }]) : s } : void 0;
        },
        z = (e) => !!V(e, S.gI.Weak),
        H = (e) => !!M(e),
        $ = (e) => !!V(e, S.gI.Compromised),
        Q = (e) => e.excluded,
        Y = 3,
        X = 5;
      function J(e, t, r = Y, s = X) {
        if (!e || !t) return !1;
        const a = e.length,
          n = t.length;
        if (Math.abs(a - n) > r) return !1;
        if (a < s || n < s) return e === t;
        if (e === t) return !0;
        let i = new Array(n + 1),
          o = new Array(n + 1),
          c = !1;
        for (let e = 0; e < n + 1; e++) i[e] = e;
        for (let s = 0; s < a; s++) {
          (o[0] = s + 1), (c = o[0] > r);
          for (let a = 0; a < n; a++) {
            const n = i[a + 1] + 1,
              u = o[a] + 1;
            let d = i[a];
            e[s] !== t[a] && d++, (o[a + 1] = Math.min(n, Math.min(u, d))), (c = c && o[a + 1] > r);
          }
          const a = i;
          if (((i = o), (o = a), c)) break;
        }
        return i[n] <= r;
      }
      const Z = (e, t, r) => {
          const s = ((e, t) => Object.keys(t).reduce((r, s) => (J(s, e.password) ? [...r, ...t[s]] : r), []))(e, r);
          if (!t && 0 === s.length) return {};
          const a = ((e) => {
              if (0 !== e.length) return { riskType: S.gI.Compromised, breaches: e };
            })(s),
            n = t ? G(t, S.gI.Compromised) : [],
            i = { ...W(e), risks: a ? n.concat(a) : n };
          return { [e.id]: 0 === i.risks.length ? void 0 : i };
        },
        ee = (e, t, r) => {
          if (!r) return Promise.resolve({});
          const s = t[e.id] ?? W(e),
            a = s.risks.length > 0,
            n = ((e, t) =>
              Object.keys(t)
                .map((e) => t[e])
                .filter((t) => t.id !== e.id && J(t.password, e.password))
                .map((e) => e.id))(e, r);
          if (0 === n.length && !a) return Promise.resolve({});
          const i = M(s)?.credentialIds ?? [],
            o = ((e, t, r, s) => {
              const a = r.filter((e) => !t.includes(e));
              if (0 === a.length) return {};
              const n = {};
              for (const t of a) {
                const r = s[t];
                if (!r) continue;
                const a = M(r);
                if (!a) continue;
                const i = G(r, S.gI.Reused);
                1 === a.credentialIds.length && 0 === i.length
                  ? (n[t] = void 0)
                  : (n[t] = { ...r, risks: 1 === a.credentialIds.length ? i : j(e, a, i) });
              }
              return n;
            })(e.id, n, i, t),
            c = ((e, t, r, s, a) => {
              const n = t.filter((e) => !r.includes(e));
              if (0 === n.length) return {};
              const i = {};
              for (const t of n) {
                const r = s[t];
                if (r) i[t] = q(e, r);
                else {
                  const r = a[t];
                  i[t] = { ...W(r), risks: [{ riskType: S.gI.Reused, credentialIds: [e.id] }] };
                }
              }
              return i;
            })(e, n, i, t, r),
            u = B(e, s, n);
          return Promise.resolve({ ...o, ...c, [e.id]: u });
        };
      var te = r(85465);
      const re = async (e) => {
          if (e) return (await (async (e) => (await (0, te.evaluate)(e)).score)(e)) / 25;
        },
        se = async (e, t) => {
          const r = await re(e.password),
            s = t ?? W(e),
            a = G(s, S.gI.Weak),
            n = void 0 !== r && r < 2;
          return n || 0 !== a.length
            ? { [e.id]: { ...s, ...K(e), risks: n ? a.concat([{ riskType: S.gI.Weak, strength: r }]) : a } }
            : { [e.id]: void 0 };
        },
        ae = (e, t, r) => {
          if (!t) return {};
          const s = e.domains.some((e) => r.has(e)),
            a = { ...t, isImportant: s };
          return { [t.id]: a };
        },
        ne = (e) => {
          const t = {};
          return (
            Object.keys(e).forEach((r) => {
              const s = e[r];
              s && (t[r] = s);
            }),
            t
          );
        },
        ie = async ({
          credentialUpdates: e,
          allCredentials: t,
          breaches: r,
          importantDomains: s,
          hasUpdatedBreaches: a,
          healthState: n,
          deletedCredentialIds: i
        }) => {
          const o = ((e) => {
              const t = {};
              return (
                e.forEach((e) => {
                  e.LeakedPasswords &&
                    e.LeakedPasswords.forEach((r) => {
                      Object.prototype.hasOwnProperty.call(t, r)
                        ? t[r].push({ breachId: e.Id, date: e.Content.eventDate, domains: e.Content.domains })
                        : (t[r] = [{ breachId: e.Id, date: e.Content.eventDate, domains: e.Content.domains }]);
                    });
                }),
                t
              );
            })(r),
            c = 0 === e.length && 0 === i.length && !a,
            u = { ...(n?.credentialsAtRisk ?? {}) },
            d = (e) => Object.keys(e).forEach((t) => (u[t] = e[t]));
          i.length > 0 && d(((e = []) => e.reduce((e, t) => ({ ...e, [t]: void 0 }), {}))(i));
          const l = {},
            p = {};
          for (const e of Object.keys(t)) t[e].excluded ? (l[e] = W(t[e])) : (p[e] = t[e]);
          const h = [],
            m = [];
          for (const t of e) t.excluded ? m.push(t) : i.includes(t.id) || h.push(t);
          d(
            ((e, t) => {
              const r = {};
              for (const s of Object.values(t)) {
                if (!s) continue;
                const t = M(s);
                if (!t) continue;
                const a = t.credentialIds.filter((t) => !e.includes(t));
                if (a.length !== t.credentialIds.length) {
                  const e = G(s, S.gI.Reused);
                  0 === a.length && 0 === e.length
                    ? (r[s.id] = void 0)
                    : (r[s.id] = { ...s, risks: 0 === a.length ? e : [...e, { ...t, credentialIds: a }] });
                }
              }
              return r;
            })([...Object.values(m).map((e) => e.id), ...i], u)
          ),
            c &&
              d(
                ((e) => {
                  const t = {};
                  for (let r = 0; r < e.length; r++) {
                    const s = e[r],
                      a = s.password,
                      n = s.id,
                      i = [];
                    for (let o = r + 1; o < e.length; o++) {
                      const r = e[o].id,
                        c = e[o].password,
                        u = e[o];
                      if (J(a, c)) {
                        const e = t[r] ?? W(u),
                          a = V(e, S.gI.Reused),
                          o = a?.credentialIds ?? [];
                        (t[r] = B(s, e, o.concat(n))), i.push(r);
                      }
                    }
                    const o = t[n] ?? W(s),
                      c = V(o, S.gI.Reused),
                      u = c?.credentialIds ?? [];
                    t[n] = B(s, o, i.concat(u));
                  }
                  return t;
                })(Object.values(p))
              );
          const y = c ? Object.values(p) : h;
          if (a)
            for await (const e of Object.values(p)) {
              d(Z(e, u[e.id], o));
            }
          for await (const e of y) {
            if (!a) {
              d(Z(e, u[e.id], o));
            }
            if (!c) {
              d(await ee(e, u, p));
            }
            d(await se(e, u[e.id])), d(ae(e, u[e.id], s));
          }
          return d(l), { credentialsAtRisk: ne(u), index: E(u) };
        };
      var oe = r(67978),
        ce = r(75994);
      let ue = class extends oe.K {
        constructor(e) {
          super("assets/domains/importantDomains.json", e);
        }
        loadResource(e) {
          if (!(t = e) || !Array.isArray(t)) throw new Error("Important domains file corrupted");
          var t;
          return new Set(e);
        }
      };
      ue = (0, s.__decorate)([(0, T.GS)(), (0, s.__metadata)("design:paramtypes", [ce.X])], ue);
      var de = r(60399);
      let le = class {
        constructor(e, t, r, s, a, n) {
          (this.store = e),
            (this.credentialsGetter = t),
            (this.breachesGetter = r),
            (this.importantDomains = s),
            (this.eventEmitter = a),
            (this.client = n);
        }
        async run({ updatedCredentialIds: e, deletedCredentialIds: t, hasUpdatedBreaches: r = !1 }) {
          const { userFeatureFlips: s } = this.client.getClient(F.cV).queries,
            a = await (0, de.z)(s());
          if ((0, h.d6)(a) && a.data.web_disable_password_health)
            return (
              await this.store.set({ credentialsAtRisk: {}, index: {} }),
              void this.eventEmitter.sendEvent("passwordHealthComputationFinished", null)
            );
          const n = await this.store.getState(),
            i = await (0, de.z)(this.credentialsGetter.get()),
            o = await (0, de.z)(this.breachesGetter.get()),
            c = await this.importantDomains.get();
          if ((0, h.hx)(i) || (0, h.hx)(o)) throw new Error("Failure getting vault data");
          const u = e?.length ?? 0,
            d = t?.length ?? 0,
            l = u > 0 || d > 0 || r,
            p = u + d <= 50,
            m = l && p ? n : void 0,
            y = l ? ((e, t) => e.reduce((e, r) => (void 0 === t[r] ? e : [...e, t[r]]), []))(e ?? [], i.data) : [],
            g = await ie({
              hasUpdatedBreaches: r,
              credentialUpdates: p ? y : [],
              allCredentials: i.data,
              breaches: o.data,
              importantDomains: c,
              healthState: m,
              deletedCredentialIds: p ? [...(t ?? [])] : []
            });
          await this.store.set({ ...g }), this.eventEmitter.sendEvent("passwordHealthComputationFinished", null);
        }
      };
      le = (0, s.__decorate)([(0, T.GS)(), (0, s.__metadata)("design:paramtypes", [w, N.J, O.U, ue, L, U.w])], le);
      const pe = new D.WU();
      let he = class {
        constructor(e, t) {
          (this.store = e), (this.passwordHealthCalculationService = t);
        }
        update(e) {
          pe.runExclusive(async () => {
            const t = await this.store.getState();
            this.store.set(
              ((e, t) => {
                const { isOutdated: r } = t;
                if (!r) return { isOutdated: !1, lastUpdateTimestamp: e.lastUpdateTimestamp };
                const { updatedCredentialIds: s, deletedCredentialIds: a, hasUpdatedBreaches: n } = t,
                  i = e.isOutdated
                    ? { ...e }
                    : {
                        isOutdated: !0,
                        lastUpdateTimestamp: e.lastUpdateTimestamp,
                        updatedCredentialIds: {},
                        deletedCredentialIds: {},
                        hasUpdatedBreaches: !1
                      };
                return (
                  s && (i.updatedCredentialIds = { ...i.updatedCredentialIds, ...s.reduce((e, t) => ({ ...e, [t]: t }), {}) }),
                  a && (i.deletedCredentialIds = { ...i.deletedCredentialIds, ...a.reduce((e, t) => ({ ...e, [t]: t }), {}) }),
                  n && (i.hasUpdatedBreaches = n),
                  i
                );
              })(t, e)
            );
          });
        }
        async updateHealthState() {
          await pe.runExclusive(async () => {
            const e = await this.store.getState();
            (e.isOutdated || 0 === e.lastUpdateTimestamp || e.lastUpdateTimestamp + 864e5 < Date.now()) &&
              (await this.passwordHealthCalculationService.run(this.prepCacheStateProps(e)), await this.markAsUpToDate());
          });
        }
        prepCacheStateProps(e) {
          return e.isOutdated
            ? {
                updatedCredentialIds: Object.keys(e.updatedCredentialIds),
                deletedCredentialIds: Object.keys(e.deletedCredentialIds),
                hasUpdatedBreaches: e.hasUpdatedBreaches
              }
            : {};
        }
        async markAsUpToDate() {
          await this.store.set({ isOutdated: !1, lastUpdateTimestamp: new Date().getTime() });
        }
      };
      he = (0, s.__decorate)([(0, T.GS)(), (0, s.__metadata)("design:paramtypes", [P, le])], he);
      let me = class {
        constructor(e) {
          this.healthCacheUpdaterService = e;
        }
        execute() {
          return this.healthCacheUpdaterService.update({ isOutdated: !0 }), Promise.resolve((0, h.Vp)(void 0));
        }
      };
      me = (0, s.__decorate)([(0, l.W)(b.t), (0, s.__metadata)("design:paramtypes", [he])], me);
      var ye = r(87065),
        ge = r(20754),
        ve = r(99097),
        fe = r(61076),
        we = r(95233);
      let Se = class {
        constructor(e, t, r) {
          (this.store = e),
            (this.cacheStore = t),
            (this.healthCacheUpdater = r),
            (this.state$ = this.cacheStore.state$.pipe(
              (0, fe.V)(this.store.state$),
              (0, we.b)(() => {
                this.healthCacheUpdater.updateHealthState();
              }),
              (0, ye.U)(([e, t]) => t)
            ));
        }
      };
      Se = (0, s.__decorate)([(0, T.GS)(), (0, s.__metadata)("design:paramtypes", [w, P, he])], Se);
      const Ee = (e, t) => {
        const r = ((e, t) => {
          if (0 !== t.length)
            switch (e) {
              case S._x.All: {
                const e = { [S.gI.Compromised]: 3, [S.gI.Weak]: 2, [S.gI.Reused]: 1, [S.gI.Excluded]: 0 };
                return t.reduce((t, r) => (t ? (e[r.riskType] > e[t.riskType] ? r : t) : r), void 0);
              }
              case S._x.Compromised:
                return t.find((e) => e.riskType === S.gI.Compromised);
              case S._x.Weak:
                return t.find((e) => e.riskType === S.gI.Weak);
              case S._x.Reused:
                return t.find((e) => e.riskType === S.gI.Reused);
              default:
                return;
            }
        })(e, t);
        if (!r) return;
        const s = { severity: S.bp.COMMON };
        switch (r.riskType) {
          case S.gI.Compromised: {
            const e = [...r.breaches].sort((e, t) => {
              const r = Date.parse(e.date),
                s = Date.parse(t.date);
              return r === s ? 0 : r < s ? 1 : -1;
            })[0];
            return { ...s, riskType: S.gI.Compromised, date: e.date, domain: e.domains[0] ?? null, severity: S.bp.STRONG };
          }
          case S.gI.Reused:
            return { ...s, riskType: S.gI.Reused, reuseCount: r.credentialIds.length };
          case S.gI.Weak:
            return { ...s, riskType: S.gI.Weak, strength: r.strength >= 1 ? S.ub.WEAK : S.ub.EXTREMELY_WEAK };
        }
      };
      let _e = class {
        constructor(e) {
          this.store = e;
        }
        execute({ body: e }) {
          const { credentialId: t } = e;
          return this.store.state$.pipe(
            (0, ye.U)((e) =>
              e.credentialsAtRisk[t]
                ? (0, h.Vp)(
                    ((e) => {
                      const { excluded: t, risks: r } = e;
                      return { excluded: t, corruptionData: Ee(S._x.All, r) };
                    })(e.credentialsAtRisk[t])
                  )
                : (0, h.Vp)(null)
            )
          );
        }
      };
      _e = (0, s.__decorate)([(0, ge.e)(ve.w), (0, s.__metadata)("design:paramtypes", [Se])], _e);
      var be = r(75787),
        Te = r(86742);
      const Ae = (e) => (null === e ? null : Math.round(100 * e)),
        Ce = (e, t) => ({
          total: t,
          excluded: e.excluded.length,
          compromised: e.compromised.length,
          reused: e.reused.length,
          weak: e.weak.length,
          score: Ae((0, Te.R9)(e.corruptedCount, e.importantCorruptedCount, t - e.excluded.length))
        }),
        Re = (e, t) => {
          const {
              compromised: r,
              reused: s,
              weak: a,
              corrupted: n,
              excluded: i,
              importantCorrupted: o
            } = Object.keys(e).reduce(
              (t, r) => ({
                compromised: t.compromised + e[r].compromised.length,
                reused: t.reused + e[r].reused.length,
                weak: t.weak + e[r].weak.length,
                corrupted: t.corrupted + e[r].corruptedCount,
                importantCorrupted: t.importantCorrupted + e[r].importantCorruptedCount,
                excluded: t.excluded + e[r].excluded.length
              }),
              { compromised: 0, reused: 0, weak: 0, corrupted: 0, importantCorrupted: 0, excluded: 0 }
            ),
            c = (0, Te.R9)(n, o, t - i);
          return { compromised: r, reused: s, total: t, weak: a, score: Ae(c), excluded: i };
        };
      function Ie(e, t) {
        return (0, h.hx)(e) ? 0 : Object.keys(e.data).filter((r) => e.data[r].spaceId === t).length;
      }
      let xe = class {
        constructor(e, t, r) {
          (this.cacheStateStore = e), (this.credentialsGetter = t), (this.store = r);
        }
        execute({ body: e }) {
          const { spaceId: t = null } = e;
          return this.store.state$.pipe(
            (0, fe.V)(this.credentialsGetter.get(), this.cacheStateStore.state$),
            (0, ye.U)(([e, r, s]) => {
              if (null !== t && void 0 === e.index[t]) {
                const e = Ie(r, t);
                return (0, h.Vp)({
                  counters: { compromised: 0, reused: 0, score: 100, total: e, weak: 0, excluded: 0 },
                  isInitialized: s.lastUpdateTimestamp > 0
                });
              }
              if (null === t) {
                const t = (0, h.hx)(r) ? 0 : Object.keys(r.data).length;
                return (0, h.Vp)({ counters: Re(e.index, t), isInitialized: s.lastUpdateTimestamp > 0 });
              }
              const a = Ie(r, t);
              return (0, h.Vp)({ counters: Ce(e.index[t], a), isInitialized: s.lastUpdateTimestamp > 0 });
            })
          );
        }
      };
      xe = (0, s.__decorate)([(0, ge.e)(be.e), (0, s.__metadata)("design:paramtypes", [P, N.J, Se])], xe);
      var Pe = r(53489);
      const De = { [S.gI.Compromised]: 1, [S.gI.Reused]: 2, [S.gI.Weak]: 3, [S.gI.Excluded]: 4 },
        Ue = (e) =>
          [...e].sort((e, t) => {
            const r = De[e.corruptionData?.riskType ?? S.gI.Excluded],
              s = De[t.corruptionData?.riskType ?? S.gI.Excluded];
            if (r === s) {
              const r = ((e, t) =>
                e?.riskType === S.gI.Compromised && t?.riskType === S.gI.Compromised
                  ? Date.parse(t.date) - Date.parse(e.date)
                  : e?.riskType === S.gI.Reused && t?.riskType === S.gI.Reused
                  ? t.reuseCount - e.reuseCount
                  : e?.riskType === S.gI.Weak && t?.riskType === S.gI.Weak
                  ? e.strength === t.strength
                    ? 0
                    : e.strength === S.ub.WEAK
                    ? 1
                    : -1
                  : 0)(e.corruptionData, t.corruptionData);
              return 0 !== r ? r : e.title.localeCompare(t.title);
            }
            return r - s;
          }),
        Fe = (e, t) =>
          t === S._x.All ? [...new Set([...e[S.gI.Compromised], ...e[S.gI.Reused], ...e[S.gI.Weak], ...e[S.gI.Excluded]])] : e[t],
        Oe = (e, t) => {
          const { id: r, title: s, login: a, email: n, autoProtected: i, shared: o, excluded: c, domains: u, risks: d } = e;
          return {
            id: r,
            title: s,
            login: a,
            email: n,
            autoProtected: i,
            shared: o,
            excluded: c,
            domainIcon: void 0,
            corruptionData: Ee(t, d),
            domain: u[0]
          };
        };
      let Ne = class {
        constructor(e) {
          this.store = e;
        }
        execute({ body: e }) {
          const { healthFilter: t, spaceId: r } = e;
          return this.store.state$.pipe(
            (0, ye.U)((e) =>
              null !== r && void 0 === e.index[r]
                ? (0, h.Vp)([])
                : (0, h.Vp)(
                    Ue(
                      ((e, t, r, s) => {
                        let a;
                        if (null !== e) a = Fe(t[e], r);
                        else {
                          if (r === S._x.All) return Object.values(s).map((e) => Oe(e, r));
                          a = Object.keys(t).reduce((e, s) => [...e, ...Fe(t[s], r)], []);
                        }
                        return a.map((e) => Oe(s[e], r));
                      })(r, e.index, t || S._x.All, e.credentialsAtRisk)
                    )
                  )
            )
          );
        }
      };
      Ne = (0, s.__decorate)([(0, ge.e)(Pe.Q), (0, s.__metadata)("design:paramtypes", [Se])], Ne);
      var ke = r(65796);
      let Le = class {
        constructor(e) {
          this.store = e;
        }
        execute({ body: e }) {
          const { credentialIds: t } = e;
          return this.store.state$.pipe(
            (0, ye.U)((e) =>
              (0, h.Vp)(
                ((e, t) =>
                  Object.keys(e)
                    .reduce((t, r) => [...t, ...e[r].compromised], [])
                    .filter((e) => t.includes(e)))(e.index, t)
              )
            )
          );
        }
      };
      Le = (0, s.__decorate)([(0, ge.e)(ke.v), (0, s.__metadata)("design:paramtypes", [Se])], Le);
      var Me = r(32069);
      let Ve = class {
        constructor(e) {
          this.store = e;
        }
        execute({ body: e }) {
          const { breachId: t } = e;
          return this.store.state$.pipe(
            (0, ye.U)((e) =>
              (0, h.Vp)(
                ((e, t) =>
                  Object.keys(e.index).reduce(
                    (r, s) => [
                      ...r,
                      ...e.index[s].compromised.filter((r) => {
                        const s = V(e.credentialsAtRisk[r], S.gI.Compromised);
                        return s?.breaches.some((e) => e.breachId === t);
                      })
                    ],
                    []
                  ))(e, t)
              )
            )
          );
        }
      };
      Ve = (0, s.__decorate)([(0, ge.e)(Me.A), (0, s.__metadata)("design:paramtypes", [Se])], Ve);
      var Ge = r(7466);
      function je(e) {
        const t = {};
        return (
          Object.keys(e).forEach((r) => {
            const s = e[r].spaceId;
            void 0 === t[s] ? (t[s] = 1) : t[s]++;
          }),
          t
        );
      }
      let qe = class {
        constructor(e, t) {
          (this.store = e), (this.credentialsGetter = t);
        }
        execute() {
          return this.store.state$.pipe(
            (0, fe.V)(this.credentialsGetter.get()),
            (0, ye.U)(([e, t]) => {
              const r = {};
              if (!(0, h.d6)(t)) throw new Error("Error while retrieving credentials");
              const s = je(t.data),
                a = Object.keys(t.data).length,
                n = (function (e) {
                  const t = {};
                  return (
                    Object.keys(e).forEach((r) => {
                      const s = V(e[r], S.gI.Compromised),
                        a = e[r].spaceId;
                      if (void 0 === s) return;
                      void 0 === t[a] && (t[a] = { breaches: new Set(), compromisedByBreaches: {} });
                      const n = s.breaches.map((e) => e.breachId);
                      (t[a].breaches = new Set([...t[a].breaches, ...n])), (t[a].compromisedByBreaches[r] = new Set(n));
                    }),
                    t
                  );
                })(e.credentialsAtRisk);
              let i = new Set([]),
                o = {},
                c = 0;
              return (
                Object.keys(e.index).forEach((t) => {
                  const a = e.index[t],
                    u = Ce(a, s[t]);
                  (r[t] = {
                    ...u,
                    breaches: n[t]?.breaches ?? new Set(),
                    compromisedByBreach: n[t]?.compromisedByBreaches ?? {},
                    corrupted: a.corruptedCount
                  }),
                    (i = new Set([...i, ...(n[t]?.breaches ?? new Set())])),
                    (o = { ...o, ...(n[t]?.compromisedByBreaches ?? {}) }),
                    (c += a.corruptedCount);
                }),
                (r.global = { ...Re(e.index, a), breaches: i, compromisedByBreach: o, corrupted: c }),
                (0, h.Vp)(r)
              );
            })
          );
        }
      };
      qe = (0, s.__decorate)([(0, ge.e)(Ge.b), (0, s.__metadata)("design:paramtypes", [w, N.J])], qe);
      var Ke = r(48844);
      const We = (e) => {
        if (!e) return;
        const t = e;
        if (
          !(
            (r = t.spaces) &&
            Array.isArray(r) &&
            0 !== r.length &&
            ((e) => {
              if (!e) return !1;
              const t = e;
              return !!(
                t.associatedEmail &&
                t.billingAdmins &&
                t.color &&
                t.info &&
                t.letter &&
                t.planType &&
                t.status &&
                t.teamAdmins &&
                t.teamId &&
                t.teamName &&
                t.tier
              );
            })(r.find((e) => "accepted" === e.status))
          )
        )
          return;
        var r;
        const s = t.spaces.find((e) => "accepted" === e.status);
        return s?.teamId;
      };
      let Be = class {
        constructor(e) {
          this.carbon = e;
        }
        get() {
          const {
            queries: { carbonState: e }
          } = this.carbon;
          return e({ path: "userSession.localSettings.premiumStatus" }).pipe((0, Ke.Qn)(We));
        }
      };
      Be = (0, s.__decorate)([(0, T.GS)(), (0, s.__metadata)("design:paramtypes", [p.CarbonLegacyClient])], Be);
      var ze = r(23347);
      const He = A.z.object({ lastSentDate: A.z.number() }),
        $e = (A.z.object({ lastSentDate: A.z.number(), lastHash: A.z.string() }), (e) => He.safeParse(e).success);
      class Qe extends (0, y.Q)({
        persist: !0,
        storage: {
          initialValue: { lastSentDate: 0, lastHash: "" },
          typeGuard: $e,
          schemaVersion: 2,
          migrateStorageSchema: () => ({ lastSentDate: 0, lastHash: "" })
        },
        scope: d.F.User,
        storeName: "user-activity-state",
        storeTypeGuard: $e,
        codec: g.E,
        capacity: ze.Y._001KB,
        isCache: !0
      }) {}
      let Ye = class {
        constructor(e, t) {
          (this.client = e), (this.healthCacheUpdater = t);
        }
        async run() {
          await this.healthCacheUpdater.updateHealthState();
        }
      };
      Ye = (0, s.__decorate)([(0, T.GS)(), (0, s.__metadata)("design:paramtypes", [U.w, he])], Ye);
      var Xe = r(25547),
        Je = r(68307),
        Ze = r(61501),
        et = r(96303),
        tt = r(54066);
      const rt = 0;
      const st = (e) => Math.floor(e / 1e3);
      let at = class {
        constructor(e, t, r, s, a, n) {
          (this.serverApiClient = e),
            (this.userActivityStore = t),
            (this.credentialsGetter = r),
            (this.store = s),
            (this.md5Hasher = a),
            (this.currentSpaceGetter = n);
        }
        async sendIfReportUpdated() {
          const e = await (0, de.z)(this.currentSpaceGetter.get());
          if (!(0, h.d6)(e)) throw new Error("Error while retrieving current space for activity report");
          const t = (0, h.db)(e);
          if (!t) return Promise.resolve();
          const r = await this.store.getState(),
            s = await this.userActivityStore.getState(),
            a = await (0, de.z)(this.credentialsGetter.get()),
            n = Date.now(),
            i = st(n),
            o = st(s.lastSentDate || n);
          if (!(0, h.d6)(a)) throw new Error("Error while retrieving credentials");
          const c = je(a.data),
            u = (function (e, t, r) {
              const s = e[r],
                a = t[r] ?? 0;
              return s
                ? {
                    checkedPasswords: s.excluded.length,
                    compromisedPasswords: s.compromised.length,
                    nbrPasswords: a,
                    reused: s.reused.length,
                    safePasswords: a - s.corruptedCount,
                    securityIndex: Ae((0, Te.R9)(s.corruptedCount, s.importantCorruptedCount, a - s.excluded.length)) ?? rt,
                    weakPasswords: s.weak.length
                  }
                : {
                    checkedPasswords: 0,
                    compromisedPasswords: 0,
                    nbrPasswords: a,
                    reused: 0,
                    safePasswords: a,
                    securityIndex: a < Te.RG ? rt : Te.JK,
                    weakPasswords: 0
                  };
            })(r.index, c, t),
            d = s.lastHash,
            l = (0, et.k)(this.md5Hasher.compute((0, tt.u)(JSON.stringify(u))));
          return (
            d === l ||
              (await (0, de.z)(
                this.serverApiClient.v1.useractivity.create({
                  userActivity: { securityIndex: 0 },
                  teamActivity: t ? { teamId: parseInt(t, 10), activity: u } : void 0,
                  relativeEnd: i,
                  relativeStart: o
                })
              ),
              this.userActivityStore.set({ lastSentDate: n, lastHash: l })),
            Promise.resolve()
          );
        }
      };
      at = (0, s.__decorate)([(0, T.GS)(), (0, s.__metadata)("design:paramtypes", [Ze.l, Qe, N.J, w, i.f, Be])], at);
      var nt = r(21242);
      let it = class {
        constructor(e, t) {
          (this.featureFlips = e), (this.userActivitySender = t);
        }
        async isPasswordHealthEnabled() {
          const { userFeatureFlips: e } = this.featureFlips.queries,
            t = await (0, de.z)(e());
          return !!(0, h.hx)(t) || !(0, h.db)(t).web_disable_password_health;
        }
        async handle() {
          (await this.isPasswordHealthEnabled()) && (await this.userActivitySender.sendIfReportUpdated());
        }
      };
      it = (0, s.__decorate)([(0, Je.b)(Xe.w), (0, s.__metadata)("design:paramtypes", [nt.P, at])], it);
      var ot = r(20587),
        ct = r(11564),
        ut = r(60765);
      let dt = class {
        constructor(e, t) {
          (this.store = e), (this.cqrsClient = t);
        }
        async handle({ body: e }) {
          const { credentialId: t } = e,
            {
              commands: { trackEvent: r }
            } = this.cqrsClient.getClient(ot.Yu),
            s = ((e) => ({ is_excluded: !!e && Q(e), is_weak: !!e && z(e), is_reused: !!e && H(e), is_compromised: !!e && $(e) }))(
              (await (0, de.z)(this.store.state$)).credentialsAtRisk[t]
            );
          return r({ event: new ut.UserCredentialHealthReportEvent({ credentialSecurityStatus: s, itemId: t }) }), Promise.resolve(void 0);
        }
      };
      dt = (0, s.__decorate)([(0, Je.b)(ct.p), (0, s.__metadata)("design:paramtypes", [Se, U.w])], dt);
      var lt = r(82706),
        pt = r(72989);
      let ht = class {
        constructor(e) {
          this.healthCacheUpdater = e;
        }
        handle({ body: e }) {
          const { ids: t, vaultItemType: r } = e;
          return (
            r === lt.U.Credential && this.healthCacheUpdater.update({ isOutdated: !0, updatedCredentialIds: t }), Promise.resolve(void 0)
          );
        }
      };
      ht = (0, s.__decorate)([(0, Je.b)(pt.V), (0, s.__metadata)("design:paramtypes", [he])], ht);
      var mt = r(3137);
      let yt = class {
        constructor(e) {
          this.healthCacheUpdater = e;
        }
        handle({ body: e }) {
          const { ids: t, vaultItemType: r } = e;
          return (
            r === lt.U.Credential && this.healthCacheUpdater.update({ isOutdated: !0, updatedCredentialIds: t }), Promise.resolve(void 0)
          );
        }
      };
      yt = (0, s.__decorate)([(0, Je.b)(mt.J), (0, s.__metadata)("design:paramtypes", [he])], yt);
      var gt = r(49135);
      let vt = class {
        constructor(e) {
          this.healthCacheUpdater = e;
        }
        handle({ body: e }) {
          const { ids: t, vaultItemType: r } = e;
          return (
            r === lt.U.Credential && this.healthCacheUpdater.update({ isOutdated: !0, deletedCredentialIds: t }), Promise.resolve(void 0)
          );
        }
      };
      vt = (0, s.__decorate)([(0, Je.b)(gt.s), (0, s.__metadata)("design:paramtypes", [he])], vt);
      let ft = class {};
      ft = (0, s.__decorate)(
        [
          (0, o.Y)({
            api: a.d,
            crons: [{ handler: Ye, name: "health-cache", periodInMinutes: 15, scope: d.F.User }],
            handlers: {
              commands: { updateIsCredentialExcluded: _, recalculatePasswordHealth: me },
              events: {
                ...(0, o.g)(a.d, { passwordHealthComputationFinished: it }),
                ...(0, o.g)(c.Y, { passwordAutofillPerformed: dt }),
                ...(0, o.g)(u.L, { updated: ht, created: yt, deleted: vt })
              },
              queries: {
                credentialHealthData: _e,
                score: xe,
                filterCredentials: Ne,
                compromisedCredentials: Le,
                compromisedCredentialsIdsForBreach: Ve,
                passwordHealthReport: qe
              }
            },
            imports: [n.n],
            stores: [w, Qe, P],
            providers: [N.J, O.U, ue, le, he, Ye, L, at, Se, i.f, Be],
            requiredFeatureFlips: ["web_disable_password_health"]
          })
        ],
        ft
      );
    },
    86742: (e, t, r) => {
      "use strict";
      r.d(t, { JK: () => c, R9: () => u, RG: () => s });
      const s = 5,
        a = 0.6,
        n = 1,
        i = 1,
        o = 0.2,
        c = 100;
      function u(e, t, r) {
        if (r < s) return null;
        const c = a * Math.pow(1 - t / r, n),
          u = (1 - a) * Math.pow(1 - e / r, i);
        return o + (1 - o) * (c + u);
      }
    },
    63277: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => V });
      var s = r(88802),
        a = r(99634),
        n = r(93856),
        i = r(57668),
        o = r(57924),
        c = r(94189),
        u = r(20587),
        d = r(87279),
        l = r(60765),
        p = r(60399),
        h = r(59206),
        m = r(45883),
        y = r(86742),
        g = r(53576),
        v = r(48844),
        f = r(7165);
      const w = f.z.object({ Id: f.z.string(), VaultItems: f.z.array(f.z.object({ Id: f.z.string() })) }),
        S = f.z.array(w);
      let E = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        get() {
          const {
            queries: { carbonState: e }
          } = this.carbonLegacyClient;
          return e({ path: "userSession.personalData.collections" }).pipe(
            (0, v.Qn)((e) => {
              if (!((e) => S.safeParse(e).success)(e)) throw new Error("Collection array has a wrong format");
              return e;
            })
          );
        }
      };
      E = (0, s.__decorate)([(0, o.GS)(), (0, s.__metadata)("design:paramtypes", [g.CarbonLegacyClient])], E);
      var _ = r(25029),
        b = r(95681),
        T = r(23347),
        A = r(28489),
        C = r(10722);
      const R = (e) => !(!e || "object" != typeof e) && (0, A.l$)(e, "lastSentDate") && "number" == typeof e.lastSentDate;
      class I extends (0, b.Q)({
        codec: C.E,
        persist: !0,
        storage: { initialValue: { lastSentDate: 0 }, schemaVersion: 1, typeGuard: R },
        scope: _.F.User,
        storeName: "vault-report",
        storeTypeGuard: R,
        capacity: T.Y._001KB,
        isCache: !0
      }) {}
      const x = {
        collections_count: -1,
        collections_shared_count: -1,
        multiple_collections_count: -1,
        multiple_collections_shared_count: -1,
        single_collection_count: -1,
        single_collection_shared_count: -1,
        shared_count: -1,
        total_count: -1
      };
      function P(e) {
        if (0 === e.length) return 0;
        const t = e.flatMap((e) => e.VaultItems),
          r = new Set(t.map((e) => e.Id)).size;
        return Math.round(t.length / r);
      }
      function D(e) {
        if (0 === e.length) return 0;
        let t = 0,
          r = 0;
        for (const s of e) s.VaultItems.length > 0 && ((r += s.VaultItems.length), t++);
        return Math.round(r / t);
      }
      function U(e, t) {
        let r = 0,
          s = 0;
        const a = e
          .map((e) => e.VaultItems)
          .reduce(
            (e, t) => (
              t.forEach((t) => {
                const r = t.Id;
                e[r] ? (e[r] += 1) : (e[r] = 1);
              }),
              e
            ),
            {}
          );
        return (
          Object.values(a).forEach((e) => {
            e > 1 ? r++ : s++;
          }),
          {
            collections_count: e.length,
            collections_shared_count: -1,
            multiple_collections_count: r,
            multiple_collections_shared_count: -1,
            single_collection_count: s,
            single_collection_shared_count: -1,
            shared_count: -1,
            total_count: t
          }
        );
      }
      function F(e, t) {
        return {
          itemsTotalCount: -1,
          itemsSharedCount: -1,
          collectionsTotalCount: e.length,
          collectionsSharedCount: -1,
          itemsPerCollectionAverageCount: D(e),
          collectionsPerItemAverageCount: P(e),
          ids: x,
          passwords: U(e, t),
          payments: x,
          personalInfo: x,
          secureNotes: x
        };
      }
      var O = r(9811);
      let N = class {
        constructor(e, t, r, s, a) {
          (this.breachesGetter = e), (this.credentialGetter = t), (this.vaultCollectionGetter = r), (this.store = s), (this.cqrsClient = a);
        }
        getSpaceScope(e) {
          switch (e) {
            case "":
              return l.Scope.Personal;
            case "global":
              return l.Scope.Global;
            default:
              return l.Scope.Team;
          }
        }
        async send() {
          const { queries: e } = this.cqrsClient.getClient(i.d),
            t = await (0, p.z)(e.passwordHealthReport()),
            r = await (0, p.z)(this.credentialGetter.get()),
            s = await (0, p.z)(this.vaultCollectionGetter.get()),
            a = await (0, p.z)(this.breachesGetter.getSupportedBreaches()),
            {
              commands: { trackEvent: n }
            } = this.cqrsClient.getClient(u.Yu);
          if (!((0, d.d6)(r) && (0, d.d6)(a) && (0, d.d6)(t) && (0, d.d6)(s)))
            return Promise.reject(new Error("Error while retrieving credentials/breaches/health/collections"));
          const o = (function (e) {
              const t = { global: { domainsWithoutAutofill: 0, nbrPasswords: 0, passwordsWithOtpCount: 0, protectedPasswords: 0 } };
              return (
                Object.keys(e).forEach((r) => {
                  const s = e[r].spaceId;
                  void 0 === t[s] &&
                    (t[s] = { domainsWithoutAutofill: 0, nbrPasswords: 0, passwordsWithOtpCount: 0, protectedPasswords: 0 }),
                    t[s].nbrPasswords++,
                    t.global.nbrPasswords++,
                    e[r].autoLogin || (t[s].domainsWithoutAutofill++, t.global.domainsWithoutAutofill++),
                    (e[r].otpSecret || e[r].otpUrl) && (t[s].passwordsWithOtpCount++, t.global.passwordsWithOtpCount++),
                    e[r].autoProtected && (t[s].protectedPasswords++, t.global.protectedPasswords++);
                }),
                t
              );
            })(r.data),
            c = (function (e, t) {
              const r = new Set(),
                s = new Set();
              e.forEach((e) => {
                (0, O.F7)(e.Content) ? s.add(e.Id) : r.add(e.Id);
              });
              const a = new Set(),
                n = new Set(),
                i = {
                  global: {
                    activePrivateBreachAlerts: 0,
                    activePublicBreachAlerts: 0,
                    passwordsCompromisedThroughPrivateBreaches: 0,
                    privateBreachAlerts: s.size,
                    publicBreachAlerts: r.size
                  }
                };
              return (
                Object.keys(t).forEach((e) => {
                  if ("global" === e) return;
                  const o = t[e];
                  void 0 === i[e] &&
                    (i[e] = {
                      activePrivateBreachAlerts: 0,
                      activePublicBreachAlerts: 0,
                      passwordsCompromisedThroughPrivateBreaches: 0,
                      privateBreachAlerts: s.size,
                      publicBreachAlerts: r.size
                    }),
                    [...o.breaches].forEach((t) => {
                      r.has(t) ? (i[e].activePublicBreachAlerts++, a.add(t)) : s.has(t) && (i[e].activePrivateBreachAlerts++, n.add(t));
                    }),
                    Object.keys(o.compromisedByBreach).forEach((t) => {
                      [...o.compromisedByBreach[t]].some((e) => s.has(e)) && i[e].passwordsCompromisedThroughPrivateBreaches++;
                    }),
                    (i.global.passwordsCompromisedThroughPrivateBreaches += i[e].passwordsCompromisedThroughPrivateBreaches);
                }),
                (i.global.activePrivateBreachAlerts = n.size),
                (i.global.activePublicBreachAlerts = a.size),
                i
              );
            })(a.data, t.data);
          return (
            Object.keys(o).forEach((e) => {
              const r = t.data[e],
                a = { scope: this.getSpaceScope(e), ...F(s.data, o[e].nbrPasswords), ...o[e], ...c[e] },
                i = r
                  ? {
                      passwordsSafeCount: o[e].nbrPasswords - r.corrupted,
                      passwordsExcludedCount: r.excluded,
                      passwordsCompromisedCount: r.compromised,
                      passwordsReusedCount: r.reused,
                      securityScore: r.score ?? void 0,
                      passwordsWeakCount: r.weak
                    }
                  : {
                      passwordsSafeCount: o[e].nbrPasswords,
                      passwordsExcludedCount: 0,
                      passwordsCompromisedCount: 0,
                      passwordsReusedCount: 0,
                      securityScore: o[e].nbrPasswords < y.RG ? void 0 : y.JK,
                      passwordsWeakCount: 0
                    };
              n({ event: new l.UserVaultReportEvent({ ...a, ...i }) });
            }),
            this.store.set({ lastSentDate: Date.now() }),
            Promise.resolve()
          );
        }
        async shouldBeSent() {
          return (await (0, p.z)(this.store.state$)).lastSentDate + 864e5 < Date.now();
        }
      };
      N = (0, s.__decorate)([(0, o.GS)(), (0, s.__metadata)("design:paramtypes", [h.U, m.J, E, I, c.w])], N);
      var k = r(25547),
        L = r(68307);
      let M = class {
        constructor(e) {
          this.vaultReportSender = e;
        }
        async handle() {
          (await this.vaultReportSender.shouldBeSent()) && this.vaultReportSender.send();
        }
      };
      M = (0, s.__decorate)([(0, L.b)(k.w), (0, s.__metadata)("design:paramtypes", [N])], M);
      let V = class {};
      V = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.f,
            handlers: { commands: {}, events: { ...(0, a.g)(i.d, { passwordHealthComputationFinished: M }) }, queries: {} },
            providers: [h.U, m.J, N, E],
            stores: [I]
          })
        ],
        V
      );
    },
    57578: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => i });
      var s = r(86952),
        a = r(75183),
        n = r(43832);
      const i = (0, s.Q)({ name: "userConsents", commands: { UpdateConsentsCommand: a.a }, events: {}, queries: { getConsents: n.o } });
    },
    75183: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    43832: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    46093: (e, t, r) => {
      "use strict";
      r.d(t, { K: () => w });
      var s = r(88802),
        a = r(99634),
        n = r(57578),
        i = r(63663),
        o = r(75183),
        c = r(60399),
        u = r(57924),
        d = r(61501),
        l = r(48844),
        p = r(87279);
      let h = class {
        constructor(e) {
          this.serverApiClient = e;
        }
        updateConsents({ triggerBy: e, consents: t }) {
          return (0, c.z)(
            this.serverApiClient.v1.userconsents.updateConsents({ triggerBy: e, consents: t }).pipe(
              (0, l.DZ)((e) => {
                throw new Error(e.message);
              }),
              (0, l.lk)((e) => (0, p.Vp)(e.data))
            )
          );
        }
      };
      h = (0, s.__decorate)([(0, u.GS)(), (0, s.__metadata)("design:paramtypes", [d.l])], h);
      let m = class {
        constructor(e) {
          this.userConsentsService = e;
        }
        execute({ body: { triggerBy: e, consents: t } }) {
          return this.userConsentsService.updateConsents({ triggerBy: e, consents: t });
        }
      };
      m = (0, s.__decorate)([(0, i.W)(o.a), (0, s.__metadata)("design:paramtypes", [h])], m);
      var y = r(20754),
        g = r(43832);
      let v = class {
        constructor(e) {
          this.serverApiClient = e;
        }
        execute() {
          return this.serverApiClient.v1.userconsents.getConsents({ format: "two-consents" }).pipe(
            (0, l.Qn)((e) => e.data),
            (0, l.DZ)((e) => {
              throw new Error(e.message);
            })
          );
        }
      };
      v = (0, s.__decorate)([(0, y.e)(g.o), (0, s.__metadata)("design:paramtypes", [d.l])], v);
      var f = r(1824);
      let w = class {};
      w = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.y,
            imports: [f.n],
            providers: [h],
            handlers: { commands: { updateConsents: m }, events: {}, queries: { getConsents: v } }
          })
        ],
        w
      );
    },
    89193: (e, t, r) => {
      "use strict";
      r.d(t, { g: () => n });
      var s = r(86952),
        a = r(98976);
      const n = (0, s.Q)({ name: "activityLogs", commands: { storeActivityLogs: a.M }, events: {}, queries: {} });
    },
    98976: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => i, W: () => s });
      var s,
        a = r(74354),
        n = r(25029);
      !(function (e) {
        (e.AUDIT_LOG_MISSING_JSON_SCHEMA = "AUDIT_LOG_MISSING_JSON_SCHEMA"),
          (e.AUDIT_LOG_INVALID_JSON_FOR_JSON_SCHEMA = "AUDIT_LOG_INVALID_JSON_FOR_JSON_SCHEMA"),
          (e.AUDIT_LOG_INVALID_LOG_SCHEMA_TYPE_OR_VERSION = "AUDIT_LOG_INVALID_LOG_SCHEMA_TYPE_OR_VERSION"),
          (e.AUDIT_LOG_ERROR_READING_JSON_SCHEMA = "AUDIT_LOG_ERROR_READING_JSON_SCHEMA"),
          (e.STORING_SENSITIVE_AUDIT_LOGS_NOT_ALLOWED = "STORING_SENSITIVE_AUDIT_LOGS_NOT_ALLOWED");
      })(s || (s = {}));
      class i extends (0, a.g)({ scope: n.F.User }) {}
    },
    97494: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          ActivityLogCategory: () => a,
          ActivityLogType: () => s,
          StoreActivityLogsCommand: () => i.M,
          StoreActivityLogsInvalidLogsError: () => i.W,
          activityLogsApi: () => n.g
        });
      var s,
        a,
        n = r(89193),
        i = r(98976);
      !(function (e) {
        (e.UserInvited = "user_invited"),
          (e.UserReinvited = "user_reinvited"),
          (e.UserRemoved = "user_removed"),
          (e.TeamCaptainAdded = "team_captain_added"),
          (e.TeamCaptainRemoved = "team_captain_removed"),
          (e.GroupManagerAdded = "group_manager_added"),
          (e.GroupManagerRemoved = "group_manager_removed"),
          (e.MasterPasswordResetAccepted = "master_password_reset_accepted"),
          (e.MasterPasswordResetRefused = "master_password_reset_refused"),
          (e.BillingAdminAdded = "billing_admin_added"),
          (e.BillingAdminRemoved = "billing_admin_removed"),
          (e.UserGroupCreated = "user_group_created"),
          (e.UserGroupRenamed = "user_group_renamed"),
          (e.UserGroupDeleted = "user_group_deleted"),
          (e.UserJoinedUserGroup = "user_joined_user_group"),
          (e.UserLeftUserGroup = "user_left_user_group"),
          (e.UserInvitedToUserGroup = "user_invited_to_user_group"),
          (e.UserDeclinedInviteToUserGroup = "user_declined_invite_to_user_group"),
          (e.UserRemovedFromUserGroup = "user_removed_from_user_group"),
          (e.DomainRequested = "domain_requested"),
          (e.DomainValidated = "domain_validated"),
          (e.SensitiveLogsEnabled = "collect_sensitive_data_audit_logs_enabled"),
          (e.SensitiveLogsDisabled = "collect_sensitive_data_audit_logs_disabled"),
          (e.SsoIdpMetadataSet = "sso_idp_metadata_set"),
          (e.SsoServiceProviderUrlSet = "sso_service_provider_url_set"),
          (e.SsoEnabled = "sso_enabled"),
          (e.SsoDisabled = "sso_disabled"),
          (e.NitroSsoDomainProvisioned = "nitro_sso_domain_provisioned"),
          (e.NitroSsoDomainRemoved = "nitro_sso_domain_removed"),
          (e.NitroSsoDomainVerified = "nitro_sso_domain_verified"),
          (e.NitroSsoSetupStarted = "nitro_sso_setup_started"),
          (e.TeamNameChanged = "team_name_changed"),
          (e.NewBillingPeriodCreated = "new_billing_period_created"),
          (e.SeatsAdded = "seats_added"),
          (e.ContactEmailChanged = "contact_email_changed"),
          (e.MasterPasswordMobileResetEnabled = "master_password_mobile_reset_enabled"),
          (e.MasterPasswordMobileResetDisabled = "master_password_mobile_reset_disabled"),
          (e.MasterPasswordMobileReset = "master_password_mobile_reset"),
          (e.MasterPasswordChanged = "master_password_changed"),
          (e.MpToViewPasswordsEnabled = "mp_to_view_passwords_enabled"),
          (e.MpToViewPasswordsDisabled = "mp_to_view_passwords_disabled"),
          (e.TwoFactorAuthenticationLoginMethodAdded = "two_factor_authentication_login_method_added"),
          (e.TwoFactorAuthenticationLoginMethodRemoved = "two_factor_authentication_login_method_removed"),
          (e.BiometricSignInDisabled = "biometric_sign_in_disabled"),
          (e.DWMEmailAdded = "dwm_email_added"),
          (e.DWMEmailRemoved = "dwm_email_removed"),
          (e.DWMAlertReceived = "dwm_alert_received"),
          (e.UserDeviceAdded = "user_device_added"),
          (e.UserDeviceRemoved = "user_device_removed"),
          (e.UserDeviceLogin = "user_device_login"),
          (e.MasterPasswordReset = "master_password_reset"),
          (e.RequestedAccountRecovery = "requested_account_recovery"),
          (e.CompletedAccountRecovery = "completed_account_recovery"),
          (e.UserSharedCredentialWithGroup = "user_shared_credential_with_group"),
          (e.UserSharedCredentialWithEmail = "user_shared_credential_with_email"),
          (e.UserSharedCredentialWithExternal = "user_shared_credential_with_external"),
          (e.UserSharedSecureNoteWithGroup = "user_shared_secure_note_with_group"),
          (e.UserSharedSecureNoteWithEmail = "user_shared_secure_note_with_email"),
          (e.UserSharedSecureNoteWithExternal = "user_shared_secure_note_with_external"),
          (e.UserRevokedSharedCredentialGroup = "user_revoked_shared_credential_group"),
          (e.UserRevokedSharedCredentialEmail = "user_revoked_shared_credential_email"),
          (e.UserRevokedSharedCredentialExternal = "user_revoked_shared_credential_external"),
          (e.UserRevokedSharedSecureNoteGroup = "user_revoked_shared_secure_note_group"),
          (e.UserRevokedSharedSecureNoteEmail = "user_revoked_shared_secure_note_email"),
          (e.UserRevokedSharedSecureNoteExternal = "user_revoked_shared_secure_note_external"),
          (e.UserAcceptedSharingInviteSecureNote = "user_accepted_sharing_invite_secure_note"),
          (e.UserRejectedSharingInviteSecureNote = "user_rejected_sharing_invite_secure_note"),
          (e.UserAcceptedSharingInviteCredential = "user_accepted_sharing_invite_credential"),
          (e.UserRejectedSharingInviteCredential = "user_rejected_sharing_invite_credential"),
          (e.UserCreatedCredential = "user_created_credential"),
          (e.UserModifiedCredential = "user_modified_credential"),
          (e.UserDeletedCredential = "user_deleted_credential"),
          (e.UserImportedCredentials = "user_imported_credentials"),
          (e.UserCreatedSecureNote = "user_created_secure_note"),
          (e.UserModifiedSecureNote = "user_modified_secure_note"),
          (e.UserDeletedSecureNote = "user_deleted_secure_note");
      })(s || (s = {})),
        (function (e) {
          (e.Account = "account"),
            (e.Authentication = "authentication"),
            (e.DarkWebMonitoring = "dark_web_monitoring"),
            (e.Groups = "groups"),
            (e.ImportExport = "import_export"),
            (e.TeamSettings = "team_settings"),
            (e.TeamSettingsActiveDirectory = "team_settings_activedirectory"),
            (e.TeamSettingsPolicies = "team_settings_policies"),
            (e.TeamSettingsSAMLProvisioning = "team_settings_samlprovisioning"),
            (e.TeamSettingsSCIM = "team_settings_scim"),
            (e.TeamSettingsSSO = "team_settings_sso"),
            (e.Sharing = "sharing"),
            (e.UserSettings = "user_settings"),
            (e.UserSettingsAccountRecovery = "user_settings_accountrecovery"),
            (e.Users = "users"),
            (e.VaultIDs = "vault_ids"),
            (e.VaultPasswords = "vault_passwords"),
            (e.VaultPayments = "vault_payments"),
            (e.VaultPersonalInfo = "vault_personalinfo"),
            (e.VaultSecureNotes = "vault_securenotes");
        })(a || (a = {}));
    },
    4070: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => I });
      var s = r(88802),
        a = r(99634),
        n = r(1824),
        i = r(89193),
        o = r(25029),
        c = r(95681),
        u = r(23347),
        d = r(10722);
      const l = (e) => !(!e || "object" != typeof e) && "activityLogsQueue" in e && Array.isArray(e.activityLogsQueue);
      class p extends (0, c.Q)({
        persist: !0,
        storage: { initialValue: { activityLogsQueue: [] }, typeGuard: l, schemaVersion: 1 },
        scope: o.F.User,
        storeName: "activity-logs",
        storeTypeGuard: l,
        codec: d.E,
        capacity: u.Y._010KB
      }) {}
      var h = r(53576),
        m = r(57924),
        y = r(48844);
      let g = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        get() {
          const {
            queries: { carbonState: e }
          } = this.carbonLegacyClient;
          return e({ path: "state.userSession.spaceData.spaces" }).pipe(
            (0, y.Qn)((e) => {
              if (
                !((e) =>
                  !!Array.isArray(e) &&
                  (0 === e.length ||
                    e.every((e) => {
                      const t = e;
                      return "string" == typeof t?.teamId && "object" == typeof t?.details && "string" == typeof t?.details.status;
                    })))(e)
              )
                throw new Error("Bad space item format");
              const t = e.find((e) => "accepted" === e.details.status),
                r = t?.details.info.collectSensitiveDataAuditLogsEnabled;
              return Boolean(r);
            })
          );
        }
      };
      g = (0, s.__decorate)([(0, m.GS)(), (0, s.__metadata)("design:paramtypes", [h.CarbonLegacyClient])], g);
      var v = r(64987),
        f = r(98976),
        w = r(63663),
        S = r(87279),
        E = r(60399);
      const _ = new v.WU();
      let b = class {
        constructor(e, t) {
          (this.activityLogsStore = e), (this.sensitiveLogsEnabledGetter = t);
        }
        async execute({ body: { activityLogs: e } }) {
          const t = await (0, E.z)(this.sensitiveLogsEnabledGetter.get());
          if (!(0, S.d6)(t)) throw new Error("Error while getting sensitive logs enabled data");
          const r = e.filter((e) => !e.is_sensitive || t.data);
          return r.length && (await this.updateActivityLogsState(r)), Promise.resolve((0, S.Vp)(void 0));
        }
        async updateActivityLogsState(e) {
          await _.runExclusive(async () => {
            const t = await this.activityLogsStore.getState();
            await this.activityLogsStore.set({ ...t, activityLogsQueue: [...t.activityLogsQueue, ...e] });
          });
        }
      };
      b = (0, s.__decorate)([(0, w.W)(f.M), (0, s.__metadata)("design:paramtypes", [p, g])], b);
      var T = r(9671),
        A = r(61501);
      let C = class {
        constructor(e) {
          this.serverApiClient = e;
        }
        async sendLogs(e) {
          return await (0, E.z)(
            this.serverApiClient.v1.teams.storeAuditLogs({ auditLogs: e }).pipe(
              (0, y.DZ)(() => (0, S.Rn)("storeActivityLogs failed with an unknown HTTP error")),
              (0, y.lk)((e) =>
                e.data.invalidAuditLogs.length
                  ? (0, S.Vp)(this.serverToTechnicalSchemaErrorsMapper(e.data.invalidAuditLogs))
                  : (0, S.Vp)(void 0)
              )
            )
          );
        }
        serverToTechnicalSchemaErrorsMapper(e) {
          return { invalidActivityLogs: e.map((e) => ({ uuid: e.uuid, error: f.W[e.error] })) };
        }
      };
      C = (0, s.__decorate)([(0, m.GS)(), (0, s.__metadata)("design:paramtypes", [A.l])], C);
      let R = class {
        constructor(e, t, r) {
          (this.activityLogsService = e), (this.allowedToFail = t), (this.activityLogsStore = r);
        }
        async isRunnable() {
          const { activityLogsQueue: e } = await this.activityLogsStore.getState();
          return e.length > 0;
        }
        async run() {
          const { activityLogsQueue: e } = await this.activityLogsStore.getState();
          await this.attemptSendLogsToServer(e);
        }
        async attemptSendLogsToServer(e) {
          const t = [...e];
          for (; t.length > 0; ) {
            const e = t.splice(0, 40);
            await this.sendLogsToServer(e);
          }
        }
        async sendLogsToServer(e) {
          const t = await this.activityLogsService.sendLogs(e);
          if ((0, S.hx)(t)) return;
          const r = e.map((e) => e.uuid);
          if ((await this.removeSentLogsFromActivityLogsQueue(r), t.data?.invalidActivityLogs)) {
            const r = this.createLogsTypeMap(e),
              s = (e) => () => {
                const t = r.get(e.uuid);
                throw new Error(`An activity log with a log type of ${t} has been detected to have a technical/schema error. (${e.error})`);
              };
            await this.allowedToFail.do((t.data.invalidActivityLogs ?? []).map(s));
          }
        }
        createLogsTypeMap(e) {
          const t = new Map();
          return (
            e.forEach((e) => {
              t.set(e.uuid, e.log_type);
            }),
            t
          );
        }
        async removeSentLogsFromActivityLogsQueue(e) {
          const { activityLogsQueue: t } = await this.activityLogsStore.getState(),
            r = t.filter((t) => !e.includes(t.uuid));
          await this.activityLogsStore.set({ activityLogsQueue: [...r] });
        }
      };
      R = (0, s.__decorate)([(0, m.GS)(), (0, s.__metadata)("design:paramtypes", [C, T.J, p])], R);
      let I = class {};
      I = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: i.g,
            imports: [n.n],
            providers: [C, g],
            stores: [p],
            crons: [{ handler: R, periodInMinutes: 1, name: "activity-logs-cron", scope: o.F.User }],
            handlers: { commands: { storeActivityLogs: b }, events: {}, queries: {} }
          })
        ],
        I
      );
    },
    70305: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => i });
      var s = r(86952),
        a = r(67490),
        n = r(98193);
      const i = (0, s.Q)({
        name: "changeMasterPassword",
        commands: { temporarySendMasterPasswordChangedEvent: n.n },
        events: { masterPasswordChanged: a.D },
        queries: {}
      });
    },
    98193: (e, t, r) => {
      "use strict";
      r.d(t, { n: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    67490: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => n });
      var s = r(88885),
        a = r(25029);
      class n extends (0, s.d)({ scope: a.F.User }) {}
    },
    29597: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          ChangeSessionKeyErrorTypes: () => d.eq,
          CheckSessionKeyErrorTypes: () => w.f3,
          CheckSessionKeyQuery: () => h.Z,
          CheckSessionSessionNotCreated: () => w.OT,
          CloseUserSessionCommand: () => i.V,
          CreateUserSessionCommand: () => o.lk,
          CreatedSessionState: () => l.XL,
          CreatedSessionsStateQuery: () => l.iH,
          DeleteLocalSessionCommand: () => u.G,
          DeviceLimitQuery: () => A.X,
          FlushLocalDataCommand: () => a.e,
          IsAllowedQuery: () => T.bY,
          MasterPasswordChangedEvent: () => E.D,
          MultiAccountNotYetSupported: () => c.y9,
          NotAllowedReason: () => T.Oq,
          OpenUserSessionCommand: () => c.Dx,
          PlatformView: () => A.i,
          PrepareLocalDataFlushCommand: () => n.X,
          SelectedOpenedSessionQuery: () => p._,
          SessionAlreadyExists: () => o.X0,
          SessionAlreadyOpened: () => c.mR,
          SessionClient: () => f.x,
          SessionCloseMode: () => m.K,
          SessionClosedEvent: () => m.X,
          SessionClosingEvent: () => y.Z,
          SessionCreationErrorTypes: () => o.v5,
          SessionKeyChecker: () => w.BD,
          SessionNotCreated: () => c.aK,
          SessionOpenErrorTypes: () => c.T8,
          SessionOpenedEvent: () => g.M,
          SessionOpeningEvent: () => v.$,
          SessionQueryParamsSchema: () => l.cM,
          SessionState: () => l.sM,
          SessionStateQuery: () => l.ZP,
          TemporarySendMasterPasswordChangedEventCommand: () => _.n,
          UnableToUpdateSessionKeyForNonExistingAccount: () => d.pX,
          UnableToUpdateSessionSessionNotOpened: () => d.nA,
          UpdateUserSessionKeyCommand: () => d.yt,
          UserNotLogged: () => T.Fh,
          changeMasterPasswordApi: () => S.v,
          sessionApi: () => s.Q,
          vaultAccessApi: () => b.Y
        });
      var s = r(34710),
        a = r(42858),
        n = r(15473),
        i = r(86334),
        o = r(69207),
        c = r(37334),
        u = r(54703),
        d = r(90032),
        l = r(55510),
        p = r(31839),
        h = r(45911),
        m = r(66134),
        y = r(82398),
        g = r(5237),
        v = r(90775),
        f = r(89358),
        w = r(57385),
        S = r(70305),
        E = r(67490),
        _ = r(98193),
        b = r(65766),
        T = r(57755),
        A = r(49273);
    },
    34710: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => f });
      var s = r(86952),
        a = r(55510),
        n = r(45911),
        i = r(5237),
        o = r(82398),
        c = r(66134),
        u = r(42858),
        d = r(15473),
        l = r(69207),
        p = r(37334),
        h = r(86334),
        m = r(54703),
        y = r(90775),
        g = r(31839),
        v = r(90032);
      const f = (0, s.Q)({
        name: "session",
        commands: {
          FlushLocalDataCommand: u.e,
          PrepareLocalDataFlushCommand: d.X,
          CreateUserSessionCommand: l.lk,
          OpenUserSessionCommand: p.Dx,
          CloseUserSessionCommand: h.V,
          DeleteLocalSessionCommand: m.G,
          UpdateUserSessionKeyCommand: v.yt
        },
        queries: { sessionState: a.ZP, createdSessionsState: a.iH, selectedOpenedSession: g._, checkSessionKey: n.Z },
        events: { SessionOpenedEvent: i.M, SessionClosingEvent: o.Z, SessionClosedEvent: c.X, SessionOpeningEvent: y.$ }
      });
    },
    86334: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.Device }) {}
    },
    69207: (e, t, r) => {
      "use strict";
      r.d(t, { X0: () => o, lk: () => c, v5: () => s });
      var s,
        a = r(74354),
        n = r(25029),
        i = r(96168);
      !(function (e) {
        e.AlreadyExists = "alreadyExists";
      })(s || (s = {}));
      class o extends (0, i.Hu)(s.AlreadyExists, "The session already exists. Delete it first.") {}
      class c extends (0, a.g)({ scope: n.F.Device }) {}
    },
    54703: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.Device }) {}
    },
    42858: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    37334: (e, t, r) => {
      "use strict";
      r.d(t, { Dx: () => d, T8: () => s, aK: () => o, mR: () => c, y9: () => u });
      var s,
        a = r(74354),
        n = r(25029),
        i = r(96168);
      !(function (e) {
        (e.NotCreated = "notCreated"), (e.AlreadyOpened = "alreadyOpened"), (e.MultiAccountNotYetSupported = "multiAccountNotYetSupported");
      })(s || (s = {}));
      class o extends (0, i.Hu)(s.NotCreated, "The session has not been created. Create it first.") {}
      class c extends (0, i.Hu)(s.AlreadyOpened, "The session is already opened for this user. Close it first.") {}
      class u extends (0, i.Hu)(s.MultiAccountNotYetSupported, "Another session is opened. Close it first.") {}
      class d extends (0, a.g)({ scope: n.F.Device }) {}
    },
    15473: (e, t, r) => {
      "use strict";
      r.d(t, { X: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    90032: (e, t, r) => {
      "use strict";
      r.d(t, { eq: () => s, nA: () => c, pX: () => o, yt: () => u });
      var s,
        a = r(74354),
        n = r(25029),
        i = r(96168);
      !(function (e) {
        (e.NotCreated = "notCreated"), (e.NotOpened = "notOpened");
      })(s || (s = {}));
      class o extends (0, i.Hu)(s.NotCreated, "The session has not been created. Create it first.") {}
      class c extends (0, i.Hu)(s.NotOpened, "The session has not been opened") {}
      class u extends (0, a.g)({ scope: n.F.Device }) {}
    },
    66134: (e, t, r) => {
      "use strict";
      r.d(t, { K: () => s, X: () => i });
      var s,
        a = r(88885),
        n = r(25029);
      !(function (e) {
        (e.Close = "close"), (e.Lock = "lock");
      })(s || (s = {}));
      class i extends (0, a.d)({ scope: n.F.Device }) {}
    },
    82398: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => n });
      var s = r(88885),
        a = r(25029);
      class n extends (0, s.d)({ scope: a.F.User }) {}
    },
    5237: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => n });
      var s = r(88885),
        a = r(25029);
      class n extends (0, s.d)({ scope: a.F.User }) {}
    },
    90775: (e, t, r) => {
      "use strict";
      r.d(t, { $: () => n });
      var s = r(88885),
        a = r(25029);
      class n extends (0, s.d)({ scope: a.F.User }) {}
    },
    45911: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.Device }) {}
    },
    31839: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.Device }) {}
    },
    55510: (e, t, r) => {
      "use strict";
      r.d(t, { XL: () => c, ZP: () => u, cM: () => i, iH: () => d, sM: () => o });
      var s = r(99059),
        a = r(25029),
        n = r(7165);
      const i = n.z.object({ email: n.z.string() });
      var o, c;
      !(function (e) {
        (e.NotCreated = "notCreated"), (e.Closed = "closed"), (e.Open = "open");
      })(o || (o = {}));
      class u extends (0, s.k)({ scope: a.F.Device }) {}
      !(function (e) {
        (e.Closed = "closed"), (e.Open = "open");
      })(c || (c = {}));
      class d extends (0, s.k)({ scope: a.F.Device }) {}
    },
    57385: (e, t, r) => {
      "use strict";
      r.d(t, { BD: () => i, OT: () => n, f3: () => s });
      var s,
        a = r(96168);
      !(function (e) {
        e.SessionNotCreated = "notCreated";
      })(s || (s = {}));
      class n extends (0, a.Hu)(s.SessionNotCreated, "The session has not been created. Create it first.") {}
      class i {}
    },
    89358: (e, t, r) => {
      "use strict";
      r.d(t, { x: () => n });
      var s = r(67837),
        a = r(34710);
      class n extends (0, s.E)(a.Q) {}
      (0, s.K)(a.Q, n);
    },
    65766: (e, t, r) => {
      "use strict";
      r.d(t, { Y: () => i });
      var s = r(86952),
        a = r(57755),
        n = r(49273);
      const i = (0, s.Q)({ name: "vaultAccess", commands: {}, events: {}, queries: { isAllowed: a.bY, deviceLimit: n.X } });
    },
    49273: (e, t, r) => {
      "use strict";
      r.d(t, { X: () => i, i: () => s });
      var s,
        a = r(99059),
        n = r(25029);
      !(function (e) {
        (e.Android = "android"),
          (e.DesktopMacOS = "macosx"),
          (e.DesktopWindows = "windows"),
          (e.IPad = "ipad"),
          (e.IPhone = "iphone"),
          (e.IPod = "ipod"),
          (e.Other = "other"),
          (e.StandaloneExtension = "saex"),
          (e.TeamAdminConsole = "tac"),
          (e.WebApp = "webapp");
      })(s || (s = {}));
      class i extends (0, a.k)({ scope: n.F.User }) {}
    },
    57755: (e, t, r) => {
      "use strict";
      r.d(t, { Fh: () => o, Oq: () => s, bY: () => c });
      var s,
        a = r(99059),
        n = r(25029),
        i = r(96168);
      !(function (e) {
        (e.DeviceLimited = "DeviceLimited"),
          (e.Requires2FAEnforcement = "Requires2FAEnforcement"),
          (e.RequiresSSO2MPMigration = "RequiresSSO2MPMigration"),
          (e.RequiresMP2SSOMigration = "RequiresMP2SSOMigration"),
          (e.NoActiveUser = "NoActiveUser");
      })(s || (s = {}));
      class o extends (0, i.Hu)("UserNotLogged", "Please log the user") {}
      class c extends (0, a.k)({ scope: n.F.Device }) {}
    },
    28365: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => h });
      var s = r(88802),
        a = r(99634),
        n = r(70305),
        i = r(81459),
        o = r(57924);
      let c = class extends i.f {};
      c = (0, s.__decorate)([(0, o.GS)()], c);
      var u = r(98193),
        d = r(63663),
        l = r(87279);
      let p = class {
        constructor(e) {
          this.eventEmitter = e;
        }
        execute() {
          return this.eventEmitter.sendEvent("masterPasswordChanged", void 0), Promise.resolve((0, l.Vp)(void 0));
        }
      };
      p = (0, s.__decorate)([(0, d.W)(u.n), (0, s.__metadata)("design:paramtypes", [c])], p);
      let h = class {};
      h = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.v,
            handlers: { commands: { temporarySendMasterPasswordChangedEvent: p }, events: {}, queries: {} },
            providers: [c]
          })
        ],
        h
      );
    },
    32109: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => a });
      var s = r(94805);
      const a = (e) => {
        const [, , t] = e.split("$");
        return "pbkdf2" === t ? s.E1 : s.mr;
      };
    },
    87918: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => l });
      var s = r(88802),
        a = r(60399),
        n = r(53576),
        i = r(57924),
        o = r(54066),
        c = r(43293),
        u = r(48844),
        d = r(25594);
      let l = class {
        constructor(e, t) {
          (this.carbonLegacyClient = e), (this.flexibleDecryptor = t);
        }
        async decrypt(e) {
          const { carbonStateList: t } = this.carbonLegacyClient.queries;
          return await (0, a.z)(
            t({ paths: ["userSession.session.localKey", "userSession.session.masterPassword", "userSession.session.serverKey"] }).pipe(
              (0, u.nb)({
                success: ([t, r, s]) => {
                  if ("string" == typeof t) return this.flexibleDecryptor.decrypt((0, o.u)(t), e);
                  if ("string" == typeof r && "string" == typeof s) {
                    const t = s + r,
                      a = (0, c.N)(t);
                    return this.flexibleDecryptor.decrypt((0, o.u)(a), e);
                  }
                  throw new Error("Wrong types for local data key");
                },
                failure: () => {
                  throw new Error("Failure getting state list");
                }
              })
            )
          );
        }
      };
      l = (0, s.__decorate)([(0, i.GS)(), (0, s.__metadata)("design:paramtypes", [n.CarbonLegacyClient, d.a])], l);
    },
    12642: (e, t, r) => {
      "use strict";
      r.d(t, { Y: () => o });
      var s = r(88802),
        a = r(57924),
        n = r(87918),
        i = r(73378);
      let o = class {
        constructor(e, t) {
          (this.localDataKeyDecryptor = e), (this.localDatKeyaEncryptor = t);
        }
        encode(e) {
          return this.localDatKeyaEncryptor.encrypt(e);
        }
        decode(e) {
          return this.localDataKeyDecryptor.decrypt(e);
        }
      };
      o = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [n.t, i.n])], o);
    },
    73378: (e, t, r) => {
      "use strict";
      r.d(t, { n: () => g });
      var s = r(88802),
        a = r(60399),
        n = r(57924),
        i = r(53576),
        o = r(48844),
        c = r(94805),
        u = r(16698),
        d = r(54066),
        l = r(43293),
        p = r(66122),
        h = r(56268),
        m = r(19603),
        y = r(32109);
      let g = class {
        constructor(e, t, r) {
          (this.carbonLegacyClient = e), (this.flexibleEncryptor = t), (this.randomValuesGetter = r);
        }
        async encrypt(e) {
          const { carbonStateList: t } = this.carbonLegacyClient.queries;
          return await (0, a.z)(
            t({
              paths: [
                "userSession.session.localKey",
                "userSession.session.masterPassword",
                "userSession.session.serverKey",
                "userSession.personalSettings.CryptoFixedSalt",
                "userSession.personalSettings.CryptoUserPayload"
              ]
            }).pipe(
              (0, o.nb)({
                success: ([t, r, s, a, n]) => {
                  if ("string" == typeof t) return this.flexibleEncryptor.encrypt((0, d.u)(t), e, c.oo, u.gO);
                  if ("string" == typeof r && "string" == typeof s) {
                    const t = s + r,
                      i = (0, l.N)(t),
                      o = "string" == typeof n ? (0, y.P)(n) : c.mr,
                      { saltLength: h } = o,
                      m = "string" === a ? (0, p.R)(a) : this.randomValuesGetter.get(h);
                    return this.flexibleEncryptor.encrypt((0, d.u)(i), e, o, u.Nw, { salt: m });
                  }
                  throw new Error("Wrong types for local data key");
                },
                failure: () => {
                  throw new Error("Failure getting state list");
                }
              })
            )
          );
        }
      };
      g = (0, s.__decorate)([(0, n.GS)(), (0, s.__metadata)("design:paramtypes", [i.CarbonLegacyClient, h._, m.Y])], g);
    },
    14785: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => be });
      var s = r(88802),
        a = r(99634),
        n = r(34710),
        i = r(57385),
        o = r(37935),
        c = r(53576),
        u = r(87918),
        d = r(73378),
        l = r(12642),
        p = r(57924),
        h = r(25594),
        m = r(66122),
        y = r(82933),
        g = r(54066),
        v = r(95087);
      let f = class {
        constructor(e) {
          this.flexibleDecryptor = e;
        }
        decrypt(e, t) {
          const { flexibleDecryptor: r } = this;
          let s;
          switch (t.type) {
            case "sso":
              s = (0, m.R)(t.ssoKey);
              break;
            case "mp":
              s = (0, y.K)((0, g.u)(t.masterPassword), (0, m.R)(t.secondaryKey ?? ""));
              break;
            default:
              (0, v.U)(t);
          }
          return r.decrypt(s, e);
        }
      };
      f = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [h.a])], f);
      var w = r(56268),
        S = r(16698);
      let E = class {
        constructor(e) {
          this.flexibleEncryptor = e;
        }
        encrypt(e, t, r) {
          const { flexibleEncryptor: s } = this,
            { derivation: a, salt: n } = r,
            { algorithm: i } = a;
          if ("noderivation" === i) throw new Error("Session key requires derivation");
          let o;
          switch (t.type) {
            case "sso":
              o = (0, m.R)(t.ssoKey);
              break;
            case "mp":
              o = (0, y.K)((0, g.u)(t.masterPassword), (0, m.R)(t.secondaryKey ?? ""));
              break;
            default:
              (0, v.U)(t);
          }
          return s.encrypt(o, e, a, S.Nw, { salt: (0, m.R)(n) });
        }
      };
      E = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [w._])], E);
      var _ = r(87279),
        b = r(87065),
        T = r(25029),
        A = r(95681),
        C = r(23347),
        R = r(10722);
      const I = (e) =>
        !(!e || "object" != typeof e) &&
        (0 === Object.keys(e).length || Object.entries(e).every(([, e]) => "object" == typeof e && "derivation" in e && "salt" in e));
      class x extends (0, A.Q)({
        storeName: "sessions-crypto-settings-store",
        scope: T.F.Device,
        capacity: C.Y._010KB,
        persist: !0,
        storage: { schemaVersion: 1, initialValue: {}, typeGuard: I },
        codec: R.E
      }) {}
      let P = class {
        constructor(e) {
          this.sessionsCryptoSettingsStore = e;
        }
        getConfig(e) {
          return this.sessionsCryptoSettingsStore.state$.pipe(
            (0, b.U)((t) => {
              if (e in t) {
                const { derivation: r, salt: s } = t[e];
                return (0, _.Vp)({ derivation: r, salt: s });
              }
              throw new Error("No crypto settings found for this user");
            })
          );
        }
      };
      P = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [x])], P);
      var D = r(63663),
        U = r(71949),
        F = r(42858);
      let O = class {
        constructor(e) {
          this.storeFlusher = e;
        }
        async execute() {
          return await this.storeFlusher.flush(), Promise.resolve((0, _.Vp)(void 0));
        }
      };
      O = (0, s.__decorate)([(0, D.W)(F.e), (0, s.__metadata)("design:paramtypes", [U.X])], O);
      var N = r(15473);
      let k = class {
        constructor(e) {
          this.storeFlusher = e;
        }
        async execute() {
          return await this.storeFlusher.prepare(), Promise.resolve((0, _.Vp)(void 0));
        }
      };
      k = (0, s.__decorate)([(0, D.W)(N.X), (0, s.__metadata)("design:paramtypes", [U.X])], k);
      var L = r(69207),
        M = r(55510),
        V = r(64987),
        G = r(60399),
        j = r(10370);
      let q = class {
        constructor(e, t) {
          (this.encryptor = e), (this.settings = t);
        }
        decode(e) {
          const t = {};
          for (const [r, s] of Object.entries(e)) t[r] = { status: "closed", encryptedLocalKey: s.encryptedLocalKey };
          return t;
        }
        async encode(e) {
          const t = {};
          for (const [r, s] of Object.entries(e)) {
            if ("closed" === s.status) {
              t[r] = { encryptedLocalKey: s.encryptedLocalKey };
              continue;
            }
            if (!s.localKey) {
              t[r] = { encryptedLocalKey: null };
              continue;
            }
            const e = await (0, G.z)(this.settings.getConfig(r));
            if (!(0, _.d6)(e)) throw new Error("Fail to get crypto settings");
            t[r] = { encryptedLocalKey: (0, j.s)(await this.encryptor.encrypt((0, m.R)(s.localKey), s.sessionKey, e.data)) };
          }
          return t;
        }
      };
      q = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [E, P])], q);
      class K extends (0, A.Q)({
        storeName: "sessions-state-store",
        scope: T.F.Device,
        capacity: C.Y._010KB,
        persist: !0,
        isCache: !0,
        codec: q,
        storage: { initialValue: {}, schemaVersion: 1, typeGuard: (e) => !0, migrateStorageSchema: () => ({}) }
      }) {}
      const W = new V.WU();
      var B = r(6220);
      let z = class {
        constructor(e, t, r) {
          (this.carbon = e), (this.store = t), (this.settings = r);
        }
        getLocalKey(e) {
          const t = this.generate.bind(this),
            r = this.changeLocalKey.bind(this);
          return this.store.state$.pipe(
            (0, B.z)(async (s) => {
              if (e in s) {
                const t = s[e];
                if ("open" !== t.status) throw new Error("Session is not open ");
                const r = t.localKey;
                return r ? (0, m.R)(r) : null;
              }
              const a = await t();
              return await r(e, a), a;
            })
          );
        }
        async changeLocalKey(e, t) {
          const { store: r } = this,
            s = await (0, G.z)(this.settings.getConfig(e));
          if (!(0, _.d6)(s)) throw new Error("Fail to get crypto settings");
          await W.runExclusive(async () => {
            const s = await r.getState();
            if (!(e in s)) throw new Error("Session is not created");
            const a = s[e];
            if ("open" !== a.status) throw new Error("Session is not open");
            await r.set({ ...s, [e]: { status: "open", localKey: t ? (0, j.s)(t) : null, sessionKey: a.sessionKey } });
          });
        }
        async generateKeyIfNotExist(e) {
          await (0, G.z)(this.getLocalKey(e));
        }
        async generate() {
          const { carbonStateList: e } = this.carbon.queries,
            t = await (0, G.z)(e({ paths: ["userSession.session.localKey"] }));
          if ((0, _.hx)(t)) throw new Error("Failure getting state list");
          const [r] = t.data;
          return "string" == typeof r ? (0, g.u)(r) : null;
        }
      };
      z = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [c.CarbonLegacyClient, K, P])], z);
      var H = r(32109);
      let $ = class {
        constructor(e, t, r, s) {
          (this.carbon = e), (this.store = t), (this.localKeyRepository = r), (this.encryptor = s);
        }
        async execute({ body: { sessionKey: e, email: t, personalSettings: r } }) {
          const s = await this.localKeyRepository.generate(),
            a = s ? await this.encryptor.encrypt(s, e, { derivation: (0, H.P)(r.CryptoUserPayload), salt: r.CryptoFixedSalt }) : null;
          return await W.runExclusive(async () => {
            const r = await this.store.getState();
            if (t in r) return (0, _.Rn)(new L.X0());
            switch (e.type) {
              case "mp": {
                await this.store.set({ ...r, [t]: { status: M.sM.Closed, encryptedLocalKey: a ? (0, j.s)(a) : null } });
                const s = await this.carbon.commands.carbonLegacyLeeloo({
                  name: "openSessionWithMasterPassword",
                  arg: [
                    { login: t, password: e.masterPassword, rememberPassword: !1, requiredPermissions: void 0, serverKey: e.secondaryKey }
                  ]
                });
                if ((0, _.hx)(s)) throw new Error("Failed to create the session in carbon");
                return (0, _.Vp)(void 0);
              }
              case "sso":
                throw new Error("Creating a SSO session in session module is not supported");
              default:
                (0, v.U)(e);
            }
          });
        }
      };
      $ = (0, s.__decorate)([(0, D.W)(L.lk), (0, s.__metadata)("design:paramtypes", [c.CarbonLegacyClient, K, z, E])], $);
      var Q = r(81459);
      let Y = class extends Q.f {};
      Y = (0, s.__decorate)([(0, p.GS)()], Y);
      var X = r(66134),
        J = r(86334),
        Z = r(69008);
      let ee = class {
        constructor(e, t) {
          (this.emitter = e), (this.requestContextClient = t);
        }
        async execute({ body: { email: e } }) {
          return (
            await this.emitter.sendEvent("sessionClosing", void 0),
            await this.emitter.sendEvent("sessionClosed", { email: e, mode: X.K.Close }),
            await this.requestContextClient.commands.setActiveUser({ userName: void 0 }),
            Promise.resolve((0, _.Vp)(void 0))
          );
        }
      };
      ee = (0, s.__decorate)([(0, D.W)(J.V), (0, s.__metadata)("design:paramtypes", [Y, Z.Q])], ee);
      var te = r(37334);
      let re = class {
        constructor(e, t, r) {
          (this.carbon = e), (this.sessionStore = t), (this.sessionKeyDecryptor = r);
        }
        async execute({ body: { email: e, sessionKey: t, rememberPassword: r } }) {
          if ("sso" === t.type) throw new Error("not implemented");
          const { sessionStore: s, carbon: a } = this;
          return (
            await W.runExclusive(async () => {
              const n = await s.getState();
              if (!(e in n)) return (0, _.Rn)(new te.aK());
              if (Object.values(n).some((e) => "open" === e.status)) return (0, _.Rn)(new te.y9());
              const i = n[e];
              if ("open" === i.status || "opening" === i.status) return (0, _.Rn)(new te.mR());
              await s.set({
                ...n,
                [e]: {
                  status: "opening",
                  sessionKey: t,
                  localKey: i.encryptedLocalKey ? (0, j.s)(await this.sessionKeyDecryptor.decrypt((0, m.R)(i.encryptedLocalKey), t)) : null
                }
              }),
                await a.commands.carbonLegacyLeeloo({
                  name: "openSessionWithMasterPassword",
                  arg: [
                    { login: e, password: t.masterPassword, rememberPassword: r, requiredPermissions: void 0, serverKey: t.secondaryKey }
                  ]
                });
            }),
            (0, _.Vp)(void 0)
          );
        }
      };
      re = (0, s.__decorate)([(0, D.W)(te.Dx), (0, s.__metadata)("design:paramtypes", [c.CarbonLegacyClient, K, f])], re);
      var se = r(20754);
      let ae = class {
        constructor(e) {
          this.sessionsStateStore = e;
        }
        execute({ body: e }) {
          const t = e.email;
          return this.sessionsStateStore.state$.pipe(
            (0, b.U)((e) => {
              if (!(t in e)) return (0, _.Vp)(M.sM.NotCreated);
              {
                const { status: r } = e[t];
                switch (r) {
                  case "open":
                    return (0, _.Vp)(M.sM.Open);
                  case "closed":
                  case "opening":
                    return (0, _.Vp)(M.sM.Closed);
                  default:
                    (0, v.U)(r);
                }
              }
            })
          );
        }
      };
      ae = (0, s.__decorate)([(0, se.e)(M.ZP), (0, s.__metadata)("design:paramtypes", [K])], ae);
      let ne = class {
        constructor(e) {
          this.sessionsStateStore = e;
        }
        execute() {
          return this.sessionsStateStore.state$.pipe(
            (0, b.U)((e) => {
              const t = {};
              for (const r in e) "open" === e[r].status ? (t[r] = M.XL.Open) : (t[r] = M.XL.Closed);
              return (0, _.Vp)(t);
            })
          );
        }
      };
      ne = (0, s.__decorate)([(0, se.e)(M.iH), (0, s.__metadata)("design:paramtypes", [K])], ne);
      var ie = r(31839);
      let oe = class {
        constructor(e) {
          this.sessionsStateStore = e;
        }
        execute() {
          return this.sessionsStateStore.state$.pipe(
            (0, b.U)((e) => {
              let t;
              for (const r in e) e[r].status === M.sM.Open && (t = r);
              return (0, _.Vp)(t);
            })
          );
        }
      };
      oe = (0, s.__decorate)([(0, se.e)(ie._), (0, s.__metadata)("design:paramtypes", [K])], oe);
      var ce = r(54703);
      let ue = class {
        execute() {
          return Promise.resolve((0, _.Vp)(void 0));
        }
      };
      ue = (0, s.__decorate)([(0, D.W)(ce.G)], ue);
      var de = r(68307),
        le = r(94805),
        pe = r(19603);
      let he = class {
        constructor(e, t, r, s, a, n, i, o, c) {
          (this.carbon = e),
            (this.sessionsStateStore = t),
            (this.sessionsCryptoSettingsStore = r),
            (this.eventEmitter = s),
            (this.randomValuesGetter = a),
            (this.localKeyRepo = n),
            (this.encryptor = i),
            (this.settings = o),
            (this.context = c);
        }
        async getUserCryptoSettings() {
          const { getUserCryptoSettings: e } = this.carbon.queries,
            t = await (0, G.z)(e());
          if (!(0, _.d6)(t)) throw new Error("Fail to fetch crypto settings from carbon");
          const { cryptoUserPayload: r, cryptoFixedSalt: s } = t.data;
          return { cryptoUserPayload: r, cryptoFixedSalt: s };
        }
        async getSessionKey() {
          const { getMasterPasswordAndServerKey: e, getIsSSOUser: t } = this.carbon.queries,
            r = await (0, G.z)(t());
          if (!(0, _.d6)(r)) throw new Error("Fail to fetch is sso user from carbon");
          if (r.data) return { type: "sso", ssoKey: "" };
          const s = await (0, G.z)(e());
          if (!(0, _.d6)(s)) throw new Error("Fail to fetch master password and server key from carbon");
          const { password: a, serverKey: n } = s.data;
          return { type: "mp", masterPassword: a, secondaryKey: n };
        }
        async handleLogin(e) {
          await W.runExclusive(async () => {
            const { cryptoUserPayload: t, cryptoFixedSalt: r } = await this.getUserCryptoSettings(),
              s = t ? (0, H.P)(t) : le.mr,
              a = r || (0, j.s)(this.randomValuesGetter.get(s.saltLength)),
              n = await this.sessionsCryptoSettingsStore.getState();
            this.sessionsCryptoSettingsStore.set({ ...n, [e]: { derivation: s, salt: a } });
            const i = await this.getSessionKey(),
              o = await this.sessionsStateStore.getState(),
              c = await this.localKeyRepo.generate();
            if (e in o)
              await this.sessionsStateStore.set({ ...o, [e]: { status: "open", sessionKey: i, localKey: c ? (0, j.s)(c) : null } });
            else {
              const t = { status: "open", sessionKey: i, localKey: c ? (0, j.s)(c) : null };
              await this.sessionsStateStore.set({ ...o, [e]: t });
            }
          }),
            await this.context.commands.setActiveUser({ userName: e }),
            await this.eventEmitter.sendEvent("sessionOpening", void 0),
            await this.eventEmitter.sendEvent("sessionOpened", void 0);
        }
        async handleLogout(e) {
          e &&
            (await W.runExclusive(async () => {
              const t = await this.sessionsStateStore.getState();
              if (!(e in t)) return;
              const r = t[e];
              if ("open" === r.status) {
                const s = await (0, G.z)(this.settings.getConfig(e));
                if (!(0, _.d6)(s)) throw new Error("Fail to get crypto settings");
                const a = s.data,
                  n = r.localKey ? (0, j.s)(await this.encryptor.encrypt((0, m.R)(r.localKey), r.sessionKey, a)) : null;
                (t[e] = { status: "closed", encryptedLocalKey: n }), await this.sessionsStateStore.set(t);
              }
            }),
            await this.eventEmitter.sendEvent("sessionClosed", { mode: X.K.Close, email: e }));
        }
        async handle(e) {
          if ("loginStatusChanged" !== e.body.eventName) return;
          const t = e.body.eventData;
          t.loggedIn ? await this.handleLogin(t.login) : await this.handleLogout(t.login);
        }
      };
      he = (0, s.__decorate)(
        [(0, de.b)(c.CarbonLegacyEvent), (0, s.__metadata)("design:paramtypes", [c.CarbonLegacyClient, K, x, Y, pe.Y, z, E, P, Z.Q])],
        he
      );
      var me = r(708);
      let ye = class {
        constructor(e) {
          this.flexibleVerifier = e;
        }
        verify(e, t) {
          const { flexibleVerifier: r } = this;
          let s;
          switch (t.type) {
            case "sso":
              s = (0, m.R)(t.ssoKey);
              break;
            case "mp":
              s = (0, y.K)((0, g.u)(t.masterPassword), (0, m.R)(t.secondaryKey ?? ""));
              break;
            default:
              (0, v.U)(t);
          }
          return r.verifySignature(s, e);
        }
      };
      ye = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [me.y])], ye);
      let ge = class extends i.BD {
        constructor(e, t) {
          super(), (this.sessionsStateStore = e), (this.verifier = t);
        }
        async checkSessionKey(e, t) {
          if ("mp" !== t.type) return (0, _.Vp)(!0);
          const r = await (0, G.z)(this.sessionsStateStore.state$);
          if (!(e in r)) return (0, _.Vp)(!0);
          const s = r[e];
          if ("open" === s.status || "opening" === s.status)
            return (0, _.Vp)(
              (function (e, t) {
                switch (e.type) {
                  case "mp":
                    return "mp" === t.type && e.masterPassword === t.masterPassword && e.secondaryKey === t.secondaryKey;
                  case "sso":
                    return "sso" === t.type && e.ssoKey === t.ssoKey;
                  default:
                    (0, v.U)(e);
                }
              })(s.sessionKey, t)
            );
          if (!s.encryptedLocalKey) return (0, _.Vp)(!0);
          const a = (0, m.R)(s.encryptedLocalKey);
          return (0, _.Vp)(await this.verifier.verify(a, t));
        }
      };
      ge = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [K, ye])], ge);
      var ve = r(45911),
        fe = r(162);
      let we = class {
        constructor(e) {
          this.checker = e;
        }
        execute({ body: { email: e, sessionKey: t } }) {
          return (0, fe.D)(this.checker.checkSessionKey(e, t));
        }
      };
      we = (0, s.__decorate)([(0, se.e)(ve.Z), (0, s.__metadata)("design:paramtypes", [i.BD])], we);
      let Se = class {
        constructor(e) {
          this.store = e;
        }
        async handle({ body: { user: e } }) {
          await W.runExclusive(async () => {
            const t = await this.store.getState();
            delete t[e], await this.store.set(t);
          });
        }
      };
      Se = (0, s.__decorate)([(0, de.b)(c.CarbonLegacyDeviceRemotelyDeleted), (0, s.__metadata)("design:paramtypes", [K])], Se);
      var Ee = r(90032);
      let _e = class {
        constructor(e) {
          this.store = e;
        }
        async execute({ body: { email: e, sessionKey: t } }) {
          return await W.runExclusive(async () => {
            const r = await this.store.getState();
            if (!(e in r)) return (0, _.Rn)(new Ee.pX());
            const s = r[e];
            return "closed" === s.status
              ? (0, _.Rn)(new Ee.nA())
              : ((r[e] = { status: "open", localKey: s.localKey, sessionKey: t }), await this.store.set(r), (0, _.Vp)(void 0));
          });
        }
      };
      _e = (0, s.__decorate)([(0, D.W)(Ee.yt), (0, s.__metadata)("design:paramtypes", [K])], _e);
      let be = class {};
      be = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.Q,
            handlers: {
              commands: {
                flushLocalData: O,
                prepareLocalDataFlush: k,
                closeUserSession: ee,
                createUserSession: $,
                openUserSession: re,
                deleteLocalSession: ue,
                updateUserSessionKey: _e
              },
              events: { ...(0, a.g)(c.carbonLegacyApi, { carbonLegacy: he, CarbonLegacyDeviceRemotelyDeleted: Se }) },
              queries: { createdSessionsState: ne, sessionState: ae, selectedOpenedSession: oe, checkSessionKey: we }
            },
            providers: [Y, u.t, d.n, l.Y, z, f, E, ye, P, q, { provide: i.BD, useClass: ge }],
            exports: [u.t, d.n, l.Y, i.BD],
            stores: [K, x],
            imports: [o.D]
          })
        ],
        be
      );
    },
    13843: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => S });
      var s = r(88802),
        a = r(99634),
        n = r(65766),
        i = r(36636),
        o = r(53576),
        c = r(20754),
        u = r(87279),
        d = r(57755),
        l = r(89358),
        p = r(85390),
        h = r(30523),
        m = r(87065);
      const y = (e) =>
          !!e?.name &&
          e.name !== o.LoginDeviceLimitFlowStage.DeviceLimitDone &&
          e.name !== o.LoginDeviceLimitFlowStage.OpeningSessionAfterDeviceLimitRemoval,
        g = {
          [o.SSOMigrationType.MP_TO_SSO]: d.Oq.RequiresMP2SSOMigration,
          [o.SSOMigrationType.MP_TO_SSO_WITH_INFO]: d.Oq.RequiresMP2SSOMigration,
          [o.SSOMigrationType.SSO_TO_MP]: d.Oq.RequiresSSO2MPMigration
        };
      let v = class {
        constructor(e, t, r) {
          (this.carbon = e), (this.authentication = t), (this.session = r);
        }
        execute() {
          const { selectedOpenedSession: e } = this.session.queries,
            { getProviderInfo: t } = this.authentication.queries,
            { liveLoginDeviceLimitFlow: r, liveTwoFactorAuthenticationInfo: s } = this.carbon.queries,
            a = e(void 0),
            n = t(void 0),
            i = r(void 0),
            c = s(void 0);
          return (0, p.a)({ activeLogin: a, ssoMigrationType: n, loginDeviceLimitFlow: i, twoFactorAuthenticationInfo: c }).pipe(
            (0, h.h)(
              ({ twoFactorAuthenticationInfo: e }) => !!(0, u.d6)(e) && e.data.status === o.TwoFactorAuthenticationInfoRequestStatus.READY
            ),
            (0, m.U)(({ activeLogin: e, ssoMigrationType: t, loginDeviceLimitFlow: r, twoFactorAuthenticationInfo: s }) => {
              if (!(0, u.d6)(e)) return (0, u.Vp)({ isAllowed: !1, reasons: [d.Oq.NoActiveUser] });
              if (!(0, u.d6)(t) || !(0, u.d6)(r) || !(0, u.d6)(s) || s.data.status !== o.TwoFactorAuthenticationInfoRequestStatus.READY)
                throw new Error("One query failed");
              const a = y(r.data);
              if (void 0 === t.data.migrationType && !a && !s.data.shouldEnforceTwoFactorAuthentication)
                return (0, u.Vp)({ isAllowed: !0 });
              const n = { isAllowed: !1, reasons: [] };
              return (
                void 0 !== t.data.migrationType && n.reasons.push(g[t.data.migrationType]),
                a && n.reasons.push(d.Oq.DeviceLimited),
                s.data.shouldEnforceTwoFactorAuthentication && n.reasons.push(d.Oq.Requires2FAEnforcement),
                (0, u.Vp)(n)
              );
            })
          );
        }
      };
      v = (0, s.__decorate)([(0, c.e)(d.bY), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient, i.e, l.x])], v);
      var f = r(49273);
      let w = class {
        constructor(e) {
          this.carbon = e;
        }
        execute() {
          const { liveLoginDeviceLimitFlow: e } = this.carbon.queries;
          return e(void 0).pipe(
            (0, m.U)((e) => {
              if (!(0, u.d6)(e)) throw new Error("liveLoginDeviceLimitFlow failed");
              return (0, u.Vp)({ isLimited: y(e.data) });
            })
          );
        }
      };
      w = (0, s.__decorate)([(0, c.e)(f.X), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient])], w);
      let S = class {};
      S = (0, s.__decorate)([(0, a.Y)({ api: n.Y, handlers: { commands: {}, events: {}, queries: { isAllowed: v, deviceLimit: w } } })], S);
    },
    56999: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          AcceptCollectionInviteCommand: () => d.cD,
          AcceptCollectionInviteFailedError: () => d.nu,
          AcceptCollectionInviteResultErrorCode: () => d.Ti,
          AddItemToCollectionsCommand: () => P.$,
          AddItemsToCollectionCommand: () => x.Z,
          CreateSharedCollectionCommand: () => D.I,
          DeleteSharedCollectionCommand: () => U.U,
          GetCollectionPermissionsQuery: () => A.A,
          GetInvitesQuery: () => y.q,
          GetItemGroupForItemQuery: () => i.i,
          GetItemIdsInSharedCollectionsQuery: () => T.q,
          GetItemIdsInSharedCollectionsSchema: () => w.Po,
          GetPendingCollectionsQuery: () => g.D,
          GetPermissionForItemQuery: () => c.C,
          GetSharedCollectionsQuery: () => C.$,
          GetSharingStatusForItemQuery: () => o.S,
          GetSharingTeamLoginsQuery: () => a.G,
          HasInvitesQuery: () => v._,
          InviteCollectionMembersCommand: () => F.Q,
          PendingCollectionSchema: () => S,
          PendingItemGroupSchema: () => E,
          PendingUserGroupSchema: () => _,
          Permission: () => w.y3,
          PermissionSchema: () => w.Iy,
          RefuseCollectionInviteCommand: () => l.UC,
          RefuseCollectionInviteFailedError: () => l.R$,
          RefuseCollectionInviteResultErrorCode: () => l.eT,
          RefuseItemGroupInviteAuthorHasInvalidStatusError: () => p.bp,
          RefuseItemGroupInviteCommand: () => p.gm,
          RefuseItemGroupInviteGroupHasInvalidStatusError: () => p.Xj,
          RefuseItemGroupInviteInvalidItemGroupRevisionError: () => p.Ne,
          RefuseItemGroupInviteNotEnoughAdminsError: () => p.Ix,
          RefuseItemGroupInviteNotFoundError: () => p.fL,
          RefuseItemGroupInviteResultErrorCode: () => p.dI,
          RefuseItemGroupInviteUserGroupIsNotInItemGroupError: () => p.Te,
          RefuseItemGroupInviteUserIsNotInItemGroupError: () => p.hp,
          RefuseItemGroupInviteUserIsNotInPendingStatusError: () => p.gR,
          RefuseUserGroupInviteAuthorHasInvalidStatusError: () => h.K8,
          RefuseUserGroupInviteCommand: () => h.Fo,
          RefuseUserGroupInviteGroupHasInvalidStatusError: () => h.kh,
          RefuseUserGroupInviteInsufficientPrivilegesError: () => h.FO,
          RefuseUserGroupInviteInvalidItemGroupRevisionError: () => h.Uf,
          RefuseUserGroupInviteInvalidTeamIdError: () => h.Ix,
          RefuseUserGroupInviteNotFoundError: () => h.i6,
          RefuseUserGroupInviteResultErrorCode: () => h.xC,
          RefuseUserGroupInviteUserGroupIsNotFoundError: () => h.U1,
          RefuseUserGroupInviteUserGroupUpdateConflictError: () => h.Xp,
          RefuseUserGroupInviteUserIsNotInPendingStatusError: () => h.PZ,
          RefuseUserGroupInviteUserIsNotInUserGroupError: () => h.xz,
          RemoveItemFromCollectionsCommand: () => N.B,
          RenameCollectionCommand: () => O.r,
          RevokeCollectionMembersCommand: () => k.q,
          RsaStatusSchema: () => w.bd,
          ShareableCollectionSchema: () => R.JQ,
          ShareableCollectionVaultItemSchema: () => R.FN,
          SharedCollectionRole: () => w.Yt,
          SharedCollectionSchema: () => w.MX,
          SharedCollectionUserGroupSchema: () => w.yD,
          SharedCollectionUserOrGroupViewSchema: () => w.fg,
          SharedCollectionUserSchema: () => w.Me,
          SharedCollectionsWithItemsQuery: () => R.MO,
          SharingCollectionsClient: () => V.L,
          SharingEnabledQuery: () => n.N,
          Status: () => w.qb,
          StatusSchema: () => w.y$,
          UpdateCollectionMembersCommand: () => M.c,
          UpdatePendingCollectionsCommand: () => m.r,
          UpdateSharedCollectionsCommand: () => L.M,
          UsersAndGroupsInCollectionQuery: () => I.O,
          UsersAndGroupsInCollectionSchema: () => w.a7,
          getRefuseItemGroupInviteFunctionalError: () => p.fr,
          getRefuseUserGroupInviteFunctionalError: () => h.cz,
          sharingCollectionsApi: () => b.a,
          sharingInvitesApi: () => u.t,
          sharingItemsApi: () => s.X
        });
      var s = r(48958),
        a = r(31485),
        n = r(54003),
        i = r(54326),
        o = r(20920),
        c = r(4975),
        u = r(58425),
        d = r(31609),
        l = r(68096),
        p = r(55677),
        h = r(84009),
        m = r(79517),
        y = r(15179),
        g = r(36610),
        v = r(36469),
        f = r(7165),
        w = r(4400);
      const S = f.z.object({
          uuid: f.z.string(),
          name: f.z.string(),
          referrer: f.z.string(),
          permission: f.z.nativeEnum(w.y3),
          seen: f.z.boolean()
        }),
        E = f.z.object({
          itemGroupId: f.z.string(),
          referrer: f.z.string(),
          permission: f.z.enum(["admin", "limited"]),
          seen: f.z.boolean()
        }),
        _ = f.z.object({
          groupId: f.z.string(),
          name: f.z.string(),
          referrer: f.z.string(),
          permission: f.z.enum(["admin", "limited"]),
          seen: f.z.boolean()
        });
      var b = r(72721),
        T = r(67591),
        A = r(35317),
        C = r(24249),
        R = r(11578),
        I = r(6233),
        x = r(99676),
        P = r(46629),
        D = r(11527),
        U = r(50384),
        F = r(89074),
        O = r(86590),
        N = r(68827),
        k = r(77311),
        L = r(15507),
        M = r(177),
        V = r(85612);
    },
    72721: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => w });
      var s = r(86952),
        a = r(67591),
        n = r(24249),
        i = r(35317),
        o = r(11578),
        c = r(6233),
        u = r(99676),
        d = r(46629),
        l = r(11527),
        p = r(50384),
        h = r(89074),
        m = r(177),
        y = r(68827),
        g = r(86590),
        v = r(77311),
        f = r(15507);
      const w = (0, s.Q)({
        name: "sharingCollections",
        commands: {
          addItemsToCollection: u.Z,
          addItemToCollections: d.$,
          createSharedCollection: l.I,
          deleteSharedCollection: p.U,
          inviteCollectionMembers: h.Q,
          updateCollectionMembers: m.c,
          removeItemFromCollections: y.B,
          renameCollection: g.r,
          revokeCollectionMembers: v.q,
          updateSharedCollections: f.M
        },
        events: {},
        queries: {
          getItemIdsInSharedCollections: a.q,
          getSharedCollections: n.$,
          getCollectionPermissions: i.A,
          sharedCollectionsWithItems: o.MO,
          usersAndGroupsInCollection: c.O
        }
      });
    },
    46629: (e, t, r) => {
      "use strict";
      r.d(t, { $: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    99676: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    11527: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    50384: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    89074: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    68827: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    86590: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    77311: (e, t, r) => {
      "use strict";
      r.d(t, { q: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    177: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    15507: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    67591: (e, t, r) => {
      "use strict";
      r.d(t, { q: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    35317: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    24249: (e, t, r) => {
      "use strict";
      r.d(t, { $: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    11578: (e, t, r) => {
      "use strict";
      r.d(t, { FN: () => i, JQ: () => o, MO: () => c });
      var s = r(7165),
        a = r(99059),
        n = r(25029);
      const i = s.z.object({ id: s.z.string(), type: s.z.string() }),
        o = s.z.object({
          id: s.z.string(),
          name: s.z.string(),
          spaceId: s.z.string(),
          vaultItems: s.z.array(i),
          isShared: s.z.optional(s.z.boolean())
        });
      class c extends (0, a.k)({ scope: n.F.User }) {}
    },
    6233: (e, t, r) => {
      "use strict";
      r.d(t, { O: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    85612: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => n });
      var s = r(67837),
        a = r(72721);
      class n extends (0, s.E)(a.a) {}
      (0, s.K)(a.a, n);
    },
    4400: (e, t, r) => {
      "use strict";
      r.d(t, {
        Iy: () => o,
        MX: () => p,
        Me: () => u,
        Po: () => m,
        Yt: () => y,
        a7: () => h,
        bd: () => c,
        fg: () => l,
        qb: () => a,
        y$: () => i,
        y3: () => s,
        yD: () => d
      });
      var s,
        a,
        n = r(7165);
      !(function (e) {
        (e.Admin = "admin"), (e.Limited = "limited");
      })(s || (s = {})),
        (function (e) {
          (e.Pending = "pending"), (e.Accepted = "accepted"), (e.Refused = "refused"), (e.Revoked = "revoked");
        })(a || (a = {}));
      const i = n.z.nativeEnum(a),
        o = n.z.nativeEnum(s),
        c = n.z.union([n.z.literal("noKey"), n.z.literal("publicKey"), n.z.literal("sharingKeys")]),
        u = n.z.object({
          acceptSignature: n.z.optional(n.z.nullable(n.z.string())),
          collectionKey: n.z.optional(n.z.nullable(n.z.string())),
          login: n.z.string(),
          permission: o,
          proposeSignature: n.z.optional(n.z.string()),
          proposeSignatureUsingAlias: n.z.optional(n.z.boolean()),
          referrer: n.z.string(),
          rsaStatus: n.z.optional(c),
          status: i
        }),
        d = n.z.object({
          acceptSignature: n.z.optional(n.z.nullable(n.z.string())),
          collectionKey: n.z.optional(n.z.nullable(n.z.string())),
          name: n.z.string(),
          permission: o,
          proposeSignature: n.z.optional(n.z.string()),
          referrer: n.z.optional(n.z.string()),
          status: i,
          uuid: n.z.string()
        }),
        l = n.z.object({ label: n.z.string(), status: i, permission: o, id: n.z.string() }),
        p = n.z.object({
          name: n.z.string(),
          privateKey: n.z.string(),
          publicKey: n.z.string(),
          revision: n.z.number(),
          userGroups: n.z.optional(n.z.array(d)),
          users: n.z.optional(n.z.array(u)),
          uuid: n.z.string()
        }),
        h = n.z.object({ userGroups: n.z.optional(n.z.array(l)), users: n.z.optional(n.z.array(l)) }),
        m = n.z.array(n.z.string());
      var y;
      !(function (e) {
        (e.Editor = "editor"), (e.Manager = "manager");
      })(y || (y = {}));
    },
    58425: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => p });
      var s = r(86952),
        a = r(31609),
        n = r(68096),
        i = r(55677),
        o = r(84009),
        c = r(79517),
        u = r(15179),
        d = r(36610),
        l = r(36469);
      const p = (0, s.Q)({
        name: "sharingInvites",
        commands: {
          AcceptCollectionInviteCommand: a.cD,
          RefuseCollectionInviteCommand: n.UC,
          RefuseItemGroupInviteCommand: i.gm,
          RefuseUserGroupInviteCommand: o.Fo,
          UpdatePendingCollectionsCommand: c.r
        },
        events: {},
        queries: { GetInvitesQuery: u.q, GetPendingCollectionsQuery: d.D, HasInvitesQuery: l._ }
      });
    },
    31609: (e, t, r) => {
      "use strict";
      r.d(t, { Ti: () => s, cD: () => c, nu: () => o });
      var s,
        a = r(74354),
        n = r(25029),
        i = r(96168);
      !(function (e) {
        e.AcceptFailed = "AcceptFailed";
      })(s || (s = {}));
      class o extends (0, i.Hu)(s.AcceptFailed, "Failed to accept collection") {}
      class c extends (0, a.g)({ scope: n.F.User }) {}
    },
    68096: (e, t, r) => {
      "use strict";
      r.d(t, { R$: () => o, UC: () => c, eT: () => s });
      var s,
        a = r(74354),
        n = r(25029),
        i = r(96168);
      !(function (e) {
        e.RefuseFailed = "RefuseFailed";
      })(s || (s = {}));
      class o extends (0, i.Hu)(s.RefuseFailed, "Failed to refuse collection") {}
      class c extends (0, a.g)({ scope: n.F.User }) {}
    },
    55677: (e, t, r) => {
      "use strict";
      r.d(t, {
        Ix: () => h,
        Ne: () => p,
        Te: () => l,
        Xj: () => u,
        bp: () => c,
        dI: () => s,
        fL: () => o,
        fr: () => y,
        gR: () => m,
        gm: () => g,
        hp: () => d
      });
      var s,
        a = r(74354),
        n = r(25029),
        i = r(96168);
      !(function (e) {
        (e.ItemGroupNotFound = "ItemGroupNotFound"),
          (e.AuthorHasInvalidStatus = "AuthorHasInvalidStatus"),
          (e.GroupHasInvalidStatus = "GroupHasInvalidStatus"),
          (e.UserIsNotInItemGroup = "UserIsNotInItemGroup"),
          (e.UserGroupIsNotInItemGroup = "UserGroupIsNotInItemGroup"),
          (e.InvalidItemGroupRevision = "InvalidItemGroupRevision"),
          (e.NotEnoughAdmins = "NotEnoughAdmins"),
          (e.UserIsNotInPendingStatus = "UserIsNotInPendingStatus");
      })(s || (s = {}));
      class o extends (0, i.Hu)(s.ItemGroupNotFound, "Item Group not found") {}
      class c extends (0, i.Hu)(s.AuthorHasInvalidStatus, "User is not in accepted/pending status (already refused or revoked)") {}
      class u extends (0, i.Hu)(s.GroupHasInvalidStatus, "UserGroup is not in accepted/pending status (already refused or revoked)") {}
      class d extends (0, i.Hu)(s.UserIsNotInItemGroup, "User is not part of item group") {}
      class l extends (0, i.Hu)(s.UserGroupIsNotInItemGroup, "User group is not part of item group") {}
      class p extends (0, i.Hu)(s.InvalidItemGroupRevision, "Item group revision is not valid") {}
      class h extends (0, i.Hu)(s.NotEnoughAdmins, "The operation would let the item group with no admin") {}
      class m extends (0, i.Hu)(s.UserIsNotInPendingStatus, 'User is not in "pending" status or not part of a group') {}
      function y(e) {
        switch (e) {
          case "AUTHOR_HAS_INVALID_STATUS":
            return new c();
          case "GROUP_HAS_INVALID_STATUS":
            return new u();
          case "USER_IS_NOT_IN_ITEM_GROUP":
            return new d();
          case "USER_GROUP_IS_NOT_IN_ITEM_GROUP":
            return new l();
          case "INVALID_ITEM_GROUP_REVISION":
            return new p();
          case "NOT_ENOUGH_ADMINS":
            return new h();
          case "USER_IS_NOT_IN_PENDING_STATUS":
            return new m();
          default:
            throw new Error("Unknown server error");
        }
      }
      class g extends (0, a.g)({ scope: n.F.User }) {}
    },
    84009: (e, t, r) => {
      "use strict";
      r.d(t, {
        FO: () => p,
        Fo: () => f,
        Ix: () => c,
        K8: () => g,
        PZ: () => m,
        U1: () => u,
        Uf: () => d,
        Xp: () => l,
        cz: () => v,
        i6: () => o,
        kh: () => y,
        xC: () => s,
        xz: () => h
      });
      var s,
        a = r(74354),
        n = r(25029),
        i = r(96168);
      !(function (e) {
        (e.UserGroupNotFound = "UserGroupNotFound"),
          (e.InvalidTeamId = "InvalidTeamId"),
          (e.UserGroupIsNotFound = "UserGroupIsNotFound"),
          (e.InvalidItemGroupRevision = "InvalidItemGroupRevision"),
          (e.UserGroupUpdateConflict = "UserGroupUpdateConflict"),
          (e.InsufficientPrivileges = "InsufficientPrivileges"),
          (e.UserIsNotInUserGroup = "UserIsNotInUserGroup"),
          (e.UserIsNotInPendingStatus = "UserIsNotInPendingStatus"),
          (e.GroupHasInvalidStatus = "GroupHasInvalidStatus"),
          (e.AuthorHasInvalidStatus = "AuthorHasInvalidStatus");
      })(s || (s = {}));
      class o extends (0, i.Hu)(s.UserGroupNotFound, "User Group not found") {}
      class c extends (0, i.Hu)(s.InvalidTeamId, "Provided Team ID is not a number") {}
      class u extends (0, i.Hu)(s.UserGroupIsNotFound, "User group for provided ID does not exist") {}
      class d extends (0, i.Hu)(s.InvalidItemGroupRevision, "User group revision is not valid") {}
      class l extends (0, i.Hu)(s.UserGroupUpdateConflict, "Conflict between users attempting to update the same user group") {}
      class p extends (0, i.Hu)(s.InsufficientPrivileges, "The user does not have User Group permission to refuse the invitation") {}
      class h extends (0, i.Hu)(s.UserIsNotInUserGroup, "User is not part of a group") {}
      class m extends (0, i.Hu)(s.UserIsNotInPendingStatus, 'User is not in "pending" status or not part of a group') {}
      class y extends (0, i.Hu)(
        s.GroupHasInvalidStatus,
        'UserGroup is not in "accepted" or "pending" status (already refused or revoked)'
      ) {}
      class g extends (0, i.Hu)(s.AuthorHasInvalidStatus, "User is not in accepted/pending status (already refused or revoked)") {}
      function v(e) {
        switch (e) {
          case "INVALID_TEAM_ID":
            return new c();
          case "USER_GROUP_IS_NOT_FOUND":
            return new u();
          case "INVALID_USER_GROUP_REVISION":
            return new d();
          case "USER_GROUP_UPDATE_CONFLICT":
            return new l();
          case "INSUFFICIENT_PRIVILEGES":
            return new p();
          case "USER_IS_NOT_IN_USER_GROUP":
            return new h();
          case "USER_IS_NOT_IN_PENDING_STATUS":
            return new m();
          case "GROUP_HAS_INVALID_STATUS":
            return new y();
          case "AUTHOR_HAS_INVALID_STATUS":
            return new g();
          default:
            throw new Error("Unknown server error");
        }
      }
      class f extends (0, a.g)({ scope: n.F.User }) {}
    },
    79517: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    15179: (e, t, r) => {
      "use strict";
      r.d(t, { q: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    36610: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    36469: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    48958: (e, t, r) => {
      "use strict";
      r.d(t, { X: () => u });
      var s = r(86952),
        a = r(31485),
        n = r(54003),
        i = r(54326),
        o = r(20920),
        c = r(4975);
      const u = (0, s.Q)({
        name: "sharingItems",
        commands: {},
        events: {},
        queries: {
          getSharingTeamLogins: a.G,
          sharingEnabled: n.N,
          getItemGroupForItem: i.i,
          getSharingStatusForItem: o.S,
          getPermissionForItem: c.C
        }
      });
    },
    54326: (e, t, r) => {
      "use strict";
      r.d(t, { i: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    4975: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    20920: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    31485: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    54003: (e, t, r) => {
      "use strict";
      r.d(t, { N: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    10647: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => l });
      var s = r(88802),
        a = r(99634),
        n = r(89560),
        i = r(72614),
        o = r(81982),
        c = r(66076),
        u = r(59452),
        d = r(19617);
      let l = class {};
      l = (0, s.__decorate)(
        [
          (0, a.Y)({
            sharedModuleName: "sharing-carbon-helpers",
            providers: [n.E, c.J, i.n, o.a, d.V, u.B],
            exports: [n.E, c.J, i.n, o.a, d.V, u.B],
            imports: []
          })
        ],
        l
      );
    },
    89560: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => l });
      var s = r(88802),
        a = r(53576),
        n = r(57924),
        i = r(48844),
        o = r(63877);
      function c(e) {
        switch (e) {
          case "admin":
            return o.y3.Admin;
          case "limited":
            return o.y3.Limited;
        }
      }
      function u(e) {
        switch (e) {
          case "pending":
            return o.qb.Pending;
          case "accepted":
            return o.qb.Accepted;
          case "refused":
            return o.qb.Refused;
          case "revoked":
            return o.qb.Revoked;
        }
      }
      function d(e) {
        return {
          groupId: e.groupId,
          revision: e.revision,
          type: e.type,
          teamId: e.teamId,
          items: e.items,
          users: e.users ? [...e.users.map((e) => ({ ...e, permission: c(e.permission), status: u(e.status) }))] : void 0,
          groups: e.groups ? [...e.groups.map((e) => ({ ...e, permission: c(e.permission), status: u(e.status) }))] : void 0,
          collections: e.collections
            ? [...(e.collections?.map((e) => ({ ...e, permission: c(e.permission), status: u(e.status) })) ?? [])]
            : void 0
        };
      }
      let l = class {
        constructor(e) {
          this.client = e;
        }
        get() {
          const {
            queries: { carbonState: e }
          } = this.client;
          return e({ path: "userSession.sharingData.itemGroups" }).pipe((0, i.Qn)((e) => e.map(d)));
        }
        getForItemId(e) {
          return this.get().pipe((0, i.Qn)((t) => t.find((t) => t.items?.some((t) => e === t.itemId))));
        }
        getForItemsIds(e) {
          return this.get().pipe((0, i.Qn)((t) => t.filter((t) => t.items?.some((t) => e.includes(t.itemId)))));
        }
        getForCollectionId(e) {
          return this.get().pipe((0, i.Qn)((t) => t.filter((t) => t.collections?.some((t) => e.includes(t.uuid)))));
        }
      };
      l = (0, s.__decorate)([(0, n.GS)(), (0, s.__metadata)("design:paramtypes", [a.CarbonLegacyClient])], l);
    },
    66076: (e, t, r) => {
      "use strict";
      r.d(t, { J: () => c });
      var s = r(88802),
        a = r(60399),
        n = r(53576),
        i = r(57924),
        o = r(87279);
      let c = class {
        constructor(e) {
          this.client = e;
        }
        async getCarbonCredentialsByItemIds(e) {
          const {
              queries: { carbonState: t }
            } = this.client,
            r = await (0, a.z)(t({ path: "userSession.personalData.credentials" }));
          if ((0, o.hx)(r)) throw new Error("Unable to access credentials from carbon");
          const s = r.data;
          if (!s) throw new Error("No credentials found");
          return s.filter(({ Id: t }) => e.includes(t));
        }
      };
      c = (0, s.__decorate)([(0, i.GS)(), (0, s.__metadata)("design:paramtypes", [n.CarbonLegacyClient])], c);
    },
    72614: (e, t, r) => {
      "use strict";
      r.d(t, { n: () => c });
      var s = r(88802),
        a = r(53576),
        n = r(57924),
        i = r(48844);
      const o = (e) => {
        if (!e) return { teamId: "", isSharingEnabled: !1, isCollectionsSharingEnabled: !1 };
        const t = e;
        if (
          !(
            (r = t.spaces) &&
            Array.isArray(r) &&
            0 !== r.length &&
            ((e) => {
              if (!e) return !1;
              const t = e;
              return !!(
                t.associatedEmail &&
                t.billingAdmins &&
                t.color &&
                t.info &&
                t.letter &&
                t.planType &&
                t.status &&
                t.teamAdmins &&
                t.teamId &&
                t.teamName &&
                t.tier
              );
            })(r.find((e) => "accepted" === e.status))
          )
        )
          return { teamId: "", isSharingEnabled: !0, isCollectionsSharingEnabled: !1 };
        var r;
        const s = t.spaces.find((e) => "accepted" === e.status),
          a = Boolean(t.capabilities?.collectionSharing.enabled);
        return { teamId: s?.teamId ?? "", isSharingEnabled: Boolean(s && !s.info.sharingDisabled), isCollectionsSharingEnabled: a };
      };
      let c = class {
        constructor(e) {
          this.client = e;
        }
        get() {
          const {
            queries: { carbonState: e }
          } = this.client;
          return e({ path: "userSession.localSettings.premiumStatus" }).pipe((0, i.Qn)(o));
        }
      };
      c = (0, s.__decorate)([(0, n.GS)(), (0, s.__metadata)("design:paramtypes", [a.CarbonLegacyClient])], c);
    },
    81982: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => c });
      var s = r(88802),
        a = r(60399),
        n = r(53576),
        i = r(57924),
        o = r(48844);
      let c = class {
        constructor(e) {
          this.client = e;
        }
        async getCurrentUserWithKeys() {
          const {
            queries: { carbonStateList: e }
          } = this.client;
          return await (0, a.z)(
            e({
              paths: ["userSession.account.login", "userSession.session.keyPair.publicKey", "userSession.session.keyPair.privateKey"]
            }).pipe(
              (0, o.nb)({
                success: ([e, t, r]) => {
                  if ("string" != typeof e || "string" != typeof t || "string" != typeof r)
                    throw new Error("Invalid format of current user keys");
                  return { login: e, publicKey: t, privateKey: r };
                },
                failure: () => {
                  throw new Error("Failure getting current user and key pair");
                }
              })
            )
          );
        }
      };
      c = (0, s.__decorate)([(0, i.GS)(), (0, s.__metadata)("design:paramtypes", [n.CarbonLegacyClient])], c);
    },
    19617: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => c });
      var s = r(88802),
        a = r(53576),
        n = r(57924),
        i = r(48844),
        o = r(31766);
      let c = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        get() {
          const {
            queries: { carbonState: e }
          } = this.carbonLegacyClient;
          return e({ path: "userSession.sharingSync" }).pipe(
            (0, i.Qn)((e) => {
              if (!(0, o.o)(e)) throw new Error("Bad SharingSync format");
              return e;
            })
          );
        }
      };
      c = (0, s.__decorate)([(0, n.GS)(), (0, s.__metadata)("design:paramtypes", [a.CarbonLegacyClient])], c);
    },
    59452: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => y });
      var s = r(88802),
        a = r(60399),
        n = r(87065),
        i = r(7165),
        o = r(53576),
        c = r(57924),
        u = r(87279),
        d = r(63877);
      function l(e) {
        switch (e) {
          case "admin":
            return d.y3.Admin;
          case "limited":
            return d.y3.Limited;
        }
      }
      function p(e) {
        switch (e) {
          case "pending":
            return d.qb.Pending;
          case "accepted":
            return d.qb.Accepted;
          case "refused":
            return d.qb.Refused;
          case "revoked":
            return d.qb.Revoked;
        }
      }
      function h(e) {
        return {
          groupId: e.groupId,
          revision: e.revision,
          type: e.type,
          teamId: e.teamId,
          name: e.name,
          privateKey: e.privateKey,
          publicKey: e.publicKey,
          externalId: e.externalId,
          familyId: e.familyId,
          users: [...e.users.map((e) => ({ ...e, permission: l(e.permission), status: p(e.status) }))]
        };
      }
      const m = i.z.array(
        i.z.object({
          groupId: i.z.string(),
          name: i.z.string(),
          externalId: i.z.string().nullable().optional(),
          teamId: i.z.number().optional(),
          type: i.z.enum(["users", "teamAdmins"]),
          publicKey: i.z.string(),
          privateKey: i.z.string(),
          revision: i.z.number(),
          users: i.z.array(
            i.z.object({
              userId: i.z.string(),
              alias: i.z.string(),
              referrer: i.z.string(),
              groupKey: i.z.string().nullable().optional(),
              acceptSignature: i.z.string().nullable().optional(),
              permission: i.z.enum(["admin", "limited"]),
              rsaStatus: i.z.enum(["noKey", "publicKey", "sharingKeys"]),
              status: i.z.enum(["pending", "accepted", "refused", "revoked"]),
              proposeSignatureUsingAlias: i.z.boolean().optional(),
              proposeSignature: i.z.string().optional()
            })
          )
        })
      );
      let y = class {
        constructor(e) {
          this.client = e;
        }
        getRawCarbon$() {
          const {
            queries: { carbonState: e }
          } = this.client;
          return e({ path: "userSession.sharingData.userGroups" });
        }
        async getRawCarbon() {
          const e = await (0, a.z)(this.getRawCarbon$());
          if ((0, u.hx)(e)) throw new Error("Failure getting user groups state from carbon sharing data");
          return e.data;
        }
        async get() {
          const e = await this.getRawCarbon(),
            t = m.safeParse(e);
          if (!t.success) throw new Error("Invalid format of user group state");
          return t.data;
        }
        async getForGroupIds(e) {
          return (await this.get()).filter((t) => e.includes(t.groupId));
        }
        getCarbonUserGroups$() {
          return this.getRawCarbon$().pipe(
            (0, n.U)((e) => {
              if ((0, u.hx)(e)) throw new Error("Failure getting user groups state from carbon sharing data");
              return (0, u.db)(e).map(h);
            })
          );
        }
        async getCarbonUserGroups() {
          return (await this.getRawCarbon()).map(h);
        }
      };
      y = (0, s.__decorate)([(0, c.GS)(), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient])], y);
    },
    36458: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => d });
      var s = r(95681),
        a = r(23347),
        n = r(25029),
        i = r(7165),
        o = r(4400);
      const c = i.z.object({ sharedCollections: i.z.array(o.MX) }),
        u = (e) => c.safeParse(e).success;
      class d extends (0, s.Q)({
        capacity: a.Y._010KB,
        persist: !1,
        scope: n.F.User,
        storeName: "collections-store",
        storeTypeGuard: u,
        initialValue: { sharedCollections: [] }
      }) {}
    },
    31370: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => Ne });
      var s = r(88802),
        a = r(99634),
        n = r(72721),
        i = r(1824),
        o = r(37935),
        c = r(63663),
        u = r(87279),
        d = r(99676),
        l = r(60399),
        p = r(57924),
        h = r(24917),
        m = r(89560),
        y = r(66076);
      class g {}
      var v = r(61076),
        f = r(87065),
        w = r(69885),
        S = r(21869),
        E = r(48844),
        _ = r(4400),
        b = r(59452),
        T = r(36458);
      let A = class {
        constructor(e) {
          this.store = e;
        }
        async getCollections() {
          return (await this.store.getState()).sharedCollections;
        }
        collections$() {
          return this.store.state$.pipe((0, f.U)((e) => e.sharedCollections));
        }
        collection$(e) {
          return this.collections$().pipe((0, f.U)((t) => t.find((t) => t.uuid === e)));
        }
        async getCollection(e) {
          const t = (await this.store.getState()).sharedCollections.find((t) => t.uuid === e);
          if (t) return t;
        }
        async updateCollections(e) {
          await this.store.set({ sharedCollections: [...e] });
        }
      };
      A = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [T.S])], A);
      let C = class {
        constructor(e, t, r, s) {
          (this.itemGroupsGetter = e), (this.userGroupGetter = t), (this.collectionsRepository = r), (this.context = s);
        }
        async canShareItemGroup(e) {
          const t = this.getCurrentUserLogin();
          if (!t) return !1;
          const r = await this.userGroupGetter.getCarbonUserGroups(),
            s = await this.collectionsRepository.getCollections(),
            a =
              e.users?.some(
                (e) =>
                  e.userId === t && e.status === _.qb.Accepted && !e.proposeSignatureUsingAlias && e.permission === _.y3.Admin && e.groupKey
              ) ?? !1,
            n = r.filter((e) =>
              e.users.some((e) => e.userId === t && e.status === _.qb.Accepted && !e.proposeSignatureUsingAlias && e.groupKey)
            ),
            i =
              e.groups?.some(
                (e) => n.some((t) => t.groupId === e.groupId) && e.status === _.qb.Accepted && e.permission === _.y3.Admin && e.groupKey
              ) ?? !1,
            o = s.filter(
              (e) =>
                e.users?.some(
                  (e) =>
                    e.login === t &&
                    e.status === _.qb.Accepted &&
                    !e.proposeSignatureUsingAlias &&
                    e.permission === _.y3.Admin &&
                    e.collectionKey
                ) ||
                e.userGroups?.some(
                  (e) => n.some((t) => t.groupId === e.uuid) && e.status === _.qb.Accepted && e.permission === _.y3.Admin && e.collectionKey
                )
            ),
            c =
              e.collections?.some(
                (e) => o.some((t) => t.uuid === e.uuid) && e.status === _.qb.Accepted && e.permission === _.y3.Admin && e.itemGroupKey
              ) ?? !1;
          return a || i || c;
        }
        getUserRoleInCollection$(e) {
          const t = this.getCurrentUserLogin();
          return this.userGroupGetter.getCarbonUserGroups$().pipe(
            (0, v.V)(this.collectionsRepository.collection$(e)),
            (0, f.U)(([e, r]) => {
              if (!r) throw new Error("Shared collection not found");
              const s = r.users?.find((e) => e.login === t),
                a = s?.permission === _.y3.Admin && s.status === _.qb.Accepted,
                n = e.filter((e) => e.users.some((e) => e.userId === t && e.status === _.qb.Accepted)).map((e) => e.groupId),
                i = r.userGroups?.filter((e) => n.includes(e.uuid)),
                o = i?.some((e) => e.permission === _.y3.Admin);
              return a || o ? _.Yt.Manager : _.Yt.Editor;
            })
          );
        }
        canShareItems(e) {
          return 0 === e.length
            ? (0, w.of)((0, u.Vp)(!0))
            : this.itemGroupsGetter
                .getForItemsIds(e)
                .pipe((0, E.Gx)(async (e) => (await Promise.all(e.map((e) => this.canShareItemGroup(e)))).every(Boolean)));
        }
        getCurrentUserLogin() {
          return this.context.get(S.l.UserName);
        }
      };
      C = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [m.E, b.B, A, S.f])], C);
      var R = r(66122),
        I = r(89685),
        x = r(41923),
        P = r(50200),
        D = r(67541);
      let U = class {
        constructor(e, t, r) {
          (this.sharingInvitesCrypto = e), (this.sharingCrypto = t), (this.sharingDecryption = r);
        }
        async createItemGroupCollectionInvites(e, t, r) {
          const s = await Promise.all(
            r.map(async (r) => {
              const s = await this.sharingDecryption.decryptItemGroupKey(r, t);
              if (null === s) throw new Error("Unable to decrypt item group key");
              const a = await this.sharingDecryption.decryptCollectionKey(e);
              if (null === a) throw new Error("Unable to decrypt collection key");
              const n = await this.sharingCrypto.decryptSecureData(a, (0, R.R)(e.privateKey)),
                {
                  proposeSignature: i,
                  acceptSignature: o,
                  resourceKey: c
                } = await this.sharingInvitesCrypto.createSignedInvite(
                  e.uuid,
                  { resourceKey: s, uuid: r.groupId },
                  e.publicKey,
                  (0, I.v)(n)
                );
              if (!o) throw new Error("should not happen");
              return { id: r.groupId, permission: _.y3.Admin, resourceKey: c, proposeSignature: i, acceptSignature: o };
            })
          );
          return { collectionId: e.uuid, revision: e.revision, itemGroups: s };
        }
      };
      U = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [x.h, P.O, D.c])], U);
      let F = class {
        constructor(e, t, r, s, a, n) {
          (this.collectionAccess = e),
            (this.sharingManager = t),
            (this.sharingItemGroups = r),
            (this.itemGroupsGetter = s),
            (this.sharingCollectionsApi = a),
            (this.credentialsGetter = n);
        }
        async addItemsToCollections(e, t, r) {
          const s = await (0, l.z)(this.itemGroupsGetter.getForItemsIds(t));
          if ((0, u.hx)(s)) throw new Error("Unable to find item groups for items");
          const a = (0, u.db)(s);
          if (a.some((t) => t.collections?.some((t) => e.some(({ uuid: e }) => e === t.uuid))))
            throw new Error("Items are already shared in the collections");
          if (!(await Promise.all(a.map((e) => this.collectionAccess.canShareItemGroup(e)))).every(Boolean))
            throw new Error("User does not have access to share selected items");
          const n = [
              ...(await this.credentialsGetter.getCarbonCredentialsByItemIds(t)).filter(
                ({ Id: e }) => !a.some((t) => t.items?.some((t) => t.itemId === e))
              )
            ],
            i = await Promise.all(n.map((e) => this.sharingItemGroups.createItemGroup(e))),
            o = [...a, ...i];
          return (
            await Promise.all(
              e.map(async (e) => {
                const t = await this.sharingManager.createItemGroupCollectionInvites(e, r, o);
                await this.sharingCollectionsApi.addItemGroupsToCollection(t);
              })
            ),
            (0, u.Vp)(void 0)
          );
        }
      };
      F = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [C, U, h.k, m.E, g, y.J])], F);
      var O = r(12521);
      let N = class {
        constructor(e, t, r) {
          (this.sharingCollectionItems = e), (this.sharingSync = t), (this.collectionsRepository = r);
        }
        async execute({ body: e }) {
          const { collectionId: t, itemIds: r } = e,
            s = await this.collectionsRepository.getCollection(t);
          if (!s) throw new Error("Unable to find collection");
          const a = await this.collectionsRepository.getCollections(),
            n = await this.sharingCollectionItems.addItemsToCollections([s], r, a);
          if ((0, u.hx)(n)) throw new Error("Failed adding items to collection");
          return await this.sharingSync.scheduleSync(), (0, u.Vp)(void 0);
        }
      };
      N = (0, s.__decorate)([(0, c.W)(d.Z), (0, s.__metadata)("design:paramtypes", [F, O.D, A])], N);
      var k = r(11527),
        L = r(87969),
        M = r(80231),
        V = r(87853);
      let G = class {
        constructor(e, t, r, s, a) {
          (this.sharingCollectionsGateway = e),
            (this.sharingCrypto = t),
            (this.sharingDecryption = r),
            (this.sharingUserGroups = s),
            (this.sharingUsers = a);
        }
        async createCollection(e, t, r, s, a) {
          const n = await this.sharingCrypto.createResourceKey(),
            i = { resourceKey: n, uuid: e },
            o = await this.sharingUsers.createSignedUserInvites(s, i),
            c = a.length > 0 ? await this.sharingUserGroups.createSignedUserGroupInvites(a, i) : void 0,
            { publicKey: u, privateKey: d } = await this.sharingCrypto.createRecipientKeyPair(n);
          return this.sharingCollectionsGateway.createCollection({
            collectionId: e,
            collectionName: r,
            publicKey: u,
            privateKey: d,
            users: o,
            userGroups: c,
            teamId: Number(t)
          });
        }
        async renameCollection(e, t) {
          const { revision: r, uuid: s } = e;
          await this.sharingCollectionsGateway.renameCollection({ collectionId: s, revision: r, updatedName: t });
        }
        async inviteCollectionMembers(e, t, r) {
          const { revision: s, uuid: a } = e,
            n = await this.sharingDecryption.decryptCollectionKey(e);
          if (!n) throw new Error("Cannot decrypt collection key.");
          const i = t.length ? this.sharingUsers.createSignedUserInvites(t, { resourceKey: n, uuid: e.uuid }, !1) : void 0,
            o = r.length ? this.sharingUserGroups.createSignedUserGroupInvites(r, { resourceKey: n, uuid: e.uuid }) : void 0,
            [c, u] = await Promise.all([i, o]);
          return await this.sharingCollectionsGateway.inviteCollectionMembers({ revision: s, collectionId: a, users: c, userGroups: u });
        }
        async updateCollectionMembers(e, t, r) {
          const { revision: s, uuid: a } = e;
          return await this.sharingCollectionsGateway.updateCollectionMembers({ revision: s, collectionId: a, users: t, userGroups: r });
        }
      };
      G = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [g, P.O, D.c, M.o, V.E])], G);
      var j = r(40896);
      const q = (e) => (e === _.Yt.Manager ? _.y3.Admin : _.y3.Limited),
        K = (e) => ({ login: e.login, permission: q(e.role) }),
        W = (e) => ({ groupId: e.groupId, permission: q(e.role) }),
        B = (e) => e.login,
        z = (e) => e.groupId,
        H = (e) => (e.length > 0 ? e.map(B) : void 0);
      let $ = class {
        constructor(e, t, r, s, a, n) {
          (this.sharingCollections = e),
            (this.collectionsRepository = t),
            (this.sharingCollectionsGateway = r),
            (this.sharingCollectionItems = s),
            (this.vaultClient = a),
            (this.sharingSync = n);
        }
        async execute({ body: e }) {
          const { teamId: t, collectionName: r, privateCollectionId: s, users: a, groups: n, itemIds: i } = e,
            o = (0, j.R)(),
            c = await this.sharingCollections.createCollection(o, t, r, a.map(K), n.map(W));
          if (i.length > 0)
            try {
              const e = await this.collectionsRepository.getCollections();
              await this.sharingCollectionItems.addItemsToCollections([c], i, e);
            } catch (e) {
              const t = await this.sharingCollectionsGateway.revokeCollectionMembers({
                collectionId: c.uuid,
                revision: c.revision,
                userGroupIds: ((d = n), d.length > 0 ? d.map(z) : void 0),
                userLogins: H(a)
              });
              throw (await this.sharingCollectionsGateway.deleteCollection(t.uuid, t.revision), await this.sharingSync.scheduleSync(), e);
            }
          var d;
          const { commands: l } = this.vaultClient;
          return s ? await l.deleteCollection({ id: s }) : await this.sharingSync.scheduleSync(), (0, u.Vp)(void 0);
        }
      };
      $ = (0, s.__decorate)([(0, c.W)(k.I), (0, s.__metadata)("design:paramtypes", [G, A, g, F, L.C, O.D])], $);
      var Q = r(50384);
      let Y = class {
        constructor(e, t, r) {
          (this.sharingSync = e), (this.collectionsRepository = t), (this.sharingCollectionsApi = r);
        }
        async execute({ body: e }) {
          const { id: t } = e,
            r = await this.collectionsRepository.getCollection(t);
          if (!r) throw new Error("Failed to find collection revision");
          return (
            await this.sharingCollectionsApi.deleteCollection(r.uuid, r.revision), await this.sharingSync.scheduleSync(), (0, u.Vp)(void 0)
          );
        }
      };
      Y = (0, s.__decorate)([(0, c.W)(Q.U), (0, s.__metadata)("design:paramtypes", [O.D, A, g])], Y);
      var X = r(89074);
      let J = class {
        constructor(e, t) {
          (this.sharingCollectionsService = e), (this.collectionsRepository = t);
        }
        async execute({ body: e }) {
          const { collectionId: t, userRecipients: r, userGroupRecipients: s } = e,
            a = await this.collectionsRepository.getCollection(t);
          if (!a) throw new Error("Collection not found");
          const n = await this.sharingCollectionsService.inviteCollectionMembers(a, r?.map(K) || [], s?.map(W) || []),
            i = (await this.collectionsRepository.getCollections()).filter((e) => e.uuid !== n.uuid);
          return await this.collectionsRepository.updateCollections([...i, n]), (0, u.Vp)(void 0);
        }
      };
      J = (0, s.__decorate)([(0, c.W)(X.Q), (0, s.__metadata)("design:paramtypes", [G, A])], J);
      var Z = r(68827);
      let ee = class {
        constructor(e, t, r, s) {
          (this.sharingCollectionsGateway = e), (this.collectionsRepository = t), (this.itemGroupsGetter = r), (this.sharingSync = s);
        }
        async removeItemToCollection(e, t) {
          const r = await this.collectionsRepository.getCollection(t);
          if (!r) throw new Error("Unable to find collection");
          const s = await (0, l.z)(this.itemGroupsGetter.getForItemId(e));
          if ((0, u.hx)(s) || !s.data) throw new Error("Item group to remove cannot be found");
          await this.sharingCollectionsGateway.removeItemGroupsFromCollection(r, [s.data.groupId]);
        }
        async execute({ body: e }) {
          const { collectionIds: t, itemId: r } = e;
          for (const e of t) await this.removeItemToCollection(r, e);
          return await this.sharingSync.scheduleSync(), (0, u.Vp)(void 0);
        }
      };
      ee = (0, s.__decorate)([(0, c.W)(Z.B), (0, s.__metadata)("design:paramtypes", [g, A, m.E, O.D])], ee);
      var te = r(86590);
      let re = class {
        constructor(e, t, r) {
          (this.sharingCollections = e), (this.collectionsRepository = t), (this.sharingSync = r);
        }
        async execute({ body: e }) {
          const { collectionId: t, newName: r } = e,
            s = await this.collectionsRepository.getCollection(t);
          if (!s) throw new Error("Failed to find collection revision");
          return await this.sharingCollections.renameCollection(s, r), await this.sharingSync.scheduleSync(), (0, u.Vp)(void 0);
        }
      };
      re = (0, s.__decorate)([(0, c.W)(te.r), (0, s.__metadata)("design:paramtypes", [G, A, O.D])], re);
      var se = r(77311);
      let ae = class {
        constructor(e, t) {
          (this.collectionsRepository = e), (this.sharingCollectionsGateway = t);
        }
        async execute({ body: e }) {
          const { collectionUUID: t, userGroupUUIDs: r, userLogins: s } = e,
            a = await this.collectionsRepository.getCollection(t);
          if (!a) throw new Error("Cannot access the requested collection.");
          const { revision: n } = a,
            i = await this.sharingCollectionsGateway.revokeCollectionMembers({
              collectionId: t,
              revision: n,
              userGroupIds: r,
              userLogins: s
            }),
            o = (await this.collectionsRepository.getCollections()).filter((e) => e.uuid !== i.uuid);
          return await this.collectionsRepository.updateCollections([...o, i]), (0, u.Vp)(void 0);
        }
      };
      ae = (0, s.__decorate)([(0, c.W)(se.q), (0, s.__metadata)("design:paramtypes", [A, g])], ae);
      var ne = r(15507);
      let ie = class {
        constructor(e) {
          this.collectionsRepository = e;
        }
        async execute({ body: e }) {
          return await this.collectionsRepository.updateCollections(e.collections), (0, u.Vp)(void 0);
        }
      };
      ie = (0, s.__decorate)([(0, c.W)(ne.M), (0, s.__metadata)("design:paramtypes", [A])], ie);
      var oe = r(43978),
        ce = r(20754),
        ue = r(35317),
        de = r(72614);
      let le = class {
        constructor(e, t, r) {
          (this.sharingAccess = e), (this.vaultOrganization = t), (this.currentSpace = r);
        }
        isCollectionsSharingEnabled(e) {
          return e.isSharingEnabled && e.isCollectionsSharingEnabled;
        }
        execute({ body: e }) {
          const { collectionId: t } = e,
            {
              queries: { queryCollections: r }
            } = this.vaultOrganization;
          return r({ ids: [t] }).pipe(
            (0, v.V)(this.currentSpace.get()),
            (0, oe.w)(([e, r]) => {
              if ((0, u.hx)(e)) throw new Error("Error accessing private collections");
              if ((0, u.hx)(r)) throw new Error("Error accessing current space info");
              const s = this.isCollectionsSharingEnabled((0, u.db)(r)),
                a = (0, u.db)(e).collections.find(({ id: e }) => e === t);
              if (a) {
                const e = a.vaultItems.map(({ id: e }) => e);
                return (0, w.of)({ isCollectionsSharingEnabled: s, itemIds: e, role: _.Yt.Manager, isPrivateCollection: !0 });
              }
              return this.sharingAccess
                .getUserRoleInCollection$(t)
                .pipe(
                  (0, f.U)((e) => ({ itemIds: [], role: s ? e : _.Yt.Editor, isCollectionsSharingEnabled: s, isPrivateCollection: !1 }))
                );
            }),
            (0, oe.w)(({ itemIds: e, role: t, isCollectionsSharingEnabled: r, isPrivateCollection: s }) => {
              const a = t === _.Yt.Manager;
              return r
                ? this.sharingAccess.canShareItems(e).pipe(
                    (0, f.U)((e) => {
                      if ((0, u.hx)(e)) throw new Error("Error checking if user can share a collection");
                      const r = !!a && (0, u.db)(e);
                      return (0, u.Vp)({ canShare: r, canEditRoles: a, canEdit: a, canDelete: a, role: t });
                    })
                  )
                : (0, w.of)((0, u.Vp)({ canShare: !1, canEditRoles: !1, canEdit: s, canDelete: s, role: t }));
            })
          );
        }
      };
      le = (0, s.__decorate)([(0, ce.e)(ue.A), (0, s.__metadata)("design:paramtypes", [C, L.C, de.n])], le);
      var pe = r(67591),
        he = r(11578),
        me = r(82706);
      const ye = (e) => {
          if (!e.items || 1 !== e.items.length) throw new Error("Corrupted item group");
          return { id: e.items[0].itemId, type: me.U.Credential };
        },
        ge = (e, t, r) => {
          const s = ((e, t, r) => ({
            name: e.name,
            id: e.uuid,
            spaceId: r,
            isShared: !0,
            vaultItems: t.filter((t) => t.collections?.some((t) => t.uuid === e.uuid)).map(ye)
          }))(e, t, r);
          if (he.JQ.safeParse(s).success) return s;
          throw new Error("Failure to convert shared collection");
        };
      let ve = class {
        constructor(e, t, r) {
          (this.currentSpaceGetter = e), (this.itemGroupsGetter = t), (this.collectionsRepository = r);
        }
        execute({ body: e }) {
          const { itemIds: t } = e;
          return this.collectionsRepository.collections$().pipe(
            (0, v.V)(this.currentSpaceGetter.get(), this.itemGroupsGetter.get()),
            (0, f.U)(([e, r, s]) => {
              if ((0, u.hx)(r) || (0, u.hx)(s)) throw new Error("Unable to access sharing data");
              const a = e.map((e) => ge(e, s.data, r.data.teamId)).flatMap((e) => e.vaultItems),
                n = t.filter((e) => a.some((t) => t.id === e));
              return (0, u.Vp)(n);
            })
          );
        }
      };
      ve = (0, s.__decorate)([(0, ce.e)(pe.q), (0, s.__metadata)("design:paramtypes", [de.n, m.E, A])], ve);
      var fe = r(24249);
      let we = class {
        constructor(e) {
          this.collectionsRepository = e;
        }
        execute({ body: e }) {
          const t = e.collectionIds ? e.collectionIds : [];
          return this.collectionsRepository
            .collections$()
            .pipe((0, f.U)((e) => (0, u.Vp)(e.filter((e) => !t.length || t.includes(e.uuid)))));
        }
      };
      we = (0, s.__decorate)([(0, ce.e)(fe.$), (0, s.__metadata)("design:paramtypes", [A])], we);
      let Se = class {
        constructor(e, t, r) {
          (this.collectionsRepository = e), (this.currentSpaceGetter = t), (this.itemGroupsGetter = r);
        }
        execute() {
          return this.collectionsRepository.collections$().pipe(
            (0, v.V)(this.currentSpaceGetter.get(), this.itemGroupsGetter.get()),
            (0, f.U)(([e, t, r]) => {
              if ((0, u.hx)(t) || (0, u.hx)(r)) throw new Error("Failed to load shared collections");
              return (0, u.Vp)(e.map((e) => ge(e, r.data, t.data.teamId)));
            })
          );
        }
      };
      Se = (0, s.__decorate)([(0, ce.e)(he.MO), (0, s.__metadata)("design:paramtypes", [A, de.n, m.E])], Se);
      var Ee = r(6233);
      let _e = class {
        constructor(e) {
          this.collectionsRepository = e;
        }
        execute({ body: e }) {
          const { collectionUUIDs: t } = e;
          return this.collectionsRepository.collections$().pipe(
            (0, f.U)((e) => {
              const r = e.filter((e) => t.includes(e.uuid)),
                s = r
                  .flatMap((e) => (e.users ? e.users : []))
                  .map((e) => ({ id: e.login, label: e.login, status: e.status, permission: e.permission })),
                a = r
                  .flatMap((e) => (e.userGroups ? e.userGroups : []))
                  .map((e) => ({ id: e.uuid, label: e.name, status: e.status, permission: e.permission }));
              return (0, u.Vp)({ userGroups: a, users: s });
            })
          );
        }
      };
      _e = (0, s.__decorate)([(0, ce.e)(Ee.O), (0, s.__metadata)("design:paramtypes", [A])], _e);
      var be = r(46629);
      function Te(e) {
        return void 0 !== e;
      }
      let Ae = class {
        constructor(e, t, r) {
          (this.sharingCollectionItems = e), (this.sharingSync = t), (this.collectionsRepository = r);
        }
        async execute({ body: e }) {
          const { collectionIds: t, itemId: r, shouldSkipSync: s } = e,
            a = await Promise.all(t.map((e) => this.collectionsRepository.getCollection(e)));
          if (a.some((e) => void 0 === e)) throw new Error("Unable to find collection");
          const n = await this.collectionsRepository.getCollections(),
            i = await this.sharingCollectionItems.addItemsToCollections(a.filter(Te), [r], n);
          if ((0, u.hx)(i)) throw new Error("Failed adding items to collection");
          return s || (await this.sharingSync.scheduleSync()), (0, u.Vp)(void 0);
        }
      };
      Ae = (0, s.__decorate)([(0, c.W)(be.$), (0, s.__metadata)("design:paramtypes", [F, O.D, A])], Ae);
      var Ce = r(61501);
      const Re = (e) =>
          e.map(
            ({
              id: e,
              resourceKey: t,
              proposeSignature: r,
              proposeSignatureUsingAlias: s,
              acceptSignature: a,
              alias: n,
              permission: i
            }) => ({
              login: e,
              collectionKey: t,
              proposeSignature: r,
              proposeSignatureUsingAlias: s,
              acceptSignature: a,
              alias: n,
              permission: i
            })
          ),
        Ie = (e) =>
          e.map(({ id: e, resourceKey: t, proposeSignature: r, proposeSignatureUsingAlias: s, acceptSignature: a, permission: n }) => ({
            groupUUID: e,
            collectionKey: t,
            proposeSignature: r,
            proposeSignatureUsingAlias: s,
            acceptSignature: a,
            permission: n
          }));
      let xe = class {
        constructor(e) {
          this.serverApiClient = e;
        }
        async createCollection(e) {
          const t = await (0, l.z)(
            this.serverApiClient.v1.sharingUserdevice.createCollection(
              ((e) => {
                const { collectionId: t, collectionName: r, users: s, userGroups: a, publicKey: n, privateKey: i, teamId: o } = e;
                return {
                  collectionUUID: t,
                  collectionName: r,
                  publicKey: n,
                  privateKey: i,
                  teamId: o,
                  users: Re(s),
                  userGroups: a ? Ie(a) : void 0
                };
              })(e)
            )
          );
          if ((0, u.hx)(t)) throw new Error("Failed to create shared collection from private one");
          const r = (0, u.db)(t).data.collections?.find((t) => t.uuid === e.collectionId);
          if (!r) throw new Error("Unable to find collection");
          return r;
        }
        async renameCollection(e) {
          const { collectionId: t, revision: r, updatedName: s } = e,
            a = await (0, l.z)(
              this.serverApiClient.v1.sharingUserdevice.renameCollection({ collectionUUID: t, revision: r, updatedName: s })
            );
          if ((0, u.hx)(a)) throw new Error("Failed to rename shared collection");
        }
        async addItemGroupsToCollection(e) {
          const t = await (0, l.z)(
            this.serverApiClient.v1.sharingUserdevice.addItemGroupsToCollection({
              collectionUUID: e.collectionId,
              itemGroups: e.itemGroups.map(({ id: e, proposeSignature: t, acceptSignature: r, permission: s, resourceKey: a }) => ({
                uuid: e,
                proposeSignature: t,
                acceptSignature: r,
                permission: s,
                itemGroupKey: a
              })),
              revision: e.revision
            })
          );
          if ((0, u.hx)(t)) throw new Error("Failed to add items to collection");
          if (0 === ((0, u.db)(t).data.collections || []).length) throw new Error("Failed to add items to collection");
        }
        async deleteCollection(e, t) {
          const r = { collectionUUID: e, revision: t },
            s = await (0, l.z)(this.serverApiClient.v1.sharingUserdevice.deleteCollection(r));
          if ((0, u.hx)(s)) throw new Error("Failed to delete shared collection");
        }
        async inviteCollectionMembers({ collectionId: e, revision: t, users: r, userGroups: s }) {
          const a = { collectionUUID: e, revision: t, users: r ? Re(r) : void 0, userGroups: s ? Ie(s) : void 0 },
            n = this.serverApiClient.v1.sharingUserdevice.inviteCollectionMembers(a),
            i = await (0, l.z)(n);
          if ((0, u.hx)(i) || !i.data.data.collections) throw new Error("Failed to add members to collection");
          return i.data.data.collections[0];
        }
        async updateCollectionMembers({ collectionId: e, revision: t, users: r, userGroups: s }) {
          const a = {
              collectionUUID: e,
              revision: t,
              users: r,
              userGroups: s?.map(({ groupId: e, permission: t }) => ({ groupUUID: e, permission: t }))
            },
            n = this.serverApiClient.v1.sharingUserdevice.updateCollectionMembers(a),
            i = await (0, l.z)(n);
          if ((0, u.hx)(i) || !i.data.data.collections) throw new Error("Failed to update collection members");
          return i.data.data.collections[0];
        }
        async revokeCollectionMembers({ collectionId: e, revision: t, userGroupIds: r, userLogins: s }) {
          const a = this.serverApiClient.v1.sharingUserdevice.revokeCollectionMembers({
              collectionUUID: e,
              revision: t,
              userLogins: s,
              userGroupUUIDs: r
            }),
            n = await (0, l.z)(a);
          if ((0, u.hx)(n) || !n.data.data.collections) throw new Error("Failed to revoke access to collection");
          return n.data.data.collections[0];
        }
        async removeItemGroupsFromCollection(e, t) {
          const r = await (0, l.z)(
            this.serverApiClient.v1.sharingUserdevice.removeItemGroupsFromCollection({
              collectionUUID: e.uuid,
              itemGroupUUIDs: t,
              revision: e.revision
            })
          );
          if ((0, u.hx)(r)) throw new Error("Failure to remove item from collection");
        }
      };
      xe = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [Ce.l])], xe);
      var Pe = r(28845),
        De = r(71419),
        Ue = r(10647),
        Fe = r(177);
      let Oe = class {
        constructor(e, t) {
          (this.sharingCollectionsService = e), (this.collectionsRepository = t);
        }
        async execute({ body: e }) {
          const { collectionId: t, userRecipients: r, userGroupRecipients: s } = e,
            a = await this.collectionsRepository.getCollection(t);
          if (!a) throw new Error("Collection not found");
          const n = await this.sharingCollectionsService.updateCollectionMembers(a, r?.map(K), s?.map(W)),
            i = (await this.collectionsRepository.getCollections()).filter((e) => e.uuid !== n.uuid);
          return await this.collectionsRepository.updateCollections([...i, n]), (0, u.Vp)(void 0);
        }
      };
      Oe = (0, s.__decorate)([(0, c.W)(Fe.c), (0, s.__metadata)("design:paramtypes", [G, A])], Oe);
      let Ne = class {};
      Ne = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.a,
            stores: [T.S],
            providers: [G, U, C, F, A, { provide: g, useClass: xe }],
            handlers: {
              commands: {
                addItemsToCollection: N,
                addItemToCollections: Ae,
                createSharedCollection: $,
                deleteSharedCollection: Y,
                inviteCollectionMembers: J,
                updateCollectionMembers: Oe,
                removeItemFromCollections: ee,
                renameCollection: re,
                revokeCollectionMembers: ae,
                updateSharedCollections: ie
              },
              events: {},
              queries: {
                getCollectionPermissions: le,
                getItemIdsInSharedCollections: ve,
                getSharedCollections: we,
                sharedCollectionsWithItems: Se,
                usersAndGroupsInCollection: _e
              }
            },
            imports: [i.n, o.D, Pe.k, De.I, Ue.y],
            requiredFeatureFlips: [
              "sharing_web_collectionsSharing",
              "sharing_web_invalidSignatureAutoRevoke_prod",
              "sharingVault_web_Collection_Editor_Manager_dev",
              "sharingVault_web_Collection_Editor_Manager_prod"
            ]
          })
        ],
        Ne
      );
    },
    71419: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => _ });
      var s = r(88802),
        a = r(99634),
        n = r(60399),
        i = r(57924),
        o = r(61501),
        c = r(48844),
        u = r(87279);
      const d = /[<>]/g;
      function l(e, t) {
        const r = "SECURENOTE" === e ? "note" : "password";
        return { type: r, name: t || `Untitled ${r}` };
      }
      const p = (e) =>
        e.map(
          ({ id: e, resourceKey: t, proposeSignature: r, proposeSignatureUsingAlias: s, acceptSignature: a, alias: n, permission: i }) => ({
            userId: e,
            groupKey: t,
            proposeSignature: r,
            proposeSignatureUsingAlias: s,
            acceptSignature: a,
            alias: n,
            permission: i
          })
        );
      let h = class {
        constructor(e) {
          this.serverApiClient = e;
        }
        async getPublicKeysForUsers(e) {
          const t = await (0, n.z)(
            this.serverApiClient.v1.sharingUserdevice.getUsersPublicKey({ logins: e }).pipe(
              (0, c.DZ)(() => {
                throw new Error("Cannot get public keys of requested users.");
              }),
              (0, c.lk)((e) => (0, u.Vp)(e.data))
            )
          );
          if ((0, u.hx)(t)) throw new Error("Cannot get public keys of requested users.");
          return t.data.data.map((e) => {
            return { login: e.login ?? ((t = e.email), t.trim().toLowerCase().replace(d, "")), publicKey: e.publicKey };
            var t;
          });
        }
        async createItemGroup({ users: e, item: t, itemTitle: r, groupId: s }) {
          const a = await (0, n.z)(
            this.serverApiClient.v1.sharingUserdevice.createItemGroup({
              groupId: s,
              items: [t],
              users: p(e),
              itemsForEmailing: [l(t.itemType, r)]
            })
          );
          if ((0, u.hx)(a)) throw new Error("Failed to create item group");
          const i = a.data.data.itemGroups?.find((e) => e.groupId === s);
          if (!i) throw new Error("Error creating item group");
          return i;
        }
      };
      h = (0, s.__decorate)([(0, i.GS)(), (0, s.__metadata)("design:paramtypes", [o.l])], h);
      var m = r(24917),
        y = r(12521),
        g = r(80231),
        v = r(87853),
        f = r(28845),
        w = r(1824),
        S = r(10647),
        E = r(51911);
      let _ = class {};
      _ = (0, s.__decorate)(
        [
          (0, a.Y)({
            sharedModuleName: "sharing-carbon-helpers",
            providers: [m.k, y.D, g.o, v.E, { provide: E.b, useClass: h }],
            exports: [m.k, y.D, g.o, v.E],
            imports: [f.k, w.n, S.y]
          })
        ],
        _
      );
    },
    24917: (e, t, r) => {
      "use strict";
      r.d(t, { k: () => d });
      var s = r(88802),
        a = r(57924),
        n = r(10370),
        i = r(40896),
        o = r(50200),
        c = r(87853),
        u = r(51911);
      let d = class {
        constructor(e, t, r) {
          (this.sharingApi = e), (this.sharingCrypto = t), (this.sharingUsers = r);
        }
        async createItemGroup(e) {
          const t = (0, i.R)(),
            r = await this.sharingCrypto.createResourceKey(),
            s = await this.sharingUsers.createSignedUserInvites([], { resourceKey: r, uuid: t }),
            a = await this.sharingCrypto.createResourceKey(),
            o = await this.sharingCrypto.encryptSecureData(r, a),
            c = await this.sharingCrypto.encryptSharingItem(a, e);
          return this.sharingApi.createItemGroup({
            groupId: t,
            item: {
              itemId: e.Id,
              itemType: "KWSecureNote" === e.kwType ? "SECURENOTE" : "AUTHENTIFIANT",
              itemKey: (0, n.s)(o),
              content: (0, n.s)(c)
            },
            itemTitle: e.Title,
            users: s
          });
        }
      };
      d = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [u.b, o.O, c.E])], d);
    },
    12521: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => h });
      var s = r(88802),
        a = r(87279),
        n = r(60399),
        i = r(30523),
        o = r(57924),
        c = r(76183),
        u = r(67837),
        d = r(33470);
      class l extends (0, u.E)(d.r) {}
      (0, u.K)(d.r, l);
      var p = r(60765);
      let h = class {
        constructor(e) {
          this.syncClient = e;
        }
        async scheduleSync() {
          const { commands: e, queries: t } = this.syncClient;
          return (
            await (0, n.z)(
              t.syncProgress().pipe(
                (0, i.h)(a.d6),
                (0, i.h)((e) => e.data.status !== c.L.IN_PROGRESS)
              )
            ),
            await e.sync({ trigger: p.Trigger.Sharing }),
            (0, a.Vp)(void 0)
          );
        }
      };
      h = (0, s.__decorate)([(0, o.GS)(), (0, s.__metadata)("design:paramtypes", [l])], h);
    },
    80231: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => d });
      var s = r(88802),
        a = r(57924),
        n = r(4400),
        i = r(59452),
        o = r(81982),
        c = r(50200),
        u = r(41923);
      let d = class {
        constructor(e, t, r, s) {
          (this.userGroupsGetter = e), (this.sharingCrypto = t), (this.sharingInvitesCrypto = r), (this.currentUserGetter = s);
        }
        async createSignedUserGroupInvites(e, t) {
          const r = await this.currentUserGetter.getCurrentUserWithKeys(),
            s = await this.userGroupsGetter.getForGroupIds(e.map((e) => e.groupId));
          return await Promise.all(
            s.map(async (s) => {
              const a = e.find((e) => e.groupId === s.groupId)?.permission ?? n.y3.Limited,
                i = s.users.find((e) => e.userId === r.login),
                o = i?.groupKey;
              if (!o) throw new Error("Unable to get user group key.");
              const c = await this.sharingCrypto.decryptResourceKeyToClearText(r.privateKey, s.privateKey, o),
                {
                  proposeSignature: u,
                  acceptSignature: d,
                  resourceKey: l
                } = await this.sharingInvitesCrypto.createSignedInvite(s.groupId, t, s.publicKey, c);
              return { permission: a, proposeSignature: u, acceptSignature: d, id: s.groupId, resourceKey: l };
            })
          );
        }
      };
      d = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [i.B, c.O, u.h, o.a])], d);
    },
    87853: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => u });
      var s = r(88802),
        a = r(57924),
        n = r(4400),
        i = r(81982),
        o = r(41923),
        c = r(51911);
      let u = class {
        constructor(e, t, r) {
          (this.currentUserGetter = e), (this.invitesCryptoService = t), (this.sharingGateway = r);
        }
        async createSignedUserInvites(e, t, r = !0) {
          const s = await this.sharingGateway.getPublicKeysForUsers(e.map((e) => e.login)),
            a = await this.currentUserGetter.getCurrentUserWithKeys(),
            i = [
              ...(r ? [{ login: a.login, publicKey: a.publicKey, permission: n.y3.Admin }] : []),
              ...s.map((t) => ({ ...t, permission: e.find((e) => e.login === t.login)?.permission ?? n.y3.Limited }))
            ];
          return await Promise.all(
            i.map(async (e) => {
              const r = a.login === e.login;
              if (!e.publicKey) throw new Error("missing user public key");
              return {
                ...(await this.invitesCryptoService.createSignedInvite(e.login, t, e.publicKey, r ? a.privateKey : void 0)),
                id: e.login,
                alias: e.login,
                permission: r ? n.y3.Admin : e.permission
              };
            })
          );
        }
      };
      u = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [i.a, o.h, c.b])], u);
    },
    51911: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => s });
      class s {}
    },
    28845: (e, t, r) => {
      "use strict";
      r.d(t, { k: () => d });
      var s = r(88802),
        a = r(99634),
        n = r(10647),
        i = r(50200),
        o = r(67541),
        c = r(41923),
        u = r(37935);
      let d = class {};
      d = (0, s.__decorate)(
        [(0, a.Y)({ sharedModuleName: "sharing-crypto", providers: [i.O, o.c, c.h], exports: [i.O, o.c, c.h], imports: [n.y, u.D] })],
        d
      );
    },
    50200: (e, t, r) => {
      "use strict";
      r.d(t, { O: () => I });
      var s = r(88802),
        a = r(57924),
        n = r(31222),
        i = r(92258),
        o = r(40173),
        c = r(71634),
        u = r(83919),
        d = r(12554),
        l = r(77970),
        p = r(28008),
        h = r(54066),
        m = r(3417),
        y = r.n(m);
      function g(e) {
        return e.replace(/(?:\\[r]|[\r\n]+)+/g, "\n");
      }
      var v = r(10370),
        f = r(83168),
        w = r(66122),
        S = r(89685),
        E = r(53576),
        _ = r(43293),
        b = r(93347),
        T = r.n(b),
        A = r(82933);
      function C(e) {
        const t = new Uint8Array([0, 0, 0, 0]).buffer,
          r = new Uint8Array(e),
          s = T().deflate(r, { level: 7 }).buffer;
        return (0, A.K)(t, s);
      }
      var R = r(87279);
      let I = class {
        constructor(e, t, r, s, a, n, i, o, c) {
          (this.client = e),
            (this.hmacSigner = t),
            (this.keyGeneratorAes256 = r),
            (this.rsaKeyPairGenerator = s),
            (this.kwc5Decryptor = a),
            (this.kwc5Encryptor = n),
            (this.rsaDecryptor = i),
            (this.rsaEncryptor = o),
            (this.rsaSigner = c);
        }
        async createResourceKey() {
          return await this.keyGeneratorAes256.generate();
        }
        async encryptSecureData(e, t) {
          return await this.kwc5Encryptor.encrypt(e, t);
        }
        async decryptSecureData(e, t) {
          return await this.kwc5Decryptor.decrypt(e, t);
        }
        async createProposeSignature(e, t) {
          return await this.hmacSigner.sign(e, t);
        }
        async createRecipientKeyPair(e) {
          const { publicKey: t, privateKey: r } = await this.rsaKeyPairGenerator.generate(),
            s = (0, h.u)(
              (function (e) {
                const { asn1: t, pki: r, util: s } = y(),
                  a = s.createBuffer(e),
                  n = t.fromDer(a),
                  i = r.privateKeyFromAsn1(n);
                return g(r.privateKeyToPem(i));
              })(r)
            ),
            a = await this.encryptSecureData(e, s),
            n = (function (e) {
              const { asn1: t, pki: r, util: s } = y(),
                a = s.createBuffer(e),
                n = t.fromDer(a),
                i = r.publicKeyFromAsn1(n);
              return g(r.publicKeyToRSAPublicKeyPem(i));
            })(t);
          return { publicKey: n, privateKey: (0, v.s)(a) };
        }
        async createAcceptSignature(e, t, r) {
          const s = `${t}-accepted-${(0, v.s)(r)}`,
            a = (0, h.u)(s);
          return await this.rsaSigner.sign(e, a);
        }
        async encryptResourceKey(e, t) {
          return await this.rsaEncryptor.encrypt(e, t);
        }
        async decryptResourceKey(e, t) {
          return await this.rsaDecryptor.decrypt(e, t);
        }
        async decryptResourceKeyToClearText(e, t, r) {
          const s = await this.decryptResourceKey((0, f.B)(e), (0, w.R)(r)),
            a = await this.decryptSecureData(s, (0, w.R)(t));
          return (0, S.v)(a);
        }
        async encryptSharingItem(e, t) {
          const {
              commands: { carbon: r }
            } = this.client,
            s = await r({ name: "convertItemToDashlaneXml", args: [{ item: t }] }),
            a = ((n = s), (0, R.hx)(n) || "string" != typeof n.data.carbonResult.xml ? null : n.data.carbonResult.xml);
          var n;
          if ("" === a || null === a) throw new Error("Unable to convert item to XML");
          const i = ((e) => {
            const t = (0, _.N)(e);
            return C((0, h.u)(t));
          })(a);
          return await this.encryptSecureData(e, i);
        }
        async decryptEncapsulatedPrivateKey(e, t, r) {
          const s = await this.decryptResourceKey(e, (0, w.R)(t)),
            a = await this.decryptSecureData(s, (0, w.R)(r));
          return (0, f.B)((0, S.v)(a));
        }
      };
      I = (0, s.__decorate)(
        [(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [E.CarbonLegacyClient, n.q, i.c, o.e, c.$, u.o, d.g, l.H, p.k])],
        I
      );
    },
    67541: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => l });
      var s = r(88802),
        a = r(57924),
        n = r(63877),
        i = r(83168),
        o = r(66122),
        c = r(50200),
        u = r(81982),
        d = r(59452);
      let l = class {
        constructor(e, t, r) {
          (this.sharingCrypto = e), (this.currentUserGetter = t), (this.userGroupsGetter = r);
        }
        async decryptItemGroupKey(e, t) {
          const r = await this.currentUserGetter.getCurrentUserWithKeys(),
            s = e.users?.find((e) => e.userId === r.login && e.status === n.qb.Accepted && e.groupKey);
          if (s?.groupKey) return await this.decryptItemGroupKeyViaUserMember(s, r);
          const a = (await this.userGroupsGetter.getCarbonUserGroups()).filter((e) =>
              e.users.some((e) => e.userId === r.login && e.status === n.qb.Accepted && !e.proposeSignatureUsingAlias && e.groupKey)
            ),
            i = e.groups?.find((e) => a.some((t) => t.groupId === e.groupId) && e.status === n.qb.Accepted && e.groupKey);
          if (i?.groupKey) return await this.decryptItemGroupKeyViaGroupMember(i, r, a);
          const o = t.filter(
              (e) =>
                e.users?.some(
                  (e) => e.login === r.login && e.status === n.qb.Accepted && !e.proposeSignatureUsingAlias && e.collectionKey
                ) || e.userGroups?.some((e) => a.some((t) => t.groupId === e.uuid) && e.status === n.qb.Accepted && e.collectionKey)
            ),
            c = e.collections?.find((e) => o.some((t) => t.uuid === e.uuid) && e.status === n.qb.Accepted && e.itemGroupKey);
          return c?.itemGroupKey ? await this.decryptItemGroupKeyViaCollectionMember(c, r, o, a) : null;
        }
        async decryptItemGroupKeyViaUserMember(e, t) {
          if (!e.groupKey) return null;
          try {
            return await this.sharingCrypto.decryptResourceKey((0, i.B)(t.privateKey), (0, o.R)(e.groupKey));
          } catch {
            return null;
          }
        }
        async decryptItemGroupKeyViaGroupMember(e, t, r) {
          if (!e.groupKey) return null;
          try {
            const s = r.find(({ groupId: t }) => t === e.groupId),
              a = s?.users.find(({ userId: e }) => e === t.login);
            if (!a?.groupKey || !s) return null;
            const n = await this.sharingCrypto.decryptEncapsulatedPrivateKey((0, i.B)(t.privateKey), a.groupKey, s.privateKey);
            return await this.sharingCrypto.decryptResourceKey(n, (0, o.R)(e.groupKey));
          } catch (e) {
            return null;
          }
        }
        async decryptItemGroupKeyViaCollectionMember(e, t, r, s) {
          if (!e.itemGroupKey) return null;
          const a = r.find(({ uuid: t }) => t === e.uuid);
          if (!a) return null;
          const n = a.users?.find(({ login: e }) => e === t.login),
            c = a.userGroups?.find(({ uuid: e }) => s.some(({ groupId: t }) => t === e));
          if (n?.collectionKey) {
            const r = await this.sharingCrypto.decryptEncapsulatedPrivateKey((0, i.B)(t.privateKey), n.collectionKey, a.privateKey);
            return await this.sharingCrypto.decryptResourceKey(r, (0, o.R)(e.itemGroupKey));
          }
          if (c?.collectionKey) {
            const r = s.find(({ groupId: e }) => e === c.uuid),
              n = r?.users.find(({ userId: e }) => e === t.login);
            if (!n?.groupKey || !r) return null;
            const u = await this.sharingCrypto.decryptEncapsulatedPrivateKey((0, i.B)(t.privateKey), n.groupKey, r.privateKey),
              d = await this.sharingCrypto.decryptEncapsulatedPrivateKey(u, c.collectionKey, a.privateKey);
            return await this.sharingCrypto.decryptResourceKey(d, (0, o.R)(e.itemGroupKey));
          }
          return null;
        }
        async decryptCollectionKey(e, t = n.qb.Accepted) {
          const r = await this.currentUserGetter.getCurrentUserWithKeys(),
            s = e.users?.find((e) => e.login === r.login && e.status === t && e.collectionKey);
          if (s?.collectionKey) return await this.decryptCollectionKeyViaUserMember(s, r);
          const a = (await this.userGroupsGetter.getCarbonUserGroups()).filter((e) =>
              e.users.some((e) => e.userId === r.login && e.status === t && !e.proposeSignatureUsingAlias && e.groupKey)
            ),
            i = e.userGroups?.find((e) => a.some((t) => t.groupId === e.uuid) && e.status === t && e.collectionKey);
          return i?.collectionKey ? await this.decryptCollectionKeyViaGroupMember(i, r, a) : null;
        }
        async decryptCollectionKeyViaUserMember(e, t) {
          if (!e.collectionKey) return null;
          try {
            return await this.sharingCrypto.decryptResourceKey((0, i.B)(t.privateKey), (0, o.R)(e.collectionKey));
          } catch {
            return null;
          }
        }
        async decryptCollectionKeyViaGroupMember(e, t, r) {
          if (!e.collectionKey) return null;
          try {
            const s = r.find(({ groupId: t }) => t === e.uuid),
              a = s?.users.find(({ userId: e }) => e === t.login);
            if (!a?.groupKey || !s) return null;
            const n = await this.sharingCrypto.decryptEncapsulatedPrivateKey((0, i.B)(t.privateKey), a.groupKey, s.privateKey);
            return await this.sharingCrypto.decryptResourceKey(n, (0, o.R)(e.collectionKey));
          } catch {
            return null;
          }
        }
      };
      l = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [c.O, u.a, d.B])], l);
    },
    41923: (e, t, r) => {
      "use strict";
      r.d(t, { h: () => l });
      var s = r(88802),
        a = r(57924),
        n = r(3417),
        i = r.n(n),
        o = r(54066);
      var c = r(10370),
        u = r(83168),
        d = r(50200);
      let l = class {
        constructor(e) {
          this.sharingCrypto = e;
        }
        async createSignedInvite(e, t, r, s) {
          const a = await this.sharingCrypto.encryptResourceKey(
              (function (e) {
                const { asn1: t, pki: r } = i(),
                  s = r.publicKeyFromPem(e),
                  a = r.publicKeyToAsn1(s),
                  n = t.toDer(a).getBytes();
                return (0, o.u)(n);
              })(r),
              t.resourceKey
            ),
            n = (0, c.s)(a),
            d = (0, o.u)(e),
            l = await this.sharingCrypto.createProposeSignature(t.resourceKey, d),
            p = (0, c.s)(l),
            h = s ? await this.sharingCrypto.createAcceptSignature((0, u.B)(s), t.uuid, t.resourceKey) : void 0;
          return { proposeSignature: p, acceptSignature: h ? (0, c.s)(h) : void 0, resourceKey: n, proposeSignatureUsingAlias: !r };
        }
      };
      l = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [d.O])], l);
    },
    31766: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => s });
      const s = (e) => {
        if (!e) return !1;
        const t = e;
        return !!t.pendingItemGroups && !!t.pendingUserGroups;
      };
    },
    63090: (e, t, r) => {
      "use strict";
      r.d(t, { p: () => de });
      var s = r(88802),
        a = r(99634),
        n = r(58425),
        i = r(1824),
        o = r(37935),
        c = r(85390),
        u = r(87065),
        d = r(21869),
        l = r(20754),
        p = r(87279),
        h = r(15179),
        m = r(19617),
        y = r(7165),
        g = r(95681),
        v = r(23347),
        f = r(25029),
        w = r(4400);
      const S = y.z.object({ pendingCollections: y.z.array(w.MX) }),
        E = (e) => S.safeParse(e).success;
      class _ extends (0, g.Q)({
        capacity: v.Y._010KB,
        persist: !1,
        scope: f.F.User,
        storeName: "pending-shared-collections-state",
        storeTypeGuard: E,
        initialValue: { pendingCollections: [] }
      }) {}
      const b = (e) => void 0 !== e.referrer && void 0 !== e.permission,
        T = (e, t) =>
          e
            .map((e) => {
              const r = (e.users || []).find((e) => e.login === t && e.status === w.qb.Pending);
              return { uuid: e.uuid, name: e.name, referrer: r?.referrer, permission: r?.permission, seen: !0 };
            })
            .filter(b);
      let A = class {
        constructor(e, t, r) {
          (this.inviteGetter = e), (this.store = t), (this.context = r);
        }
        execute() {
          const e = this.inviteGetter.get(),
            t = this.store.state$,
            r = this.getCurrentUserLogin();
          return (0, c.a)([e, t]).pipe(
            (0, u.U)(([e, t]) => {
              const s = (0, p.d6)(e) ? e.data : { pendingItemGroups: [], pendingUserGroups: [] },
                a = r ? T(t.pendingCollections, r) : [];
              return (0, p.Vp)({ pendingItemGroups: s.pendingItemGroups, pendingUserGroups: s.pendingUserGroups, pendingCollections: a });
            })
          );
        }
        getCurrentUserLogin() {
          return this.context.get(d.l.UserName);
        }
      };
      A = (0, s.__decorate)([(0, l.e)(h.q), (0, s.__metadata)("design:paramtypes", [m.V, _, d.f])], A);
      var C = r(36610);
      let R = class {
        constructor(e, t) {
          (this.store = e), (this.context = t);
        }
        execute() {
          const e = this.getCurrentUserLogin();
          if (void 0 === e) throw new Error("Unable to get pending collections, user login not found");
          return this.store.state$.pipe(
            (0, u.U)((t) => {
              const r = T(t.pendingCollections, e);
              return (0, p.Vp)(r);
            })
          );
        }
        getCurrentUserLogin() {
          return this.context.get(d.l.UserName);
        }
      };
      R = (0, s.__decorate)([(0, l.e)(C.D), (0, s.__metadata)("design:paramtypes", [_, d.f])], R);
      var I = r(36469),
        x = r(48844),
        P = r(53576),
        D = r(21242),
        U = r(31766);
      let F = class {
        constructor(e, t, r) {
          (this.carbonLegacyClient = e), (this.featureFlipsClient = t), (this.store = r);
        }
        execute() {
          const {
              queries: { carbonState: e }
            } = this.carbonLegacyClient,
            t = e({ path: "userSession.sharingSync" }).pipe(
              (0, x.Qn)((e) => {
                if (!(0, U.o)(e)) throw new Error("Bad SharingSync format");
                return e;
              })
            ),
            r = this.store.state$,
            { userFeatureFlips: s } = this.featureFlipsClient.queries,
            a = s();
          return (0, c.a)([t, r, a]).pipe(
            (0, u.U)(([e, t, r]) => {
              const s = (0, p.d6)(e) ? e.data : { pendingItemGroups: [], pendingUserGroups: [] },
                a = s.pendingItemGroups.length > 0,
                n = s.pendingUserGroups.length > 0,
                i = t.pendingCollections.length > 0;
              if ((0, p.hx)(r)) return (0, p.Vp)(a || n);
              const o = r.data.sharing_web_collectionsSharing ? a || n || i : a || n;
              return (0, p.Vp)(o);
            })
          );
        }
      };
      F = (0, s.__decorate)([(0, l.e)(I._), (0, s.__metadata)("design:paramtypes", [P.CarbonLegacyClient, D.P, _])], F);
      var O = r(60399),
        N = r(63663),
        k = r(61501),
        L = r(31609),
        M = r(63877),
        V = r(83168),
        G = r(10370),
        j = r(50200),
        q = r(67541),
        K = r(12521),
        W = r(81982);
      let B = class {
        constructor(e, t, r, s, a, n) {
          (this.serverApiClient = e),
            (this.sharingCrypto = t),
            (this.sharingDecryption = r),
            (this.pendingCollectionsStore = s),
            (this.sharingSync = a),
            (this.currentUserGetter = n);
        }
        async execute(e) {
          const {
              body: { collectionId: t }
            } = e,
            r = (await this.pendingCollectionsStore.getState()).pendingCollections.find(({ uuid: e }) => e === t);
          if (!r) throw new Error("Pending Collection not found");
          const s = await this.sharingDecryption.decryptCollectionKey(r, M.qb.Pending);
          if (!s) throw new Error("Unable to decrypt Collection Key for pending collection");
          const a = await this.currentUserGetter.getCurrentUserWithKeys(),
            n = await this.sharingCrypto.createAcceptSignature((0, V.B)(a.privateKey), t, s),
            i = await (0, O.z)(
              this.serverApiClient.v1.sharingUserdevice.acceptCollection({
                collectionUUID: t,
                revision: r.revision,
                acceptSignature: (0, G.s)(n)
              })
            );
          return (0, p.hx)(i) ? (0, p.Rn)(new L.nu()) : (await this.sharingSync.scheduleSync(), (0, p.Vp)(void 0));
        }
      };
      B = (0, s.__decorate)([(0, N.W)(L.cD), (0, s.__metadata)("design:paramtypes", [k.l, j.O, q.c, _, K.D, W.a])], B);
      var z = r(68096);
      let H = class {
        constructor(e, t) {
          (this.serverApiClient = e), (this.pendingCollectionsStore = t);
        }
        async execute(e) {
          const {
              body: { collectionId: t }
            } = e,
            r = (await this.pendingCollectionsStore.getState()).pendingCollections.find(({ uuid: e }) => e === t);
          if (!r) throw new Error("Pending Collection not found");
          const s = await (0, O.z)(this.serverApiClient.v1.sharingUserdevice.refuseCollection({ collectionUUID: t, revision: r.revision }));
          return (0, p.hx)(s) ? (0, p.Rn)(new z.R$()) : (0, p.Vp)(void 0);
        }
      };
      H = (0, s.__decorate)([(0, N.W)(z.UC), (0, s.__metadata)("design:paramtypes", [k.l, _])], H);
      var $ = r(95233),
        Q = r(94189),
        Y = r(70493),
        X = r(60765),
        J = r(55677),
        Z = r(64718);
      const ee = (e) => {
        if (!e || "object" != typeof e) return !1;
        const t = e;
        return (
          (r = t.items),
          !!Array.isArray(r) &&
            (0 === r.length ||
              r.every((e) => {
                const t = e;
                return "string" == typeof t.content && "string" == typeof t.itemId && "number" == typeof t.timestamp;
              })) &&
            ((e) =>
              !!Array.isArray(e) &&
              (0 === e.length ||
                e.every((e) => {
                  const t = e;
                  return "string" == typeof t.groupId && "string" == typeof t.type && "number" == typeof t.revision;
                })))(t.itemGroups) &&
            ((e) =>
              !!Array.isArray(e) &&
              (0 === e.length ||
                e.every((e) => {
                  const t = e;
                  return (
                    "string" == typeof t.groupId &&
                    "string" == typeof t.name &&
                    "string" == typeof t.publicKey &&
                    "string" == typeof t.privateKey &&
                    "number" == typeof t.revision
                  );
                })))(t.userGroups)
        );
        var r;
      };
      let te = class {
        constructor(e, t, r, s, a) {
          (this.client = e), (this.carbonLegacyClient = t), (this.serverApiClient = r), (this.context = s), (this.inviteGetter = a);
        }
        async execute(e) {
          const {
              body: { itemGroupId: t }
            } = e,
            {
              queries: { carbonState: r },
              commands: { carbonLegacyLeeloo: s }
            } = this.carbonLegacyClient,
            a = this.inviteGetter.get().pipe(
              (0, x.Qn)((e) => {
                const r = e.pendingItemGroups.find((e) => e.itemGroupId === t);
                if (!r) throw new Error(`Pending item group not found for id ${t}`);
                if (r.items.length < 1) throw new Error(`Missing item content for pending item group with id ${t}`);
                return r.items[0];
              })
            ),
            n = await (0, O.z)(a);
          if ((0, p.hx)(n)) throw new Error(`Failed to retrieve item content for pending item group with id ${t}`);
          const i = n.data,
            o = r({ path: "userSession.sharingData" })
              .pipe(
                (0, x.Qn)((e) => {
                  if (!ee(e)) throw new Error("Bad sharingData");
                  return e;
                })
              )
              .pipe(
                (0, x.lk)((e) => {
                  const r = e.itemGroups.find(({ groupId: e }) => e === t);
                  return (0, p.Vp)(r);
                })
              ),
            c = await (0, O.z)(o);
          if ((0, p.hx)(c)) throw new Error(`Failed to retrieve item group for pending item group with id ${t}`);
          if (void 0 === c.data) return (0, p.Rn)(new J.fL());
          const u = r({ path: "userSession.localSettings.premiumStatus" }).pipe(
              (0, x.Qn)((e) => ((e) => (e.spaces ?? []).filter((e) => "accepted" === e.status))(e)[0])
            ),
            d = await (0, O.z)(u),
            { userFeatureFlips: l } = this.client.getClient(Y.cV).queries,
            h = await (0, O.z)(l());
          if ((0, p.hx)(h)) throw new Error("Failed to retrieve user features");
          const m =
            h.data.audit_logs_sharing && h.data.send_activity_log && (0, p.d6)(d)
              ? ((e, t) => {
                  const r = (!!t?.SpaceId && e?.info.collectSensitiveDataAuditLogsEnabled) ?? !1,
                    s = t && (0, P.isCredential)(t),
                    a = s ? new Z.Y(t.Url).getRootDomain() : "";
                  return r ? { captureLog: r, domain: s ? a || "" : void 0, type: s ? "AUTHENTIFIANT" : "SECURENOTE" } : void 0;
                })(d.data, i)
              : void 0;
          return (0, O.z)(
            this.serverApiClient.v1.sharingUserdevice
              .refuseItemGroup({
                groupId: c.data.groupId,
                revision: c.data.revision,
                itemsForEmailing: [((y = i), { type: (0, P.isCredential)(y) ? "password" : "note", name: y.Title })],
                auditLogDetails: m
              })
              .pipe(
                (0, x.DZ)((e) => {
                  if ("BusinessError" === e.tag) return (0, J.fr)(e.code);
                  throw new Error(e.message);
                }),
                (0, x.lk)((e) => {
                  if (void 0 === e.data.itemGroupErrors || 0 === e.data.itemGroupErrors.length) return (0, p.Vp)(void 0);
                  if (e.data.itemGroupErrors.length > 0)
                    throw new Error(`Error for item group ${e.data.itemGroupErrors[0].groupId}: ${e.data.itemGroupErrors[0].message}`);
                  throw new Error("Unknown server error");
                }),
                (0, $.b)(async (e) => {
                  (0, p.d6)(e) && (await s({ name: "sessionForceSync", arg: [{ trigger: X.Trigger.Sharing }] }));
                })
              )
          );
          var y;
        }
        getCurrentUserLogin() {
          return this.context.get(d.l.UserName);
        }
      };
      te = (0, s.__decorate)([(0, N.W)(J.gm), (0, s.__metadata)("design:paramtypes", [Q.w, P.CarbonLegacyClient, k.l, d.f, m.V])], te);
      var re = r(84009);
      let se = class {
        constructor(e, t) {
          (this.carbonLegacyClient = e), (this.serverApiClient = t);
        }
        async execute(e) {
          const {
              body: { userGroupId: t }
            } = e,
            {
              queries: { carbonState: r },
              commands: { carbonLegacyLeeloo: s }
            } = this.carbonLegacyClient,
            a = r({ path: "userSession.sharingData" })
              .pipe(
                (0, x.Qn)((e) => {
                  if (!ee(e)) throw new Error("Bad sharingData");
                  return e;
                })
              )
              .pipe(
                (0, x.Qn)((e) => {
                  const r = e.userGroups.find(({ groupId: e }) => e === t);
                  if (!r) throw new Error("Could not find userGroup");
                  return r;
                })
              ),
            n = await (0, O.z)(a);
          if ((0, p.hx)(n)) throw new Error(`Failed to retrieve user group for pending user group with id ${t}`);
          return await (0, O.z)(
            this.serverApiClient.v1.sharingUserdevice
              .refuseUserGroup({ groupId: n.data.groupId, revision: n.data.revision, provisioningMethod: M.ET.USER })
              .pipe(
                (0, x.DZ)((e) => {
                  if ("BusinessError" === e.tag) return (0, re.cz)(e.code);
                  throw new Error(e.message);
                }),
                (0, x.lk)((e) => {
                  if (void 0 === e.data.userGroupErrors || 0 === e.data.userGroupErrors.length) return (0, p.Vp)(void 0);
                  if (e.data.userGroupErrors.length > 0)
                    throw new Error(`Error for user group ${e.data.userGroupErrors[0].groupId}: ${e.data.userGroupErrors[0].message}`);
                  throw new Error("Unknown server error");
                }),
                (0, $.b)(async (e) => {
                  (0, p.d6)(e) && (await s({ name: "sessionForceSync", arg: [{ trigger: X.Trigger.Sharing }] }));
                })
              )
          );
        }
      };
      se = (0, s.__decorate)([(0, N.W)(re.Fo), (0, s.__metadata)("design:paramtypes", [P.CarbonLegacyClient, k.l])], se);
      var ae = r(79517);
      let ne = class {
        constructor(e, t) {
          (this.store = e), (this.context = t);
        }
        execute({ body: e }) {
          const t = e,
            r = this.getCurrentUserLogin(),
            s = t.filter((e) => (e.users || []).some((e) => e.login === r && e.status === w.qb.Pending));
          return this.store.set({ pendingCollections: s }), Promise.resolve((0, p.Vp)(void 0));
        }
        getCurrentUserLogin() {
          return this.context.get(d.l.UserName);
        }
      };
      ne = (0, s.__decorate)([(0, N.W)(ae.r), (0, s.__metadata)("design:paramtypes", [_, d.f])], ne);
      var ie = r(28845),
        oe = r(36458),
        ce = r(71419),
        ue = r(10647);
      let de = class {};
      de = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.t,
            stores: [_, oe.S],
            handlers: {
              commands: {
                acceptCollectionInvite: B,
                refuseCollectionInvite: H,
                refuseItemGroupInvite: te,
                refuseUserGroupInvite: se,
                updatePendingCollections: ne
              },
              events: {},
              queries: { getInvites: A, getPendingCollections: R, hasInvites: F }
            },
            imports: [i.n, o.D, ie.k, ce.I, ue.y],
            requiredFeatureFlips: ["audit_logs_sharing", "sharing_web_collectionsSharing", "send_activity_log"],
            providers: []
          })
        ],
        de
      );
    },
    44862: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => D });
      var s = r(88802),
        a = r(99634),
        n = r(1824),
        i = r(48958),
        o = r(20754),
        c = r(31485),
        u = r(61501),
        d = r(48844);
      let l = class {
        constructor(e) {
          this.serverApiClient = e;
        }
        execute() {
          return this.serverApiClient.v1.sharingUserdevice.getTeamLogins().pipe(
            (0, d.Qn)((e) => ({ userLogins: e.data.teamLogins })),
            (0, d.DZ)((e) => {
              throw e;
            })
          );
        }
      };
      l = (0, s.__decorate)([(0, o.e)(c.G), (0, s.__metadata)("design:paramtypes", [u.l])], l);
      var p = r(54003),
        h = r(72614);
      let m = class {
        constructor(e) {
          this.currentSpaceGetter = e;
        }
        execute() {
          return this.currentSpaceGetter.get().pipe((0, d.Qn)((e) => e.isSharingEnabled));
        }
      };
      m = (0, s.__decorate)([(0, o.e)(p.N), (0, s.__metadata)("design:paramtypes", [h.n])], m);
      var y = r(54326),
        g = r(89560);
      let v = class {
        constructor(e) {
          this.itemGroupsGetter = e;
        }
        execute({ body: e }) {
          const { itemId: t } = e;
          return this.itemGroupsGetter
            .getForItemId(t)
            .pipe((0, d.Qn)((e) => ({ itemGroupId: e?.groupId, collectionIds: e?.collections?.map((e) => e.uuid) ?? [] })));
        }
      };
      v = (0, s.__decorate)([(0, o.e)(y.i), (0, s.__metadata)("design:paramtypes", [g.E])], v);
      var f = r(53576),
        w = r(20920),
        S = r(7165);
      const E = S.z.object({ itemGroups: S.z.array(S.z.object({ groupId: S.z.string() })) }),
        _ = (e) => E.safeParse(e).success;
      let b = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        execute({ body: e }) {
          const {
              queries: { carbonState: t }
            } = this.carbonLegacyClient,
            { itemId: r } = e;
          return t({ path: "userSession.sharingData" }).pipe(
            (0, d.Qn)((e) => {
              if (!_(e)) throw new Error("Incorrect type");
              const t = e.itemGroups.find((e) => e.items?.some((e) => e.itemId === r));
              return { isShared: !!t?.groupId };
            })
          );
        }
      };
      b = (0, s.__decorate)([(0, o.e)(w.S), (0, s.__metadata)("design:paramtypes", [f.CarbonLegacyClient])], b);
      var T = r(87065),
        A = r(61076),
        C = r(87279),
        R = r(4975);
      var I;
      !(function (e) {
        (e.Admin = "admin"), (e.Limited = "limited");
      })(I || (I = {}));
      let x = class {
        constructor(e) {
          (this.carbonLegacyClient = e),
            (this.getUserLogin = () => {
              const {
                queries: { carbonState: e }
              } = this.carbonLegacyClient;
              return e({ path: "state.userSession.account.login" }).pipe(
                (0, T.U)((e) => {
                  if ((0, C.d6)(e) && "string" == typeof e.data) return e.data;
                  throw new Error("No active login");
                })
              );
            });
        }
        execute({ body: e }) {
          const {
              queries: { carbonState: t }
            } = this.carbonLegacyClient,
            { itemId: r } = e;
          return t({ path: "userSession.sharingData" }).pipe(
            (0, A.V)(this.getUserLogin()),
            (0, T.U)(([e, t]) => {
              if (!(0, C.d6)(e) || !_(e.data)) throw new Error("Incorrect type");
              const s = e.data.itemGroups.find((e) => e.items?.some((e) => e.itemId === r));
              if (!s?.groupId) return (0, C.Vp)({ permission: void 0 });
              const a = ((e, t, r) => {
                const { collections: s, itemGroups: a } = e,
                  n = e.userGroups.filter((e) => e.users.some((e) => e.userId === t && "accepted" === e.status)),
                  i = new Set(n.map((e) => e.groupId)),
                  o = (c = a) && c.length > 0 ? c.reduce((e, t) => ({ ...e, [t.groupId]: t }), {}) : {};
                var c;
                const u = s.filter(
                    (e) =>
                      (e.users ?? []).some((e) => e.login === t && "accepted" === e.status) ||
                      (e.userGroups ?? []).some((e) => i.has(e.uuid) && "accepted" === e.status)
                  ),
                  d = new Set(u.map((e) => e.uuid));
                return e.itemGroups.some((e) => {
                  const s = e.items?.some((e) => e.itemId === r);
                  if (s) {
                    const r = e.users?.some((e) => e.userId === t && "admin" === e.permission && "accepted" === e.status),
                      s = e.groups?.some((e) => i.has(e.groupId) && "admin" === e.permission && "accepted" === e.status),
                      a = o[e.groupId].collections?.some((e) => d.has(e.uuid) && "admin" === e.permission && "accepted" === e.status);
                    return !(r || s || a);
                  }
                  return !1;
                });
              })(e.data, t, r)
                ? I.Limited
                : I.Admin;
              return (0, C.Vp)({ permission: a });
            })
          );
        }
      };
      x = (0, s.__decorate)([(0, o.e)(R.C), (0, s.__metadata)("design:paramtypes", [f.CarbonLegacyClient])], x);
      var P = r(10647);
      let D = class {};
      D = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: i.X,
            providers: [],
            handlers: {
              commands: {},
              events: {},
              queries: {
                getSharingTeamLogins: l,
                sharingEnabled: m,
                getItemGroupForItem: v,
                getSharingStatusForItem: b,
                getPermissionForItem: x
              }
            },
            imports: [n.n, P.y]
          })
        ],
        D
      );
    },
    40896: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => a });
      var s = r(69183);
      const a = () => `{${(0, s.Z)().toUpperCase()}}`;
    },
    77007: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => s });
      const s = (0, r(86952).Q)({ name: "enclaveSdkApi", commands: {}, events: {}, queries: {} });
    },
    64483: (e, t, r) => {
      "use strict";
      r.d(t, { m: () => c });
      var s = r(86952),
        a = r(15181),
        n = r(75437),
        i = r(49540),
        o = r(76264);
      const c = (0, s.Q)({
        name: "scim",
        commands: { updateScimConfiguration: a.G, generateScimToken: n.S },
        events: {},
        queries: { scimConfiguration: i.I, scimEndpoint: o.v }
      });
    },
    75437: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    15181: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    49540: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    76264: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    95082: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => g });
      var s = r(86952),
        a = r(85355),
        n = r(26758),
        i = r(2073),
        o = r(41689),
        c = r(39118),
        u = r(80974),
        d = r(94603),
        l = r(50179),
        p = r(74746),
        h = r(82249),
        m = r(66012),
        y = r(1434);
      const g = (0, s.Q)({
        name: "confidentialSSOApi",
        commands: {
          CheckDNSValidationCommand: a.o,
          ClearSettingsCommand: n.h,
          CreateTeamCommand: i.p,
          DeleteDomainCommand: o.k,
          EnableSsoCommand: c.F,
          InitSsoProvisioningCommand: u.S,
          LoginUserWithEnclaveSSOCommand: d.B,
          ProvisionDomainCommand: l.p,
          TestLoginUserWithEnclaveSSOCommand: p.b,
          UpdateMetadataCommand: h.o,
          ValidateMetadataCommand: m.l
        },
        events: {},
        queries: { SsoProvisioningQuery: y._ }
      });
    },
    85355: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    26758: (e, t, r) => {
      "use strict";
      r.d(t, { h: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    2073: (e, t, r) => {
      "use strict";
      r.d(t, { p: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    41689: (e, t, r) => {
      "use strict";
      r.d(t, { k: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    39118: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    80974: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    94603: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.Device }) {}
    },
    50179: (e, t, r) => {
      "use strict";
      r.d(t, { p: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    74746: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    82249: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    66012: (e, t, r) => {
      "use strict";
      r.d(t, { l: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    1434: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    36577: (e, t, r) => {
      "use strict";
      r.d(t, { $m: () => o, Ep: () => i, N6: () => n, xp: () => a });
      const s = ["local", "staging", "prod"];
      function a(e) {
        return s.includes(e);
      }
      class n {
        constructor(e, t, r) {
          (this.cloudflareHeaders = e), (this.enclaveUrl = t), (this.environment = r);
        }
      }
      const i = (e) =>
          "local" === e
            ? "MIICqzCCAjKgAwIBAgIUGdKnU0kGWeXtXL7BK1VpIbnjXZkwCgYIKoZIzj0EAwMwgYQxCzAJBgNVBAYTAkZSMQ8wDQYDVQQIDAZGcmFuY2UxDjAMBgNVBAcMBVBhcmlzMQswCQYDVQQKDAJETDELMAkGA1UECwwCREwxFjAUBgNVBAMMDU5pdHJvIFRlc3QgQ0ExIjAgBgkqhkiG9w0BCQEWE3NlcnZlckBkYXNobGFuZS5jb20wHhcNMjIwNDI3MTI0NTQ5WhcNNDIwNDIyMTI0NTQ5WjCBhDELMAkGA1UEBhMCRlIxDzANBgNVBAgMBkZyYW5jZTEOMAwGA1UEBwwFUGFyaXMxCzAJBgNVBAoMAkRMMQswCQYDVQQLDAJETDEWMBQGA1UEAwwNTml0cm8gVGVzdCBDQTEiMCAGCSqGSIb3DQEJARYTc2VydmVyQGRhc2hsYW5lLmNvbTB2MBAGByqGSM49AgEGBSuBBAAiA2IABLeu4raurW6XA9/c13rzPwzbk1aYAR/fPj49YoaZI+K0PFfo75rKUr0m7LawW/jpwkAqWad44SXxj2fF+REDz4ii8tUjVl8Ijp1ohrQEAvDZLcxS98bQV+NFmoyx6QxbQKNjMGEwHQYDVR0OBBYEFM5p3QEkzjDGWRntWRdqC0aWiGiaMB8GA1UdIwQYMBaAFM5p3QEkzjDGWRntWRdqC0aWiGiaMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMAoGCCqGSM49BAMDA2cAMGQCMGdird9+5r9vw9vt2x4q86nMJwu2eGXbcOE6sVRSQ92nWYHk2VX2NZix1tBX3nMGiQIwRHALNGgnkUofNBOoxZ/Pntk14Djv5Kt3/fKd6NWFRhyFZ97jho4c+slS7u9LrttE"
            : "MIICETCCAZagAwIBAgIRAPkxdWgbkK/hHUbMtOTn+FYwCgYIKoZIzj0EAwMwSTELMAkGA1UEBhMCVVMxDzANBgNVBAoMBkFtYXpvbjEMMAoGA1UECwwDQVdTMRswGQYDVQQDDBJhd3Mubml0cm8tZW5jbGF2ZXMwHhcNMTkxMDI4MTMyODA1WhcNNDkxMDI4MTQyODA1WjBJMQswCQYDVQQGEwJVUzEPMA0GA1UECgwGQW1hem9uMQwwCgYDVQQLDANBV1MxGzAZBgNVBAMMEmF3cy5uaXRyby1lbmNsYXZlczB2MBAGByqGSM49AgEGBSuBBAAiA2IABPwCVOumCMHzaHDimtqQvkY4MpJzbolL//Zy2YlES1BR5TSksfbb48C8WBoyt7F2Bw7eEtaaP+ohG2bnUs990d0JX28TcPQXCEPZ3BABIeTPYwEoCWZEh8l5YoQwTcU/9KNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUkCW1DdkFR+eWw5b6cp3PmanfS5YwDgYDVR0PAQH/BAQDAgGGMAoGCCqGSM49BAMDA2kAMGYCMQCjfy+Rocm9Xue4YnwWmNJVA44fA0P5W2OpYow9OYCVRaEevL8uO1XYru5xtMPWrfMCMQCi85sWBbJwKKXdS6BptQFuZbT73o/gBh1qUxl/nNr12UO8Yfwr6wPLb+6NIwLz3/Y=",
        o = (e) =>
          "local" === e
            ? { 0: "9e33eca6497ec3b68ae13735cd28b1a9be1235d3440f10121327150495de4a4f854eb902a62991b366757f3d87ce57e4" }
            : "staging" === e
            ? { 3: "90528150e0f0537fa9e96b067137f6494d525f2fcfd15b478ce28ab2cfaf38dd4e24ad73f9d9d6f238a7f39f2d1956b7" }
            : {
                3: "dfb6428f132530b8c021bea8cbdba2c87c96308ba7e81c7aff0655ec71228122a9297fd31fe5db7927a7322e396e4c16",
                8: "4dbb92401207e019e132d86677857081d8e4d21f946f3561b264b7389c6982d3a86bcf9560cef4a2327eac5c5c6ab820"
              };
    },
    57318: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => d });
      var s = r(88802),
        a = r(99634),
        n = r(25504),
        i = r(77007),
        o = r(15203),
        c = r(36577),
        u = r(44985);
      let d = class {};
      d = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: i.S,
            imports: [n.X, u.i],
            providers: [o.d],
            exports: [o.d],
            configurations: { enclaveApiSettings: { token: c.N6 } },
            handlers: { commands: {}, events: {}, queries: {} }
          })
        ],
        d
      );
    },
    15203: (e, t, r) => {
      "use strict";
      r.d(t, { d: () => O });
      var s = r(88802),
        a = r(57924),
        n = r(73774),
        i = r(58895),
        o = r(36577),
        c = r(56695),
        u = r(839);
      var d = r(60399),
        l = r(87279),
        p = r(7165);
      const h = (e) => {
          const t = e.match(/[\da-f]{2}/gi);
          return t ? new Uint8Array(t.map((e) => parseInt(e, 16))).buffer : new Uint8Array().buffer;
        },
        m = p.z.object({ data: p.z.object({ attestation: p.z.string(), clientIdentifier: p.z.string() }), requestId: p.z.string() });
      class y {
        decode(e) {
          const t = m.safeParse(e);
          if (!t.success) throw new Error("Invalid response format");
          return { attestation: h(t.data.data.attestation), clientIdentifier: t.data.data.clientIdentifier };
        }
      }
      const g = async (e, t) => {
        const { headers: r, httpClient: s, publicKey: a } = t,
          n = await (async (e) => (await c.ready, { clientPublicKey: c.to_hex(e) }))(a),
          i = await (0, d.z)(
            s.post(e, n, { observe: "body", responseType: "json", responseBodyDecoder: new y(), withCredentials: !0, headers: r })
          );
        if ((0, l.hx)(i)) throw new Error("string" == typeof i.error ? i.error : "HTTP Error");
        return i.data;
      };
      var v = r(73155);
      const f = p.z.object({
        requestId: p.z.string(),
        errors: p.z.array(p.z.object({ status: p.z.string(), code: p.z.string(), message: p.z.string() }))
      });
      class w {
        assertData(e) {
          if (!e) throw new Error("toDecode expected to be truthy");
          if ("[object Object]" != `${e}` || Array.isArray(e)) throw new Error("toDecode expected to be object");
          if (!Object.prototype.hasOwnProperty.call(e, "data")) throw new Error('toDecode expected to contain a "data" property');
          const t = e;
          if ("string" != typeof t.data) throw new Error("toDecode.data expected to be type string but was " + typeof t.data);
        }
        decode(e) {
          return this.assertData(e), e.data;
        }
      }
      var S = r(76465);
      function E(e) {
        return (0, S.Jx)(new Uint8Array(e));
      }
      const _ = (e) => {
        const t = E(new Uint8Array(e)),
          r = ((s = t), Array.isArray(s) ? s : s.value);
        var s;
        const [a, , n, i] = r;
        if (!a) throw new Error("parseSignedMessage: no protected header field");
        if (!n) throw new Error("parseSignedMessage: no payload field");
        if (!i) throw new Error("parseSignedMessage: no signature field");
        return { payload: new Uint8Array(n).buffer, protectedHeaders: new Uint8Array(a).buffer, signature: new Uint8Array(i).buffer };
      };
      var b = r(89685),
        T = r(66122);
      const A = p.z.object({
          module_id: p.z.string(),
          timestamp: p.z.bigint(),
          digest: p.z.string(),
          pcrs: p.z.record(p.z.string(), p.z.instanceof(Uint8Array)),
          certificate: p.z.instanceof(Uint8Array),
          cabundle: p.z.array(p.z.instanceof(Uint8Array)),
          user_data: p.z.instanceof(Uint8Array),
          nonce: p.z.instanceof(Uint8Array).nullable()
        }),
        C = p.z.object({ header: p.z.string(), publicKey: p.z.string() });
      var R = r(71833);
      const I = async (e, t, r, s) => {
        const a = R.KBB.fromBER(s),
          n = await a.getPublicKey(),
          i = ["Signature1", t, new ArrayBuffer(0), r],
          o = ((c = i), (0, S.cv)(c));
        var c;
        return await crypto.subtle.verify({ name: "ECDSA", hash: "SHA-384" }, n, e, o);
      };
      var x = r(96303);
      const P = (e) => (0, x.k)(((e) => new Uint8Array(e).buffer)(e)),
        D = async (e) => {
          const { attestation: t, rootCertBER: r, expectedPCRs: s } = e,
            { protectedHeaders: a, payload: n, signature: i } = _(t),
            o = ((e) => {
              const t = E(e),
                r = A.safeParse(t);
              if (!r.success) throw new Error("failed to parse attestation document");
              const s = r.data,
                a = (0, b.v)(s.user_data),
                n = JSON.parse(a),
                i = C.safeParse(n);
              if (!i.success) throw new Error("failed to parse server crypto info");
              const o = i.data;
              return {
                moduleId: s.module_id,
                timestamp: s.timestamp,
                digest: s.digest,
                pcrs: s.pcrs,
                certificate: new Uint8Array(s.certificate).buffer,
                cabundle: ((c = s.cabundle), c.map((e) => new Uint8Array(e).buffer)),
                serverHeader: (0, T.R)(o.header),
                serverPublicKey: (0, T.R)(o.publicKey),
                nonce: null !== s.nonce ? new Uint8Array(s.nonce).buffer : null
              };
              var c;
            })(n),
            c = await (async (e, t, r) => {
              const s = R.KBB.fromBER(e),
                a = t.map((e) => R.KBB.fromBER(e));
              a.push(s);
              const n = [R.KBB.fromBER((0, T.R)(r))],
                i = new R.DMg({ trustedCerts: n, certs: a });
              return (await i.verify()).result;
            })(o.certificate, o.cabundle, r);
          if (!c) throw new Error("Invalid cert chain!");
          if (!(await I(i, a, n, o.certificate))) throw new Error("Invalid signature!");
          return (
            ((e, t) => {
              for (const [r, s] of Object.entries(t)) if (s !== P(e[Number(r)])) throw new Error("PCRs did not match");
            })(o.pcrs, s),
            { serverPublicKey: o.serverPublicKey, serverHeader: o.serverHeader }
          );
        };
      var U;
      !(function (e) {
        (e.CLIENT_HELLO = "api/tunnel/ClientHello"), (e.TERMINATE_HELLO = "api/tunnel/TerminateHello");
      })(U || (U = {}));
      const F = async (e, t) => {
        await c.ready;
        const {
            enclaveApiSettings: { cloudflareHeaders: r, enclaveUrl: s },
            rootCertBER: a,
            expectedPCRs: n,
            httpClient: i,
            platformInfo: o,
            data: p
          } = t,
          h = {};
        (h["dashlane-client-agent"] = JSON.stringify({ platform: o.platformName, osversion: o.osVersion, version: o.appVersion })),
          r.accessKey && r.secretKey && ((h["CF-Access-Client-Id"] = r.accessKey), (h["CF-Access-Client-Secret"] = r.secretKey));
        const m = c.crypto_kx_keypair(),
          {
            clientHelloUrl: y,
            terminateHelloUrl: S,
            secureContentUrl: E
          } = ((e, t) => ({
            clientHelloUrl: `${e}${U.CLIENT_HELLO}`,
            terminateHelloUrl: `${e}${U.TERMINATE_HELLO}`,
            secureContentUrl: `${e}${t}`
          }))(s, e),
          _ = await g(y, { headers: h, httpClient: i, publicKey: m.publicKey }),
          { serverPublicKey: b, serverHeader: T } = await D({ attestation: _.attestation, rootCertBER: a, expectedPCRs: n });
        var A;
        (A = {
          url: s,
          name: "ClientIdentifier",
          value: _.clientIdentifier,
          expirationDate: new Date().getTime() + 15e5,
          sameSite: "strict",
          secure: !0
        }),
          new Promise((e, t) => {
            (0, u.qX)(["cookies"])
              ? (0, u.Ez)("cookies.set")
                ? chrome.cookies.set(A, (r) => {
                    if (chrome.runtime.lastError) {
                      const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                        r = new Error(`cookies/set: ${e}`);
                      t(r);
                    } else e(r);
                  })
                : t(new Error("No cookies.set support"))
              : t(new Error("No cookies.set support, permission is missing"));
          });
        const C = await (async (e, t) => {
          const { headers: r, clientKeyPair: s, httpClient: a, serverPublicKey: n } = t;
          await c.ready;
          const i = c.crypto_kx_client_session_keys(s.publicKey, s.privateKey, new Uint8Array(n)),
            o = c.crypto_secretstream_xchacha20poly1305_init_push(i.sharedRx),
            u = o.state,
            p = o.header,
            h = { clientHeader: c.to_hex(p) },
            m = await (0, d.z)(a.post(e, h, { observe: "response", responseType: "json", withCredentials: !0, headers: r }));
          if ((0, l.hx)(m)) throw new Error("HTTP error");
          return { clientStateOut: u, sessionKeys: i };
        })(S, { headers: h, httpClient: i, clientKeyPair: m, serverPublicKey: b });
        return await (async (e, t) => {
          const { clientStateOut: r, serverHeader: s, sessionKeys: a, headers: n, httpClient: i } = t;
          await c.ready;
          const o = c.crypto_secretstream_xchacha20poly1305_push(
              r,
              c.from_string(t.data),
              null,
              c.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE
            ),
            u = { data: c.to_hex(o) },
            p = await (0, d.z)(
              i.post(e, u, { observe: "body", responseType: "json", responseBodyDecoder: new w(), withCredentials: !0, headers: n })
            );
          if ((0, l.hx)(p)) {
            if (p.error instanceof v.R) {
              const e = await JSON.parse(await p.error.response.text()),
                t = f.safeParse(e);
              if (t.success) {
                const e = t.data.errors[0];
                throw new Error(e.code);
              }
            }
            throw new Error("HTTP error");
          }
          const h = c.crypto_secretstream_xchacha20poly1305_init_pull(new Uint8Array(s), a.sharedTx),
            m = c.crypto_secretstream_xchacha20poly1305_pull(h, c.from_hex(p.data)).message;
          return { decryptedResponse: c.to_string(m) };
        })(E, { data: p, headers: h, httpClient: i, clientStateOut: C.clientStateOut, sessionKeys: C.sessionKeys, serverHeader: T });
      };
      let O = class {
        constructor(e, t, r) {
          (this.platformInfoService = e), (this.httpClient = t), (this.enclaveApiSettings = r);
        }
        async callEnclaveEndpoint(e) {
          const { body: t, endpoint: r, responseSchema: s } = e,
            a = JSON.stringify(t),
            n = await this.platformInfoService.getPlatformInfo(),
            i = (0, o.Ep)(this.enclaveApiSettings.environment),
            c = (0, o.$m)(this.enclaveApiSettings.environment),
            { decryptedResponse: u } = await F(r, {
              data: a,
              httpClient: this.httpClient,
              enclaveApiSettings: this.enclaveApiSettings,
              rootCertBER: i,
              expectedPCRs: c,
              platformInfo: n
            }),
            d = s.safeParse(JSON.parse(u));
          if (d.success) return d.data;
          throw new Error("Enclave response parsing failed");
        }
        getEnclaveApiSettings() {
          return this.enclaveApiSettings;
        }
      };
      O = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [i.t, n.e, o.N6])], O);
    },
    97386: (e, t, r) => {
      "use strict";
      r.d(t, { i: () => H });
      var s = r(88802),
        a = r(99634),
        n = r(37935),
        i = r(64483),
        o = r(25029),
        c = r(7165);
      const u = c.z.object({ token: c.z.string(), active: c.z.boolean() }).optional();
      var d = r(95681),
        l = r(23347);
      const p = (e) => u.safeParse(e).success;
      class h extends (0, d.Q)({
        persist: !1,
        capacity: l.Y._001KB,
        initialValue: undefined,
        scope: o.F.User,
        storeName: "confidential-scim-state",
        storeTypeGuard: p
      }) {}
      var m = r(63663),
        y = r(87279),
        g = r(15181),
        v = r(57924),
        f = r(15203),
        w = r(42645),
        S = r(53576),
        E = r(60399),
        _ = r(33229),
        b = r(13878);
      const T = "api/scim/GetSCIMConfiguration",
        A = "api/scim/SetSCIMConfiguration",
        C = c.z.object({ token: c.z.string().nullable(), active: c.z.boolean() }),
        R = c.z.object({ token: c.z.string(), active: c.z.boolean() });
      let I = class {
        constructor(e, t, r) {
          (this.enclaveService = e), (this.teamPlansClient = t), (this.carbonClient = r);
        }
        async getConfidentialScimConfig() {
          const e = { token: "", active: !1 },
            { teamUuid: t, adminProvisioningKey: r } = await this.getTeamIdentifiers(),
            s = await this.enclaveService.callEnclaveEndpoint({
              endpoint: T,
              body: { teamUuid: t, adminProvisioningKey: r },
              responseSchema: C
            });
          return (e.active = s.active), (e.token = s.token ?? ""), e;
        }
        async setConfidentialScimConfig(e) {
          const { teamUuid: t, adminProvisioningKey: r } = await this.getTeamIdentifiers();
          await this.enclaveService.callEnclaveEndpoint({
            endpoint: A,
            body: { teamUuid: t, adminProvisioningKey: r, ...e },
            responseSchema: R
          });
        }
        async getTeamIdentifiers() {
          const e = await (0, E.z)(this.teamPlansClient.queries.getTeamId());
          if ((0, y.hx)(e)) throw new Error("Could not get teamId");
          const t = await (0, _.I)(this.carbonClient.commands.carbon);
          if ((0, y.hx)(t)) throw new Error("Could not get team info");
          const {
            teamInfo: { uuid: r }
          } = t.data;
          if (!r) throw new Error("No team uuid found. Is confidential team created?");
          const s = e.data.teamId ?? "",
            a = await (0, b.B)(s, this.carbonClient.queries.carbonState);
          if (!a) throw new Error("No admin provisioning key found. Is confidential team created?");
          return { teamUuid: r, adminProvisioningKey: a };
        }
      };
      I = (0, s.__decorate)([(0, v.GS)(), (0, s.__metadata)("design:paramtypes", [f.d, w.e, S.CarbonLegacyClient])], I);
      let x = class {
        constructor(e, t) {
          (this.confidentialScimService = e), (this.confidentialScimStore = t);
        }
        async execute({ body: e }) {
          const t = await this.confidentialScimStore.getState();
          try {
            const r = { token: e.token ?? (t?.token || ""), active: e.active ?? !!t?.active };
            return (
              await this.confidentialScimStore.set({ ...r }),
              await this.confidentialScimService.setConfidentialScimConfig({ ...t, ...e }),
              (0, y.Vp)(void 0)
            );
          } catch (e) {
            return await this.confidentialScimStore.set(t), (0, y.Rn)({ tag: e.message });
          }
        }
      };
      x = (0, s.__decorate)([(0, m.W)(g.G), (0, s.__metadata)("design:paramtypes", [I, h])], x);
      var P = r(19603),
        D = r(75437),
        U = r(67837),
        F = r(95082);
      class O extends (0, U.E)(F.y) {}
      (0, U.K)(F.y, O);
      var N = r(10370);
      let k = class {
        constructor(e, t, r, s, a) {
          (this.randomValuesGetter = e),
            (this.confidentialScimStore = t),
            (this.confidentialScimService = r),
            (this.ssoClient = s),
            (this.teamPlansClient = a);
        }
        async execute() {
          const e = await this.confidentialScimStore.getState(),
            t = await this.hasNitroTeam();
          try {
            t || (await this.createTeam());
            const e = this.randomValuesGetter.get(64),
              r = (0, N.s)(e);
            return (
              await this.confidentialScimStore.set({ token: r, active: !1 }),
              await this.confidentialScimService.setConfidentialScimConfig({ token: r, active: !1 }),
              (0, y.Vp)(void 0)
            );
          } catch (t) {
            return this.confidentialScimStore.set(e), (0, y.Rn)({ tag: `Something wrong happened: ${t}` });
          }
        }
        async createTeam() {
          const e = await (0, E.z)(this.teamPlansClient.queries.getTeamId());
          if ((0, y.hx)(e)) throw new Error("TeamID not found, are you logged in?");
          await this.ssoClient.commands.initSsoProvisioning({ teamId: `${e.data.teamId}` }), await this.ssoClient.commands.createTeam();
        }
        async hasNitroTeam() {
          try {
            return !!(await this.confidentialScimService.getTeamIdentifiers()).adminProvisioningKey;
          } catch {
            return !1;
          }
        }
      };
      k = (0, s.__decorate)([(0, m.W)(D.S), (0, s.__metadata)("design:paramtypes", [P.Y, h, I, O, w.e])], k);
      var L = r(43978),
        M = r(20754),
        V = r(49540);
      let G = class {
        constructor(e, t, r) {
          (this.confidentialScimStore = e), (this.scimConfigurationService = t), (this.scimStore = r);
        }
        execute() {
          return this.confidentialScimStore.state$.pipe((0, L.w)(async (e) => (e ? (0, y.Vp)(e) : await this.getInitState())));
        }
        async getInitState() {
          try {
            const e = await this.scimConfigurationService.getConfidentialScimConfig();
            return await this.scimStore.set(e), (0, y.Vp)(e);
          } catch (e) {
            return (0, y.Vp)({ active: !1, token: null });
          }
        }
      };
      G = (0, s.__decorate)([(0, M.e)(V.I), (0, s.__metadata)("design:paramtypes", [h, I, h])], G);
      var j = r(57318),
        q = r(37182),
        K = r(69885),
        W = r(76264),
        B = r(36577);
      let z = class {
        constructor(e, t, r) {
          (this.enclaveApiSettings = e), (this.confidentialScimService = t), (this.confidentialScimStore = r);
        }
        execute() {
          return this.confidentialScimStore.state$.pipe(
            (0, L.w)(async (e) => {
              if (!e?.token) return (0, y.Rn)({ tag: "Could not load team uuid" });
              const t = await this.confidentialScimService.getTeamIdentifiers(),
                r = new URL(`scim/${t.teamUuid}`, this.enclaveApiSettings.enclaveUrl);
              return (0, y.Vp)({ endpoint: r.href });
            }),
            (0, q.K)(() => (0, K.of)((0, y.Rn)({ tag: "Could not load team uuid" })))
          );
        }
      };
      z = (0, s.__decorate)([(0, M.e)(W.v), (0, s.__metadata)("design:paramtypes", [B.N6, I, h])], z);
      let H = class {};
      H = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: i.m,
            imports: [j.E, n.D],
            handlers: {
              commands: { updateScimConfiguration: x, generateScimToken: k },
              events: {},
              queries: { scimConfiguration: G, scimEndpoint: z }
            },
            stores: [h],
            providers: [I]
          })
        ],
        H
      );
    },
    13878: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => o });
      var s = r(7165),
        a = r(60399),
        n = r(48844);
      const i = s.z.object({
          adminProvisioningKey: s.z
            .object({ adminProvisioningKey: s.z.ostring().nullable(), itemId: s.z.ostring().nullable() })
            .optional()
            .nullable()
        }),
        o = async (e, t) => {
          const r = t({ path: `userSession.teamAdminData.teams.${e}` }).pipe(
            (0, n.nb)({
              success: (e) => {
                const t = i.safeParse(e);
                if (!t.success) throw t.error;
                return t.data.adminProvisioningKey?.adminProvisioningKey ?? null;
              },
              failure: () => ""
            })
          );
          return await (0, a.z)(r);
        };
    },
    33229: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => d });
      var s = r(7165),
        a = r(87279),
        n = r(53576);
      const i = s.z.object({ enabled: s.z.boolean() }).optional(),
        o = s.z.object({
          teamInfo: s.z.object({
            uuid: s.z.ostring().nullable(),
            ssoEnabled: s.z.boolean(),
            ssoIsNitroProvider: s.z.boolean(),
            ssoServiceProviderUrl: s.z.ostring().nullable(),
            ssoIdpMetadata: s.z.ostring().nullable(),
            ssoIdpEntrypoint: s.z.ostring().nullable()
          }),
          capabilities: s.z.object({ sso: i })
        }),
        c = s.z.object({ data: o }),
        u = s.z.object({ message: s.z.string(), reason: s.z.nativeEnum(n.AuthenticationCode) }),
        d = async (e) => {
          const t = await e({ name: "getTeamInfo", args: [] });
          if ((0, a.hx)(t)) {
            switch (u.parse(t.error.error).reason) {
              case n.AuthenticationCode.UNAUTHORIZED:
                return (0, a.Rn)({ tag: "UserNotAuthorized" });
              case n.AuthenticationCode.UNKNOWN_ERROR:
                return (0, a.Rn)({ tag: "CouldNotGetTeamStatus" });
              default:
                throw new Error("An unexpected error happened while trying to retrieve team info");
            }
          }
          const {
            data: { teamInfo: r, capabilities: s }
          } = c.parse(t.data.carbonResult);
          return (0, a.Vp)({ teamInfo: r, capabilities: s });
        };
    },
    69031: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => je });
      var s = r(88802),
        a = r(99634),
        n = r(25504),
        i = r(44985),
        o = r(95082),
        c = r(57318);
      class u {}
      var d,
        l = r(63663),
        p = r(87279),
        h = r(94603),
        m = r(7165);
      !(function (e) {
        (e.AUTH_CONFIRM_LOGIN = "api/authentication/ConfirmLogin2"),
          (e.AUTH_REQUEST_LOGIN = "api/authentication/RequestLogin2"),
          (e.AUTH_REQUEST_TEST_LOGIN = "api/authentication/RequestTestLogin2"),
          (e.AUTH_CONFIRM_TEST_LOGIN = "api/authentication/ConfirmTestLogin2"),
          (e.DOMAINS_CREATE_DOMAIN = "api/domains/CreateDomain"),
          (e.DOMAINS_DELETE_DOMAIN = "api/domains/DeleteDomain2"),
          (e.DOMAINS_UPDATE_DOMAIN = "api/domains/UpdateDomain2"),
          (e.DOMAINS_CHECK_DNS_VALIDATION = "api/domains/CheckDNSValidation2"),
          (e.TEAMS_CREATE_TEAM = "api/teams/CreateTeam"),
          (e.TEAMS_GET_TEAM = "api/teams/GetTeam"),
          (e.TEAMS_DELETE_TEAM = "api/teams/DeleteTeam"),
          (e.IDPS_CREATE_IDP = "api/idps/CreateIdp"),
          (e.IDPS_UPDATE_IDP = "api/idps/UpdateIdp"),
          (e.IDPS_DELETE_IDP = "api/idps/DeleteIdp"),
          (e.TEAMS_GET_TEAM_STATUS = "api/teams/GetTeamStatus");
      })(d || (d = {}));
      const y = m.z.object({
          idpAuthorizeUrl: m.z.string(),
          teamUuid: m.z.string(),
          spCallbackUrl: m.z.string(),
          domainName: m.z.string()
        }),
        g = m.z.object({
          exists: m.z.boolean(),
          ssoToken: m.z.string(),
          userServiceProviderKey: m.z.string(),
          currentAuthenticationMethods: m.z.string().array(),
          expectedAuthenticationMethods: m.z.string().array()
        });
      var v = r(53576),
        f = r(15203);
      let w = class {
        constructor(e, t, r) {
          (this.enclaveService = e), (this.enclaveLoginContext = t), (this.carbonLegacyClient = r);
        }
        async execute(e) {
          const t = e.body.userEmailAddress,
            r = t.slice(t.indexOf("@") + 1);
          try {
            const s = await (async (e, t) => await e.callEnclaveEndpoint({ endpoint: d.AUTH_REQUEST_LOGIN, body: t, responseSchema: y }))(
                this.enclaveService,
                { login: t }
              ),
              { idpAuthorizeUrl: a, teamUuid: n } = s,
              { samlToken: i } = await this.enclaveLoginContext.getSamlFromLogin(a, !0),
              o = btoa(atob(i).replace(/\n/g, "")),
              c = {
                ...(await (async (e, t) => await e.callEnclaveEndpoint({ endpoint: d.AUTH_CONFIRM_LOGIN, body: t, responseSchema: g }))(
                  this.enclaveService,
                  { domainName: r, samlResponse: o, teamUuid: n }
                )),
                login: e.body.userEmailAddress
              };
            return await this.enclaveLoginContext.redirectUserIntoLoginFlow(c), (0, p.Vp)(void 0);
          } catch {
            return (0, p.Rn)({ tag: "LoginFailed" });
          }
        }
      };
      w = (0, s.__decorate)([(0, l.W)(h.B), (0, s.__metadata)("design:paramtypes", [f.d, u, v.CarbonLegacyClient])], w);
      var S = r(21242);
      const E = m.z.object({
          idpUuid: m.z.string().uuid(),
          certificates: m.z.array(m.z.string()),
          entrypoint: m.z.string(),
          creationDateUnix: m.z.number(),
          updateDateUnix: m.z.number()
        }),
        _ = m.z.enum(["valid", "pending", "expired", "invalid"]),
        b = m.z.enum(["tokenNotFound", "invalidToken"]),
        T = m.z.object({
          status: _.nullable(),
          verificationToken: m.z.string(),
          lastCheckDateUnix: m.z.number(),
          pendingReason: b.nullable(),
          expiryDateUnix: m.z.number()
        }),
        A = m.z.object({
          creationDateUnix: m.z.number(),
          dnsCheckStatus: T,
          domainName: m.z.string(),
          idpUuid: m.z.ostring(),
          updateDateUnix: m.z.number()
        }),
        C = m.z.enum([
          "NitroComplete",
          "NitroIncomplete",
          "SelfHostedComplete",
          "SelfHostedIncomplete",
          "SsoConnectorIncomplete",
          "SsoConnectorComplete",
          "SsoConnectorToSelfHostedMigration",
          "None",
          "Unknown"
        ]),
        R = m.z.object({
          subdomainValue: m.z.string().nullable(),
          txtValue: m.z.string().nullable(),
          verificationStatus: _.nullable(),
          tokenFound: m.z.string().nullable(),
          pendingReason: b.nullable()
        }),
        I = m.z.array(m.z.object({ domainName: m.z.string().url(), verificationStatus: _, idpUuid: m.z.string().optional().nullable() })),
        x = m.z.object({
          global: m.z.object({
            adminProvisioningKey: m.z.string().nullable(),
            isTeamProvisionedInNitro: m.z.boolean().nullable(),
            inferredSsoState: C,
            teamUuid: m.z.string().nullable(),
            ssoCapable: m.z.boolean().nullable()
          }),
          idpApplication: m.z.object({
            entityId: m.z.string().nullable(),
            acsUrl: m.z.string().nullable(),
            signOnUrl: m.z.string().nullable()
          }),
          idpMetadata: m.z.object({ metadataValue: m.z.string().nullable(), idpUuid: m.z.string().nullable() }),
          domainSetup: I,
          domainVerificationInfo: m.z.record(m.z.string().url(), R),
          enableSSO: m.z.object({ ssoEnabled: m.z.boolean().nullable() })
        });
      var P = r(50179),
        D = r(64718);
      const U = m.z.object({ error: m.z.string() }),
        F = m.z.object({ data: m.z.object({ samlIdpEntryPoint: m.z.string(), samlIdpCertificate: m.z.string() }) }),
        O = async (e, t) => {
          if (null === t) return { samlIdpEntryPoint: "", samlIdpCertificate: "" };
          let r = "";
          if (new D.Y(t).isUrlValid()) {
            const e = await fetch(t);
            r = await e.text();
          } else r = t;
          const s = await e({ name: "parseMetadataFields", args: [{ ssoIdpMetadata: r }] });
          if ((0, p.d6)(s)) return F.parse(s.data.carbonResult).data;
          throw new Error("failed to parse metadata, please validate first.");
        };
      var N = r(57924),
        k = r(25029),
        L = r(95681),
        M = r(23347);
      const V = (e) => x.safeParse(e).success,
        G = {
          global: {
            adminProvisioningKey: null,
            teamUuid: null,
            isTeamProvisionedInNitro: null,
            inferredSsoState: C.enum.Unknown,
            ssoCapable: null
          },
          idpApplication: { entityId: null, acsUrl: null, signOnUrl: null },
          idpMetadata: { metadataValue: null, idpUuid: null },
          domainSetup: [],
          domainVerificationInfo: {},
          enableSSO: { ssoEnabled: null }
        };
      class j extends (0, L.Q)({
        persist: !1,
        capacity: M.Y._010KB,
        initialValue: G,
        scope: k.F.User,
        storeName: "nitro-sso-provisioning-state",
        storeTypeGuard: V
      }) {}
      const q = "_dashlane-challenge";
      let K = class {
        constructor(e) {
          this.store = e;
        }
        async reset() {
          await this.store.init({
            global: {
              adminProvisioningKey: null,
              teamUuid: null,
              isTeamProvisionedInNitro: null,
              inferredSsoState: C.enum.Unknown,
              ssoCapable: null
            },
            idpApplication: { entityId: null, acsUrl: null, signOnUrl: null },
            idpMetadata: { metadataValue: null, idpUuid: null },
            domainSetup: [],
            domainVerificationInfo: {},
            enableSSO: { ssoEnabled: null }
          });
        }
        async update(e, t) {
          const r = await this.store.getState(),
            s = ((e, t) => ({ ...e, ...t }))(r, { [t]: { ...r[t], ...e } });
          await this.store.set(s);
        }
        set(e) {
          return this.store.set(e);
        }
      };
      K = (0, s.__decorate)([(0, N.GS)(), (0, s.__metadata)("design:paramtypes", [j])], K);
      const W = m.z.object({ dnsVerificationToken: m.z.string() });
      let B = class {
        constructor(e, t, r, s, a) {
          (this.enclaveService = e),
            (this.ssoProvisioningStoreUpdater = t),
            (this.ssoProvisioningStore = r),
            (this.featureFlipsClient = s),
            (this.carbonLegacyClient = a);
        }
        async execute({ body: e }) {
          const t = await this.ssoProvisioningStore.getState();
          if (!t.global.teamUuid) return (0, p.Rn)({ tag: "TeamIdNotFound" });
          if (!t.global.adminProvisioningKey) return (0, p.Rn)({ tag: "AdminProvisioningKeyNotFound" });
          if (!e.domainName) return (0, p.Rn)({ tag: "DomainNameNotProvided" });
          const r = t.idpMetadata.metadataValue ? await O(this.carbonLegacyClient.commands.carbon, t.idpMetadata.metadataValue) : null,
            s = {
              domainName: e.domainName,
              adminProvisioningKey: t.global.adminProvisioningKey,
              idpMetadata: r ? { certificate: r.samlIdpCertificate, entrypoint: r.samlIdpEntryPoint } : void 0,
              teamUuid: t.global.teamUuid
            };
          if (new Set(t.domainSetup.map((e) => e.domainName)).has(e.domainName)) return (0, p.Rn)({ tag: "DomainAlreadyProvisioned" });
          const { dnsVerificationToken: a } = await (async (e, t) =>
              await e.callEnclaveEndpoint({ body: t, endpoint: d.DOMAINS_CREATE_DOMAIN, responseSchema: W }))(this.enclaveService, s),
            n = [...t.domainSetup, { idpUuid: t.idpMetadata.idpUuid, domainName: e.domainName, verificationStatus: _.enum.pending }];
          await this.ssoProvisioningStoreUpdater.set({ ...t, domainSetup: n });
          const i = {
            ...t.domainVerificationInfo,
            [e.domainName]: { txtValue: a, verificationStatus: _.enum.pending, subdomainValue: q, pendingReason: null, tokenFound: null }
          };
          return await this.ssoProvisioningStoreUpdater.update(i, "domainVerificationInfo"), (0, p.Vp)(void 0);
        }
      };
      B = (0, s.__decorate)([(0, l.W)(P.p), (0, s.__metadata)("design:paramtypes", [f.d, K, j, S.P, v.CarbonLegacyClient])], B);
      var z = r(2073);
      const H = m.z.object({ data: m.z.object({ deviceAccessKey: m.z.string(), deviceSecretKey: m.z.string() }) }),
        $ = m.z.object({ data: m.z.object({ devicePrivateKey: m.z.string(), devicePublicKey: m.z.string() }) }),
        Q = m.z.object({ adminProvisioningKey: m.z.string() });
      let Y = class {
        constructor(e, t, r, s) {
          (this.enclaveService = e),
            (this.ssoProvisioningStoreUpdater = t),
            (this.ssoProvisioningStore = r),
            (this.carbonClient = s),
            (this.ssoServiceProviderUrl = new URL(this.enclaveService.getEnclaveApiSettings().enclaveUrl).origin);
        }
        async execute() {
          const e = (await this.ssoProvisioningStore.getState()).global.teamUuid;
          if (!e) return (0, p.Rn)({ tag: "TeamIdNotFound" });
          const t = await (async (e) => {
            const t = await e.commands.registerTeamDevice({ platform: v.TeamDevicePlatform.NITRO, deviceName: "Nitro Encryption Service" });
            if ((0, p.hx)(t)) return t;
            const {
                data: { deviceAccessKey: r, deviceSecretKey: s }
              } = H.parse((0, p.db)(t)),
              a = await e.commands.registerTeamDeviceAccount({ deviceAccessKey: r, shouldGenerateDeviceKeyPair: !0 });
            if ((0, p.hx)(a)) return a;
            const {
              data: { devicePrivateKey: n, devicePublicKey: i }
            } = $.parse((0, p.db)(a));
            return (0, p.Vp)({ deviceAccessKey: r, deviceSecretKey: s, devicePrivateKey: n, devicePublicKey: i });
          })(this.carbonClient);
          if ((0, p.hx)(t)) return (0, p.Rn)({ tag: "RegisterTeamDeviceFailed" });
          const { deviceAccessKey: r, devicePublicKey: s, deviceSecretKey: a, devicePrivateKey: n } = (0, p.db)(t);
          await this.carbonClient.commands.updateTeamSettings({ ssoServiceProviderUrl: this.ssoServiceProviderUrl }),
            await this.ssoProvisioningStoreUpdater.update({ inferredSsoState: C.enum.NitroIncomplete }, "global");
          let i = null;
          try {
            if (
              ((i = (
                await (async (e, t) => await e.callEnclaveEndpoint({ endpoint: d.TEAMS_CREATE_TEAM, body: t, responseSchema: Q }))(
                  this.enclaveService,
                  { teamDeviceCredentials: { teamUuid: e, accessKey: r, secretKey: a, sharingPublicKey: s, sharingPrivateKey: n } }
                )
              ).adminProvisioningKey),
              !i)
            )
              return await this.rollBackTeamCreation(r), (0, p.Rn)({ tag: "AdminProvisioningKeyNotFound" });
          } catch (e) {
            return this.rollBackTeamCreation(r);
          }
          return this.persistAdminProvisionningKey(i);
        }
        async persistAdminProvisionningKey(e) {
          return (
            await this.carbonClient.commands.persistAdminProvisioningKey({ adminProvisioningKey: e }),
            await this.ssoProvisioningStoreUpdater.update({ adminProvisioningKey: e, isTeamProvisionedInNitro: !0 }, "global"),
            (0, p.Vp)(void 0)
          );
        }
        async rollBackTeamCreation(e) {
          return (
            await this.carbonClient.commands.updateTeamSettings({ ssoServiceProviderUrl: null }),
            await this.carbonClient.commands.deactivateTeamDevice({ teamDeviceAccessKey: e }),
            await this.ssoProvisioningStoreUpdater.update({ inferredSsoState: C.enum.None }, "global"),
            (0, p.Rn)({ tag: "CreateTeamApiError" })
          );
        }
      };
      Y = (0, s.__decorate)([(0, l.W)(z.p), (0, s.__metadata)("design:paramtypes", [f.d, K, j, v.CarbonLegacyClient])], Y);
      var X = r(41689);
      m.z.object({ domainName: m.z.string(), teamUuid: m.z.string(), adminProvisioningKey: m.z.string() });
      const J = ["DOMAIN_NOT_FOUND", "DOMAIN_CONFIGURATION_NOT_FOUND"];
      let Z = class {
        constructor(e, t, r, s) {
          (this.enclaveService = e), (this.ssoProvisioningStoreUpdater = t), (this.ssoProvisioningStore = r), (this.featureFlipsClient = s);
        }
        async execute({ body: e }) {
          const t = await this.ssoProvisioningStore.getState();
          if (!t.global.teamUuid) return (0, p.Rn)({ tag: "TeamIdNotFound" });
          if (!t.global.adminProvisioningKey) return (0, p.Rn)({ tag: "AdminProvisioningKeyNotFound" });
          if (!e.domainName) return (0, p.Rn)({ tag: "DomainNameNotProvided" });
          const r = { domainName: e.domainName, teamUuid: t.global.teamUuid, adminProvisioningKey: t.global.adminProvisioningKey };
          try {
            await (async (e, t) => {
              await e.callEnclaveEndpoint({ endpoint: d.DOMAINS_DELETE_DOMAIN, body: t, responseSchema: m.z.object({}) });
            })(this.enclaveService, r);
          } catch (e) {
            const t = e instanceof Error ? e.message : "Unable to delete domain.";
            if (!J.includes(t)) throw e;
          }
          return await this.applyDeleteDomainOnState(t, e.domainName), (0, p.Vp)(void 0);
        }
        async applyDeleteDomainOnState(e, t) {
          (e.domainSetup = e.domainSetup.filter((e) => e.domainName !== t)),
            delete e.domainVerificationInfo[t],
            await this.ssoProvisioningStoreUpdater.set(e);
        }
      };
      Z = (0, s.__decorate)([(0, l.W)(X.k), (0, s.__metadata)("design:paramtypes", [f.d, K, j, S.P])], Z);
      var ee = r(58895),
        te = r(74746);
      const re = m.z.object({ idpAuthorizeUrl: m.z.string(), spCallbackUrl: m.z.ostring() });
      var se = r(36577);
      let ae = class {
        constructor(e, t, r, s, a, n) {
          (this.enclaveService = e),
            (this.enclaveLoginContext = t),
            (this.enclaveApiSettings = r),
            (this.platformInfoService = s),
            (this.ssoProvisioningStore = a),
            (this.featureFlips = n);
        }
        async execute(e) {
          const t = await this.ssoProvisioningStore.getState(),
            {
              global: { adminProvisioningKey: r, teamUuid: s },
              idpMetadata: { idpUuid: a }
            } = t,
            n = e.body.domainName;
          if (!(r && n && s && a)) return (0, p.Rn)({ tag: "MissingCommandParameters" });
          try {
            const e = await (async (e, t) =>
                await e.callEnclaveEndpoint({ endpoint: d.AUTH_REQUEST_TEST_LOGIN, body: t, responseSchema: re }))(this.enclaveService, {
                adminProvisioningKey: r,
                teamUuid: s,
                idpUuid: a
              }),
              { samlToken: t } = await this.enclaveLoginContext.getSamlFromLogin(e.idpAuthorizeUrl, !1);
            return (
              await (async (e, t) => {
                await e.callEnclaveEndpoint({ endpoint: d.AUTH_CONFIRM_TEST_LOGIN, body: t, responseSchema: m.z.object({}) });
              })(this.enclaveService, { domainName: n, samlResponse: t, adminProvisioningKey: r, teamUuid: s }),
              await this.enclaveLoginContext.cleanupTestLogin(),
              (0, p.Vp)(void 0)
            );
          } catch {
            return (0, p.Rn)({ tag: "FailedToLoginIntoSsoProvider" });
          }
        }
      };
      ae = (0, s.__decorate)([(0, l.W)(te.b), (0, s.__metadata)("design:paramtypes", [f.d, u, se.N6, ee.t, j, S.P])], ae);
      var ne = r(26457),
        ie = r(65255),
        oe = r(80974);
      const ce = m.z.enum(["sso_connector", "encryption_service", "nitro_encryption_service", "command_line"]),
        ue = [ce.enum.encryption_service, ce.enum.nitro_encryption_service, ce.enum.sso_connector],
        de = m.z.object({
          platform: ce,
          accessKey: m.z.string(),
          deviceName: m.z.string().nullable(),
          activated: m.z.boolean(),
          creationDateUnix: m.z.number(),
          updateDateUnix: m.z.number()
        }),
        le = m.z.object({ data: m.z.object({ teamDevices: m.z.array(de) }) }),
        pe = async (e) => {
          const t = await e({ name: "listTeamDevices", args: [] });
          if ((0, p.hx)(t)) throw new Error("Failed to get team devices");
          const {
              data: { carbonResult: r }
            } = t,
            {
              data: { teamDevices: s }
            } = le.parse(r);
          return s
            .filter((e) => ue.includes(e.platform))
            .reduce((e, t) => ((!e && t.activated) || (e && t.activated && t.updateDateUnix > e.updateDateUnix) ? t : e), null);
        },
        he = m.z.object({}),
        me =
          (m.z.object({ teamUuid: m.z.string().uuid(), adminProvisioningKey: m.z.string(), idpUuid: m.z.string().uuid() }),
          m.z.object({ idpUuid: m.z.string().uuid() })),
        ye = m.z.record(m.z.string(), A),
        ge = m.z.object({ domains: ye, idps: m.z.record(m.z.string(), E), updateDateUnix: m.z.number() });
      var ve = r(33229),
        fe = r(13878),
        we = r(60399),
        Se = r(87065);
      let Ee = class {
        constructor(e, t, r, s, a) {
          (this.enclaveService = e),
            (this.ssoProvisioningStoreUpdater = t),
            (this.carbonLegacyClient = r),
            (this.featureFlipsClient = s),
            (this.appLogger = a),
            (this.fetchInitialStateInfo = async (e) => {
              const {
                  queries: { carbonState: t },
                  commands: { carbon: r }
                } = this.carbonLegacyClient,
                s = [(0, fe.B)(e, t), (0, ve.I)(r), pe(r)],
                [a, n, i] = await Promise.all(s);
              if ((0, p.hx)(n)) return n;
              let o = this.makeGetTeamDecryptedResponse();
              const { teamInfo: c, capabilities: u } = n.data;
              a && c.uuid && (o = await this.performGetTeam(a, c.uuid));
              const d = this.extractCapabilities(u);
              return (0, p.Vp)({ provisioningKey: a, teamInfo: c, teamStatus: o, capabilities: d, currentTeamDevice: i });
            }),
            (this.makeGetTeamDecryptedResponse = () => ({ domains: {}, idps: {}, updateDateUnix: 0 }));
        }
        async execute({ body: { teamId: e } }) {
          if (!e) return (0, p.Rn)({ tag: "TeamIdNotFound" });
          try {
            await this.ssoProvisioningStoreUpdater.reset();
            const r = await this.fetchInitialStateInfo(e);
            if ((0, p.hx)(r)) return r;
            const { teamStatus: s, teamInfo: a, provisioningKey: n, capabilities: i, currentTeamDevice: o } = r.data;
            if (!a.uuid) return (0, p.Rn)({ tag: "TeamIdNotFound" });
            let c = C.enum.Unknown;
            try {
              c = ((e, t, r, s) => {
                if (!r) return C.enum.None;
                if (s && r.platform === ce.enum.sso_connector) return C.enum.SsoConnectorToSelfHostedMigration;
                if (t) return e ? C.enum.NitroComplete : C.enum.NitroIncomplete;
                switch (r.platform) {
                  case ce.enum.sso_connector:
                    return e ? C.enum.SsoConnectorComplete : C.enum.SsoConnectorIncomplete;
                  case ce.enum.encryption_service:
                    return e ? C.enum.SelfHostedComplete : C.enum.SelfHostedIncomplete;
                  case ce.enum.nitro_encryption_service:
                    return e ? C.enum.NitroComplete : C.enum.NitroIncomplete;
                }
                throw new Error("Invalid SSO state reached");
              })(a.ssoEnabled, a.ssoIsNitroProvider, o, !!(await this._shouldUseSSOMigration()));
            } catch {
              return (0, p.Rn)({ tag: "InvalidSsoState" });
            }
            return (
              await this.ssoProvisioningStoreUpdater.set({
                global: {
                  adminProvisioningKey: n ?? null,
                  isTeamProvisionedInNitro: !!n,
                  inferredSsoState: c,
                  ssoCapable: i.sso,
                  teamUuid: a.uuid
                },
                idpApplication: {
                  acsUrl: ((t = this.enclaveService.getEnclaveApiSettings().enclaveUrl), t ? `${new URL(t).origin}/saml/callback` : ""),
                  entityId: "dashlane-nitro-sso",
                  signOnUrl: "https://app.dashlane.com"
                },
                idpMetadata: { idpUuid: Object.keys(s.idps)[0] ?? null, metadataValue: a.ssoIdpMetadata ?? null },
                domainSetup: this.getDomainSetupState(s.domains),
                domainVerificationInfo: this.getDomainVerificationInfo(s.domains),
                enableSSO: { ssoEnabled: a.ssoEnabled }
              }),
              (0, p.Vp)(void 0)
            );
          } catch (e) {
            return this.appLogger.error(e), (0, p.Rn)({ tag: "GenericSsoError" });
          }
          var t;
        }
        getDomainSetupState(e) {
          return Object.entries(e).map(([e, t]) => ({ domainName: e, verificationStatus: t.dnsCheckStatus.status ?? "pending" }));
        }
        getDomainVerificationInfo(e) {
          return Object.entries(e).reduce(
            (e, [t, r]) => (
              (e[t] = {
                txtValue: r.dnsCheckStatus.verificationToken,
                verificationStatus: _.parse(r.dnsCheckStatus.status),
                subdomainValue: q,
                pendingReason: r.dnsCheckStatus.pendingReason,
                tokenFound: null
              }),
              e
            ),
            {}
          );
        }
        fixTeamStatusDomains(e, t, r) {
          const s = Object.values(e.idps);
          if (s.length <= 1) return Promise.resolve(e);
          const a = s.sort((e, t) => e.updateDateUnix - t.updateDateUnix).pop();
          return a
            ? (Object.values(e.domains).reduce(
                (e, s) =>
                  s.idpUuid !== a.idpUuid
                    ? e.then(() =>
                        (async (e, t) => await e.callEnclaveEndpoint({ endpoint: d.DOMAINS_UPDATE_DOMAIN, body: t, responseSchema: he }))(
                          this.enclaveService,
                          { domainName: s.domainName, adminProvisioningKey: t, teamUuid: r, idpUuid: a.idpUuid }
                        ).then(() => ((s.idpUuid = a.idpUuid), Promise.resolve()))
                      )
                    : Promise.resolve(),
                Promise.resolve()
              ),
              s.reduce(
                (e, s) =>
                  a.idpUuid !== s.idpUuid
                    ? e
                        .then(() =>
                          (async (e, t) => await e.callEnclaveEndpoint({ body: t, endpoint: d.IDPS_DELETE_IDP, responseSchema: me }))(
                            this.enclaveService,
                            { teamUuid: r, adminProvisioningKey: t, idpUuid: s.idpUuid }
                          )
                        )
                        .then(() => Promise.resolve())
                    : Promise.resolve(),
                Promise.resolve()
              ),
              (e.idps = { [a.idpUuid]: a }),
              Promise.resolve(e))
            : Promise.resolve(e);
        }
        async performGetTeam(e, t) {
          let r = await (async (e, t) =>
            t.teamUuid && t.adminProvisioningKey
              ? await e.callEnclaveEndpoint({ endpoint: d.TEAMS_GET_TEAM, body: t, responseSchema: ge })
              : { domains: {}, idps: {}, updateDateUnix: 0 })(this.enclaveService, { adminProvisioningKey: e, teamUuid: t });
          return (r = await this.fixTeamStatusDomains(r, e, t)), r;
        }
        extractCapabilities(e) {
          return Object.entries(e).reduce((e, [t, r]) => ({ ...e, [t]: r.enabled }), {});
        }
        _shouldUseSSOMigration() {
          return this._getFeatureFlip(ie.w.ItadminTacEncryptionserviceSSOmigrationReset);
        }
        _getFeatureFlip(e) {
          const { userFeatureFlips: t } = this.featureFlipsClient.queries;
          return (0, we.z)(
            t().pipe(
              (0, Se.U)((t) => {
                if ((0, p.d6)(t)) {
                  return (0, p.db)(t)[e];
                }
              })
            )
          );
        }
      };
      Ee = (0, s.__decorate)([(0, l.W)(oe.S), (0, s.__metadata)("design:paramtypes", [f.d, K, v.CarbonLegacyClient, S.P, ne.V])], Ee);
      var _e = r(66012);
      let be = class {
        constructor(e) {
          this.carbonLegacy = e;
        }
        async execute({ body: e }) {
          const {
              commands: { carbon: t }
            } = this.carbonLegacy,
            r = await (async (e, t) => {
              if (null === t) return;
              const r = await e({ name: "parseMetadataFields", args: [{ ssoIdpMetadata: t }] });
              return (0, p.d6)(r) ? void 0 : U.parse(r.error).error;
            })(t, e.metadata);
          return r ? (0, p.Rn)({ tag: r }) : (0, p.Vp)(void 0);
        }
      };
      be = (0, s.__decorate)([(0, l.W)(_e.l), (0, s.__metadata)("design:paramtypes", [v.CarbonLegacyClient])], be);
      var Te = r(82249);
      m.z.object({
        teamUuid: m.z.string().uuid(),
        adminProvisioningKey: m.z.string(),
        idpMetadata: m.z.object({ certificates: m.z.array(m.z.string()), entrypoint: m.z.string() })
      });
      const Ae = m.z.object({ idpUuid: m.z.string().uuid() }),
        Ce =
          (m.z.object({
            teamUuid: m.z.string().uuid(),
            adminProvisioningKey: m.z.string(),
            idpMetadata: m.z.object({ idpUuid: m.z.string(), certificates: m.z.array(m.z.string()), entrypoint: m.z.string() })
          }),
          m.z.object({}));
      let Re = class {
        constructor(e, t, r, s, a, n) {
          (this.enclaveService = e),
            (this.enclaveApiSettings = t),
            (this.platformInfoService = r),
            (this.ssoProvisioningStoreUpdater = s),
            (this.ssoProvisioningStore = a),
            (this.carbon = n);
        }
        async execute({ body: e }) {
          const t = await this.ssoProvisioningStore.getState();
          if (!t.global.adminProvisioningKey || !t.global.teamUuid) return (0, p.Rn)({ tag: "internal_error" });
          const { metadata: r } = e;
          let s,
            a = "",
            n = "";
          const i = new D.Y(r).isUrlValid();
          if (r && i)
            try {
              const e = await fetch(r);
              s = await e.text();
            } catch {
              return (0, p.Rn)({ tag: "invalid_metadata_url" });
            }
          else s = r;
          try {
            if (s) {
              const e = await O(this.carbon.commands.carbon, s);
              (n = e.samlIdpEntryPoint), (a = e.samlIdpCertificate);
            }
          } catch {
            const e = i ? { tag: "invalid_metadata_url" } : { tag: "invalid_metadata_content" };
            return (0, p.Rn)(e);
          }
          const { adminProvisioningKey: o, teamUuid: c } = t.global;
          try {
            let e = "";
            if (t.idpMetadata.idpUuid) {
              const r = {
                adminProvisioningKey: o,
                teamUuid: c,
                idpMetadata: { idpUuid: t.idpMetadata.idpUuid || "", certificates: [a], entrypoint: n }
              };
              await (async (e, t) => await e.callEnclaveEndpoint({ endpoint: d.IDPS_UPDATE_IDP, body: t, responseSchema: Ce }))(
                this.enclaveService,
                r
              ),
                (e = t.idpMetadata.idpUuid);
            } else {
              const t = { adminProvisioningKey: o, teamUuid: c, idpMetadata: { certificates: [a], entrypoint: n } },
                { idpUuid: r } = await (async (e, t) =>
                  await e.callEnclaveEndpoint({ endpoint: d.IDPS_CREATE_IDP, body: t, responseSchema: Ae }))(this.enclaveService, t);
              e = r;
            }
            await this.ssoProvisioningStoreUpdater.set({ ...t, idpMetadata: { ...t.idpMetadata, idpUuid: e, metadataValue: r } });
            try {
              await (async (e, { metadata: t, entrypoint: r }) => {
                const s = { ssoIdpMetadata: t || null, ssoIdpEntrypoint: t ? r : null };
                await e({ name: "updateTeamSettings", args: [s] });
              })(this.carbon.commands.carbon, { metadata: r, entrypoint: n });
            } catch (e) {
              return (0, p.Rn)({ tag: "save_metadata_failed" });
            }
          } catch (e) {
            return (0, p.Rn)({ tag: "domain_update_failed" });
          }
          return (
            await this.ssoProvisioningStoreUpdater.set({ ...t, idpMetadata: { ...t.idpMetadata, metadataValue: r } }), (0, p.Vp)(void 0)
          );
        }
      };
      Re = (0, s.__decorate)([(0, l.W)(Te.o), (0, s.__metadata)("design:paramtypes", [f.d, se.N6, ee.t, K, j, v.CarbonLegacyClient])], Re);
      var Ie = r(85355);
      const xe = m.z.object({
        previousStatus: m.z.string(),
        status: m.z.enum(["valid", "pending", "expired", "invalid"]),
        verificationToken: m.z.string(),
        lastCheckDateUnix: m.z.number(),
        pendingReason: m.z.enum(["tokenNotFound", "invalidToken"]).nullable(),
        tokenFound: m.z.string().optional()
      });
      let Pe = class {
        constructor(e, t, r, s) {
          (this.enclaveService = e), (this.ssoProvisioningStoreUpdater = t), (this.ssoProvisioningStore = r), (this.featureFlips = s);
        }
        async execute(e) {
          const t = await this.ssoProvisioningStore.getState(),
            {
              global: { adminProvisioningKey: r },
              domainVerificationInfo: s,
              domainSetup: a
            } = t,
            n = e.body.domainName;
          if (!r) return (0, p.Rn)({ tag: "AdminProvisioningKeyNotFound" });
          if (!n) return (0, p.Rn)({ tag: "DomainNameNotProvided" });
          let i;
          try {
            i = await (async (e, t) =>
              await e.callEnclaveEndpoint({ endpoint: d.DOMAINS_CHECK_DNS_VALIDATION, body: t, responseSchema: xe }))(this.enclaveService, {
              domainName: n,
              adminProvisioningKey: r,
              teamUuid: t.global.teamUuid ?? ""
            });
          } catch {
            return (0, p.Rn)({ tag: "CouldNotVerifyDns" });
          }
          const o = s[n];
          (o.txtValue = i.verificationToken),
            (o.verificationStatus = i.status),
            (o.tokenFound = i.tokenFound ?? null),
            (o.pendingReason = i.pendingReason);
          const c = a.map((e) => (e.domainName === n && (e.verificationStatus = i.status), e));
          return (
            await this.ssoProvisioningStoreUpdater.set({ ...t, domainSetup: c, domainVerificationInfo: { ...s, [n]: o } }),
            (0, p.Vp)(void 0)
          );
        }
      };
      Pe = (0, s.__decorate)([(0, l.W)(Ie.o), (0, s.__metadata)("design:paramtypes", [f.d, K, j, S.P])], Pe);
      var De = r(39118);
      let Ue = class {
        constructor(e, t, r) {
          (this.ssoProvisioningStoreUpdater = e), (this.ssoProvisioningStore = t), (this.carbonLegacy = r);
        }
        async execute() {
          if ((await this.ssoProvisioningStore.getState()).enableSSO.ssoEnabled) return (0, p.Rn)({ tag: "SsoAlreadyEnabled" });
          const {
              commands: { carbon: e }
            } = this.carbonLegacy,
            t = await (async (e, { ssoEnabled: t }) => {
              const r = await e({ name: "updateTeamSettings", args: [{ ssoEnabled: t }] });
              return !(0, p.hx)(r);
            })(e, { ssoEnabled: !0 });
          return t
            ? (await this.ssoProvisioningStoreUpdater.update({ inferredSsoState: C.enum.NitroComplete }, "global"),
              await this.ssoProvisioningStoreUpdater.update({ ssoEnabled: !0 }, "enableSSO"),
              (0, p.Vp)(void 0))
            : (0, p.Rn)({ tag: "EnableSsoFailed" });
        }
      };
      Ue = (0, s.__decorate)([(0, l.W)(De.F), (0, s.__metadata)("design:paramtypes", [K, j, v.CarbonLegacyClient])], Ue);
      var Fe = r(94189),
        Oe = r(26758);
      const Ne = m.z.object({});
      let ke = class {
        constructor(e, t, r, s, a) {
          (this.enclaveService = e),
            (this.ssoProvisioningStoreUpdater = t),
            (this.ssoProvisioningStore = r),
            (this.appLogger = s),
            (this.cqrsClient = a),
            (this.carbon = a.getClient(v.carbonLegacyApi).commands.carbon);
        }
        async execute() {
          const { global: e, enableSSO: t } = await this.ssoProvisioningStore.getState(),
            r = [];
          t.ssoEnabled && r.push((0, p.Rn)({ tag: "SsoAlreadyEnabled" })),
            e.teamUuid || r.push((0, p.Rn)({ tag: "TeamIdNotFound" })),
            e.adminProvisioningKey || r.push((0, p.Rn)({ tag: "NitroTeamNotProvisioned" }));
          const s = [this.deactivateTeamDevice.bind(this), this.deleteCurrentTeam.bind(this), this.clearLegacyTeamSettings.bind(this)],
            a = await this.ssoProvisioningStore.getState(),
            n = await this.setCleaningFunctorApplier(a),
            i = await s.reduce(n, Promise.resolve([]));
          return (
            await this.ssoProvisioningStoreUpdater.reset(),
            [...r, ...i].forEach((e) => {
              this.appLogger.error(`[Clear Settings Error]: ${e.tag}`);
            }),
            (0, p.Vp)(void 0)
          );
        }
        setCleaningFunctorApplier(e) {
          return async (t, r) => {
            const s = await t,
              a = await r(e);
            return (0, p.hx)(a) && (this.appLogger.error((0, p.Yv)(a)), s.push((0, p.Yv)(a))), s;
          };
        }
        async deactivateTeamDevice() {
          try {
            const e = await pe(this.carbon);
            e?.platform === ce.enum.nitro_encryption_service &&
              (await (async (e, t) => {
                const r = await e({ name: "deactivateTeamDevice", args: [{ teamDeviceAccessKey: t }] });
                return !(0, p.hx)(r);
              })(this.carbon, e.accessKey));
          } catch {
            return (0, p.Rn)({ tag: "CouldNotDeleteNitroTeam" });
          }
          return (0, p.Vp)(void 0);
        }
        async deleteCurrentTeam(e) {
          const { global: t } = e;
          if (!t.isTeamProvisionedInNitro) return (0, p.Rn)({ tag: "NitroTeamNotProvisioned" });
          const r = { teamUuid: t.teamUuid, adminProvisioningKey: t.adminProvisioningKey };
          try {
            await (async (e, t) => await e.callEnclaveEndpoint({ endpoint: d.TEAMS_DELETE_TEAM, body: t, responseSchema: Ne }))(
              this.enclaveService,
              r
            );
          } catch (e) {
            return (0, p.Rn)({ tag: "CouldNotDeleteNitroTeam" });
          }
          return this.removeAdmingProvisionningKey(e);
        }
        async clearLegacyTeamSettings(e) {
          const { global: t } = e;
          if (!t.isTeamProvisionedInNitro) return (0, p.Rn)({ tag: "NitroTeamNotProvisioned" });
          try {
            await (async (e, t) => {
              await e({ name: "updateTeamSettings", args: [{ ...t }] });
            })(this.carbon, { ssoServiceProviderUrl: null, ssoIdpMetadata: null, ssoIdpEntrypoint: null });
          } catch (e) {
            return (0, p.Rn)({ tag: "NitroTeamNotProvisioned" });
          }
          return (0, p.Vp)(void 0);
        }
        async removeAdmingProvisionningKey(e) {
          const { global: t } = e;
          if (!t.adminProvisioningKey) return (0, p.Rn)({ tag: "AdminProvisioningKeyNotFound" });
          try {
            await this.carbon({ name: "removeAdminProvisioningKey", args: [] });
          } catch (e) {
            return (0, p.Rn)({ tag: "CouldNotCouldNotDeleteAdminProvisioningKey" });
          }
          return (0, p.Vp)(void 0);
        }
      };
      ke = (0, s.__decorate)([(0, l.W)(Oe.h), (0, s.__metadata)("design:paramtypes", [f.d, K, j, ne.V, Fe.w])], ke);
      var Le = r(20754),
        Me = r(73774),
        Ve = r(1434);
      let Ge = class {
        constructor(e, t) {
          (this.httpClient = e), (this.ssoProvisioningStore = t);
        }
        execute() {
          return this.ssoProvisioningStore.state$.pipe((0, Se.U)((e) => (0, p.Vp)(e)));
        }
      };
      Ge = (0, s.__decorate)([(0, Le.e)(Ve._), (0, s.__metadata)("design:paramtypes", [Me.e, j])], Ge);
      let je = class {};
      je = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: o.y,
            handlers: {
              commands: {
                loginUserWithEnclaveSSO: w,
                provisionDomain: B,
                createTeam: Y,
                deleteDomain: Z,
                testLoginUserWithEnclaveSSO: ae,
                initSsoProvisioning: Ee,
                validateMetadata: be,
                updateMetadata: Re,
                checkDNSValidation: Pe,
                enableSso: Ue,
                clearSettings: ke
              },
              events: {},
              queries: { ssoProvisioning: Ge }
            },
            configurations: { enclaveLoginContextInfrastructure: { token: u } },
            imports: [n.X, i.i, c.E],
            stores: [j],
            providers: [K],
            requiredFeatureFlips: [
              "itadmin_tac_encryptionservice_SSOmigration_reset",
              "setup_rollout_confidential_scim_prod",
              "setup_rollout_reset_confidential_button",
              "setup_rollout_sso_jit_setting"
            ]
          })
        ],
        je
      );
    },
    52886: (e, t, r) => {
      "use strict";
      r.d(t, { X: () => f });
      var s = r(7165),
        a = r(56773),
        n = r(37298),
        i = r(839);
      const o = {
        addListener: function (e) {
          const t = (t, r, s) => {
            if (chrome.runtime.lastError) {
              const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError";
              throw new Error(`runtime/onMessage: ${e}`);
            }
            return e(t, r, s);
          };
          if (!(0, i.Ez)("runtime.onMessage.addListener")) throw new Error("No runtime.onMessage.addListener support");
          return chrome.runtime.onMessage.addListener(t), t;
        },
        removeListener: function (e) {
          chrome.runtime.onMessage.removeListener(e);
        }
      };
      var c = r(21763);
      const u = {
        addListener: function (e) {
          if (!(0, i.Ez)("tabs.onUpdated.addListener")) throw new Error("No tabs.onUpdated.addListener support");
          const t = (t, r, s) => {
            if (chrome.runtime.lastError) {
              const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError";
              throw new Error(`tabs/onUpdated: ${e}`);
            }
            return e(t, r, s);
          };
          return chrome.tabs.onUpdated.addListener(t), t;
        },
        removeListener: function (e) {
          if (!(0, i.Ez)("tabs.onUpdated.removeListener")) throw new Error("No tabs.onUpdated.removeListener support");
          chrome.tabs.onUpdated.removeListener(e);
        }
      };
      const d = {
        addListener: function (e) {
          if (!(0, i.Ez)("tabs.onRemoved.addListener")) throw new Error("No tabs.onRemoved.addListener support");
          const t = (t, r) => {
            if (chrome.runtime.lastError) {
              const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError";
              throw new Error(`tabs/onRemoved: ${e}`);
            }
            return e(t, r);
          };
          return chrome.tabs.onRemoved.addListener(t), t;
        },
        removeListener: function (e) {
          if (!(0, i.Ez)("tabs.onRemoved.removeListener")) throw new Error("No tabs.onRemoved.removeListener support");
          chrome.tabs.onRemoved.removeListener(e);
        }
      };
      var l = r(31460),
        p = r(72733),
        h = r(24715),
        m = r(61222),
        y = r(92204),
        g = r(49259);
      const v = s.z.object({ type: s.z.string(), saml: s.z.string() });
      class f {
        constructor() {
          (this.interceptedTabId = void 0),
            (this.originalTabId = void 0),
            (this.samlReceived = !1),
            (this.expectedMessageType = "SamlAssertionIntercepted");
          try {
            this.onMessageListener = new n.j(o, this.checkMessageType.bind(this));
          } catch {}
        }
        checkMessageType(e) {
          return !this.samlReceived && e.type === this.expectedMessageType;
        }
        interceptSamlFromTab(e) {
          return new Promise((t, r) => {
            if (!this.onMessageListener) return r(new Error("OnMessage event listener is not available in current context"));
            const s = u.addListener((t, r) => {
                t === e.id &&
                  r.url &&
                  e.id &&
                  (0, c.k)({
                    target: { tabId: e.id, allFrames: !0 },
                    files: ["content/contentScripts/dashlane-saml-intercept-script.js"],
                    injectImmediately: !0
                  });
              }),
              n = d.addListener((t) => {
                t === e.id && (u.removeListener(s), d.removeListener(n), r(new Error("Intercepting SAML - tab closed unexpectedly")));
              });
            this.onMessageListener.events$.pipe((0, a.P)()).subscribe(([e]) => {
              const a = v.safeParse(e);
              a.success
                ? ((this.samlReceived = !0), u.removeListener(s), d.removeListener(n), t({ samlToken: a.data.saml }))
                : r(new Error("Intercepting SAML - received message could not be parsed"));
            });
          });
        }
        async redirectTabToUrl(e) {
          if (this.interceptedTabId) return await (0, l.V)(this.interceptedTabId, { url: e });
          {
            const t = (await (0, p.T)({ windowTypes: ["normal"] })).id;
            return await (0, h.U)({ windowId: t, url: e });
          }
        }
        async getActiveExtensionTabId() {
          const e = await (0, m.I)({ currentWindow: !0, active: !0 }),
            t = e.length > 0 ? e[0] : null,
            r = (0, y.A)("");
          if (t?.id && t.url?.includes(r)) return t.id;
        }
        getSamlFromLogin(e, t) {
          (this.samlReceived = !1),
            (this.originalTabId = void 0),
            this.interceptedTabId && ((0, g.O)([this.interceptedTabId]), (this.interceptedTabId = void 0));
          const r = () => (0, h.U)({ url: e }).then((e) => ((this.interceptedTabId = e.id), this.interceptSamlFromTab(e))),
            s = (t) =>
              (0, l.V)(t, { url: e }).then((e) => {
                if (e) return (this.interceptedTabId = e.id), this.interceptSamlFromTab(e);
                throw new Error("Tab disappeared during nitro login");
              });
          return t
            ? this.getActiveExtensionTabId().then((e) => (e ? s(e) : r()))
            : this.getActiveExtensionTabId().then((e) => ((this.originalTabId = e), r()));
        }
        async redirectUserIntoLoginFlow(e) {
          const t = {
              ssoToken: e.ssoToken,
              exists: e.exists,
              currentAuths: e.currentAuthenticationMethods,
              expectedAuths: e.expectedAuthenticationMethods,
              key: e.userServiceProviderKey,
              login: e.login
            },
            r = Object.entries(t)
              .map((e) => `${e[0]}=${encodeURIComponent(e[1].toString())}`)
              .join("&"),
            s = (0, y.A)(`index.html#/sso?${r}`);
          await this.redirectTabToUrl(s);
        }
        async redirectUserToLoginPage() {
          const e = (0, y.A)("index.html#/login");
          await this.redirectTabToUrl(e);
        }
        async cleanupTestLogin() {
          this.interceptedTabId && (await (0, g.O)([this.interceptedTabId])),
            this.originalTabId && (0, l.V)(this.originalTabId, { active: !0 });
        }
      }
    },
    33470: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => i });
      var s = r(86952),
        a = r(20417),
        n = r(9599);
      const i = (0, s.Q)({ name: "sync", commands: { SyncCommand: a.t }, queries: { SyncProgressQuery: n.F }, events: {} });
    },
    20417: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.Device }) {}
    },
    9599: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.Device }) {}
    },
    76183: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { L: () => s, _: () => a }),
        (function (e) {
          (e.READY = "ready"), (e.IN_PROGRESS = "in_progress"), (e.SUCCESS = "success"), (e.FAILURE = "failure");
        })(s || (s = {}));
      class a {}
    },
    80310: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => C });
      var s = r(88802),
        a = r(99634),
        n = r(25029),
        i = r(33470),
        o = r(76183),
        c = r(87279),
        u = r(63663),
        d = r(20417);
      let l = class {
        constructor(e) {
          this.syncService = e;
        }
        execute(e) {
          const { trigger: t } = e.body;
          return this.syncService.attemptSync(t), Promise.resolve((0, c.Vp)(void 0));
        }
      };
      l = (0, s.__decorate)([(0, u.W)(d.t), (0, s.__metadata)("design:paramtypes", [o._])], l);
      var p = r(20754),
        h = r(9599);
      let m = class {
        constructor(e) {
          this.syncService = e;
        }
        execute() {
          return this.syncService.getSyncState();
        }
      };
      m = (0, s.__decorate)([(0, p.e)(h.F), (0, s.__metadata)("design:paramtypes", [o._])], m);
      var y = r(30523),
        g = r(60399),
        v = r(57924),
        f = r(53576),
        w = r(48844);
      const S = (e) => "object" == typeof e && null !== e && "status" in e && Object.values(o.L).includes(e.status);
      var E = r(96168);
      class _ extends (0, E.Hu)("SyncError", "An error occoured while trying to sync the vault") {}
      let b = class {
        constructor(e) {
          this.carbonLegacy = e;
        }
        async attemptSync(e) {
          await this.carbonLegacy.commands.carbonLegacyLeeloo({ name: "sessionForceSync", arg: [{ trigger: e }] });
        }
        async waitForSync(e) {
          const t = this.getSyncState().pipe(
            (0, y.h)((e) => !(!(0, c.d6)(e) || !S(e.data)) && [o.L.FAILURE, o.L.SUCCESS].includes(e.data.status)),
            (0, w.DZ)(() => new _()),
            (0, w.lk)((e) => (e.status === o.L.FAILURE ? (0, c.Rn)({ tag: "Sync failed" }) : (0, c.Vp)(void 0)))
          );
          return await this.attemptSync(e), (0, g.z)(t);
        }
        getSyncState() {
          return this.carbonLegacy.queries.carbonState({ path: "userSession.sync" }).pipe(
            (0, w.Qn)((e) => {
              if (!S(e)) throw new Error("Bad sync state format");
              return { status: e.status };
            })
          );
        }
      };
      b = (0, s.__decorate)([(0, v.GS)(), (0, s.__metadata)("design:paramtypes", [f.CarbonLegacyClient])], b);
      var T = r(60765);
      let A = class {
        constructor(e) {
          this.syncService = e;
        }
        async run() {
          return await this.syncService.attemptSync(T.Trigger.Periodic), Promise.resolve();
        }
      };
      A = (0, s.__decorate)([(0, v.GS)(), (0, s.__metadata)("design:paramtypes", [o._])], A);
      let C = class {};
      C = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: i.r,
            handlers: { commands: { sync: l }, events: {}, queries: { syncProgress: m } },
            crons: [{ handler: A, periodInMinutes: 5, name: "periodic-sync-cron", scope: n.F.User }],
            providers: [{ provide: o._, useClass: b }],
            exports: [o._]
          })
        ],
        C
      );
    },
    17305: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => p });
      var s = r(86952),
        a = r(3171),
        n = r(14745),
        i = r(35997),
        o = r(5633),
        c = r(5407),
        u = r(71616),
        d = r(48317),
        l = r(90109);
      const p = (0, s.Q)({
        name: "teamAdminNotifications",
        commands: {
          markB2BPlanDiscontinuedSeen: a.q,
          markNewRestrictSharingPolicySeen: n.o,
          markNotificationTrialExtendedSeen: i.D,
          markOfferToExtendFreeTrialSeen: o.R
        },
        events: {},
        queries: {
          hasSeenB2BPlanDiscontinued: c.z,
          hasSeenNewRestrictSharingPolicy: u.x,
          hasSeenNotificationTrialExtended: d.q,
          hasSeenOfferToExtendFreeTrial: l.U
        }
      });
    },
    3171: (e, t, r) => {
      "use strict";
      r.d(t, { q: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    14745: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    35997: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    5633: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    5407: (e, t, r) => {
      "use strict";
      r.d(t, { z: () => a });
      var s = r(99059);
      class a extends (0, s.k)() {}
    },
    71616: (e, t, r) => {
      "use strict";
      r.d(t, { x: () => a });
      var s = r(99059);
      class a extends (0, s.k)() {}
    },
    48317: (e, t, r) => {
      "use strict";
      r.d(t, { q: () => a });
      var s = r(99059);
      class a extends (0, s.k)() {}
    },
    90109: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => a });
      var s = r(99059);
      class a extends (0, s.k)() {}
    },
    49003: (e, t, r) => {
      "use strict";
      r.d(t, { h: () => p });
      var s = r(86952),
        a = r(55958),
        n = r(56524),
        i = r(48975),
        o = r(88313),
        c = r(78651),
        u = r(59448),
        d = r(76560),
        l = r(6725);
      const p = (0, s.Q)({
        name: "teamGetStarted",
        commands: { markVaultAsVisited: u.R, markGetStartedAsSeen: d.g, markNotificationAsSeen: l.f },
        events: {},
        queries: { hasVisitedVault: a.V, hasSeenGetStarted: n.U, hasSeenNotification: i.C, isTeamCreator: o.G, teamTasksCompletion: c.M }
      });
    },
    76560: (e, t, r) => {
      "use strict";
      r.d(t, { g: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    6725: (e, t, r) => {
      "use strict";
      r.d(t, { f: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    59448: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    56524: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => a });
      var s = r(99059);
      class a extends (0, s.k)() {}
    },
    48975: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => a });
      var s = r(99059);
      class a extends (0, s.k)() {}
    },
    55958: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => a });
      var s = r(99059);
      class a extends (0, s.k)() {}
    },
    88313: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => o });
      var s = r(99059),
        a = r(25029),
        n = r(96168);
      class i extends (0, n.Hu)("UserNotLogged", "Please log the user") {}
      class o extends (0, s.k)({ scope: a.F.User, noUserError: new i() }) {}
    },
    78651: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => a });
      var s = r(99059);
      class a extends (0, s.k)() {}
    },
    13823: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => n });
      var s = r(86952),
        a = r(2564);
      const n = (0, s.Q)({ name: "teamMembers", commands: { ProposeMembersCommand: a.og }, events: {}, queries: {} });
    },
    2564: (e, t, r) => {
      "use strict";
      r.d(t, { Wv: () => m, og: () => y });
      var s,
        a = r(74354),
        n = r(25029),
        i = r(96168);
      !(function (e) {
        (e.InvalidOrigin = "InvalidOrigin"),
          (e.NoFreeSlot = "NoFreeSlot"),
          (e.NoFreeSlotFreePlan = "NoFreeSlotFreePlan"),
          (e.UserTeamInviteTokenNotFound = "UserTeamInviteTokenNotFound"),
          (e.PaymentFailed = "PaymentFailed"),
          (e.NotBillingAdmin = "NotBillingAdmin"),
          (e.CannotAddSeatDuringGracePeriod = "CannotAddSeatDuringGracePeriod");
      })(s || (s = {}));
      class o extends (0, i.Hu)(s.InvalidOrigin, "Invalid origin") {}
      class c extends (0, i.Hu)(s.NoFreeSlot, "No free slot") {}
      class u extends (0, i.Hu)(s.NoFreeSlotFreePlan, "No free slot in free plan") {}
      class d extends (0, i.Hu)(s.UserTeamInviteTokenNotFound, "No invite token to a team available for user") {}
      class l extends (0, i.Hu)(s.PaymentFailed, "Payment failed") {}
      class p extends (0, i.Hu)(s.NotBillingAdmin, "User is not the billing admin") {}
      class h extends (0, i.Hu)(s.CannotAddSeatDuringGracePeriod, "Seats cannot be added during grace period") {}
      function m(e) {
        switch (e) {
          case "invalid_origin":
            return new o();
          case "no_free_slot":
            return new c();
          case "no_free_slot_free_plan":
            return new u();
          case "USER_TEAM_INVITE_TOKEN_NOT_FOUND":
            return new d();
          case "payment_failed":
            return new l();
          case "not_billing_admin":
            return new p();
          case "cannot_add_seat_during_grace_period":
            return new h();
          default:
            throw new Error("Unknown server error");
        }
      }
      class y extends (0, a.g)({ scope: n.F.User }) {}
    },
    46888: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => n });
      var s = r(86952),
        a = r(42014);
      const n = (0, s.Q)({ name: "teamPasswordHealth", commands: {}, events: {}, queries: { getReport: a.z } });
    },
    42014: (e, t, r) => {
      "use strict";
      r.d(t, { z: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    13511: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => f });
      var s = r(86952),
        a = r(25904),
        n = r(82276),
        i = r(26657),
        o = r(26992),
        c = r(9128),
        u = r(30525),
        d = r(89859),
        l = r(19068),
        p = r(80926),
        h = r(64380),
        m = r(65245),
        y = r(704),
        g = r(27056),
        v = r(207);
      const f = (0, s.Q)({
        name: "teamPlanDetails",
        commands: { extendFreeTrial: a.N, requestTeamPlanCancellation: n.y, editTeamPolicies: i.m },
        events: {},
        queries: {
          getTeamBillingInformation: o._,
          getTeamCancellationStatus: c.F,
          getTeamCapabilities: u.Y,
          getTeamCreationDateUnixQuery: d.T,
          getTeamId: l.e,
          getTeamName: p.j,
          getTeamRoles: h.R,
          getTeamPolicies: m.K,
          getTeamSeats: y.W,
          getTeamSecurityScore: g.R,
          getTeamTrialStatus: v.P
        }
      });
    },
    42645: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => n });
      var s = r(67837),
        a = r(13511);
      class n extends (0, s.E)(a.o) {}
      (0, s.K)(a.o, n);
    },
    26657: (e, t, r) => {
      "use strict";
      r.d(t, { m: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    25904: (e, t, r) => {
      "use strict";
      r.d(t, { N: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    82276: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    26992: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    9128: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    30525: (e, t, r) => {
      "use strict";
      r.d(t, { Y: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    89859: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    19068: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    80926: (e, t, r) => {
      "use strict";
      r.d(t, { j: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    65245: (e, t, r) => {
      "use strict";
      r.d(t, { K: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    64380: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    704: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    27056: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    207: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    1701: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => o });
      var s = r(86952),
        a = r(57220),
        n = r(36767),
        i = r(56333);
      const o = (0, s.Q)({
        name: "teamVat",
        commands: { DeleteTeamVatCommand: a.Hy, GetTeamVatCommand: n.cf, UpsertTeamVatCommand: i.XW },
        events: {},
        queries: {}
      });
    },
    57220: (e, t, r) => {
      "use strict";
      r.d(t, { Hy: () => d, zK: () => u });
      var s,
        a = r(74354),
        n = r(25029),
        i = r(96168);
      !(function (e) {
        (e.TeamNotFound = "TeamNotFound"), (e.NotBillingAdmin = "NotBillingAdmin");
      })(s || (s = {}));
      class o extends (0, i.Hu)(s.TeamNotFound, "The given user is not part of a single team") {}
      class c extends (0, i.Hu)(s.NotBillingAdmin, "The user is not Billing Admin") {}
      function u(e) {
        switch (e) {
          case "TEAM_NOT_FOUND":
            return new o();
          case "not_billing_admin":
            return new c();
          default:
            throw new Error("Unknown server error");
        }
      }
      class d extends (0, a.g)({ scope: n.F.User }) {}
    },
    36767: (e, t, r) => {
      "use strict";
      r.d(t, { K$: () => d, cf: () => l });
      var s,
        a = r(74354),
        n = r(25029),
        i = r(96168);
      !(function (e) {
        (e.TeamNotFound = "TeamNotFound"), (e.VatNumberNotFound = "VatNumberNotFound"), (e.NotBillingAdmin = "NotBillingAdmin");
      })(s || (s = {}));
      class o extends (0, i.Hu)(s.TeamNotFound, "The given user is not part of a single team") {}
      class c extends (0, i.Hu)(s.VatNumberNotFound, "The given Team does not have a VAT number") {}
      class u extends (0, i.Hu)(s.NotBillingAdmin, "The user is not Billing Admin") {}
      function d(e) {
        switch (e) {
          case "TEAM_NOT_FOUND":
            return new o();
          case "VAT_NUMBER_NOT_FOUND":
            return new c();
          case "not_billing_admin":
            return new u();
          default:
            throw new Error("Unknown server error");
        }
      }
      class l extends (0, a.g)({ scope: n.F.User }) {}
    },
    56333: (e, t, r) => {
      "use strict";
      r.d(t, { XW: () => l, q5: () => d });
      var s,
        a = r(74354),
        n = r(25029),
        i = r(96168);
      !(function (e) {
        (e.TeamNotFound = "TeamNotFound"), (e.NotBillingAdmin = "NotBillingAdmin"), (e.VatNumberNotUpserted = "VatNumberNotUpserted");
      })(s || (s = {}));
      class o extends (0, i.Hu)(s.TeamNotFound, "The given user is not part of a single team") {}
      class c extends (0, i.Hu)(s.NotBillingAdmin, "The user is not Billing Admin") {}
      class u extends (0, i.Hu)(s.VatNumberNotUpserted, "The VAT number couldn't be upserted") {}
      function d(e) {
        switch (e) {
          case "TEAM_NOT_FOUND":
            return new o();
          case "not_billing_admin":
            return new c();
          case "VAT_NUMBER_NOT_UPSERTED":
            return new u();
          default:
            throw new Error("Unknown server error");
        }
      }
      class l extends (0, a.g)({ scope: n.F.User }) {}
    },
    72488: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => k });
      var s,
        a = r(88802),
        n = r(99634),
        i = r(1824),
        o = r(17305),
        c = r(63663),
        u = r(87279),
        d = r(3171),
        l = r(25029),
        p = r(95681),
        h = r(23347),
        m = r(10722),
        y = r(7165);
      !(function (e) {
        (e.OfferToExtendFreeTrial = "offerToExtendFreeTrial"),
          (e.NotificationTrialExtended = "notificationTrialExtended"),
          (e.RestrictSharingPolicy = "restrictSharingPolicy"),
          (e.B2BPlanDiscontinued = "b2bPlanDiscontinued");
      })(s || (s = {}));
      const g = y.z.object({ seenNotifications: y.z.record(y.z.nativeEnum(s), y.z.boolean()) }),
        v = (e) => g.safeParse(e).success;
      class f extends (0, p.Q)({
        storage: {
          schemaVersion: 1,
          initialValue: {
            seenNotifications: {
              offerToExtendFreeTrial: !1,
              notificationTrialExtended: !1,
              restrictSharingPolicy: !1,
              b2bPlanDiscontinued: !1
            }
          },
          typeGuard: v
        },
        persist: !0,
        scope: l.F.User,
        storeName: "team-admin-notifications-store",
        capacity: h.Y._010KB,
        codec: m.E
      }) {}
      let w = class {
        constructor(e) {
          this.store = e;
        }
        async execute() {
          const e = await this.store.getState(),
            t = { ...e.seenNotifications, b2bPlanDiscontinued: !0 };
          return await this.store.set({ ...e, seenNotifications: t }), Promise.resolve((0, u.Vp)(void 0));
        }
      };
      w = (0, a.__decorate)([(0, c.W)(d.q), (0, a.__metadata)("design:paramtypes", [f])], w);
      var S = r(14745);
      let E = class {
        constructor(e) {
          this.store = e;
        }
        async execute() {
          const e = await this.store.getState(),
            t = { ...e.seenNotifications, restrictSharingPolicy: !0 };
          return await this.store.set({ ...e, seenNotifications: t }), Promise.resolve((0, u.Vp)(void 0));
        }
      };
      E = (0, a.__decorate)([(0, c.W)(S.o), (0, a.__metadata)("design:paramtypes", [f])], E);
      var _ = r(35997);
      let b = class {
        constructor(e) {
          this.store = e;
        }
        async execute() {
          const e = await this.store.getState(),
            t = { ...e.seenNotifications, notificationTrialExtended: !0 };
          return await this.store.set({ ...e, seenNotifications: t }), Promise.resolve((0, u.Vp)(void 0));
        }
      };
      b = (0, a.__decorate)([(0, c.W)(_.D), (0, a.__metadata)("design:paramtypes", [f])], b);
      var T = r(5633);
      let A = class {
        constructor(e) {
          this.store = e;
        }
        async execute() {
          const e = await this.store.getState(),
            t = { ...e.seenNotifications, offerToExtendFreeTrial: !0 };
          return await this.store.set({ ...e, seenNotifications: t }), Promise.resolve((0, u.Vp)(void 0));
        }
      };
      A = (0, a.__decorate)([(0, c.W)(T.R), (0, a.__metadata)("design:paramtypes", [f])], A);
      var C = r(87065),
        R = r(20754),
        I = r(5407);
      let x = class {
        constructor(e) {
          this.store = e;
        }
        execute() {
          return this.store.state$.pipe((0, C.U)((e) => (0, u.Vp)(!!e.seenNotifications.b2bPlanDiscontinued)));
        }
      };
      x = (0, a.__decorate)([(0, R.e)(I.z), (0, a.__metadata)("design:paramtypes", [f])], x);
      var P = r(71616);
      let D = class {
        constructor(e) {
          this.store = e;
        }
        execute() {
          return this.store.state$.pipe((0, C.U)((e) => (0, u.Vp)(!!e.seenNotifications.restrictSharingPolicy)));
        }
      };
      D = (0, a.__decorate)([(0, R.e)(P.x), (0, a.__metadata)("design:paramtypes", [f])], D);
      var U = r(48317);
      let F = class {
        constructor(e) {
          this.store = e;
        }
        execute() {
          return this.store.state$.pipe((0, C.U)((e) => (0, u.Vp)(!!e.seenNotifications.notificationTrialExtended)));
        }
      };
      F = (0, a.__decorate)([(0, R.e)(U.q), (0, a.__metadata)("design:paramtypes", [f])], F);
      var O = r(90109);
      let N = class {
        constructor(e) {
          this.store = e;
        }
        execute() {
          return this.store.state$.pipe((0, C.U)((e) => (0, u.Vp)(!!e.seenNotifications.offerToExtendFreeTrial)));
        }
      };
      N = (0, a.__decorate)([(0, R.e)(O.U), (0, a.__metadata)("design:paramtypes", [f])], N);
      let k = class {};
      k = (0, a.__decorate)(
        [
          (0, n.Y)({
            api: o.t,
            imports: [i.n],
            stores: [f],
            handlers: {
              commands: {
                markB2BPlanDiscontinuedSeen: w,
                markNewRestrictSharingPolicySeen: E,
                markNotificationTrialExtendedSeen: b,
                markOfferToExtendFreeTrialSeen: A
              },
              events: {},
              queries: {
                hasSeenB2BPlanDiscontinued: x,
                hasSeenNewRestrictSharingPolicy: D,
                hasSeenNotificationTrialExtended: F,
                hasSeenOfferToExtendFreeTrial: N
              }
            }
          })
        ],
        k
      );
    },
    56922: (e, t, r) => {
      "use strict";
      r.d(t, { q: () => B });
      var s = r(88802),
        a = r(99634),
        n = r(1824),
        i = r(49003),
        o = r(25029),
        c = r(95681),
        u = r(23347),
        d = r(10722),
        l = r(7165);
      const p = l.z.object({
          hasVisitedVault: l.z.boolean(),
          hasSeenGetStarted: l.z.boolean(),
          notifications: l.z.record(l.z.string(), l.z.boolean())
        }),
        h = (e) => p.safeParse(e).success;
      class m extends (0, c.Q)({
        storage: { schemaVersion: 1, initialValue: { hasVisitedVault: !1, hasSeenGetStarted: !1, notifications: {} }, typeGuard: h },
        persist: !0,
        scope: o.F.User,
        storeName: "team-admin-store",
        capacity: u.Y._010KB,
        codec: d.E
      }) {}
      var y = r(87065),
        g = r(20754),
        v = r(56524),
        f = r(87279);
      let w = class {
        constructor(e) {
          this.store = e;
        }
        execute() {
          return this.store.state$.pipe((0, y.U)((e) => (0, f.Vp)(e.hasSeenGetStarted)));
        }
      };
      w = (0, s.__decorate)([(0, g.e)(v.U), (0, s.__metadata)("design:paramtypes", [m])], w);
      var S = r(48975);
      let E = class {
        constructor(e) {
          this.store = e;
        }
        execute({ body: e }) {
          return this.store.state$.pipe((0, y.U)((t) => (0, f.Vp)(!!t.notifications[e.notification])));
        }
      };
      E = (0, s.__decorate)([(0, g.e)(S.C), (0, s.__metadata)("design:paramtypes", [m])], E);
      var _ = r(55958);
      let b = class {
        constructor(e) {
          this.store = e;
        }
        execute() {
          return this.store.state$.pipe((0, y.U)((e) => (0, f.Vp)(e.hasVisitedVault)));
        }
      };
      b = (0, s.__decorate)([(0, g.e)(_.V), (0, s.__metadata)("design:paramtypes", [m])], b);
      var T = r(43978),
        A = r(69885),
        C = r(61076),
        R = r(53576),
        I = r(88313),
        x = r(42645),
        P = r(48844),
        D = r(57924),
        U = r(61501);
      let F = class {
        constructor(e) {
          (this.serverApiClient = e),
            (this.get = (e) =>
              this.serverApiClient.v1.teams.getTeamMembers({ teamId: parseInt(e, 10), orderBy: "joinedDateUnix", limit: 0 }).pipe(
                (0, P.Qn)(({ data: e }) => e),
                (0, P.DZ)((e) => {
                  throw e;
                })
              ));
        }
      };
      F = (0, s.__decorate)([(0, D.GS)(), (0, s.__metadata)("design:paramtypes", [U.l])], F);
      let O = class {
        constructor(e, t, r) {
          (this.carbon = e),
            (this.getTeamMembersData = t),
            (this.teamPlanDetailsClient = r),
            (this.getUserLogin = () => {
              const { carbonState: e } = this.carbon.queries;
              return e({ path: "state.userSession.account.login" }).pipe(
                (0, y.U)((e) => {
                  if ((0, f.d6)(e) && "string" == typeof e.data) return e.data;
                  throw new Error("No active login");
                })
              );
            }),
            (this.getTeamId = () => {
              const { getTeamId: e } = this.teamPlanDetailsClient.queries;
              return e().pipe(
                (0, T.w)((e) => {
                  if ((0, f.hx)(e) || !e.data.teamId || "" === e.data.teamId) throw new Error("Error : could not retrieve teamId");
                  return (0, A.of)(e.data.teamId);
                })
              );
            });
        }
        execute() {
          const e = this.getUserLogin();
          return this.getTeamId().pipe(
            (0, T.w)((t) =>
              this.getTeamMembersData.get(t).pipe(
                (0, C.V)(e),
                (0, y.U)(([e, t]) => {
                  if ((0, f.hx)(e)) throw new Error("Error : could not retrieve team's members");
                  const { data: r } = e,
                    s = r.members
                      .filter((e) => e.isTeamCaptain && "accepted" === e.status)
                      .sort((e, t) => (e.joinedDateUnix ?? 0) - (t.joinedDateUnix ?? 0));
                  return (0, f.Vp)(s[0]?.login === t);
                })
              )
            )
          );
        }
      };
      O = (0, s.__decorate)([(0, g.e)(I.G), (0, s.__metadata)("design:paramtypes", [R.CarbonLegacyClient, F, x.e])], O);
      var N = r(78651);
      let k = class {
        constructor(e) {
          (this.serverApiClient = e),
            (this.get = () =>
              this.serverApiClient.v1.teams.teamStatus({}).pipe(
                (0, P.Qn)(({ data: e }) => e),
                (0, P.DZ)((e) => {
                  throw e;
                })
              ));
        }
      };
      k = (0, s.__decorate)([(0, D.GS)(), (0, s.__metadata)("design:paramtypes", [U.l])], k);
      let L = class {
        constructor(e, t, r) {
          (this.getTeamStatusData = e), (this.getTeamMembersData = t), (this.teamPlanDetailsClient = r);
        }
        execute() {
          return this.teamPlanDetailsClient.queries.getTeamId().pipe(
            (0, T.w)((e) => {
              if ((0, f.hx)(e) || !e.data.teamId || "" === e.data.teamId) throw new Error("Error : could not retrieve teamId");
              return this.getTeamStatusData.get().pipe(
                (0, C.V)(this.getTeamMembersData.get(e.data.teamId)),
                (0, y.U)(([e, t]) => {
                  if ((0, f.hx)(e) || (0, f.hx)(t)) throw new Error("Error : could not retrieve team status or team's members");
                  const { data: r } = e,
                    { data: s } = t,
                    a = r.seats.paid + r.seats.extraFree - r.seats.remaining,
                    n = s.members.filter((e) => "accepted" === e.status);
                  return (0, f.Vp)({
                    hasMinimumMemberCount: a >= 2,
                    hasMoreThanOneAdmin: Object.keys(r.info.teamCaptains).length > 1,
                    hasSecurityScore: !!r.securityScore,
                    hasOnlyOneMember: 1 === n.length,
                    isSharingDisabled: r.info.sharingDisabled ?? !1
                  });
                })
              );
            })
          );
        }
      };
      L = (0, s.__decorate)([(0, g.e)(N.M), (0, s.__metadata)("design:paramtypes", [k, F, x.e])], L);
      var M = r(63663),
        V = r(59448);
      let G = class {
        constructor(e) {
          this.store = e;
        }
        async execute() {
          const e = await this.store.getState();
          return await this.store.set({ ...e, hasVisitedVault: !0 }), Promise.resolve((0, f.Vp)(void 0));
        }
      };
      G = (0, s.__decorate)([(0, M.W)(V.R), (0, s.__metadata)("design:paramtypes", [m])], G);
      var j = r(76560);
      let q = class {
        constructor(e) {
          this.store = e;
        }
        async execute() {
          const e = await this.store.getState();
          return await this.store.set({ ...e, hasSeenGetStarted: !0 }), Promise.resolve((0, f.Vp)(void 0));
        }
      };
      q = (0, s.__decorate)([(0, M.W)(j.g), (0, s.__metadata)("design:paramtypes", [m])], q);
      var K = r(6725);
      let W = class {
        constructor(e) {
          this.store = e;
        }
        async execute({ body: e }) {
          const t = await this.store.getState(),
            r = { ...t.notifications, [e.notification]: !0 };
          return await this.store.set({ ...t, notifications: r }), Promise.resolve((0, f.Vp)(void 0));
        }
      };
      W = (0, s.__decorate)([(0, M.W)(K.f), (0, s.__metadata)("design:paramtypes", [m])], W);
      let B = class {};
      B = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: i.h,
            stores: [m],
            imports: [n.n],
            providers: [k, F],
            handlers: {
              commands: { markVaultAsVisited: G, markGetStartedAsSeen: q, markNotificationAsSeen: W },
              events: {},
              queries: { hasSeenGetStarted: w, hasSeenNotification: E, hasVisitedVault: b, isTeamCreator: O, teamTasksCompletion: L }
            },
            requiredFeatureFlips: ["onboarding_web_tacgetstarted"]
          })
        ],
        B
      );
    },
    92447: (e, t, r) => {
      "use strict";
      r.d(t, { X: () => g });
      var s = r(88802),
        a = r(99634),
        n = r(1824),
        i = r(13823),
        o = r(63663),
        c = r(2564),
        u = r(60399),
        d = r(57924),
        l = r(61501),
        p = r(48844),
        h = r(87279);
      let m = class {
        constructor(e) {
          this.serverApiClient = e;
        }
        async callProposeMembers({ proposedMemberLogins: e, force: t, origin: r, notificationOptions: s }) {
          try {
            return await (0, u.z)(
              this.serverApiClient.v1.teams.proposeMembers({ proposedMemberLogins: e, force: t, origin: r, notificationOptions: s }).pipe(
                (0, p.DZ)((e) => {
                  if ("BusinessError" === e.tag) return (0, c.Wv)(e.code);
                  throw new Error(e.message);
                }),
                (0, p.lk)((e) => (0, h.Vp)(e.data))
              )
            );
          } catch (e) {
            return (0, h.Rn)({ tag: "failure", error: `Propose Members failed - ${e}` });
          }
        }
      };
      m = (0, s.__decorate)([(0, d.GS)(), (0, s.__metadata)("design:paramtypes", [l.l])], m);
      let y = class {
        constructor(e) {
          this.proposeMembersService = e;
        }
        execute({ body: { proposedMemberLogins: e, force: t, origin: r, notificationOptions: s } }) {
          return this.proposeMembersService.callProposeMembers({ proposedMemberLogins: e, force: t, origin: r, notificationOptions: s });
        }
      };
      y = (0, s.__decorate)([(0, o.W)(c.og), (0, s.__metadata)("design:paramtypes", [m])], y);
      let g = class {};
      g = (0, s.__decorate)(
        [(0, a.Y)({ api: i.L, imports: [n.n], providers: [m], handlers: { commands: { proposeMembers: y }, events: {}, queries: {} } })],
        g
      );
    },
    65529: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => g });
      var s = r(88802),
        a = r(99634),
        n = r(1824),
        i = r(46888),
        o = r(20754),
        c = r(42014),
        u = r(57924),
        d = r(61501),
        l = r(87279),
        p = r(48844),
        h = r(87065);
      let m = class {
        constructor(e) {
          (this.serverApiClient = e),
            (this.getTeamReport = () =>
              this.getTeamReportData().pipe(
                (0, h.U)((e) => {
                  if ((0, l.hx)(e)) throw new Error("could't retrieve team report");
                  const { data: t } = e;
                  return (0, l.Vp)(t);
                })
              )),
            (this.getTeamReportData = () =>
              this.serverApiClient.v1.teams.report({}).pipe(
                (0, p.Qn)(({ data: e }) => e),
                (0, p.DZ)((e) => {
                  throw e;
                })
              ));
        }
      };
      m = (0, s.__decorate)([(0, u.GS)(), (0, s.__metadata)("design:paramtypes", [d.l])], m);
      let y = class {
        constructor(e) {
          this.teamReportService = e;
        }
        execute() {
          return this.teamReportService.getTeamReport();
        }
      };
      y = (0, s.__decorate)([(0, o.e)(c.z), (0, s.__metadata)("design:paramtypes", [m])], y);
      let g = class {};
      g = (0, s.__decorate)(
        [(0, a.Y)({ api: i.B, imports: [n.n], providers: [m], handlers: { commands: {}, events: {}, queries: { getReport: y } } })],
        g
      );
    },
    93193: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => qe });
      var s = r(88802),
        a = r(99634),
        n = r(1824),
        i = r(13511),
        o = r(34710),
        c = r(63663),
        u = r(87279),
        d = r(25904),
        l = r(60399),
        p = r(57924),
        h = r(61501),
        m = r(48844);
      let y = class {
        constructor(e) {
          (this.serverApiClient = e),
            (this.extendFreeTrial = async () =>
              await (0, l.z)(
                this.serverApiClient.v1.teams.extendFreeTrial({}).pipe(
                  (0, m.DZ)((e) => (0, u.Rn)({ tag: `ExtendFreeTrial command failed with message: ${e.message}` })),
                  (0, m.lk)(() => (0, u.Vp)(void 0))
                )
              ));
        }
      };
      y = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [h.l])], y);
      var g = r(87065),
        v = r(95233),
        f = r(53576),
        w = r(7165);
      const S = w.z.array(
        w.z.object({
          details: w.z.object({ isBillingAdmin: w.z.boolean(), isTeamAdmin: w.z.boolean(), status: w.z.nativeEnum(f.SpaceStatus) })
        })
      );
      let E = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        async isUserTeamAdmin() {
          return await (0, l.z)(
            this.carbonLegacyClient.queries.carbonState({ path: "userSession.spaceData.spaces" }).pipe(
              (0, g.U)((e) => {
                return (
                  !((0, u.hx)(e) || ((t = e.data), !S.safeParse(t).success) || 0 === e.data.length) &&
                  e.data.some((e) => e.details.status === f.SpaceStatus.Accepted && (e.details.isBillingAdmin || e.details.isTeamAdmin))
                );
                var t;
              })
            )
          );
        }
      };
      var _, b, T, A, C;
      (E = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [f.CarbonLegacyClient])], E)),
        (function (e) {
          (e.Legacy = "legacy"), (e.Starter = "starter"), (e.Team = "team"), (e.Business = "business"), (e.Enterprise = "entreprise");
        })(_ || (_ = {})),
        (function (e) {
          (e.ProcessOut = "processout"), (e.Invoice = "invoice");
        })(b || (b = {})),
        (function (e) {
          (e.USD = "usd"), (e.EUR = "eur");
        })(T || (T = {})),
        (function (e) {
          (e.Pending = "pending"), (e.Canceled = "canceled"), (e.None = "none");
        })(A || (A = {})),
        (function (e) {
          (e.NoInternalUsage = "no_internal_usage"),
            (e.NoNeedForPasswordManager = "no_need_for_password_manager"),
            (e.ChoseOtherPasswordManager = "chose_other_password_manager"),
            (e.MissingCriticalFeatures = "missing_critical_features"),
            (e.TechnicalIssues = "technical_issues"),
            (e.TooExpensive = "too_expensive"),
            (e.Other = "other");
        })(C || (C = {}));
      var R;
      !(function (e) {
        (e.InTeam = "in_team"),
          (e.NotPremium = "not_premium"),
          (e.NoPayment = "no_payment"),
          (e.IsUnpaidFamilyMember = "is_unpaid_family_member"),
          (e.DefaultSettings = "default_settings"),
          (e.NoVPNCapability = "no_vpn_capability"),
          (e.DisabledForFreeUser = "disabled_for_free_user");
      })(R || (R = {}));
      const I = w.z.object({
          allowPersistenceForMasterPassword: w.z.boolean(),
          allowSharing: w.z.boolean(),
          sharingRestrictedToTeam: w.z.boolean(),
          enforce2FA: w.z.boolean(),
          cryptoForcedPayload: w.z.string(),
          disableAutoLoginDomains: w.z.array(w.z.string()),
          enableForcedDomains: w.z.boolean(),
          enablePersonalSpace: w.z.boolean(),
          enableRemoveForcedContent: w.z.boolean(),
          enableVPN: w.z.boolean(),
          forceAutomaticLogout: w.z.number(),
          lockOnExit: w.z.boolean(),
          vaultExportEnabled: w.z.boolean(),
          collectSensitiveDataAuditLogsEnabled: w.z.boolean(),
          ssoEnabled: w.z.boolean(),
          ssoProvisioning: w.z.boolean(),
          teamDomain: w.z.array(w.z.string()),
          restrictSharingToTeam: w.z.boolean()
        }),
        x = (e) => {
          switch (e) {
            case "legacy":
            default:
              return _.Legacy;
            case "starter":
              return _.Starter;
            case "team":
              return _.Team;
            case "business":
              return _.Business;
            case "entreprise":
              return _.Enterprise;
          }
        },
        P = (e) => {
          switch (e) {
            case "in_team":
              return R.InTeam;
            case "not_premium":
              return R.NotPremium;
            case "no_payment":
              return R.NoPayment;
            case "is_unpaid_family_member":
              return R.IsUnpaidFamilyMember;
            case "default_settings":
            default:
              return R.DefaultSettings;
            case "no_vpn_capability":
              return R.NoVPNCapability;
            case "disabled_for_free_user":
              return R.DisabledForFreeUser;
          }
        },
        D = (e) => ({
          allowPersistenceForMasterPassword: !e.mpPersistenceDisabled,
          allowSharing: !e.sharingDisabled,
          sharingRestrictedToTeam: !!e.sharingRestrictedToTeam,
          enforce2FA: "newDevice" === e.twoFAEnforced,
          cryptoForcedPayload: e.cryptoForcedPayload ?? "",
          disableAutoLoginDomains: e.autologinDomainDisabledArray ?? [],
          enableForcedDomains: !!e.forcedDomainsEnabled,
          enablePersonalSpace: !!e.personalSpaceEnabled,
          enableRemoveForcedContent: !!e.removeForcedContentEnabled,
          enableVPN: !!e.secureWifiEnabled,
          forceAutomaticLogout: Number(e.forceAutomaticLogout || 0),
          lockOnExit: !!e.lockOnExit,
          vaultExportEnabled: !!e.vaultExportEnabled,
          collectSensitiveDataAuditLogsEnabled: !!e.collectSensitiveDataAuditLogsEnabled,
          ssoEnabled: !!e.ssoEnabled,
          ssoProvisioning: "automatic" === e.ssoProvisioning,
          teamDomain: e.teamDomains ?? [],
          restrictSharingToTeam: !!e.sharingRestrictedToTeam
        }),
        U = (e, t, r) => {
          const s = [];
          return (
            r?.added && r.added.forEach((t) => s.push({ type: e, value: t })),
            r?.removed && r.removed.forEach((e) => s.push({ type: t, value: e })),
            s
          );
        },
        F = (e, t) => (void 0 !== t ? [{ type: e, value: t }] : []),
        O = (e) => {
          const { enabled: t, info: r } = e;
          let s;
          return (
            r &&
              (s = {
                limit: r.limit ?? void 0,
                maxFileSize: r.maxFileSize ?? void 0,
                quota: r.quota ?? void 0,
                reason: r.reason ? P(r.reason) : void 0
              }),
            { enabled: t, info: s }
          );
        },
        N = (e) => {
          const { activeDirectorySync: t, activityLog: r, phoneSupport: s, samlProvisioning: a, scim: n, sso: i, usageReports: o } = e;
          return {
            activeDirectorySync: O(t),
            activityLog: O(r),
            phoneSupport: O(s),
            samlProvisioning: O(a),
            scim: O(n),
            sso: O(i),
            usageReports: O(o)
          };
        },
        k = (e, t) => ({ ...e, planTier: x(t) }),
        L = (e) => new Set(Object.keys(e));
      var M = r(95681),
        V = r(23347),
        G = r(25029);
      const j = w.z.union([
          w.z.object({
            reason: w.z.union([w.z.custom(), w.z.undefined()]),
            quota: w.z.union([
              w.z.object({ max: w.z.union([w.z.number(), w.z.undefined()]), remaining: w.z.union([w.z.number(), w.z.undefined()]) }),
              w.z.undefined()
            ]),
            maxFileSize: w.z.union([w.z.number(), w.z.undefined()]),
            limit: w.z.union([w.z.number(), w.z.undefined()])
          }),
          w.z.undefined()
        ]),
        q = w.z.object({ paid: w.z.number(), extraFree: w.z.number(), remaining: w.z.number() }),
        K = w.z.object({
          billingMethod: w.z.union([w.z.custom(), w.z.undefined()]),
          creditCardLastDigits: w.z.union([w.z.string(), w.z.undefined()]),
          isFreeTrial: w.z.boolean(),
          isGracePeriod: w.z.boolean(),
          planTier: w.z.custom(),
          lastBillingDateUnix: w.z.number(),
          nextBillingDetails: w.z.object({
            amount: w.z.number(),
            currency: w.z.union([w.z.literal("eur"), w.z.literal("usd")]),
            dateUnix: w.z.number()
          }),
          usersToBeRenewedCount: w.z.number()
        }),
        W = w.z.object({ enabled: w.z.boolean(), info: j }),
        B = w.z.object({ samlProvisioning: W, sso: W, scim: W, phoneSupport: W, activeDirectorySync: W, activityLog: W, usageReports: W }),
        z = w.z.object({
          isBillingOrFullAdmin: w.z.literal(!0),
          lastRefreshDate: w.z.number(),
          billing: K,
          seats: q,
          capabilities: B,
          securityScore: w.z.number().nullable(),
          creationDateUnix: w.z.number(),
          teamName: w.z.string(),
          teamRoles: w.z.object({ groupManagersIds: w.z.array(w.z.number()), teamCaptainsIds: w.z.set(w.z.string()) }),
          policies: I
        }),
        H = w.z.object({ isBillingOrFullAdmin: w.z.literal(!1) }),
        $ = w.z.discriminatedUnion("isBillingOrFullAdmin", [z, H]),
        Q = (e) => $.safeParse(e).success;
      class Y extends (0, M.Q)({
        initialValue: { isBillingOrFullAdmin: !1 },
        storeTypeGuard: Q,
        persist: !1,
        scope: G.F.User,
        storeName: "team-admin-store",
        capacity: V.Y._010KB
      }) {}
      let X = class {
        constructor(e, t, r) {
          (this.serverApiClient = e),
            (this.isUserTeamAdminService = t),
            (this.teamAdminStore = r),
            (this.MIN_DELAY_BETWEEN_REFRESHES = 500);
        }
        async refreshState() {
          if (!(await this.isUserTeamAdminService.isUserTeamAdmin())) return void this.teamAdminStore.set({ isBillingOrFullAdmin: !1 });
          const e = await this.teamAdminStore.getState();
          return e.isBillingOrFullAdmin && e.lastRefreshDate + this.MIN_DELAY_BETWEEN_REFRESHES > Date.now()
            ? void 0
            : await (0, l.z)(
                this.serverApiClient.v1.teams.teamStatus({}).pipe(
                  (0, g.U)((e) =>
                    (0, u.hx)(e)
                      ? { isBillingOrFullAdmin: !1 }
                      : ((e) => {
                          const { securityScore: t, creationDateUnix: r, billing: s, capabilities: a, seats: n, planTier: i, info: o } = e,
                            { name: c, groupManagers: u, teamCaptains: d } = o;
                          return {
                            isBillingOrFullAdmin: !0,
                            creationDateUnix: r,
                            teamName: c,
                            securityScore: t,
                            seats: n,
                            capabilities: N(a),
                            billing: k(s, i),
                            teamRoles: { groupManagersIds: u, teamCaptainsIds: L(d) },
                            lastRefreshDate: Date.now(),
                            policies: D(o)
                          };
                        })(e.data.data)
                  ),
                  (0, v.b)((e) => {
                    this.teamAdminStore.set(e);
                  })
                )
              );
        }
      };
      X = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [h.l, E, Y])], X);
      let J = class {
        constructor(e, t) {
          (this.freeTrialService = e), (this.teamAdminService = t);
        }
        async execute() {
          const e = await this.freeTrialService.extendFreeTrial();
          return (0, u.d6)(e) && (await this.teamAdminService.refreshState()), e;
        }
      };
      J = (0, s.__decorate)([(0, c.W)(d.N), (0, s.__metadata)("design:paramtypes", [y, X])], J);
      var Z = r(82276);
      let ee = class {
        execute() {
          return Promise.resolve((0, u.Vp)(void 0));
        }
      };
      ee = (0, s.__decorate)([(0, c.W)(Z.y)], ee);
      var te = r(26657);
      let re = class {
        constructor(e, t) {
          (this.teamAdminService = e), (this.serverApiClient = t);
        }
        async execute({ body: e }) {
          const { teamId: t, policyUpdates: r } = e;
          return (
            await (0, l.z)(
              this.serverApiClient.v1.teams.editSettings(
                ((e, t) => {
                  const r = [
                    ...U("add_team_domain", "remove_team_domain", t.teamDomain),
                    ...U("add_autologin_domain_disabled", "remove_autologin_domain_disabled", t.disableAutoLoginDomains),
                    ...F("set_forced_domains_enabled", t.enableForcedDomains),
                    ...F("set_rm_forced_content_enabled", t.enableRemoveForcedContent),
                    ...F("set_vault_export_enabled", t.vaultExportEnabled),
                    ...F("set_secure_wifi", t.enableVPN),
                    ...F("set_lock_on_exit", t.lockOnExit),
                    ...F("set_collect_sensitive_data_audit_logs_enabled", t.collectSensitiveDataAuditLogsEnabled),
                    ...F("set_sharing_restricted_to_team", t.restrictSharingToTeam),
                    ...((s = "set_sharing_disabled"), (a = t.allowSharing), void 0 !== a ? [{ type: s, value: !a }] : [])
                  ];
                  var s, a;
                  return (
                    void 0 !== t.enforce2FA &&
                      r.push({ type: "set_two_factor_authentication_enforced", value: t.enforce2FA ? "newDevice" : "disabled" }),
                    void 0 !== t.forceAutomaticLogout &&
                      r.push({
                        type: null === t.forceAutomaticLogout ? "unset_force_automatic_logout" : "set_force_automatic_logout",
                        value: t.forceAutomaticLogout
                      }),
                    void 0 !== t.cryptoForcedPayload && r.push({ type: "set_crypto_forced_payload", value: t.cryptoForcedPayload }),
                    void 0 !== t.ssoProvisioning &&
                      r.push({ type: "set_sso_provisioning", value: t.ssoProvisioning ? "automatic" : "disabled" }),
                    { operations: r, teamId: e }
                  );
                })(t, r)
              )
            ),
            await this.teamAdminService.refreshState(),
            (0, u.Vp)(void 0)
          );
        }
      };
      re = (0, s.__decorate)([(0, c.W)(te.m), (0, s.__metadata)("design:paramtypes", [X, h.l])], re);
      var se = r(162),
        ae = r(20754),
        ne = r(26992),
        ie = r(25859),
        oe = r(85390),
        ce = r(95557),
        ue = r(10994),
        de = r(92481),
        le = r(50793);
      const pe = (e) => {
          if (!e) return new Date();
          const t = (0, ce.Z)(e, "yyyy-MM-dd", new Date());
          return "Invalid Date" !== t.toString() ? t : new Date(e);
        },
        he = (e) => {
          const t = pe((0, ue.Z)(e).toString());
          return (0, de.Z)(t, "yyyy-MM-dd") === (0, de.Z)(pe(new Date().toString()), "yyyy-MM-dd");
        },
        me = (e) => {
          const t = new Date(),
            r = (0, ue.Z)(e);
          return r.setDate(r.getDate() + 6), (s = r), t.setHours(0, 0, 0, 0) <= s.setHours(0, 0, 0, 0);
          var s;
        },
        ye = (e) => (0, le.Z)((0, ue.Z)(e), new Date());
      let ge = class {
        constructor(e, t, r) {
          (this.carbon = e),
            (this.teamAdminStore = t),
            (this.teamAdminService = r),
            (this.getTeamTrialStatus = () =>
              (0, ie.P)(
                () => (
                  this.teamAdminService.refreshState(),
                  this.teamAdminStore.state$.pipe(
                    (0, g.U)((e) => {
                      if (!e.isBillingOrFullAdmin) throw new Error("Error : could not retrieve team status");
                      const t = {
                        isFreeTrial: e.billing.isFreeTrial,
                        isGracePeriod: e.billing.isGracePeriod,
                        isFirstDayOfTrial: he(e.creationDateUnix),
                        isSecondStageOfTrial: me(e.creationDateUnix),
                        daysLeftInTrial: ye(e.billing.nextBillingDetails.dateUnix),
                        spaceTier: e.billing.planTier
                      };
                      return (0, u.Vp)(t);
                    })
                  )
                )
              )),
            (this.getTeamBillingDetails = () =>
              (0, oe.a)([this.teamAdminStore.state$, this.getTeamSubscriptionInformation()]).pipe(
                (0, g.U)(([e, t]) => {
                  if (!e.isBillingOrFullAdmin) throw new Error("Error : could not retrieve team status");
                  const { billing: r, seats: s } = e,
                    a = {
                      amount: r.nextBillingDetails.amount,
                      currency: "usd" === r.nextBillingDetails.currency ? T.USD : T.EUR,
                      dateUnix: r.nextBillingDetails.dateUnix
                    };
                  return (0, u.Vp)({
                    billingType: "invoice" === t?.billingInformation?.billingType ? b.Invoice : b.ProcessOut,
                    spaceTier: r.planTier,
                    creditCardLastDigits: t?.billingInformation?.last4 ?? null,
                    lastBillingDateUnix: r.lastBillingDateUnix,
                    nextBillingDetails: a,
                    seatsNumber: s.paid + s.extraFree,
                    usersToBeRenewedCount: r.usersToBeRenewedCount,
                    daysLeftUntilNextBillingPeriod: ye(r.nextBillingDetails.dateUnix)
                  });
                })
              )),
            (this.getTeamCapabilities = () =>
              this.teamAdminStore.state$.pipe(
                (0, g.U)((e) => {
                  if (!e.isBillingOrFullAdmin) throw new Error("Error : could not retrieve team status");
                  return (0, u.Vp)(e.capabilities);
                })
              )),
            (this.getTeamCreationDateUnix = () =>
              this.teamAdminStore.state$.pipe(
                (0, g.U)((e) => {
                  if (!e.isBillingOrFullAdmin) throw new Error("Error : could not retrieve team status");
                  return (0, u.Vp)(e.creationDateUnix);
                })
              )),
            (this.getTeamSeats = () =>
              this.teamAdminStore.state$.pipe(
                (0, g.U)((e) => {
                  if (!e.isBillingOrFullAdmin) throw new Error("Error : could not retrieve team status");
                  return (0, u.Vp)(e.seats);
                })
              )),
            (this.getTeamSecurityScore = () =>
              this.teamAdminStore.state$.pipe(
                (0, g.U)((e) => {
                  if (!e.isBillingOrFullAdmin) throw new Error("Error : could not retrieve team status");
                  return (0, u.Vp)(e.securityScore);
                })
              )),
            (this.getTeamName = () =>
              this.teamAdminStore.state$.pipe(
                (0, g.U)((e) => {
                  if (!e.isBillingOrFullAdmin) throw new Error("Error : could not retrieve team status");
                  return (0, u.Vp)(e.teamName);
                })
              )),
            (this.getTeamRoles = () =>
              this.teamAdminStore.state$.pipe(
                (0, g.U)((e) => {
                  if (!e.isBillingOrFullAdmin) throw new Error("Error : could not retrieve team status");
                  return (0, u.Vp)(e.teamRoles);
                })
              )),
            (this.getTeamSubscriptionInformation = () => {
              const { getSubscriptionInformation: e } = this.carbon.queries;
              return e().pipe(
                (0, g.U)((e) => {
                  if (!(0, u.d6)(e)) throw new Error("Cannot retrieve subscription information from Carbon");
                  return (0, u.db)(e).b2bSubscription;
                })
              );
            }),
            (this.getTeamPolicies = () =>
              (0, ie.P)(
                () => (
                  this.teamAdminService.refreshState(),
                  this.teamAdminStore.state$.pipe(
                    (0, g.U)((e) => {
                      if (!e.isBillingOrFullAdmin) throw new Error("Error : could not retrieve team status");
                      return (0, u.Vp)(e.policies);
                    })
                  )
                )
              ));
        }
      };
      ge = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [f.CarbonLegacyClient, Y, X])], ge);
      let ve = class {
        constructor(e) {
          this.getTeamPlanDetailsService = e;
        }
        execute() {
          return (0, se.D)(this.getTeamPlanDetailsService.getTeamBillingDetails());
        }
      };
      ve = (0, s.__decorate)([(0, ae.e)(ne._), (0, s.__metadata)("design:paramtypes", [ge])], ve);
      var fe = r(69885),
        we = r(9128);
      let Se = class {
        execute() {
          return (0, fe.of)((0, u.Vp)(A.None));
        }
      };
      Se = (0, s.__decorate)([(0, ae.e)(we.F)], Se);
      var Ee = r(30525);
      let _e = class {
        constructor(e) {
          this.getTeamPlanDetailsService = e;
        }
        execute() {
          return (0, se.D)(this.getTeamPlanDetailsService.getTeamCapabilities());
        }
      };
      _e = (0, s.__decorate)([(0, ae.e)(Ee.Y), (0, s.__metadata)("design:paramtypes", [ge])], _e);
      var be = r(89859);
      let Te = class {
        constructor(e) {
          this.getTeamPlanDetailsService = e;
        }
        execute() {
          return (0, se.D)(this.getTeamPlanDetailsService.getTeamCreationDateUnix());
        }
      };
      Te = (0, s.__decorate)([(0, ae.e)(be.T), (0, s.__metadata)("design:paramtypes", [ge])], Te);
      var Ae = r(19068);
      let Ce = class {
        constructor(e) {
          this.carbon = e;
        }
        execute() {
          const { carbonState: e } = this.carbon.queries;
          return e({ path: "state.userSession.spaceData.spaces" })
            .pipe(
              (0, g.U)((e) => {
                if (!(0, u.d6)(e)) throw new Error("Cannot retrieve user spaces");
                const t = e.data.find((e) => "accepted" === e.details.status);
                return t ? { teamId: t.teamId } : { teamId: null };
              })
            )
            .pipe((0, g.U)(u.Vp));
        }
      };
      Ce = (0, s.__decorate)([(0, ae.e)(Ae.e), (0, s.__metadata)("design:paramtypes", [f.CarbonLegacyClient])], Ce);
      var Re = r(80926);
      let Ie = class {
        constructor(e) {
          this.getTeamPlanDetailsService = e;
        }
        execute() {
          return (0, se.D)(this.getTeamPlanDetailsService.getTeamName());
        }
      };
      Ie = (0, s.__decorate)([(0, ae.e)(Re.j), (0, s.__metadata)("design:paramtypes", [ge])], Ie);
      var xe = r(64380);
      let Pe = class {
        constructor(e) {
          this.getTeamPlanDetailsService = e;
        }
        execute() {
          return (0, se.D)(this.getTeamPlanDetailsService.getTeamRoles());
        }
      };
      Pe = (0, s.__decorate)([(0, ae.e)(xe.R), (0, s.__metadata)("design:paramtypes", [ge])], Pe);
      var De = r(65245);
      let Ue = class {
        constructor(e) {
          this.getTeamPlanDetailsService = e;
        }
        execute() {
          return (0, se.D)(this.getTeamPlanDetailsService.getTeamPolicies());
        }
      };
      Ue = (0, s.__decorate)([(0, ae.e)(De.K), (0, s.__metadata)("design:paramtypes", [ge])], Ue);
      var Fe = r(704);
      let Oe = class {
        constructor(e) {
          this.getTeamPlanDetailsService = e;
        }
        execute() {
          return (0, se.D)(this.getTeamPlanDetailsService.getTeamSeats());
        }
      };
      Oe = (0, s.__decorate)([(0, ae.e)(Fe.W), (0, s.__metadata)("design:paramtypes", [ge])], Oe);
      var Ne = r(27056);
      let ke = class {
        constructor(e) {
          this.getTeamPlanDetailsService = e;
        }
        execute() {
          return (0, se.D)(this.getTeamPlanDetailsService.getTeamSecurityScore());
        }
      };
      ke = (0, s.__decorate)([(0, ae.e)(Ne.R), (0, s.__metadata)("design:paramtypes", [ge])], ke);
      var Le = r(207);
      let Me = class {
        constructor(e) {
          this.getTeamPlanDetailsService = e;
        }
        execute() {
          return (0, se.D)(this.getTeamPlanDetailsService.getTeamTrialStatus());
        }
      };
      Me = (0, s.__decorate)([(0, ae.e)(Le.P), (0, s.__metadata)("design:paramtypes", [ge])], Me);
      var Ve = r(5237),
        Ge = r(68307);
      let je = class {
        constructor(e) {
          this.teamAdminService = e;
        }
        async handle() {
          await this.teamAdminService.refreshState();
        }
      };
      je = (0, s.__decorate)([(0, Ge.b)(Ve.M), (0, s.__metadata)("design:paramtypes", [X])], je);
      let qe = class {};
      qe = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: i.o,
            imports: [n.n],
            providers: [y, ge, X, E],
            stores: [Y],
            handlers: {
              commands: { extendFreeTrial: J, requestTeamPlanCancellation: ee, editTeamPolicies: re },
              events: { ...(0, a.g)(o.Q, { sessionOpened: je }) },
              queries: {
                getTeamBillingInformation: ve,
                getTeamCancellationStatus: Se,
                getTeamCapabilities: _e,
                getTeamCreationDateUnix: Te,
                getTeamId: Ce,
                getTeamName: Ie,
                getTeamRoles: Pe,
                getTeamPolicies: Ue,
                getTeamSeats: Oe,
                getTeamSecurityScore: ke,
                getTeamTrialStatus: Me
              }
            }
          })
        ],
        qe
      );
    },
    34431: (e, t, r) => {
      "use strict";
      r.d(t, { K: () => S });
      var s = r(88802),
        a = r(99634),
        n = r(1824),
        i = r(1701),
        o = r(63663),
        c = r(57220),
        u = r(60399),
        d = r(57924),
        l = r(61501),
        p = r(48844),
        h = r(87279),
        m = r(36767),
        y = r(56333);
      let g = class {
        constructor(e) {
          this.serverApiClient = e;
        }
        async deleteTeamVat() {
          return await (0, u.z)(
            this.serverApiClient.v1.teams.deleteTeamVat().pipe(
              (0, p.DZ)((e) => {
                if ("BusinessError" === e.tag) return (0, c.zK)(e.code);
                throw new Error(e.message);
              }),
              (0, p.lk)((e) => (0, h.Vp)(e.data))
            )
          );
        }
        async getTeamVat() {
          return await (0, u.z)(
            this.serverApiClient.v1.teams.getTeamVat().pipe(
              (0, p.DZ)((e) => {
                if ("BusinessError" === e.tag) return (0, m.K$)(e.code);
                throw new Error(e.message);
              }),
              (0, p.lk)((e) => (0, h.Vp)(e.data))
            )
          );
        }
        async upsertTeamVat({ newVATNumber: e }) {
          return await (0, u.z)(
            this.serverApiClient.v1.teams.upsertTeamVat({ newVATNumber: e }).pipe(
              (0, p.DZ)((e) => {
                if ("BusinessError" === e.tag) return (0, y.q5)(e.code);
                throw new Error(e.message);
              }),
              (0, p.lk)((e) => (0, h.Vp)(e.data))
            )
          );
        }
      };
      g = (0, s.__decorate)([(0, d.GS)(), (0, s.__metadata)("design:paramtypes", [l.l])], g);
      let v = class {
        constructor(e) {
          this.teamVatService = e;
        }
        execute() {
          return this.teamVatService.deleteTeamVat();
        }
      };
      v = (0, s.__decorate)([(0, o.W)(c.Hy), (0, s.__metadata)("design:paramtypes", [g])], v);
      let f = class {
        constructor(e) {
          this.teamVatService = e;
        }
        execute() {
          return this.teamVatService.getTeamVat();
        }
      };
      f = (0, s.__decorate)([(0, o.W)(m.cf), (0, s.__metadata)("design:paramtypes", [g])], f);
      let w = class {
        constructor(e) {
          this.teamVatService = e;
        }
        execute({ body: { newVATNumber: e } }) {
          return this.teamVatService.upsertTeamVat({ newVATNumber: e });
        }
      };
      w = (0, s.__decorate)([(0, o.W)(y.XW), (0, s.__metadata)("design:paramtypes", [g])], w);
      let S = class {};
      S = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: i.a,
            imports: [n.n],
            providers: [g],
            handlers: { commands: { deleteTeamVat: v, getTeamVat: f, upsertTeamVat: w }, events: {}, queries: {} }
          })
        ],
        S
      );
    },
    59360: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          CanUserAddNewPasswordQuery: () => q.K,
          CollectionsQuery: () => L.I,
          Country: () => i,
          CreateCollectionCommand: () => O.e,
          CreateVaultItemCommand: () => o._,
          CreatedEvent: () => p.J,
          DeleteCollectionCommand: () => F.T,
          DeleteVaultItemsCommand: () => c.c,
          DeletedEvent: () => h.s,
          DomainIconDetailsMapSchema: () => _.x,
          DomainIconDetailsQuery: () => y.s,
          DomainIconDetailsSchema: () => _.N,
          EmailType: () => E,
          EmitTemporaryVaultItemEventCommand: () => l.c,
          EventType: () => l.t,
          FilterOperators: () => g.l,
          GetPasswordLimitStatusQuery: () => K.r,
          GetVaultNotificationsStatusQuery: () => D.M,
          IdentityTitle: () => T.t,
          MigrateCategoriesCommand: () => k._,
          NoteColors: () => C.L,
          OperationType: () => N.C,
          PaymentCardColorType: () => b.X,
          PhoneType: () => A.z,
          SecureNoteCategoryQuery: () => v.F,
          SecureNoteSchema: () => C._,
          SetVaultNotificationsStatusCommand: () => P.x,
          SortDirection: () => f.S,
          TempCredentialPreferencesQuery: () => w.M,
          TempCredentialPreferencesUpdateCommand: () => d.m,
          UpdateCollectionCommand: () => N.s,
          UpdateVaultItemCommand: () => u.K,
          UpdatedEvent: () => m.V,
          VaultItemType: () => R.U,
          VaultItemTypeToResultDictionary: () => I,
          VaultItemsCrudClient: () => n,
          VaultItemsQuery: () => S.W,
          VaultOrganizationClient: () => M.C,
          VaultSearchQuery: () => G.W,
          passwordLimitApi: () => j.Z,
          vaultItemsCrudApi: () => s.L,
          vaultNotificationsApi: () => x.e,
          vaultOrganizationApi: () => U.v,
          vaultSearchApi: () => V.R
        });
      var s = r(48430),
        a = r(67837);
      class n extends (0, a.E)(s.L) {}
      (0, a.K)(s.L, n);
      var i,
        o = r(273),
        c = r(31154),
        u = r(54547),
        d = r(55441),
        l = r(47412),
        p = r(3137),
        h = r(49135),
        m = r(72989),
        y = r(55713),
        g = r(9531),
        v = r(83984),
        f = r(24652),
        w = r(11907),
        S = r(96342);
      !(function (e) {
        (e.NO_TYPE = "NO_TYPE"),
          (e.UNIVERSAL = "UNIVERSAL"),
          (e.AD = "AD"),
          (e.AE = "AE"),
          (e.AF = "AF"),
          (e.AG = "AG"),
          (e.AI = "AI"),
          (e.AL = "AL"),
          (e.AM = "AM"),
          (e.AO = "AO"),
          (e.AQ = "AQ"),
          (e.AR = "AR"),
          (e.AS = "AS"),
          (e.AT = "AT"),
          (e.AU = "AU"),
          (e.AW = "AW"),
          (e.AX = "AX"),
          (e.AZ = "AZ"),
          (e.BA = "BA"),
          (e.BB = "BB"),
          (e.BD = "BD"),
          (e.BE = "BE"),
          (e.BF = "BF"),
          (e.BG = "BG"),
          (e.BH = "BH"),
          (e.BI = "BI"),
          (e.BJ = "BJ"),
          (e.BL = "BL"),
          (e.BM = "BM"),
          (e.BN = "BN"),
          (e.BO = "BO"),
          (e.BR = "BR"),
          (e.BS = "BS"),
          (e.BT = "BT"),
          (e.BV = "BV"),
          (e.BW = "BW"),
          (e.BY = "BY"),
          (e.BZ = "BZ"),
          (e.CA = "CA"),
          (e.CC = "CC"),
          (e.CD = "CD"),
          (e.CF = "CF"),
          (e.CG = "CG"),
          (e.CH = "CH"),
          (e.CI = "CI"),
          (e.CK = "CK"),
          (e.CL = "CL"),
          (e.CM = "CM"),
          (e.CN = "CN"),
          (e.CO = "CO"),
          (e.CR = "CR"),
          (e.CU = "CU"),
          (e.CV = "CV"),
          (e.CX = "CX"),
          (e.CY = "CY"),
          (e.CZ = "CZ"),
          (e.DE = "DE"),
          (e.DJ = "DJ"),
          (e.DK = "DK"),
          (e.DM = "DM"),
          (e.DO = "DO"),
          (e.DZ = "DZ"),
          (e.EC = "EC"),
          (e.EE = "EE"),
          (e.EG = "EG"),
          (e.EH = "EH"),
          (e.ER = "ER"),
          (e.ES = "ES"),
          (e.ET = "ET"),
          (e.FI = "FI"),
          (e.FJ = "FJ"),
          (e.FK = "FK"),
          (e.FM = "FM"),
          (e.FO = "FO"),
          (e.FR = "FR"),
          (e.GA = "GA"),
          (e.GB = "GB"),
          (e.GD = "GD"),
          (e.GE = "GE"),
          (e.GF = "GF"),
          (e.GG = "GG"),
          (e.GH = "GH"),
          (e.GI = "GI"),
          (e.GL = "GL"),
          (e.GM = "GM"),
          (e.GN = "GN"),
          (e.GP = "GP"),
          (e.GQ = "GQ"),
          (e.GR = "GR"),
          (e.GS = "GS"),
          (e.GT = "GT"),
          (e.GU = "GU"),
          (e.GW = "GW"),
          (e.GY = "GY"),
          (e.HK = "HK"),
          (e.HM = "HM"),
          (e.HN = "HN"),
          (e.HR = "HR"),
          (e.HT = "HT"),
          (e.HU = "HU"),
          (e.ID = "ID"),
          (e.IE = "IE"),
          (e.IL = "IL"),
          (e.IM = "IM"),
          (e.IN = "IN"),
          (e.IO = "IO"),
          (e.IQ = "IQ"),
          (e.IR = "IR"),
          (e.IS = "IS"),
          (e.IT = "IT"),
          (e.JE = "JE"),
          (e.JM = "JM"),
          (e.JO = "JO"),
          (e.JP = "JP"),
          (e.KE = "KE"),
          (e.KG = "KG"),
          (e.KH = "KH"),
          (e.KI = "KI"),
          (e.KM = "KM"),
          (e.KN = "KN"),
          (e.KP = "KP"),
          (e.KR = "KR"),
          (e.KW = "KW"),
          (e.KY = "KY"),
          (e.KZ = "KZ"),
          (e.LA = "LA"),
          (e.LB = "LB"),
          (e.LC = "LC"),
          (e.LI = "LI"),
          (e.LK = "LK"),
          (e.LR = "LR"),
          (e.LS = "LS"),
          (e.LT = "LT"),
          (e.LU = "LU"),
          (e.LV = "LV"),
          (e.LY = "LY"),
          (e.MA = "MA"),
          (e.MC = "MC"),
          (e.MD = "MD"),
          (e.ME = "ME"),
          (e.MF = "MF"),
          (e.MG = "MG"),
          (e.MH = "MH"),
          (e.MK = "MK"),
          (e.ML = "ML"),
          (e.MM = "MM"),
          (e.MN = "MN"),
          (e.MO = "MO"),
          (e.MP = "MP"),
          (e.MQ = "MQ"),
          (e.MR = "MR"),
          (e.MS = "MS"),
          (e.MT = "MT"),
          (e.MU = "MU"),
          (e.MV = "MV"),
          (e.MW = "MW"),
          (e.MX = "MX"),
          (e.MY = "MY"),
          (e.MZ = "MZ"),
          (e.NA = "NA"),
          (e.NC = "NC"),
          (e.NE = "NE"),
          (e.NF = "NF"),
          (e.NG = "NG"),
          (e.NI = "NI"),
          (e.NL = "NL"),
          (e.NO = "NO"),
          (e.NP = "NP"),
          (e.NR = "NR"),
          (e.NU = "NU"),
          (e.NZ = "NZ"),
          (e.OM = "OM"),
          (e.PA = "PA"),
          (e.PE = "PE"),
          (e.PF = "PF"),
          (e.PG = "PG"),
          (e.PH = "PH"),
          (e.PK = "PK"),
          (e.PL = "PL"),
          (e.PM = "PM"),
          (e.PN = "PN"),
          (e.PR = "PR"),
          (e.PS = "PS"),
          (e.PT = "PT"),
          (e.PW = "PW"),
          (e.PY = "PY"),
          (e.QA = "QA"),
          (e.RE = "RE"),
          (e.RO = "RO"),
          (e.RS = "RS"),
          (e.RU = "RU"),
          (e.RW = "RW"),
          (e.SA = "SA"),
          (e.SB = "SB"),
          (e.SC = "SC"),
          (e.SD = "SD"),
          (e.SE = "SE"),
          (e.SG = "SG"),
          (e.SH = "SH"),
          (e.SI = "SI"),
          (e.SJ = "SJ"),
          (e.SK = "SK"),
          (e.SL = "SL"),
          (e.SM = "SM"),
          (e.SN = "SN"),
          (e.SO = "SO"),
          (e.SR = "SR"),
          (e.ST = "ST"),
          (e.SV = "SV"),
          (e.SY = "SY"),
          (e.SZ = "SZ"),
          (e.TC = "TC"),
          (e.TD = "TD"),
          (e.TF = "TF"),
          (e.TG = "TG"),
          (e.TH = "TH"),
          (e.TJ = "TJ"),
          (e.TK = "TK"),
          (e.TL = "TL"),
          (e.TM = "TM"),
          (e.TN = "TN"),
          (e.TO = "TO"),
          (e.TR = "TR"),
          (e.TT = "TT"),
          (e.TV = "TV"),
          (e.TW = "TW"),
          (e.TZ = "TZ"),
          (e.UA = "UA"),
          (e.UG = "UG"),
          (e.UM = "UM"),
          (e.US = "US"),
          (e.UY = "UY"),
          (e.UZ = "UZ"),
          (e.VA = "VA"),
          (e.VC = "VC"),
          (e.VE = "VE"),
          (e.VG = "VG"),
          (e.VI = "VI"),
          (e.VN = "VN"),
          (e.VU = "VU"),
          (e.WF = "WF"),
          (e.WS = "WS"),
          (e.XK = "XK"),
          (e.YE = "YE"),
          (e.YT = "YT"),
          (e.ZA = "ZA"),
          (e.ZM = "ZM"),
          (e.ZW = "ZW");
      })(i || (i = {}));
      var E,
        _ = r(19074),
        b = r(45146);
      !(function (e) {
        (e.Perso = "PERSO"), (e.Pro = "PRO"), (e.NoType = "NO_TYPE");
      })(E || (E = {}));
      var T = r(11329),
        A = r(82009),
        C = r(7149),
        R = r(82706);
      const I = {
        [R.U.Address]: "addressesResult",
        [R.U.BankAccount]: "bankAccountsResult",
        [R.U.Company]: "companiesResult",
        [R.U.Credential]: "credentialsResult",
        [R.U.DriversLicense]: "driversLicensesResult",
        [R.U.Email]: "emailsResult",
        [R.U.FiscalId]: "fiscalIdsResult",
        [R.U.IdCard]: "idCardsResult",
        [R.U.Identity]: "identitiesResult",
        [R.U.Passkey]: "passkeysResult",
        [R.U.Passport]: "passportsResult",
        [R.U.PaymentCard]: "paymentCardsResult",
        [R.U.Phone]: "phonesResult",
        [R.U.Secret]: "secretsResult",
        [R.U.SecureNote]: "secureNotesResult",
        [R.U.SocialSecurityId]: "socialSecurityIdsResult",
        [R.U.Website]: "websitesResult"
      };
      var x = r(22499),
        P = r(12338),
        D = r(19892),
        U = r(99074),
        F = r(25041),
        O = r(533),
        N = r(96862),
        k = r(65378),
        L = r(6519),
        M = r(87969),
        V = r(73883),
        G = r(88994),
        j = r(52484),
        q = r(63197),
        K = r(58684);
    },
    52484: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => i });
      var s = r(86952),
        a = r(63197),
        n = r(58684);
      const i = (0, s.Q)({
        name: "passwordLimit",
        commands: {},
        events: {},
        queries: { canUserAddNewPassword: a.K, getPasswordLimitStatus: n.r }
      });
    },
    63197: (e, t, r) => {
      "use strict";
      r.d(t, { K: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    58684: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    48430: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => g });
      var s = r(86952),
        a = r(273),
        n = r(31154),
        i = r(54547),
        o = r(55441),
        c = r(47412),
        u = r(3137),
        d = r(49135),
        l = r(72989),
        p = r(55713),
        h = r(96342),
        m = r(83984),
        y = r(11907);
      const g = (0, s.Q)({
        name: "vaultItemsCrud",
        commands: {
          createVaultItem: a._,
          deleteVaultItems: n.c,
          updateVaultItem: i.K,
          tempCredentialPreferencesUpdate: o.m,
          emitTemporaryVaultItemEvent: c.c
        },
        events: { createdEvent: u.J, deletedEvent: d.s, updatedEvent: l.V },
        queries: { domainIconDetails: p.s, query: h.W, secureNoteCategory: m.F, tempCredentialPreferences: y.M }
      });
    },
    273: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    31154: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    47412: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => i, t: () => s });
      var s,
        a = r(74354),
        n = r(25029);
      !(function (e) {
        (e.Deleted = "deleted"), (e.Updated = "updated"), (e.Created = "created");
      })(s || (s = {}));
      class i extends (0, a.g)({ scope: n.F.User }) {}
    },
    55441: (e, t, r) => {
      "use strict";
      r.d(t, { m: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    54547: (e, t, r) => {
      "use strict";
      r.d(t, { K: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    77649: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => n });
      var s = r(88885),
        a = r(25029);
      class n extends (0, s.d)({ scope: a.F.User }) {}
    },
    3137: (e, t, r) => {
      "use strict";
      r.d(t, { J: () => a });
      var s = r(77649);
      class a extends s.D {}
    },
    49135: (e, t, r) => {
      "use strict";
      r.d(t, { s: () => a });
      var s = r(77649);
      class a extends s.D {}
    },
    72989: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => a });
      var s = r(77649);
      class a extends s.D {}
    },
    55713: (e, t, r) => {
      "use strict";
      r.d(t, { s: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    9531: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { l: () => s }),
        (function (e) {
          (e.Equal = "equal"), (e.LessThan = "lessThan"), (e.GreaterThan = "greaterThan");
        })(s || (s = {}));
    },
    83984: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    24652: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { S: () => s }),
        (function (e) {
          (e.Ascend = "ascend"), (e.Descend = "descend");
        })(s || (s = {}));
    },
    11907: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    96342: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    19074: (e, t, r) => {
      "use strict";
      r.d(t, { N: () => i, x: () => o });
      var s = r(7165);
      const a = [
          "crawled",
          "xs",
          "sm",
          "sm@2x",
          "md",
          "md.tiff",
          "xmd",
          "xmd@2x",
          "l",
          "l@2x",
          "xl",
          "xl@2x",
          "46x30",
          "46x30@2x",
          "50x33",
          "50x33@2x",
          "56x56",
          "56x56@2x",
          "118x98",
          "118x98@2x",
          "160x106",
          "160x106@2x"
        ],
        n = (s.z.enum(a), a.reduce((e, t) => e.setKey(t, s.z.string().optional().nullable()), s.z.object({}))),
        i = s.z.object({ backgroundColor: s.z.string(), mainColor: s.z.string(), urls: n }),
        o = s.z.map(s.z.string(), i);
    },
    45146: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { X: () => s }),
        (function (e) {
          (e.Black = "BLACK"),
            (e.Blue1 = "BLUE1"),
            (e.Blue2 = "BLUE2"),
            (e.Gold = "GOLD"),
            (e.Green1 = "GREEN1"),
            (e.Green2 = "GREEN2"),
            (e.Orange = "ORANGE"),
            (e.Red = "RED"),
            (e.Silver = "SILVER"),
            (e.White = "WHITE");
        })(s || (s = {}));
    },
    11329: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { t: () => s }),
        (function (e) {
          (e.Mr = "MR"), (e.Mrs = "MRS"), (e.Miss = "MISS"), (e.Ms = "MS"), (e.Mx = "MX"), (e.NoneOfThese = "NONEOFTHESE");
        })(s || (s = {}));
    },
    82009: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { z: () => s }),
        (function (e) {
          (e.Any = "ANY"),
            (e.Fax = "FAX"),
            (e.Landline = "LANDLINE"),
            (e.Mobile = "MOBILE"),
            (e.WorkFax = "WORKFAX"),
            (e.WorkLandline = "WORKLANDLINE"),
            (e.WorkMobile = "WORKMOBILE");
        })(s || (s = {}));
    },
    7149: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => s, _: () => n });
      var s,
        a = r(7165);
      !(function (e) {
        (e.BLUE = "BLUE"),
          (e.BROWN = "BROWN"),
          (e.GRAY = "GRAY"),
          (e.GREEN = "GREEN"),
          (e.ORANGE = "ORANGE"),
          (e.PINK = "PINK"),
          (e.PURPLE = "PURPLE"),
          (e.RED = "RED"),
          (e.YELLOW = "YELLOW");
      })(s || (s = {}));
      const n = a.z.object({
        color: a.z.string(),
        isSecured: a.z.boolean(),
        title: a.z.string(),
        content: a.z.string(),
        categoryId: a.z.string()
      });
    },
    82706: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { U: () => s }),
        (function (e) {
          (e.Address = "KWAddress"),
            (e.BankAccount = "KWBankStatement"),
            (e.Company = "KWCompany"),
            (e.Credential = "KWAuthentifiant"),
            (e.DriversLicense = "KWDriverLicence"),
            (e.Email = "KWEmail"),
            (e.FiscalId = "KWFiscalStatement"),
            (e.IdCard = "KWIDCard"),
            (e.Identity = "KWIdentity"),
            (e.Passkey = "KWPasskey"),
            (e.Passport = "KWPassport"),
            (e.PaymentCard = "KWPaymentMean_creditCard"),
            (e.Phone = "KWPhone"),
            (e.Secret = "KWSecret"),
            (e.SecureNote = "KWSecureNote"),
            (e.SocialSecurityId = "KWSocialSecurityStatement"),
            (e.Website = "KWPersonalWebsite");
        })(s || (s = {}));
    },
    22499: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => i });
      var s = r(86952),
        a = r(12338),
        n = r(19892);
      const i = (0, s.Q)({
        name: "vaultNotifications",
        commands: { setVaultNotificationsStatus: a.x },
        events: {},
        queries: { getVaultNotificationsStatus: n.M }
      });
    },
    12338: (e, t, r) => {
      "use strict";
      r.d(t, { x: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    19892: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    99074: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => u });
      var s = r(86952),
        a = r(25041),
        n = r(533),
        i = r(65378),
        o = r(96862),
        c = r(6519);
      const u = (0, s.Q)({
        name: "vaultOrganization",
        commands: { deleteCollection: a.T, createCollection: n.e, migrateCategories: i._, updateCollection: o.s },
        events: {},
        queries: { queryCollections: c.I }
      });
    },
    533: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    25041: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    65378: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.User }) {}
    },
    96862: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => s, s: () => i });
      var s,
        a = r(74354),
        n = r(25029);
      !(function (e) {
        (e.SUBSTRACT_VAULT_ITEMS = "subtract_vault_items"), (e.APPEND_VAULT_ITEMS = "append_vault_items");
      })(s || (s = {}));
      class i extends (0, a.g)({ scope: n.F.User }) {}
    },
    6519: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    87969: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => n });
      var s = r(67837),
        a = r(99074);
      class n extends (0, s.E)(a.v) {}
      (0, s.K)(a.v, n);
    },
    73883: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => n });
      var s = r(86952),
        a = r(88994);
      const n = (0, s.Q)({ name: "vaultSearch", commands: {}, events: {}, queries: { search: a.W } });
    },
    88994: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => n });
      var s = r(99059),
        a = r(25029);
      class n extends (0, s.k)({ scope: a.F.User }) {}
    },
    11375: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => w });
      var s = r(88802),
        a = r(99634),
        n = r(52484),
        i = r(62025),
        o = r(85390),
        c = r(87065),
        u = r(20754),
        d = r(87279),
        l = r(63197),
        p = r(53576),
        h = r(57924),
        m = r(82706);
      let y = class {
        constructor(e, t) {
          (this.carbon = e),
            (this.vaultRepository = t),
            (this.isPasswordLimitEnabled = () => this._getPasswordsLimitCapability().pipe((0, c.U)((e) => e?.enabled ?? !1))),
            (this.getNumberOfPasswordsLeft = () => {
              const e = this.vaultRepository.fetchVaultItems$({ vaultItemTypes: [m.U.Credential] }).pipe(
                  (0, c.U)((e) => {
                    if (!(0, d.d6)(e)) throw new Error("Cannot retrieve credentials from vault");
                    return (0, d.db)(e).credentialsResult.matchCount;
                  })
                ),
                t = this._getPasswordsLimitCapability().pipe((0, c.U)((e) => e?.info?.limit));
              return (0, o.a)(e, t).pipe(
                (0, c.U)(([e, t]) => {
                  if ("number" == typeof t) return t - e;
                })
              );
            }),
            (this._getPasswordsLimitCapability = () =>
              this.carbon.queries.getNodePremiumStatus().pipe(
                (0, c.U)((e) => {
                  if (!(0, d.d6)(e)) throw new Error("Cannot retrieve node premium status from carbon");
                  return (0, d.db)(e).capabilities?.passwordsLimit;
                })
              ));
        }
      };
      y = (0, s.__decorate)([(0, h.GS)(), (0, s.__metadata)("design:paramtypes", [p.CarbonLegacyClient, i.g])], y);
      let g = class {
        constructor(e) {
          this.passwordLimitRepository = e;
        }
        execute() {
          const e = this.passwordLimitRepository.isPasswordLimitEnabled(),
            t = this.passwordLimitRepository.getNumberOfPasswordsLeft();
          return (0, o.a)(e, t).pipe((0, c.U)(([e, t]) => (e && "number" == typeof t ? (0, d.Vp)(t > 0) : (0, d.Vp)(!0))));
        }
      };
      g = (0, s.__decorate)([(0, u.e)(l.K), (0, s.__metadata)("design:paramtypes", [y])], g);
      var v = r(58684);
      let f = class {
        constructor(e) {
          this.passwordLimitRepository = e;
        }
        execute() {
          const e = this.passwordLimitRepository.isPasswordLimitEnabled(),
            t = this.passwordLimitRepository.getNumberOfPasswordsLeft();
          return (0, o.a)(e, t).pipe(
            (0, c.U)(([e, t]) => (e && "number" == typeof t ? (0, d.Vp)({ hasLimit: e, passwordsLeft: t }) : (0, d.Vp)({ hasLimit: !1 })))
          );
        }
      };
      f = (0, s.__decorate)([(0, u.e)(v.r), (0, s.__metadata)("design:paramtypes", [y])], f);
      let w = class {};
      w = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.Z,
            stores: [],
            handlers: { commands: {}, events: {}, queries: { canUserAddNewPassword: g, getPasswordLimitStatus: f } },
            providers: [i.g, y],
            requiredFeatureFlips: []
          })
        ],
        w
      );
    },
    26954: (e, t, r) => {
      "use strict";
      r.d(t, { z: () => K });
      var s,
        a = r(88802),
        n = r(99634),
        i = r(37935),
        o = r(48430);
      !(function (e) {
        (e.PasskeysInVaultDev = "vault_web_passkey_dev"), (e.PasskeysInVaultProd = "vault_web_passkey_prod");
      })(s || (s = {}));
      var c = r(63663),
        u = r(87279),
        d = r(53576),
        l = r(273),
        p = r(81459),
        h = r(57924);
      let m = class extends p.f {};
      m = (0, a.__decorate)([(0, h.GS)()], m);
      var y = r(82706);
      const g = {
        [y.U.Address]: (e) => ({ ...e }),
        [y.U.BankAccount]: (e) => ({ ...e }),
        [y.U.Company]: (e) => ({ ...e }),
        [y.U.Credential]: (e) => ({
          login: e.username,
          otpUrl: e.otpURL,
          secondaryLogin: e.alternativeUsername,
          title: e.itemName,
          url: e.URL,
          linkedWebsites: { addedByUser: e.linkedURLs },
          ...e
        }),
        [y.U.DriversLicense]: (e) => ({ ...e }),
        [y.U.Email]: (e) => ({ ...e }),
        [y.U.FiscalId]: (e) => ({ ...e }),
        [y.U.IdCard]: (e) => ({ ...e }),
        [y.U.Identity]: (e) => ({ ...e }),
        [y.U.Passkey]: (e) => ({ ...e }),
        [y.U.Passport]: (e) => ({ ...e }),
        [y.U.PaymentCard]: (e) => ({ ...e }),
        [y.U.Phone]: (e) => ({ ...e }),
        [y.U.Secret]: (e) => ({ ...e }),
        [y.U.SecureNote]: (e) => ({ ...e }),
        [y.U.SocialSecurityId]: (e) => ({ ...e }),
        [y.U.Website]: (e) => ({ ...e })
      };
      let v = class {
        constructor(e, t) {
          (this.carbonLegacyClient = e), (this.eventEmitter = t);
        }
        async execute({ body: e }) {
          const { vaultItemType: t, content: r, shouldSkipSync: s } = e,
            { commands: a } = this.carbonLegacyClient,
            n = await a.carbonLegacyLeeloo({
              name: "savePersonalDataItem",
              arg: [{ kwType: t, origin: "MANUAL", content: g[t](r), shouldSkipSync: s }]
            });
          if ((0, u.hx)(n)) return Promise.resolve((0, u.Rn)({ tag: "error", errorMessage: `Failed to create ${t}` }));
          const i = (0, u.db)(n).carbonResult;
          return (
            this.eventEmitter.sendEvent("created", { ids: [i.itemId], vaultItemType: t }), Promise.resolve((0, u.Vp)({ id: i.itemId }))
          );
        }
      };
      v = (0, a.__decorate)([(0, c.W)(l._), (0, a.__metadata)("design:paramtypes", [d.CarbonLegacyClient, m])], v);
      var f = r(31154);
      let w = class {
        constructor(e, t) {
          (this.carbonLegacyClient = e), (this.eventEmitter = t);
        }
        async execute({ body: e }) {
          const { vaultItemType: t, ids: r } = e,
            { commands: s } = this.carbonLegacyClient,
            a = [],
            n = r.map((e) =>
              s.carbonLegacyLeeloo({ name: "removePersonalDataItem", arg: [{ id: e }] }).then((t) => {
                (0, u.d6)(t) && a.push(e);
              })
            );
          return (
            await Promise.allSettled(n),
            a.length > 0 && this.eventEmitter.sendEvent("deleted", { ids: a, vaultItemType: t }),
            a.length !== r.length
              ? Promise.resolve(
                  (0, u.Rn)({
                    tag: "error",
                    errorMessage: `Error: Failed to delete all ${t}s`,
                    failedDeletionIds: Array.from(new Set(...r, ...a))
                  })
                )
              : Promise.resolve((0, u.Vp)(void 0))
          );
        }
      };
      w = (0, a.__decorate)([(0, c.W)(f.c), (0, a.__metadata)("design:paramtypes", [d.CarbonLegacyClient, m])], w);
      var S = r(54547);
      let E = class {
        constructor(e, t) {
          (this.carbonLegacyClient = e), (this.eventEmitter = t);
        }
        async execute({ body: e }) {
          const { content: t, id: r, vaultItemType: s } = e,
            { commands: a } = this.carbonLegacyClient,
            n = await a.carbonLegacyLeeloo({
              name: "savePersonalDataItem",
              arg: [{ kwType: s, origin: "MANUAL", content: { ...t, id: r } }]
            });
          if ((0, u.hx)(n)) throw new Error(`Failed to update ${s}`);
          return this.eventEmitter.sendEvent("updated", { ids: [r], vaultItemType: s }), Promise.resolve((0, u.Vp)(void 0));
        }
      };
      E = (0, a.__decorate)([(0, c.W)(S.K), (0, a.__metadata)("design:paramtypes", [d.CarbonLegacyClient, m])], E);
      var _ = r(47412);
      let b = class {
        constructor(e) {
          this.eventEmitter = e;
        }
        execute({ body: e }) {
          const { ids: t, eventType: r } = e;
          return this.eventEmitter.sendEvent(r, { ids: t, vaultItemType: y.U.Credential }), Promise.resolve((0, u.Vp)(void 0));
        }
      };
      b = (0, a.__decorate)([(0, c.W)(_.c), (0, a.__metadata)("design:paramtypes", [m])], b);
      var T = r(55441);
      let A = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        async execute({ body: e }) {
          const { credentialId: t, onlyAutofillExactDomain: r, requireMasterPassword: s, useAutoLogin: a } = e,
            { commands: n } = this.carbonLegacyClient,
            i = await n.carbonLegacyLeeloo({
              name: "savePersonalDataItem",
              arg: [
                {
                  kwType: y.U.Credential,
                  origin: "MANUAL",
                  content: { id: t, onlyForThisSubdomain: r, autoLogin: a, protectWithMasterPassword: s }
                }
              ]
            });
          return (0, u.hx)(i)
            ? Promise.resolve((0, u.Rn)({ tag: "error", errorMessage: `Failed to update credential preferences for: ${t}` }))
            : Promise.resolve((0, u.Vp)(void 0));
        }
      };
      A = (0, a.__decorate)([(0, c.W)(T.m), (0, a.__metadata)("design:paramtypes", [d.CarbonLegacyClient])], A);
      var C = r(20754),
        R = r(55713),
        I = r(48844),
        x = r(60733),
        P = r(96303),
        D = r(54066),
        U = r(19074);
      let F = class {
        constructor(e, t) {
          (this.carbonLegacyClient = e), (this.md5Hasher = t);
        }
        execute({ body: { domain: e } }) {
          const {
            queries: { carbonState: t }
          } = this.carbonLegacyClient;
          return t({ path: "userSession.iconsCache.domains" }).pipe(
            (0, I.Qn)((t) => {
              if (((r = t), !U.x.safeParse(r).success)) throw new Error("Bad domain icons cache format");
              var r;
              return t.get((0, P.k)(this.md5Hasher.compute((0, D.u)(e))));
            })
          );
        }
      };
      F = (0, a.__decorate)([(0, C.e)(R.s), (0, a.__metadata)("design:paramtypes", [d.CarbonLegacyClient, x.f])], F);
      var O = r(96342),
        N = r(62025);
      let k = class {
        constructor(e) {
          this.vaultRepository = e;
        }
        execute({ body: e }) {
          return this.vaultRepository.fetchVaultItems$(e);
        }
      };
      k = (0, a.__decorate)([(0, C.e)(O.W), (0, a.__metadata)("design:paramtypes", [N.g])], k);
      var L = r(83984);
      let M = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        execute({ body: { id: e } }) {
          const {
            queries: { carbonState: t }
          } = this.carbonLegacyClient;
          return t({ path: "userSession.personalData.noteCategories" }).pipe(
            (0, I.Qn)((t) => {
              if (((r = t), !Array.isArray(r) || (0 !== r.length && "KWSecureNoteCategory" !== r[0].kwType)))
                throw new Error("Bad secure note category format");
              var r;
              const s = t.find((t) => t.Id === e)?.CategoryName;
              return s;
            })
          );
        }
      };
      M = (0, a.__decorate)([(0, C.e)(L.F), (0, a.__metadata)("design:paramtypes", [d.CarbonLegacyClient])], M);
      var V = r(87065),
        G = r(11907),
        j = r(17426);
      let q = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        execute({ body: { credentialId: e = "" } }) {
          const {
            queries: { carbonState: t }
          } = this.carbonLegacyClient;
          return t({ path: "userSession.personalData.credentials" }).pipe(
            (0, V.U)((t) => {
              if ((0, u.hx)(t) || !(0, j.J)(t.data)) throw new Error("Bad credentials format");
              const r = t.data.find((t) => t.Id === e);
              if (!r) throw new Error("Credential matching provided id not found");
              return (0, u.Vp)({
                useAutoLogin: Boolean(r.AutoLogin),
                onlyAutofillExactDomain: Boolean(r.SubdomainOnly),
                requireMasterPassword: Boolean(r.AutoProtected)
              });
            })
          );
        }
      };
      q = (0, a.__decorate)([(0, C.e)(G.M), (0, a.__metadata)("design:paramtypes", [d.CarbonLegacyClient])], q);
      let K = class {};
      K = (0, a.__decorate)(
        [
          (0, n.Y)({
            api: o.L,
            handlers: {
              commands: {
                createVaultItem: v,
                deleteVaultItems: w,
                updateVaultItem: E,
                emitTemporaryVaultItemEvent: b,
                tempCredentialPreferencesUpdate: A
              },
              events: {},
              queries: { domainIconDetails: F, query: k, secureNoteCategory: M, tempCredentialPreferences: q }
            },
            imports: [i.D],
            providers: [m, N.g],
            requiredFeatureFlips: Object.values(s)
          })
        ],
        K
      );
    },
    20491: (e, t, r) => {
      "use strict";
      r.d(t, { K: () => S });
      var s = r(88802),
        a = r(99634),
        n = r(22499),
        i = r(95681),
        o = r(23347),
        c = r(25029),
        u = r(10722);
      const d = (e) => !(!e || "object" != typeof e) && "isCollectionGuidedIntroEnabled" in e;
      class l extends (0, i.Q)({
        persist: !0,
        storage: { initialValue: { isCollectionGuidedIntroEnabled: !0 }, typeGuard: d, schemaVersion: 1 },
        scope: c.F.User,
        storeName: "vault-notifications",
        capacity: o.Y._001KB,
        codec: u.E
      }) {}
      var p = r(63663),
        h = r(87279),
        m = r(12338);
      let y = class {
        constructor(e) {
          this.store = e;
        }
        async execute({ body: e }) {
          const { notificationName: t, isEnabled: r } = e;
          try {
            const e = await this.store.getState();
            return await this.store.set({ ...e, [t]: r }), (0, h.Vp)(void 0);
          } catch {
            throw new Error("SetVaultNotificationsStatus command from vault-core failed");
          }
        }
      };
      y = (0, s.__decorate)([(0, p.W)(m.x), (0, s.__metadata)("design:paramtypes", [l])], y);
      var g = r(87065),
        v = r(20754),
        f = r(19892);
      let w = class {
        constructor(e) {
          this.store = e;
        }
        execute() {
          return this.store.state$.pipe((0, g.U)(h.Vp));
        }
      };
      w = (0, s.__decorate)([(0, v.e)(f.M), (0, s.__metadata)("design:paramtypes", [l])], w);
      let S = class {};
      S = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.e,
            handlers: { commands: { setVaultNotificationsStatus: y }, events: {}, queries: { getVaultNotificationsStatus: w } },
            stores: [l]
          })
        ],
        S
      );
    },
    55808: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => O });
      var s = r(88802),
        a = r(99634),
        n = r(99074),
        i = r(60399),
        o = r(25041),
        c = r(63663),
        u = r(53576),
        d = r(87279),
        l = r(60765),
        p = r(48844);
      const h = (e) =>
        !!Array.isArray(e) &&
        (0 === e.length ||
          e.every((e) => {
            const t = e;
            return "string" == typeof t.Id && "string" == typeof t.Name && Array.isArray(t.VaultItems);
          }));
      function m(e, t) {
        const {
          queries: { carbonState: r }
        } = e;
        return r({ path: "userSession.personalData.collections" }).pipe(
          (0, p.Qn)((e) => {
            if (!h(e)) throw new Error("Collection array has a wrong format");
            return {
              collections: (t && t.length > 0 ? e.filter((e) => t.includes(e.Id)) : e).map((e) => ({
                id: e.Id,
                name: e.Name,
                spaceId: e.SpaceId,
                vaultItems: e.VaultItems.map((e) => ({ id: e.Id, type: e.Type }))
              }))
            };
          })
        );
      }
      function y(e, t, r, s) {
        const a = new l.UserUpdateCollectionEvent({ collectionId: r, action: t, itemCount: s, isShared: !1 });
        return e.commands.carbon({ name: "logEvent", args: [{ event: a }] });
      }
      let g = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        async execute({ body: e }) {
          const { id: t } = e,
            r = await (0, i.z)(m(this.carbonLegacyClient, [t]));
          if ((0, d.hx)(r)) throw new Error(`Failed to fetch additional collection info: ${r.error}`);
          const s = await this.carbonLegacyClient.commands.carbon({ name: "deleteCollection", args: [{ id: t }] });
          if ((0, d.hx)(s)) throw new Error(`Failed to delete collection: ${s.error}`);
          return (
            y(this.carbonLegacyClient, l.CollectionAction.Delete, t, r.data.collections[0]?.vaultItems?.length),
            Promise.resolve((0, d.Vp)(void 0))
          );
        }
      };
      g = (0, s.__decorate)([(0, c.W)(o.T), (0, s.__metadata)("design:paramtypes", [u.CarbonLegacyClient])], g);
      var v = r(533),
        f = r(28489);
      let w = class {
        constructor(e) {
          this.carbonLegacy = e;
        }
        async execute({ body: e }) {
          const {
              content: { name: t, spaceId: r = "", vaultItems: s = [] }
            } = e,
            a = await this.carbonLegacy.commands.carbon({ name: "addCollection", args: [{ name: t, spaceId: r, vaultItems: s }] });
          if ((0, d.hx)(a)) throw new Error(`Failed to create collection: ${a.error}`);
          if (
            "object" != typeof (n = a.data.carbonResult) ||
            null === n ||
            !(0, f.l$)(n, "id") ||
            "string" != typeof n.id ||
            !(0, f.l$)(n, "success") ||
            "boolean" != typeof n.success
          )
            throw new Error("Failed to find created collection id");
          var n;
          return (
            y(this.carbonLegacy, l.CollectionAction.Add, a.data.carbonResult.id, s.length),
            s.length && y(this.carbonLegacy, l.CollectionAction.AddCredential, a.data.carbonResult.id, s.length),
            (0, d.Vp)({ id: a.data.id })
          );
        }
      };
      w = (0, s.__decorate)([(0, c.W)(v.e), (0, s.__metadata)("design:paramtypes", [u.CarbonLegacyClient])], w);
      var S = r(65378),
        E = r(94189),
        _ = r(25029),
        b = r(95681),
        T = r(23347),
        A = r(10722);
      const C = (e) => !0;
      class R extends (0, b.Q)({
        persist: !0,
        scope: _.F.Device,
        storeName: "collections-store",
        storeTypeGuard: C,
        capacity: T.Y._001KB,
        codec: A.E,
        storage: {
          schemaVersion: 3,
          initialValue: { isCredentialCategoriesMigrated: {} },
          typeGuard: C,
          migrateStorageSchema: () => ({ isCredentialCategoriesMigrated: {} })
        }
      }) {}
      let I = class {
        constructor(e, t, r) {
          (this.client = e), (this.carbonLegacyClient = t), (this.store = r);
        }
        updateCollection(e, t) {
          const { commands: r } = this.client.getClient(n.v);
          return r.updateCollection({ id: e, collection: t });
        }
        createCollection(e) {
          const { commands: t } = this.client.getClient(n.v);
          return t.createCollection({ content: e });
        }
        fetchCategories() {
          const {
            queries: { carbonState: e }
          } = this.carbonLegacyClient;
          return e({ path: "userSession.personalData.credentialCategories" }).pipe((0, p.Qn)((e) => e));
        }
        async fetchCredentials() {
          const {
              queries: { carbonState: e }
            } = this.carbonLegacyClient,
            t = await (0, i.z)(this.fetchCategories());
          if ((0, d.hx)(t)) throw new Error("Failed to fetch categories");
          const r = t.data;
          return e({ path: "userSession.personalData.credentials" }).pipe(
            (0, p.Qn)((e) => {
              if (((t = e), !Array.isArray(t))) throw new Error("Bad credential format");
              var t;
              return e.map((e) => {
                const t = r.find((t) => t.Id === e.Category)?.CategoryName;
                return { ...e, CategoryName: t };
              });
            })
          );
        }
        async finalizeMigration(e, t) {
          return (t.isCredentialCategoriesMigrated[e] = !0), await this.store.set(t), Promise.resolve((0, d.Vp)(void 0));
        }
        async execute({ body: e }) {
          const t = e;
          if (!t) throw new Error("Failed to fetch username");
          const r = await this.store.getState();
          if (r.isCredentialCategoriesMigrated[t]) return Promise.resolve((0, d.Vp)(void 0));
          const s = await (0, i.z)(await this.fetchCredentials());
          if ((0, d.hx)(s)) throw new Error("Failed to fetch credentials");
          const a = s.data;
          if (0 === a.length) return this.finalizeMigration(t, r);
          const n = await (0, i.z)(m(this.carbonLegacyClient));
          if ((0, d.hx)(n)) throw new Error("Failed to fetch collections");
          const o = n.data.collections;
          o.forEach((e) => {
            "string" != typeof e.spaceId && (e.spaceId = "");
          });
          const c = [];
          for (let e = 0; e < a.length; e++) {
            const t = a[e];
            if (!t.CategoryName) continue;
            const r = t.CategoryName,
              s = t.SpaceId ?? "",
              n = o.find((e) => e.name === r && e.spaceId === s);
            if (n) {
              n.vaultItems.push({ id: t.Id, type: "KWAuthentifiant" });
              continue;
            }
            const i = c.find((e) => e.name === r && e.spaceId === s);
            i
              ? i.vaultItems.push({ id: t.Id, type: "KWAuthentifiant" })
              : c.push({ name: r, spaceId: s, vaultItems: [{ id: t.Id, type: "KWAuthentifiant" }] });
          }
          for (const e of o) await this.updateCollection(e.id, e);
          for (const e of c) await this.createCollection(e);
          return this.finalizeMigration(t, r);
        }
      };
      I = (0, s.__decorate)([(0, c.W)(S._), (0, s.__metadata)("design:paramtypes", [E.w, u.CarbonLegacyClient, R])], I);
      var x = r(96862);
      let P = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        async execute({ body: e }) {
          const { id: t, collection: r, operationType: s = x.C.APPEND_VAULT_ITEMS } = e,
            a = await (0, i.z)(m(this.carbonLegacyClient, [t]));
          if ((0, d.hx)(a)) throw new Error(`Failed to fetch additional collection info: ${a.error}`);
          const n = a.data.collections[0];
          r.vaultItems && (n.vaultItems = this.mutateCollectionVaultItems(n, s, r.vaultItems));
          const o = await this.carbonLegacyClient.commands.carbon({
            name: "updateCollection",
            args: [{ id: n.id, name: r.name ?? n.name, spaceId: r.spaceId ?? n.spaceId, vaultItems: n.vaultItems }]
          });
          if ((0, d.hx)(o)) throw new Error(`Failed to update collection: ${o.error}`);
          return this.handleLogs(n, r, s), Promise.resolve((0, d.Vp)(void 0));
        }
        handleLogs(e, t, r) {
          t.name && y(this.carbonLegacyClient, l.CollectionAction.Edit, e.id, e.vaultItems.length),
            t.vaultItems &&
              y(
                this.carbonLegacyClient,
                r === x.C.SUBSTRACT_VAULT_ITEMS ? l.CollectionAction.DeleteCredential : l.CollectionAction.AddCredential,
                e.id,
                1
              );
        }
        getDeduplicatedList(e) {
          return [...new Map(e.map((e) => [e.id, e])).values()];
        }
        mutateCollectionVaultItems(e, t, r) {
          return t === x.C.SUBSTRACT_VAULT_ITEMS
            ? e.vaultItems.filter((e) => !r.some((t) => t.id === e.id))
            : this.getDeduplicatedList([...e.vaultItems, ...r]);
        }
      };
      P = (0, s.__decorate)([(0, c.W)(x.s), (0, s.__metadata)("design:paramtypes", [u.CarbonLegacyClient])], P);
      var D = r(6519),
        U = r(20754);
      let F = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        execute({ body: e }) {
          const { ids: t } = e;
          return m(this.carbonLegacyClient, t);
        }
      };
      F = (0, s.__decorate)([(0, U.e)(D.I), (0, s.__metadata)("design:paramtypes", [u.CarbonLegacyClient])], F);
      let O = class {};
      O = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.v,
            stores: [R],
            handlers: {
              commands: { deleteCollection: g, createCollection: w, migrateCategories: I, updateCollection: P },
              events: {},
              queries: { queryCollections: F }
            },
            requiredFeatureFlips: ["vault_web_collection_migration_space_prod_v2", "vault_web_popupSavedState_release"]
          })
        ],
        O
      );
    },
    17426: (e, t, r) => {
      "use strict";
      r.d(t, { J: () => n });
      var s = r(82706),
        a = r(89722);
      const n = (e) => (0, a.w)(e, s.U.Credential);
    },
    89722: (e, t, r) => {
      "use strict";
      function s(e, t) {
        if (!Array.isArray(e)) return !1;
        if (0 === e.length) return !0;
        return e[0].kwType === t;
      }
      r.d(t, { w: () => s });
    },
    62025: (e, t, r) => {
      "use strict";
      r.d(t, { g: () => ie });
      var s = r(88802),
        a = r(85390),
        n = r(87065),
        i = r(57924),
        o = r(87279),
        c = r(48844),
        u = r(53576),
        d = r(82706),
        l = r(89722);
      const p = (e) => (0, l.w)(e, d.U.Address),
        h = (e) => (0, l.w)(e, d.U.Company),
        m = (e) => (0, l.w)(e, d.U.Email),
        y = (e) => (0, l.w)(e, d.U.Identity),
        g = (e) => (0, l.w)(e, d.U.Phone),
        v = (e) => (0, l.w)(e, d.U.Website),
        f = (e) => (0, l.w)(e, d.U.BankAccount);
      var w = r(17426);
      const S = (e) => (0, l.w)(e, d.U.DriversLicense),
        E = (e) => (0, l.w)(e, d.U.FiscalId),
        _ = (e) => (0, l.w)(e, d.U.IdCard),
        b = (e) => (0, l.w)(e, d.U.Passport),
        T = (e) => (0, l.w)(e, d.U.SocialSecurityId),
        A = (e) => (0, l.w)(e, d.U.Passkey),
        C = (e) => (0, l.w)(e, d.U.PaymentCard),
        R = (e) => (0, l.w)(e, d.U.SecureNote);
      const I = (e) =>
        (function (e, t) {
          if (!Array.isArray(e)) return !1;
          if (0 === e.length) return !0;
          const r = e[0];
          for (let e = 0; e < t.length; e++) {
            const s = t[e];
            if (!Object.prototype.hasOwnProperty.call(r, s)) return !1;
          }
          return !0;
        })(e, ["teamId"]);
      var x = r(9531),
        P = r(92481);
      function D(e, t) {
        return e in t;
      }
      function U(e) {
        const t = {};
        for (const r in e) t[r.charAt(0).toLowerCase() + r.slice(1)] = e[r];
        return t;
      }
      const F = (e) => (e && 3 === e.split("-").length ? (0, P.Z)(new Date(e), "yyyy-MM-dd") : "");
      function O(e, t, r) {
        return t || r
          ? e.filter(
              (e) =>
                !(
                  t &&
                  !t.every(
                    (t) =>
                      D(t.property, e) &&
                      (function (e, t, r = x.l.Equal) {
                        return { [x.l.Equal]: () => e === t, [x.l.LessThan]: () => e < t, [x.l.GreaterThan]: () => e > t }[r]();
                      })(e[t.property], t.value, t.operator)
                  )
                ) &&
                (r?.(e) ?? !0)
            )
          : e;
      }
      var N = r(24652);
      const k = (e) => {
          const { AddressName: t, LinkedPhone: r, StreetName: s, AddressFull: a, StateLevel2: n, ...i } = e;
          return { ...U(i), itemName: t, linkedPhoneId: r, streetName: s || a };
        },
        L = (e) => {
          const { BankAccountName: t, BankAccountOwner: r, BankAccountIBAN: s, BankAccountBIC: a, BankAccountBank: n, ...i } = e;
          return { ...U(i), accountName: t, bankCode: n || "", BIC: a, country: i.LocaleFormat, IBAN: s, ownerName: r };
        },
        M = (e) => {
          const { Name: t, JobTitle: r, PersonalNote: s, ...a } = e;
          return { ...U(a), companyName: t, jobTitle: r };
        },
        V = (e) => {
          const {
            AnonId: t,
            CreationDatetime: r,
            Email: s,
            Id: a,
            LastBackupTime: n,
            LastUse: i,
            LinkedServices: o,
            LocaleFormat: c,
            Login: u,
            Note: d,
            OtpSecret: l,
            OtpUrl: p,
            Password: h,
            SecondaryLogin: m,
            SpaceId: y,
            Title: g,
            Url: v,
            UserModificationDatetime: f,
            UserSelectedUrl: w
          } = e;
          return {
            ...U({
              AnonId: t,
              CreationDatetime: r,
              Email: s,
              Id: a,
              LastBackupTime: n,
              LastUse: i,
              LocaleFormat: c,
              Note: d,
              Password: h,
              SpaceId: y,
              UserModificationDatetime: f
            }),
            alternativeUsername: m,
            itemName: g,
            linkedURLs: o?.associated_domains.map((e) => e.domain) ?? [],
            otpURL: p || l,
            URL: v || w || "",
            username: u
          };
        },
        G = (e) => {
          const { DeliveryDate: t, ExpireDate: r, Fullname: s, LinkedIdentity: a, Number: n, DateOfBirth: i, Sex: o, ...c } = e;
          return { ...U(c), idName: s, idNumber: n, issueDate: F(t), expirationDate: F(r), country: c.LocaleFormat };
        },
        j = (e) => {
          const { EmailName: t, Email: r, Type: s, ...a } = e;
          return { ...U(a), itemName: t, emailAddress: r, type: s };
        },
        q = (e) => ({ ...U(e), country: e.LocaleFormat }),
        K = (e) => {
          const { DateOfBirth: t, DeliveryDate: r, ExpireDate: s, Fullname: a, LinkedIdentity: n, Number: i, Sex: o, ...c } = e;
          return { ...U(c), idName: a, idNumber: i, issueDate: F(r), expirationDate: F(s), country: c.LocaleFormat };
        };
      var W = r(11329);
      const B = { "": void 0, MR: W.t.Mr, MME: W.t.Mrs, MLLE: W.t.Miss, MS: W.t.Ms, MX: W.t.Mx, NONE_OF_THESE: W.t.NoneOfThese },
        z = (e) => {
          const { Title: t, ...r } = e;
          return { ...U(r), title: B[t] };
        },
        H = (e) => {
          const {
            DeliveryDate: t,
            DeliveryPlace: r,
            ExpireDate: s,
            Fullname: a,
            LinkedIdentity: n,
            Number: i,
            DateOfBirth: o,
            Sex: c,
            ...u
          } = e;
          return {
            ...U(u),
            idName: a,
            idNumber: i || "",
            issueDate: F(t),
            issuePlace: r || "",
            expirationDate: F(s),
            country: u.LocaleFormat
          };
        };
      var $ = r(45146);
      const Q = {
          BLACK: $.X.Black,
          BLUE_1: $.X.Blue1,
          BLUE_2: $.X.Blue2,
          GOLD: $.X.Gold,
          GREEN_1: $.X.Green1,
          GREEN_2: $.X.Green2,
          ORANGE: $.X.Orange,
          RED: $.X.Red,
          SILVER: $.X.Silver,
          WHITE: $.X.White
        },
        Y = (e) => {
          const {
            Name: t,
            CCNote: r,
            Color: s,
            Bank: a,
            CardNumberLastDigits: n,
            IssueNumber: i,
            StartMonth: o,
            StartYear: c,
            Type: u,
            ...d
          } = e;
          return { ...U(d), itemName: t, color: Q[s], note: r || "" };
        };
      var X = r(82009);
      const J = {
          [u.PhoneType.PHONE_TYPE_ANY]: X.z.Any,
          [u.PhoneType.PHONE_TYPE_FAX]: X.z.Fax,
          [u.PhoneType.PHONE_TYPE_LANDLINE]: X.z.Landline,
          [u.PhoneType.PHONE_TYPE_MOBILE]: X.z.Mobile,
          [u.PhoneType.PHONE_TYPE_WORK_FAX]: X.z.WorkFax,
          [u.PhoneType.PHONE_TYPE_WORK_LANDLINE]: X.z.WorkLandline,
          [u.PhoneType.PHONE_TYPE_WORK_MOBILE]: X.z.WorkMobile
        },
        Z = (e) => {
          const { PhoneName: t, Number: r, Type: s, ...a } = e;
          return { ...U(a), itemName: t, phoneNumber: r, type: J[s] };
        };
      var ee = r(7149);
      const te = (e) => {
          const { Secured: t, Type: r, Category: s, ...a } = e;
          return { ...U(a), categoryId: s, isSecured: t, color: ee.L[r] || ee.L.GRAY };
        },
        re = (e) => {
          const { DateOfBirth: t, LinkedIdentity: r, Sex: s, SocialSecurityFullname: a, SocialSecurityNumber: n, ...i } = e;
          return { ...U(i), idName: a, idNumber: n, country: i.LocaleFormat };
        },
        se = (e) => {
          const { Website: t, Name: r, PersonalNote: s, ...a } = e;
          return { ...U(a), itemName: r, URL: t };
        },
        ae = (e) => (0, l.w)(e, d.U.Secret),
        ne = (e) => ({ ...U(e) });
      let ie = class {
        constructor(e) {
          (this.carbonLegacyClient = e),
            (this.getVaultItems$TypeDictionary = {
              [d.U.Address]: this.getVaultItems$("addressesResult", p, k),
              [d.U.BankAccount]: this.getVaultItems$("bankAccountsResult", f, L),
              [d.U.Company]: this.getVaultItems$("companiesResult", h, M),
              [d.U.Credential]: this.getVaultItems$("credentialsResult", w.J, V),
              [d.U.DriversLicense]: this.getVaultItems$("driversLicensesResult", S, G, "driverLicenses"),
              [d.U.Email]: this.getVaultItems$("emailsResult", m, j),
              [d.U.FiscalId]: this.getVaultItems$("fiscalIdsResult", E, q),
              [d.U.IdCard]: this.getVaultItems$("idCardsResult", _, K),
              [d.U.Identity]: this.getVaultItems$("identitiesResult", y, z),
              [d.U.Passkey]: this.getVaultItems$("passkeysResult", A, U),
              [d.U.Passport]: this.getVaultItems$("passportsResult", b, H),
              [d.U.PaymentCard]: this.getVaultItems$("paymentCardsResult", C, Y),
              [d.U.Phone]: this.getVaultItems$("phonesResult", g, Z),
              [d.U.Secret]: this.getVaultItems$("secretsResult", ae, ne),
              [d.U.SecureNote]: this.getVaultItems$("secureNotesResult", R, te, "notes"),
              [d.U.SocialSecurityId]: this.getVaultItems$("socialSecurityIdsResult", T, re),
              [d.U.Website]: this.getVaultItems$("websitesResult", v, se, "personalWebsites")
            }),
            (this.getEmptyVaultItemsQueryResult = () => ({
              addressesResult: this.getEmptyItemsQueryResult(),
              bankAccountsResult: this.getEmptyItemsQueryResult(),
              companiesResult: this.getEmptyItemsQueryResult(),
              credentialsResult: this.getEmptyItemsQueryResult(),
              driversLicensesResult: this.getEmptyItemsQueryResult(),
              emailsResult: this.getEmptyItemsQueryResult(),
              fiscalIdsResult: this.getEmptyItemsQueryResult(),
              idCardsResult: this.getEmptyItemsQueryResult(),
              identitiesResult: this.getEmptyItemsQueryResult(),
              passkeysResult: this.getEmptyItemsQueryResult(),
              passportsResult: this.getEmptyItemsQueryResult(),
              paymentCardsResult: this.getEmptyItemsQueryResult(),
              phonesResult: this.getEmptyItemsQueryResult(),
              secretsResult: this.getEmptyItemsQueryResult(),
              secureNotesResult: this.getEmptyItemsQueryResult(),
              socialSecurityIdsResult: this.getEmptyItemsQueryResult(),
              websitesResult: this.getEmptyItemsQueryResult()
            })),
            (this.getEmptyItemsQueryResult = () => ({ items: [], matchCount: 0 }));
        }
        initializeVaultItemsQueryParams(e) {
          const { ids: t, pageSize: r, pageNumber: s, propertyFilters: a, propertySorting: n } = e;
          (this.ids = t), (this.propertyFilters = a), (this.propertySorting = n), (this.pageSize = r), (this.pageNumber = s);
        }
        fetchVaultItems$(e, t) {
          const { vaultItemTypes: r, ...s } = e;
          this.initializeVaultItemsQueryParams(s), (this.additionalFilterFunc = t);
          const i = (0, a.a)(r.map((e) => this.getVaultItems$TypeDictionary[e])),
            c = this.getEmptyVaultItemsQueryResult();
          return i.pipe(
            (0, n.U)(
              (e) => (
                e.forEach((e) => {
                  if ("failure" === e.tag) throw new Error("Error while fetching vault items");
                  Object.assign(c, e.data);
                }),
                (0, o.Vp)(c)
              )
            )
          );
        }
        getVaultItems$(e, t, r, s) {
          return (
            (s = s ?? e.replace("Result", "")),
            (0, a.a)([this.getCarbonVaultItems$(e, t, s), this.getQuarantinedSpaces$()], (e, t) =>
              (0, o.Vp)(
                (function (e, t, r, s) {
                  return e.flatMap((e) =>
                    t.some((t) => t.teamId === e.SpaceId) || (s && !s.some((t) => t.toUpperCase() === e.Id.toUpperCase())) ? [] : r(e)
                  );
                })(e, t, r, this.ids)
              )
            ).pipe(
              (0, c.Qn)((t) => {
                const r = (function (e, t) {
                  if (!t || !e.length || !D(t.property, e[0])) return e;
                  const r = t.property,
                    s = t.direction || N.S.Ascend;
                  return e.sort((e, t) => {
                    const a = e[r],
                      n = t[r];
                    return "string" == typeof a && "string" == typeof n
                      ? s === N.S.Ascend
                        ? a.localeCompare(n)
                        : n.localeCompare(a)
                      : "number" == typeof a && "number" == typeof n
                      ? s === N.S.Ascend
                        ? a - n
                        : n - a
                      : 0;
                  });
                })(O(t, this.propertyFilters, this.additionalFilterFunc), this.propertySorting);
                return { [e]: { items: this.getPage(r), matchCount: r.length } };
              })
            )
          );
        }
        getPage(e) {
          return this.pageNumber && this.pageSize ? e.slice(this.pageSize * (this.pageNumber - 1), this.pageSize * this.pageNumber) : e;
        }
        getCarbonVaultItems$(e, t, r) {
          const {
            queries: { carbonState: s }
          } = this.carbonLegacyClient;
          return s({ path: `userSession.personalData.${r}` }).pipe(
            (0, n.U)((r) => {
              if ((0, o.hx)(r) || !t(r.data)) throw new Error(`Bad ${e} format`);
              return r.data;
            })
          );
        }
        getQuarantinedSpaces$() {
          const {
            queries: { carbonState: e }
          } = this.carbonLegacyClient;
          return e({ path: "userSession.spaceData.spaces" }).pipe(
            (0, n.U)((e) => {
              if ((0, o.hx)(e) || !I(e.data)) throw new Error("Bad spaces format");
              return e.data.filter((e) => this.isPremiumStatusSpaceQuarantined(e.details));
            })
          );
        }
        isPremiumStatusSpaceQuarantined(e) {
          return "accepted" !== e.status.toLowerCase() && Boolean(e.info.removeForcedContentEnabled);
        }
      };
      ie = (0, s.__decorate)([(0, i.GS)(), (0, s.__metadata)("design:paramtypes", [u.CarbonLegacyClient])], ie);
    },
    36988: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => v });
      var s = r(88802),
        a = r(99634),
        n = r(73883),
        i = r(85390),
        o = r(43978),
        c = r(20754),
        u = r(87279),
        d = r(48844),
        l = r(85612),
        p = r(82706),
        h = r(88994),
        m = r(87969),
        y = r(62025);
      let g = class {
        constructor(e, t, r) {
          (this.vaultRepository = e),
            (this.vaultOrganizationClient = t),
            (this.sharingCollectionsClient = r),
            (this.separator = ","),
            (this.collections = []),
            (this.searchQuery = ""),
            (this.normalizeString = (e) =>
              e
                .normalize("NFD")
                .replace(/[\u0300-\u036f]/g, "")
                .toLowerCase()),
            (this.isVaultItemMatch = (e) => {
              let t = "";
              return (
                this.collections.forEach((r) => {
                  r.vaultItems.some((t) => t.id === e.id) && (t += `${r.name}${this.separator}`);
                }),
                this.isMatch(e, t)
              );
            });
        }
        execute({ body: e }) {
          const { vaultItemTypes: t, searchQuery: r, ...s } = e;
          this.searchQuery = r;
          const {
              queries: { queryCollections: a }
            } = this.vaultOrganizationClient,
            {
              queries: { sharedCollectionsWithItems: n }
            } = this.sharingCollectionsClient;
          return (0, i.a)([a({}), n()]).pipe(
            (0, o.w)(([e, r]) => {
              if ((0, u.hx)(e) || (0, u.hx)(r)) throw new Error("Error querying collections");
              return (
                (this.collections = e.data.collections.concat(r.data)),
                t
                  ? this.vaultRepository.fetchVaultItems$({ vaultItemTypes: t, ...s }, this.isVaultItemMatch)
                  : this.vaultRepository.fetchVaultItems$({ vaultItemTypes: Object.values(p.U), ...s }, this.isVaultItemMatch)
              );
            }),
            (0, d.Qn)((e) => {
              let r;
              if (t) r = { items: [], matchCount: 0 };
              else {
                const e = this.collections.filter((e) => this.isMatch(e));
                r = { items: e, matchCount: e.length };
              }
              return { ...e, collectionsResult: r };
            })
          );
        }
        isMatch(e, t = "") {
          return (
            (t += Object.values(e)
              .filter((e) => "object" != typeof e)
              .join(this.separator)),
            this.normalizeString(t).includes(this.normalizeString(this.searchQuery))
          );
        }
      };
      g = (0, s.__decorate)([(0, c.e)(h.W), (0, s.__metadata)("design:paramtypes", [y.g, m.C, l.L])], g);
      let v = class {};
      v = (0, s.__decorate)([(0, a.Y)({ api: n.R, handlers: { commands: {}, events: {}, queries: { search: g } }, providers: [y.g] })], v);
    },
    43866: (e, t, r) => {
      "use strict";
      r.d(t, { d: () => s });
      class s {
        constructor() {
          (this.shutdownHooks = []), (this.externalComponentReadyConditions = []), (this.appReadyHooks = []);
        }
        addExternalComponentReadyCondition(e) {
          this.externalComponentReadyConditions.push(e);
        }
        addAppReadyHook(e) {
          this.appReadyHooks.push(e);
        }
        addShutdownHook(e) {
          this.shutdownHooks.push(e);
        }
        removeShutdownHook(e) {
          const t = this.shutdownHooks.indexOf(e);
          t >= 0 && this.shutdownHooks.splice(t, 1);
        }
        startup() {
          const e = this.waitAndTriggerAppReady();
          if (!this.externalComponentReadyConditions.length) return e;
          this.addShutdownHook(async () => await e);
        }
        async shutDown() {
          for (; this.shutdownHooks.length > 0; ) {
            const e = this.shutdownHooks.pop();
            e && (await e());
          }
        }
        async waitAndTriggerAppReady() {
          await Promise.all(this.externalComponentReadyConditions.map((e) => e())), await this.executeStartupHooks(this.appReadyHooks);
        }
        async executeStartupHooks(e) {
          for (; e.length > 0; ) {
            const t = e.shift();
            if (t) {
              const e = await t();
              e && this.addShutdownHook(e);
            }
          }
        }
      }
    },
    21904: (e, t, r) => {
      "use strict";
      r.d(t, { O: () => c, r: () => u });
      var s = r(60399),
        a = r(24966),
        n = r(87065),
        i = r(30523),
        o = r(58376);
      class c {
        async waitTimeout(e) {
          await (0, s.z)(this.createObservableTimer(e, e));
        }
      }
      class u extends c {
        constructor() {
          super(...arguments),
            (this.subscribers$ = new a.X(new Set())),
            (this.time = 0),
            (this.pendingTimerCount$ = this.subscribers$.pipe((0, n.U)((e) => e.size)));
        }
        fireTimer(e = 1) {
          (this.time += e),
            [...this.subscribers$.value].forEach((e) => {
              e.next(this.time);
            });
        }
        async allSubscribersDisconnected() {
          await (0, s.z)(this.pendingTimerCount$.pipe((0, i.h)((e) => !e)));
        }
        createObservableTimer() {
          return new o.y(
            (e) => (
              this.subscribers$.next(new Set([...this.subscribers$.value, e])),
              () => {
                this.subscribers$.next(new Set([...this.subscribers$.value].filter((t) => t !== e)));
              }
            )
          );
        }
      }
    },
    96259: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => n, u: () => i });
      var s = r(8987),
        a = r(49329);
      const n = (e, t) =>
          (() => {
            const e = (t) => ({
              define: () => t,
              with: (r) => {
                const s = { api: r.module, main: r.on, queryOnly: r.queryOnly ?? [] },
                  a = { [r.module.name]: s };
                return e({ ...t, ...a });
              }
            });
            return e({});
          })()
            .with({ module: s.t$, on: e })
            .with({ module: a.e, on: e }),
        i = n("node", []);
    },
    26457: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => s, W: () => a });
      class s {}
      class a extends s {
        log() {}
        error() {}
        warn() {}
        trace() {}
      }
    },
    10514: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => n, Y: () => s });
      r(5373);
      var s,
        a = r(21869);
      !(function (e) {
        (e.Command = "command"), (e.Query = "query"), (e.Event = "event"), (e.Init = "init"), (e.Cron = "cron");
      })(s || (s = {}));
      const n = { body: void 0, context: new a.f(), module: "module", name: "command", type: s.Command };
    },
    49069: (e, t, r) => {
      "use strict";
      r.d(t, { u: () => qe, W: () => Ke });
      var s = r(10722),
        a = r(30523),
        n = r(60399),
        i = r(70695),
        o = r(28489);
      var c = r(73201),
        u = r(42949),
        d = r(94189),
        l = r(96917),
        p = r(16855),
        h = r(83081),
        m = r(43866),
        y = r(26457),
        g = r(88802),
        v = r(32875),
        f = r(10514);
      const w = { name: "api", commands: {}, events: {}, queries: {} };
      var S = r(25029),
        E = r(95087),
        _ = r(87279),
        b = r(8987);
      async function T(e) {
        const t = await (0, n.z)(e.getClient(b.t$).queries.activeUser());
        if ((0, _.d6)(t) && t.data.userName) return t.data.userName;
      }
      var A = r(21869),
        C = r(22838);
      let R = class {
        constructor(e, t, r) {
          (this.introspection = e), (this.moduleRef = t), (this.clients = r);
        }
        async execute(e) {
          const t = i.ContextIdFactory.getByRequest(e),
            { type: r } = e,
            s = () => e.context.getOrAdd(A.l.UserName, async () => await T(this.clients));
          if (!(e.module in this.introspection.modules)) throw new Error("Unknown module " + e.module);
          const a = this.introspection.modules[e.module],
            n = a.api ?? w,
            o = a.handlers ?? C.TB;
          switch (r) {
            case f.Y.Query: {
              const { queries: r } = n;
              if (e.name in r) {
                const a = r[e.name],
                  n = new a(e.body),
                  i = o.queries[e.name];
                a.metadata.scope === S.F.User && (await s());
                return { result: (await this.moduleRef.resolve(i, t, { strict: !1 })).execute(n, { name: e.name }) };
              }
              throw new Error("Unknown query " + e.name);
            }
            case f.Y.Command: {
              const { commands: r } = n;
              if (e.name in r) {
                const a = r[e.name],
                  n = new a(e.body),
                  i = o.commands[e.name];
                a.metadata.scope === S.F.User && (await s());
                const c = await this.moduleRef.resolve(i, t, { strict: !1 });
                return { result: await c.execute(n, { name: e.name }) };
              }
              throw new Error("Unknown command " + e.name);
            }
            case f.Y.Event: {
              const { events: r } = n;
              if (e.name in r) {
                const a = r[e.name],
                  n = new a(e.body),
                  i = Object.values(this.introspection.modules).flatMap((t) => (t.handlers ?? C.TB).events[e.module]?.events[e.name]);
                a.metadata.scope === S.F.User && (await s());
                const o = await Promise.all(
                  i
                    .filter((e) => this.introspection.supportedEventHandlers.has(e))
                    .map(async (e) => await this.moduleRef.resolve(e, t, { strict: !1 }))
                );
                return void (await Promise.all(o.map((e) => e.handle(n))));
              }
              throw new Error("Unknown event " + e.name);
            }
            case f.Y.Cron: {
              const r = (a.crons ?? []).find((t) => t.name === e.name);
              if (!r) throw new Error("unknown cron " + e.name);
              if (r.scope === S.F.User) {
                if (!(await s())) return { result: !1 };
              }
              const n = await this.moduleRef.resolve(r.handler, t, { strict: !1 });
              return n.isRunnable && !(await n.isRunnable()) ? { result: !1 } : (await n.run(), { result: !0 });
            }
          }
          (0, E.U)(r);
        }
      };
      (0, g.__decorate)(
        [
          (0, v.All)(),
          (0, g.__param)(0, (0, v.Req)()),
          (0, g.__metadata)("design:type", Function),
          (0, g.__metadata)("design:paramtypes", [Object]),
          (0, g.__metadata)("design:returntype", Promise)
        ],
        R.prototype,
        "execute",
        null
      ),
        (R = (0, g.__decorate)(
          [(0, v.Controller)({ scope: v.Scope.REQUEST, durable: !1 }), (0, g.__metadata)("design:paramtypes", [C.Q1, i.ModuleRef, d.m])],
          R
        ));
      var I = r(21904),
        x = r(11053),
        P = r(38144),
        D = r(23711),
        U = r(43702),
        F = r(91199),
        O = r(4603),
        N = r(75994),
        k = r(9671),
        L = r(71949),
        M = r(56860);
      let V = class {
        catch(e, t) {
          t.switchToHttp().getResponse().fail(e);
        }
      };
      V = (0, g.__decorate)([(0, v.Catch)(Error)], V);
      const G = {
        provide: A.f,
        scope: v.Scope.REQUEST,
        inject: [i.REQUEST],
        useFactory: (e) => {
          const t = (() => {
            switch (e.type) {
              case f.Y.Command:
              case f.Y.Event:
              case f.Y.Query:
              case f.Y.Cron:
                return e.context;
              case f.Y.Init:
                return new A.f();
              default:
                (0, E.U)(e);
            }
          })();
          return t.getOrAdd(A.l.UseCaseId, () => String(i.ContextIdFactory.getByRequest(e).id)), t;
        }
      };
      var j = r(97631);
      class q {
        static create({
          brokers: { cqrs: e, event: t },
          configProviders: r,
          keyValueStorageInfrastructure: a,
          lifeCycle: n,
          logger: o,
          modules: g,
          nodeConfiguration: v,
          storeInfrastructureFactory: f,
          timers: w,
          jsonFetcher: S,
          defaultDeviceStorageEncryptionCodecProvider: E,
          defaultUserStorageEncryptionCodecProvider: _,
          storeList: b,
          interceptors: T,
          introspection: K,
          moduleClientsProviders: W,
          userUseCaseScopeProvider: B
        }) {
          return {
            module: q,
            providers: [
              c.ExplorerService,
              { provide: F.QI, useValue: a },
              { provide: m.d, useValue: n },
              { provide: p.$, useValue: v },
              { provide: u.d, useValue: e },
              { provide: l.a, useValue: t },
              { provide: N.X, useValue: S },
              d.w,
              d.m,
              ...r,
              { provide: y.V, useValue: o },
              G,
              { provide: h.G, useValue: f },
              { provide: I.O, useValue: w },
              x.u1,
              { provide: O.u, useValue: new O.u(a) },
              D.z,
              E,
              _,
              U.b,
              s.E,
              { provide: C.Q1, useValue: K },
              { provide: M.D, useValue: b },
              L.X,
              k.J,
              { provide: i.APP_FILTER, useClass: V },
              ...T.flatMap((e) => [{ provide: i.APP_INTERCEPTOR, useClass: e }, e]),
              ...W,
              B
            ],
            imports: [...g],
            exports: [
              m.d,
              p.$,
              u.d,
              l.a,
              d.w,
              d.m,
              ...r.map(({ provide: e }) => e),
              y.V,
              A.f,
              h.G,
              I.O,
              x.u1,
              D.z,
              P.h,
              P.s,
              U.b,
              s.E,
              O.u,
              F.QI,
              N.X,
              L.X,
              k.J,
              C.Q1,
              ...W.map(({ provide: e }) => e),
              j.g
            ],
            controllers: [R],
            global: !0
          };
        }
      }
      var K = r(24966),
        W = r(17350),
        B = r(162),
        z = r(74081);
      const H = () => {},
        $ = () => {
          throw new Error("Not supported");
        };
      class Q {
        constructor(e, t, r) {
          (this.cqrsBroker = e),
            (this.eventsBroker = t),
            (this.cronsBroker = r),
            (this.isListening$ = new K.X(!1)),
            (this.use = $),
            (this.get = $),
            (this.post = $),
            (this.head = $),
            (this.delete = $),
            (this.put = $),
            (this.options = $),
            (this.patch = $),
            (this.end = $),
            (this.applyVersionFilter = $),
            (this.disconnect = H),
            (this.close = H),
            (this.status = $),
            (this.render = $),
            (this.redirect = $),
            (this.setHeader = $),
            (this.enableCors = $),
            (this.initHttpServer = $),
            (this.registerParserMiddleware = $),
            (this.createMiddlewareFactory = $);
        }
        isHeadersSent() {
          return !1;
        }
        bindHandler(e) {
          if (this.cqrsCallbacks || this.eventCallbacks) throw new Error("Handler already registered");
          (this.cqrsCallbacks = {
            onCommand: (t, r, s, a) =>
              new Promise((n, i) => {
                e(
                  { type: f.Y.Command, module: t, name: r, body: s, context: a },
                  { type: f.Y.Command, value: { result: (0, _.Vp)(void 0) }, reply: (e) => n(e), fail: (e) => i(e) }
                );
              }),
            onQuery: (t, r, s, a) => {
              const n = new Promise((n, i) => {
                e(
                  { type: f.Y.Query, module: t, name: r, body: s, context: a },
                  { type: f.Y.Query, value: { result: W.E }, reply: (e) => n(e), fail: (e) => i(e) }
                );
              });
              return (0, B.D)(n).pipe((0, z.J)());
            }
          }),
            (this.eventCallbacks = {
              onLocalEvent: (t, r, s, a, n) =>
                new Promise((r, i) => {
                  e({ type: f.Y.Event, body: a, context: n, name: s, module: t }, { type: f.Y.Event, reply: () => r(), fail: (e) => i(e) });
                })
            }),
            (this.cronCallbacks = (t, r) =>
              new Promise((s, a) => {
                e(
                  { type: f.Y.Cron, context: new A.f(), module: t, name: r },
                  { type: f.Y.Cron, value: { result: !1 }, reply: (e) => s(e), fail: (e) => a(e) }
                );
              }));
        }
        all(e, t) {
          if (!t) throw new Error("Provide a handler");
          return this.bindHandler(t);
        }
        async listen() {
          if (!this.cqrsCallbacks || !this.eventCallbacks || !this.cronCallbacks) throw new Error("Please call `all(path, handler)` first");
          const e = await this.cqrsBroker.connect(this.cqrsCallbacks).start(),
            t = await this.eventsBroker.connect(this.eventCallbacks).start(),
            r = await this.cronsBroker.connect(this.cronCallbacks).start(),
            { isListening$: s } = this;
          (this.disconnect = () => {
            e.stop(), t.stop(), r.stop(), s.complete();
          }),
            (this.close = this.disconnect),
            this.isListening$.next(!0);
        }
        reply(e, t) {
          switch (e.type) {
            case f.Y.Query:
            case f.Y.Command:
              e.reply(t.result);
              break;
            case f.Y.Event:
              e.reply();
              break;
            case f.Y.Cron:
              e.reply(t.result);
              break;
            default:
              (0, E.U)(e);
          }
        }
        getInstance() {
          return this;
        }
        getHttpServer() {
          return { once: H, address: () => "", removeListener: H };
        }
        getType() {
          return "AppCoreNode";
        }
      }
      const Y = () => {};
      class X extends i.AbstractHttpAdapter {
        constructor(e, t, r) {
          super(new Q(e, t, r)),
            (this.createMiddlewareFactory = this.instance.createMiddlewareFactory),
            (this.close = this.instance.close),
            (this.reply = this.instance.reply),
            (this.useStaticAssets = Y),
            (this.setViewEngine = Y),
            (this.getRequestHostname = Y),
            (this.status = Y),
            (this.render = Y),
            (this.redirect = Y),
            (this.setNotFoundHandler = Y),
            (this.setHeader = Y),
            (this.registerParserMiddleware = Y),
            (this.enableCors = Y),
            (this.setErrorHandler = Y),
            (this.end = Y),
            (this.isListening$ = this.instance.isListening$);
        }
        initHttpServer() {
          this.setHttpServer({ once: Y, address: () => "", removeListener: Y });
        }
        getRequestMethod() {
          return v.RequestMethod.ALL;
        }
        getRequestUrl() {
          return "/";
        }
        getType() {
          return "CoreApp";
        }
        isHeadersSent() {
          return !1;
        }
        applyVersionFilter() {
          throw new Error("Versioning not supported");
        }
      }
      var J = r(40945),
        Z = r(90171);
      class ee extends y.V {
        log() {}
        warn(e, ...t) {
          return console.warn(e, t);
        }
        error(e, ...t) {
          return console.error(e, t);
        }
        trace(e, ...t) {
          return console.trace(e, t);
        }
      }
      class te extends I.O {
        get time() {
          return Date.now();
        }
        createObservableTimer(e, t) {
          return (0, Z.H)(e, t);
        }
      }
      class re extends N.X {
        fetch() {
          return Promise.reject(
            new Error(
              "Please add a jsonFetcher to the application. Probably you are seing that in unit tests.\nIf this is the case, please mock whatever service is requiring to fetch the data"
            )
          );
        }
      }
      var se = r(79063);
      const ae = (e, t) =>
        t.reduce(
          (t, r) => {
            const s = Reflect.getMetadata(se.o, r.module);
            if (!(0, C.Vy)(s)) return t;
            s.onFrameworkInit &&
              (s.onFrameworkInit instanceof Array
                ? (t.onFrameworkInits = t.onFrameworkInits.concat(s.onFrameworkInit))
                : t.onFrameworkInits.push(s.onFrameworkInit));
            const a = s.api?.name ?? s.sharedModuleName ?? "unnamed";
            return (
              t.configProviders.push(
                ...(function (e, t, r, s) {
                  if (!r.configurations) return [];
                  const { configurations: a } = r,
                    n = [];
                  return (
                    Object.keys(a).forEach((e) => {
                      const r = a[e].token,
                        i = s.configurations?.[e];
                      if (!i) throw new Error(`Missing '${e}' configuration for '${t}' module`);
                      n.push({ ...i, provide: r });
                    }),
                    Object.keys(s.configurations ?? {}).forEach((s) => {
                      r.configurations?.[s] || e.error(`Unknown '${s}' configuration for '${t}' module will be unused`);
                    }),
                    n
                  );
                })(e, a, s, r)
              ),
              s.api?.name && t.modulesMetadata.set(s.api.name, s),
              t.modules.push(r.module),
              s.crons && t.crons.push(...s.crons.map((e) => ({ ...e, moduleName: a }))),
              s.handlers?.events && t.eventHandlers.push(...Object.values(s.handlers.events).flatMap((e) => Object.values(e.events))),
              s.stores && t.stores.push(...s.stores),
              (t.allDeclarations[a] = s),
              t
            );
          },
          {
            configProviders: new Array(),
            modules: new Array(),
            modulesMetadata: new Map(),
            onFrameworkInits: new Array(),
            crons: new Array(),
            eventHandlers: new Array(),
            stores: new Array(),
            allDeclarations: (0, o.Ay)({})
          }
        );
      var ne = r(54452),
        ie = r(15524),
        oe = r(69594),
        ce = r(17321),
        ue = r(5373);
      function de(e) {
        const { parameterProvider: t, token: r } = e;
        switch (t.type) {
          case ce.j.CLASS_PROVIDER:
            return { provide: r, useClass: t.useClass };
          case ce.j.VALUE_PROVIDER:
            return { provide: r, useValue: t.useValue };
          default:
            (0, E.U)(t);
        }
      }
      var le = r(99634),
        pe = r(37920),
        he = r(31638),
        me = r(63364);
      class ye extends me.fW {
        constructor() {
          super(W.E);
        }
      }
      const ge = {
        sink: (0, he.z)(
          new (class {
            logException() {
              return Promise.resolve();
            }
            start() {
              return Promise.resolve({ stop: () => Promise.resolve() });
            }
          })()
        ),
        uncaughtErrorSource: (0, he.z)(new ye())
      };
      var ve = r(57924),
        fe = r(68475),
        we = r(43004);
      let Se = class {
        constructor(e) {
          this.logger = e;
        }
        handle(e) {
          const { error: t, fileLocation: r, lineNumber: s, origin: a } = e,
            [n, i] = t instanceof fe.c ? [t.exception, t.useCaseStacktrace] : [t];
          return this.logger.captureException(n, { fileLocation: r, lineNumber: s, origin: a, useCaseStacktrace: i }, we.w.CRITICAL);
        }
      };
      Se = (0, g.__decorate)([(0, ve.GS)(), (0, g.__metadata)("design:paramtypes", [pe.v])], Se);
      let Ee = class {
        constructor(e, t, r, s) {
          (this.sink = e), (this.lifeCycle = t), (this.moduleRef = r), (this.uncaughtErrorsSource = s);
        }
        onFrameworkInit() {
          this.lifeCycle.addAppReadyHook(async () => {
            const { stop: e } = await this.sink.start(),
              t = this.uncaughtErrorsSource.events$.subscribe(this.onUncaughtErrorEvent.bind(this));
            return () => {
              t.unsubscribe(), e();
            };
          });
        }
        onUncaughtErrorEvent(e) {
          this.moduleRef.get(Se).handle(e);
        }
      };
      Ee = (0, g.__decorate)([(0, ve.ar)(), (0, g.__metadata)("design:paramtypes", [me.qD, m.d, i.ModuleRef, me.fW])], Ee);
      var _e,
        be = r(428);
      let Te = (_e = class {
        static configure(e) {
          return {
            module: _e,
            configurations: { ...ge, sink: e.sink, ...(e.uncaughtErrorSource ? { uncaughtErrorSource: e.uncaughtErrorSource } : {}) }
          };
        }
      });
      Te = _e = (0, g.__decorate)(
        [
          (0, le.Y)({
            sharedModuleName: "exception-logging",
            providers: [pe.v, { provide: i.APP_INTERCEPTOR, useClass: fe.x }, be.F, Se],
            configurations: { sink: { token: me.qD }, uncaughtErrorSource: { token: me.fW } },
            exports: [pe.v, be.F],
            onFrameworkInit: Ee,
            requiredFeatureFlips: []
          })
        ],
        Te
      );
      var Ae = r(43978),
        Ce = r(69885);
      const Re = { tag: "" };
      let Ie = class {
        constructor(e, t, r, s) {
          (this.request = e), (this.clients = t), (this.config = r), (this.introspection = s);
        }
        intercept(e, t) {
          const { request: r } = this,
            { appDefinition: s } = this.config;
          if (r.type === f.Y.Cron) return this.checkCronActiveUser(t, r);
          if (!(r.module in s)) return t.handle();
          const a = s[r.module].api;
          switch (r.type) {
            case f.Y.Query:
              return this.checkQueryActiveUser(t, r, a);
            case f.Y.Command:
              return this.checkCommandActiveUser(t, r, a);
            case f.Y.Event:
              return this.checkEventActiveUser(t, r, a);
            default:
              (0, E.U)(r);
          }
        }
        checkCronActiveUser(e, t) {
          const r = (this.introspection.modules[t.module].crons ?? []).find((e) => e.name === t.name);
          if (!r) throw new Error("No such cron " + t.name);
          return r.scope === S.F.Device
            ? e.handle()
            : this.checkActiveUserPromise(e, t.context, { noUserError: Re, scope: S.F.User }, "Cron");
        }
        checkQueryActiveUser(e, t, r) {
          const { queries: s } = r;
          if (t.name in s) {
            const r = s[t.name],
              { metadata: a } = r;
            return this.checkActiveUserObservable(e, t.context, a, `Query ${t.module}.${t.name}`);
          }
          return e.handle();
        }
        checkCommandActiveUser(e, t, r) {
          const { commands: s } = r;
          if (t.name in s) {
            const r = s[t.name],
              { metadata: a } = r;
            return this.checkActiveUserPromise(e, t.context, a, `Command ${t.module}.${t.name}`);
          }
          return e.handle();
        }
        checkEventActiveUser(e, t, r) {
          const { events: s } = r;
          if (t.name in s) {
            const r = s[t.name],
              { metadata: a } = r;
            return this.checkActiveUserPromise(e, t.context, a, `Event ${t.module}.${t.name}`);
          }
          return e.handle();
        }
        checkActiveUserPromise(e, t, r, s) {
          if (r.scope !== S.F.User) return e.handle();
          const { noUserError: a } = r;
          return (0, B.D)(t.getOrAdd(A.l.UserName, () => T(this.clients))).pipe(
            (0, Ae.w)((t) => {
              if (t) return e.handle();
              if (a) return (0, Ce.of)({ result: (0, _.Rn)(a) });
              throw new Error(`Not logged in : ${s}`);
            })
          );
        }
        checkActiveUserObservable(e, t, r, s) {
          if (r.scope !== S.F.User) return e.handle();
          const { noUserError: a } = r;
          return (0, B.D)(t.getOrAdd(A.l.UserName, () => T(this.clients))).pipe(
            (0, Ae.w)((t) => {
              if (t) return e.handle();
              if (a) return (0, Ce.of)({ result: new K.X((0, _.Rn)(a)) });
              throw new Error(`Not logged in : ${s}`);
            })
          );
        }
      };
      Ie = (0, g.__decorate)(
        [
          (0, v.Injectable)({ scope: v.Scope.REQUEST }),
          (0, g.__param)(0, (0, v.Inject)(i.REQUEST)),
          (0, g.__metadata)("design:paramtypes", [Object, d.m, p.$, C.Q1])
        ],
        Ie
      );
      class xe {
        constructor(e, t) {
          (this.storage = e), (this.storageKey = `crons.${t}`);
        }
        async setState(e) {
          await this.storage.set(this.storageKey, JSON.stringify(e));
        }
        async getState() {
          const e = await this.storage.get(this.storageKey);
          if (!e) return { entries: [] };
          const t = JSON.parse(e);
          return (r = t) &&
            "object" == typeof r &&
            "entries" in r &&
            Array.isArray(r.entries) &&
            r.entries.every((e) =>
              (function (e) {
                return (
                  !!e &&
                  "object" == typeof e &&
                  "dueTimestamp" in e &&
                  "moduleName" in e &&
                  "name" in e &&
                  "string" == typeof e.name &&
                  "string" == typeof e.moduleName &&
                  "number" == typeof e.dueTimestamp
                );
              })(e)
            )
            ? t
            : { entries: [] };
          var r;
        }
      }
      var Pe = r(34987);
      const De = 6e4;
      function Ue(e) {
        return Math.ceil(e / De) * De;
      }
      function Fe(e) {
        return Math.floor(e / De) * De;
      }
      class Oe {
        constructor(e, t) {
          (this.infra = e), (this.definitions = t);
        }
        async init() {
          const e = Ue(this.infra.timers.time),
            t = await this.infra.repository.getState(),
            r = this.definitions.filter((e) => !t.entries.find((t) => t.name === e.name && t.moduleName === e.moduleName)),
            s = {
              entries: [
                ...t.entries.filter((e) => this.definitions.find((t) => t.name === e.name && t.moduleName === e.moduleName)),
                ...r.map((t) => ({ ...t, dueTimestamp: e + t.periodInMinutes * De }))
              ]
            };
          await this.infra.repository.setState(s);
        }
        connect(e) {
          const { infra: t, definitions: r } = this;
          return {
            start: async () => {
              await this.init();
              const s = t.cronSource.alarm$
                .pipe(
                  (0, Pe.b)(async () => {
                    const s = await t.repository.getState(),
                      a = Ue(t.timers.time),
                      n = Fe(t.timers.time),
                      i = s.entries.filter((e) => e.dueTimestamp <= a);
                    await Promise.allSettled(
                      i.map((a) => {
                        const i = r.find((e) => e.moduleName === a.moduleName && e.name === a.name);
                        if (!i) throw new Error("we should have a declaration");
                        return (async function (r, s, a, n) {
                          let i = !1;
                          try {
                            i = await e(a.moduleName, a.name);
                          } finally {
                            i && ((a.dueTimestamp = Fe(r + n.periodInMinutes * De)), await t.repository.setState(s));
                          }
                        })(n, s, a, i);
                      })
                    );
                  })
                )
                .subscribe();
              return {
                stop: () => {
                  s.unsubscribe();
                }
              };
            }
          };
        }
      }
      let Ne = class {
        constructor(e, t) {
          (this.request = e), (this.useCaseStacktraceRepo = t);
        }
        intercept(e, t) {
          return this.useCaseStacktraceRepo.append(this.request.name), t.handle();
        }
      };
      Ne = (0, g.__decorate)(
        [
          (0, v.Injectable)({ scope: v.Scope.REQUEST }),
          (0, g.__param)(0, (0, v.Inject)(i.REQUEST)),
          (0, g.__metadata)("design:paramtypes", [Object, be.F])
        ],
        Ne
      );
      class ke {
        constructor(e, t) {
          this.client = e.getClient(t);
        }
        get commands() {
          return this.client.commands;
        }
        get queries() {
          return this.client.queries;
        }
      }
      var Le = r(69008),
        Me = r(33920);
      let Ve;
      var Ge = r(73656);
      const je = [Ne, Ie],
        qe = async ({
          appDefinition: e,
          channels: t,
          currentNode: r,
          implementations: c,
          otherModules: y = [],
          logger: g = new ee(),
          storeInfrastructureFactory: v = new h.N(),
          channelsListener: w = ne.y,
          timers: S = new te(),
          keyValueStorageInfrastructure: E = new ie.s(),
          jsonFetcher: _ = new re(),
          cronSource: b = new oe._C(S),
          defaultDeviceStorageEncryptionCodec: T = { type: ce.j.CLASS_PROVIDER, useClass: s.E },
          defaultUserStorageEncryptionCodec: R = { type: ce.j.CLASS_PROVIDER, useClass: s.E },
          exceptionLogging: I = ge
        }) => {
          const x = () => {
            throw new Error("Aborted");
          };
          (Ge.abort = x), (Ge.exit = x);
          const D = [
              ...[Te.configure(I)],
              ...y,
              ...Object.keys(c)
                .map((e) => e)
                .map((e) => c[e])
            ],
            {
              configProviders: U,
              modules: F,
              modulesMetadata: O,
              onFrameworkInits: N,
              crons: k,
              eventHandlers: L,
              stores: V,
              allDeclarations: G
            } = ae(g, D),
            K = new M.D();
          V.forEach((e) => {
            K.registerClass(e);
          }),
            ((e, t, r) => {
              const s = new Set([...r.keys()]),
                a = new Set(
                  Object.values(e)
                    .filter((e) => e.main === t || e.queryOnly.includes(t))
                    .map((e) => e.api.name)
                ),
                n = [...a].filter((e) => !s.has(e)),
                i = [...s].filter((e) => !a.has(e));
              if (n.length > 0) throw new Error("These APIs are not implemented " + JSON.stringify(n));
              if (i.length > 0) throw new Error("Some implementations do not have APIS " + JSON.stringify(i));
            })(e, r, O);
          const W = ((e) =>
              [...e.entries()].reduce(
                (e, [t, r]) => {
                  const s = r.handlers?.events ?? {};
                  return (
                    (e[t] = Object.values(s).reduce((e, t) => (t.name ? ((e[t.name] = Object.keys(t.events)), e) : e), (0, o.Ay)({}))), e
                  );
                },
                (0, o.Ay)({})
              ))(O),
            B = new p.$({ appDefinition: e, channels: t, channelsListener: w, currentNode: r, subscriptions: W }),
            z = new u.d(B),
            H = new l.a(B),
            $ = new Oe({ cronSource: b, repository: new xe(E, r), timers: S }, k),
            Q = new X(z, H, $),
            Y = de({ token: P.h, parameterProvider: T }),
            Z = de({ token: P.s, parameterProvider: R }),
            se = new m.d(),
            le = new C.Q1(new Set(L), G),
            pe = (function (e) {
              const t = [];
              return (
                Object.values(e).forEach((e) => {
                  const { api: r } = e,
                    { ClientClass: s } = r;
                  s && ((0, ve.GS)()(s), t.push({ provide: s, useFactory: (e) => new ke(e, r), inject: [d.w] }));
                }),
                t
              );
            })(e),
            he = {
              useFactory: (e, t, r) => {
                const s = e.get(A.l.UserName);
                if (s) return (Ve && Ve.status !== Me.p.Closed) || (Ve = new j.g(s, r, t)), Promise.resolve(Ve);
              },
              provide: j.g,
              inject: [A.f, Le.Q, m.d]
            },
            me = q.create({
              nodeConfiguration: B,
              brokers: { cqrs: z, event: H },
              modules: F,
              configProviders: U,
              logger: g,
              lifeCycle: se,
              storeInfrastructureFactory: v,
              timers: S,
              keyValueStorageInfrastructure: E,
              jsonFetcher: _,
              defaultDeviceStorageEncryptionCodecProvider: Y,
              defaultUserStorageEncryptionCodecProvider: Z,
              storeList: K,
              interceptors: je,
              introspection: le,
              moduleClientsProviders: pe,
              userUseCaseScopeProvider: he
            }),
            ye = await i.NestFactory.create(me, Q, { logger: g }),
            fe = await ye.init();
          await (async function (e, t) {
            const r = Object.freeze({ id: -1 }),
              s = e.map(async (e) => {
                const s = { type: f.Y.Init, [ue.REQUEST_CONTEXT_ID]: r };
                t.registerRequestByContextId(s, r);
                const a = await t.resolve(e, r, { strict: !1 });
                await a.onFrameworkInit();
              });
            await Promise.all(s);
          })(N, fe),
            ye.listen("");
          const we = Q.isListening$.pipe((0, a.h)((e) => !!e));
          return (
            await (0, n.z)(we),
            se.addShutdownHook(() => ye.close()),
            await se.startup(),
            {
              stop: () => se.shutDown(),
              createClient: () => (0, J.R)(e, z),
              sendEvent: (e, t, r, s) => H.publishEvent(e, t, r, s ?? new A.f())
            }
          );
        },
        Ke = (e) => qe({ ...e, appDefinition: e.appDefinition, channels: {}, currentNode: "node" });
    },
    42949: (e, t, r) => {
      "use strict";
      r.d(t, { d: () => y });
      var s = r(162),
        a = r(60399),
        n = r(30523),
        i = r(87065),
        o = r(17350),
        c = r(95087),
        u = r(28489);
      const d = (e) => "response" === e.type,
        l = (e, t, r, s) =>
          Object.keys(e).reduce(
            (a, n) => {
              const { commandMailbox: i, queryMailbox: o } = ((a) => {
                const { main: n, queryOnly: i } = e[a],
                  o = { type: "local", onMessage: s };
                if (n === t) return { commandMailbox: o, queryMailbox: o };
                const c = { type: "remote", channel: r[n] };
                return { commandMailbox: c, queryMailbox: t && i.includes(t) ? o : c };
              })(n);
              return (a[`command-${n}`] = i), (a[`query-${n}`] = o), a;
            },
            (0, u.Ay)({})
          );
      var p = r(65488),
        h = r(21869);
      const m = () => (0, s.D)([]);
      class y {
        constructor(e) {
          this.config = e;
        }
        async sendCommand(e, t, r, s) {
          if (!this.broker) throw new Error("call connect() first");
          return await (0, a.z)(
            this.broker
              .sendMessage(`command-${e}`, { type: "command", module: e, commandName: String(t), command: r, context: s.toSerializable() })
              .pipe(
                (0, n.h)(d),
                (0, i.U)((e) => e.response)
              )
          );
        }
        sendQuery(e, t, r, s) {
          if (!this.broker) throw new Error("call connect() first");
          return this.broker
            .sendMessage(`query-${e}`, { type: "query", module: e, queryName: String(t), query: r, context: s.toSerializable() })
            .pipe(
              (0, n.h)(d),
              (0, i.U)((e) => e.response)
            );
        }
        connect(e) {
          const t = e
              ? (t, r, a) => {
                  switch (r.type) {
                    case "response":
                      return o.E;
                    case "command":
                      return (0, s.D)(
                        e.onCommand(r.module, r.commandName, r.command, h.f.fromSerializable(r.context), { isReminder: a.isReminder })
                      ).pipe((0, i.U)((e) => ({ type: "response", response: e })));
                    case "query":
                      return (0, s.D)(e.onQuery(r.module, r.queryName, r.query, h.f.fromSerializable(r.context))).pipe(
                        (0, i.U)((e) => ({ type: "response", response: e }))
                      );
                  }
                  (0, c.U)(r);
                }
              : m,
            r = l(this.config.appDefinition, this.config.currentNode, this.config.channels, t);
          return (this.broker = new p.U(r)), this.broker.connect(Object.values(this.config.channels), this.config.channelsListener);
        }
      }
    },
    94189: (e, t, r) => {
      "use strict";
      r.d(t, { m: () => d, w: () => u });
      var s = r(88802),
        a = r(57924),
        n = r(16855),
        i = r(42949),
        o = r(40945),
        c = r(21869);
      let u = class {
        constructor(e, t, r) {
          (this.broker = e), (this.configuration = t), (this.context = r);
        }
        getClient(e) {
          return (0, o.c)(this.configuration.appDefinition, this.broker, e.name, this.context);
        }
      };
      u = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [i.d, n.$, c.f])], u);
      let d = class {
        constructor(e, t) {
          (this.configuration = e), (this.broker = t);
        }
        getClient(e) {
          return (0, o.c)(this.configuration.appDefinition, this.broker, e.name);
        }
      };
      d = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [n.$, i.d])], d);
    },
    40945: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => i, c: () => n });
      var s = r(28489),
        a = r(21869);
      const n = (e, t, r, n) => ({
          commands: Object.keys(e[r].api.commands).reduce(
            (e, s) => (
              (e[s] = (e) => {
                const i = n ?? new a.f();
                return t.sendCommand(r, s, e, i);
              }),
              e
            ),
            (0, s.Ay)({})
          ),
          queries: Object.keys(e[r].api.queries).reduce(
            (e, s) => (
              (e[s] = (e) => {
                const i = n ?? new a.f();
                return t.sendQuery(r, s, e, i);
              }),
              e
            ),
            (0, s.Ay)({})
          )
        }),
        i = (e, t, r) => {
          const n = (n) =>
              Object.keys(e[n].api.commands).reduce(
                (e, s) => (
                  (e[s] = (e) => {
                    const i = r ?? new a.f();
                    return t.sendCommand(n, s, e, i);
                  }),
                  e
                ),
                (0, s.Ay)({})
              ),
            i = (n) =>
              Object.keys(e[n].api.queries).reduce(
                (e, s) => (
                  (e[s] = (e) => {
                    const i = r ?? new a.f();
                    return t.sendQuery(n, s, e, i);
                  }),
                  e
                ),
                (0, s.Ay)({})
              );
          return Object.keys(e)
            .map((e) => e)
            .reduce((e, t) => ((e[t] = { commands: n(t), queries: i(t) }), e), {});
        };
    },
    81459: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => d, f: () => u });
      var s = r(88802),
        a = r(32875),
        n = r(57924),
        i = r(93417),
        o = r(96917),
        c = r(21869);
      let u = class {
        constructor(e, t, r) {
          (this.apiName = e), (this.broker = t), (this.context = r);
        }
        sendEvent(e, t) {
          return this.broker.publishEvent(this.apiName, e, t, this.context);
        }
      };
      u = (0, s.__decorate)(
        [(0, n.GS)(), (0, s.__param)(0, (0, a.Inject)(i.r)), (0, s.__metadata)("design:paramtypes", [Object, o.a, c.f])],
        u
      );
      let d = class {
        constructor(e, t) {
          (this.apiName = e), (this.broker = t);
        }
        sendEvent(e, t, r) {
          return this.broker.publishEvent(this.apiName, e, t, r ?? new c.f());
        }
      };
      d = (0, s.__decorate)([(0, n.GS)(), (0, s.__param)(0, (0, a.Inject)(i.r)), (0, s.__metadata)("design:paramtypes", [Object, o.a])], d);
    },
    96917: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => y });
      var s = r(88802),
        a = r(162),
        n = r(87065),
        i = r(17350),
        o = r(69885),
        c = r(65488),
        u = r(28489);
      const d = { type: "ask" },
        l = { type: "eventResponse" };
      var p = r(57924),
        h = r(16855),
        m = r(21869);
      let y = class {
        constructor(e) {
          (this.regenerateReverseSubscriptionMap = () => {
            const { configuration: e, subscriberToEvent: t } = this,
              r = e.getModuleNames().reduce((e, t) => ({ ...e, [t]: new Map() }), {});
            return e.getNodeList().reduce((e, r) => {
              const s = t[r];
              return (
                Object.entries(s).forEach(([t, s]) => {
                  const a = e[t];
                  s.forEach((e) => {
                    const t = [...(a.get(e) ?? []), r];
                    a.set(e, t);
                  });
                }),
                e
              );
            }, r);
          }),
            (this.configuration = e);
          const t = Object.entries(e.appDefinition).reduce((e, [t, r]) => ((e[t] = Object.keys(r.api.events)), e), {});
          (this.subscriberToEvent = this.configuration.getNodeList().reduce((e, r) => ((e[r] = { ...t }), e), {})),
            (this.eventToSubscriber = this.regenerateReverseSubscriptionMap());
        }
        async publishEvent(e, t, r, s) {
          const { broker: a, eventToSubscriber: n } = this;
          if (!a) throw new Error("Not started");
          const i = (n[e].get(t) ?? []).map((a) => ({
            type: "event",
            context: s.toSerializable(),
            event: r,
            eventName: t,
            moduleSource: e,
            nodeDestination: a
          }));
          await Promise.all(
            i.map(async (e) => {
              await a.trySendMessage(`event-${e.nodeDestination}`, e);
            })
          );
        }
        connect(e) {
          const { configuration: t } = this,
            r = Object.keys(t.subscriptions).reduce((e, r) => ({ ...e, ...t.subscriptions[r] }), (0, u.Ay)({})),
            s = { type: "subscriptions", nodeName: t.currentNode, subscribesTo: r },
            p = ((e, t) =>
              e
                .getNodeList()
                .reduce(
                  (r, s) => (
                    s === e.currentNode
                      ? (r[`event-${s}`] = { type: "local", onMessage: t })
                      : (r[`event-${s}`] = { type: "remote", channel: e.channels[s] }),
                    r
                  ),
                  (0, u.Ay)({})
                ))(this.configuration, (t, r, c) => {
              switch (r.type) {
                case "event":
                  return (0, a.D)(
                    e.onLocalEvent(r.moduleSource, r.nodeDestination, r.eventName, r.event, m.f.fromSerializable(r.context), c)
                  ).pipe((0, n.U)(() => l));
                case "eventResponse":
                  return i.E;
                case "subscriptions":
                  return (
                    (this.subscriberToEvent[r.nodeName] = r.subscribesTo),
                    (this.eventToSubscriber = this.regenerateReverseSubscriptionMap()),
                    (0, o.of)(l)
                  );
                case "ask":
                  return (0, o.of)(s);
              }
            }),
            h = new c.U(p);
          return (
            t.getNodeList().map(async (e) => {
              await h.trySendMessage(`event-${e}`, s), await h.trySendMessage(`event-${e}`, d);
            }),
            (this.broker = h),
            h.connect(Object.values(t.channels), t.channelsListener)
          );
        }
      };
      y = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [h.$])], y);
    },
    63663: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => a });
      var s = r(57924);
      function a(e) {
        const t = (0, s.GS)();
        return (r) => {
          Reflect.defineMetadata("dl-handler", r, e), t(r);
        };
      }
    },
    11053: (e, t, r) => {
      "use strict";
      r.d(t, { Tx: () => l, b2: () => d, u1: () => p });
      var s = r(88802),
        a = r(6220),
        n = r(7074),
        i = r(58376),
        o = r(57924),
        c = r(21904),
        u = r(94189);
      function d(e) {
        return e;
      }
      class l {
        constructor(e, t, { args: r, commandName: s }) {
          const i = t.commands[s];
          this.refreshObservable$ = e.pipe(
            (0, a.z)(async () => {
              await i(r);
            }),
            (0, n.B)({})
          );
        }
        withRefresh() {
          return (e) =>
            new i.y((t) => {
              const r = this.refreshObservable$.subscribe();
              return r.add(e.subscribe(t)), r;
            });
        }
      }
      let p = class {
        constructor(e, t) {
          (this.timers = e), (this.cqrsClient = t), (this.map = new WeakMap());
        }
        getRefresher(e) {
          const t = this.map.get(e);
          if (t) return t;
          return new l(this.timers.createObservableTimer(e.period, e.period), this.cqrsClient.getClient(e.api), e);
        }
      };
      p = (0, s.__decorate)([(0, o.GS)(), (0, s.__metadata)("design:paramtypes", [c.O, u.m])], p);
    },
    68307: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => a });
      var s = r(57924);
      function a(e) {
        const t = (0, s.GS)();
        return (r) => {
          if (Reflect.hasMetadata("dl-handlers", e)) {
            const t = Reflect.getMetadata("dl-handlers", e);
            Reflect.defineMetadata("dl-handlers", [...t, r], e);
          } else Reflect.defineMetadata("dl-handlers", [r], e);
          t(r);
        };
      }
    },
    20754: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => a });
      var s = r(57924);
      function a(e) {
        const t = (0, s.GS)();
        return (r) => {
          Reflect.defineMetadata("dl-handler", r, e), t(r);
        };
      }
    },
    79063: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => s });
      const s = "dl-module";
    },
    38679: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => c });
      var s = r(70695),
        a = r(69183),
        n = r(57924),
        i = r(64987),
        o = r(43866);
      const c = (e, t) => {
        const r = t.token ?? (0, a.Z)();
        class c {
          constructor() {
            this.mutex = new i.WU();
          }
          getOrCreate(e, t) {
            return this.mutex.runExclusive(
              async () => (
                this.instance ||
                  (t.addShutdownHook(() => {
                    this.invalidate();
                  }),
                  (this.instance = await e())),
                this.instance
              )
            );
          }
          invalidate() {
            this.instance = void 0;
          }
        }
        (0, n.GS)()(c);
        const u = c,
          d = {
            token: e,
            inject: [c, o.d, s.ModuleRef, s.REQUEST],
            asyncFactory: (e, t, a, n) => {
              const i = s.ContextIdFactory.getByRequest(n);
              return e.getOrCreate(() => a.resolve(r, i), t);
            }
          };
        return [{ ...t, token: r }, u, d];
      };
    },
    57924: (e, t, r) => {
      "use strict";
      r.d(t, { GS: () => n, ar: () => i, xB: () => a });
      var s = r(32875);
      function a() {
        return (0, s.Global)();
      }
      function n(e) {
        return (0, s.Injectable)({ scope: e?.neverReuseInstance ? s.Scope.TRANSIENT : s.Scope.DEFAULT });
      }
      const i = () => n();
    },
    99634: (e, t, r) => {
      "use strict";
      r.d(t, { Y: () => f, g: () => g });
      r(60171);
      var s = r(79063),
        a = r(32875),
        n = r(93417),
        i = r(88802),
        o = r(43702),
        c = r(23711),
        u = r(91199),
        d = r(21869);
      const l = new o.b(),
        p = new c.z();
      let h = class {
        constructor(e, t, r) {
          (this.kv = e), (this.prefix = `batch-storage.${r}.${t.get(d.l.UserName)}`);
        }
        async getBatchState(e) {
          const t = await this.kv.get(`${this.prefix}.${e}`);
          return t ? this.stringToState(t) : { queue: [] };
        }
        async setBatchState(e, t) {
          const r = this.stateToString(t);
          return await this.kv.set(`${this.prefix}.${e}`, r);
        }
        stateToString(e) {
          const t = l.encode(e);
          return p.encode(t);
        }
        stringToState(e) {
          const t = p.decode(e);
          return l.decode(t);
        }
      };
      h = (0, i.__decorate)([(0, i.__param)(2, (0, a.Inject)(n.r)), (0, i.__metadata)("design:paramtypes", [u.QI, d.f, String])], h);
      class m {
        getProviders(e) {
          if (!e.length) return [];
          return [
            ...e.map((e) => ({ provide: e, inject: [h, e.Definition.chunkProcessor], useFactory: (t, r) => new e(t, r) })),
            ...e.map(({ Definition: { chunkProcessor: e } }) => e),
            h
          ];
        }
      }
      var y = r(5711);
      const g = (e, t) => ({ [e.name]: { name: e.name, events: t } }),
        v = (e, t) => {
          const { exports: r = [], imports: s = [], providers: a = [], onFrameworkInit: n = [], stores: i = [], crons: o = [] } = e,
            c = [n, t.onFrameworkInit ?? []].flat();
          return {
            ...e,
            exports: r.concat(t.exports ?? []),
            imports: s.concat(t.imports ?? []),
            providers: a.concat(t.providers ?? []),
            onFrameworkInit: c,
            stores: i.concat(t.stores ?? []),
            crons: o.concat(t.crons ?? [])
          };
        };
      function f(e) {
        const { composes: t = [] } = e;
        e = t.reduce((e, t) => v(e, t), e);
        const {
            exports: r = [],
            imports: i = [],
            handlers: o = { commands: {}, events: {}, queries: {} },
            providers: c = [],
            onFrameworkInit: u = [],
            stores: d,
            batchExecutors: l,
            crons: p
          } = e,
          h = e.api?.name ?? e.sharedModuleName,
          g = h ? (0, y.N)(...(d ?? [])) : [],
          f = h ? new m().getProviders(l ?? []) : [],
          w = [
            ...c,
            ...(p ?? []).map((e) => e.handler),
            ...g,
            ...f,
            ...Object.values(o.commands),
            ...Object.values(o.queries),
            ...Object.values(o.events)
              .map((e) => Object.values(e.events))
              .reduce((e, t) => [...e, ...t], new Array()),
            ...(u instanceof Array ? u : [u]),
            { provide: n.r, useValue: h }
          ],
          { asyncProviders: S, basicClassProviders: E } = w.reduce(
            (e, t) => {
              return "object" == typeof (r = t) && "token" in r && "asyncFactory" in r && "function" == typeof r.asyncFactory
                ? { asyncProviders: [...e.asyncProviders, t], basicClassProviders: e.basicClassProviders }
                : { asyncProviders: e.asyncProviders, basicClassProviders: [...e.basicClassProviders, t] };
              var r;
            },
            { asyncProviders: new Array(), basicClassProviders: new Array() }
          ),
          _ = [...E, ...S.map((e) => ({ provide: e.token, useFactory: e.asyncFactory, inject: e.inject }))],
          b = (0, a.Module)({ exports: r, imports: i, providers: _ });
        return (t) => (Reflect.defineMetadata(s.o, e, t), b(t));
      }
    },
    93417: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => s });
      const s = "frameworkModuleName";
    },
    22838: (e, t, r) => {
      "use strict";
      r.d(t, { Q1: () => n, TB: () => s, Vy: () => a });
      const s = { commands: {}, events: {}, queries: {} },
        a = (e) =>
          !(!e || "object" != typeof e) &&
          !(e.api && !(e.api.commands && e.api.events && e.api.name && e.api.queries && e.handlers)) &&
          !(e.exports && !Array.isArray(e.exports)) &&
          !(e.handlers && !e.api) &&
          !(e.imports && !Array.isArray(e.imports)) &&
          !(e.providers && !Array.isArray(e.providers));
      class n {
        constructor(e, t) {
          (this.supportedEventHandlers = e), (this.modules = t);
        }
      }
    },
    31638: (e, t, r) => {
      "use strict";
      r.d(t, { $: () => n, z: () => a });
      var s = r(17321);
      function a(e) {
        return { type: s.j.VALUE_PROVIDER, useValue: e };
      }
      function n(e) {
        return { type: s.j.CLASS_PROVIDER, useClass: e };
      }
    },
    17321: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { j: () => s }),
        (function (e) {
          (e.VALUE_PROVIDER = "value_provider"), (e.CLASS_PROVIDER = "class_provider");
        })(s || (s = {}));
    },
    63411: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => o });
      var s = r(25029),
        a = r(95087),
        n = r(38679),
        i = r(97956);
      const o = (e, t, r) => {
        switch (e) {
          case s.F.Device:
            return (0, n.H)(t, r);
          case s.F.User:
            return (0, i.M)(t, r);
          default:
            (0, a.U)(e);
        }
      };
    },
    97956: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => c });
      var s = r(70695),
        a = r(69183),
        n = r(64987),
        i = r(21869),
        o = r(97631);
      const c = (e, t) => {
        const r = t.token ?? (0, a.Z)();
        class c {
          constructor() {
            (this.instances = new Map()), (this.mutex = new n.WU());
          }
          getOrCreate(e, t, r) {
            return this.mutex.runExclusive(async () => {
              const s = this.instances.get(e);
              if (s) return s;
              r.addCloseHook(() => {
                this.invalidate(e);
              });
              const a = await t();
              return this.instances.set(e, a), a;
            });
          }
          invalidate(e) {
            this.instances.delete(e);
          }
        }
        const u = c,
          d = {
            token: e,
            inject: [c, i.f, s.ModuleRef, s.REQUEST, o.g],
            asyncFactory: (t, a, n, o, c) => {
              const u = s.ContextIdFactory.getByRequest(o),
                d = a.getOrDefault(i.l.UserName, "");
              if ("" === d) throw new Error(`Provider ${e} is a user-scoped singleton but there is no user`);
              if (!c) throw new Error("No user scope available");
              return t.getOrCreate(d, () => n.resolve(r, u), c);
            }
          };
        return [{ token: r, asyncFactory: t.asyncFactory, inject: [...(t.inject ?? []), i.f] }, u, d];
      };
    },
    9671: (e, t, r) => {
      "use strict";
      r.d(t, { J: () => S, f: () => E });
      var s = r(88802),
        a = r(70695),
        n = r(32875),
        i = r(60399),
        o = r(87065),
        c = r(89618),
        u = r(37182),
        d = r(69885),
        l = r(70493),
        p = r(87279),
        h = r(10514),
        m = r(43004),
        y = r(37920),
        g = r(21869),
        v = r(68475),
        f = r(428),
        w = r(94189);
      let S = class {
        constructor(e, t, r, s) {
          (this.request = e), (this.logger = t), (this.useCaseStacktraceRepo = r), (this.cqrsClient = s);
        }
        async do(...e) {
          return (await Promise.all(e.map((e) => this.doOne(e)))).every((e) => !!e);
        }
        async doOne(e, t = "method") {
          try {
            const r = await e();
            if ((0, p.AZ)(r) && (0, p.hx)(r)) throw new Error(`Allowed to fail ${t} has failed`);
            return !0;
          } catch (e) {
            const { request: t, useCaseStacktraceRepo: r } = this,
              [s, a] = e instanceof v.c ? [e.exception, e.useCaseStacktrace] : [e, r.read()];
            try {
              await Promise.race([
                new Promise((e) => setTimeout(e, 100)),
                this.logger.captureException(
                  s,
                  {
                    moduleName: t?.module,
                    useCaseId: t?.context.get(g.l.UseCaseId),
                    useCaseName: t?.name,
                    useCaseStacktrace: a,
                    featureFlips: await this.getUserFeatureFlips()
                  },
                  m.w.WARNING
                )
              ]);
            } catch (e) {}
            return !1;
          }
        }
        async conditionallyAllowToFailOne(e, t) {
          return t ? this.doOne(e) : (await e(), !0);
        }
        getUserFeatureFlips() {
          const {
            queries: { userFeatureFlips: e }
          } = this.cqrsClient.getClient(l.cV);
          return (0, i.z)(
            e().pipe(
              (0, o.U)((e) => ((0, p.d6)(e) ? (0, p.db)(e) : {})),
              (0, c.V)(50),
              (0, u.K)(() => (0, d.of)({}))
            )
          );
        }
      };
      function E() {
        return new S(h.H, (0, y.G)(), f.U, { getClient: () => ({ queries: { userFeatureFlips: () => (0, d.of)((0, p.Vp)({})) } }) });
      }
      S = (0, s.__decorate)(
        [(0, s.__param)(0, (0, n.Inject)(a.REQUEST)), (0, s.__metadata)("design:paramtypes", [Object, y.v, f.F, w.w])],
        S
      );
    },
    73774: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => h });
      var s = r(88802),
        a = r(69885),
        n = r(34987),
        i = r(48844),
        o = r(95087);
      class c {
        constructor(e, t) {
          this.pipeline = this.initPipeline(e, this.dedupeInterceptorsById(t));
        }
        handle(e) {
          return this.pipeline.handle(e);
        }
        dedupeInterceptorsById(e) {
          const t = e.reduce((e, t) => (e.set(t.id, t), e), new Map());
          return Array.from(t.values());
        }
        initPipeline(e, t) {
          return t.reduceRight((e, t) => ({ handle: (r) => t.intercept(r, e.handle.bind(e)) }), e);
        }
      }
      var u = r(4043);
      class d {
        constructor(e) {
          (this.backend = e), (this.interceptors = new Map());
        }
        addInterceptor(e) {
          this.interceptors.set(e.id, e);
        }
        request(...e) {
          return this.makeRequest(...e);
        }
        delete(e, t) {
          return this.makeRequest("DELETE", e, t);
        }
        get(e, t) {
          return this.makeRequest("GET", e, t);
        }
        head(e, t) {
          return this.makeRequest("HEAD", e, t);
        }
        options(e, t) {
          return this.makeRequest("OPTIONS", e, t);
        }
        patch(e, t, r) {
          return this.makeRequest("PATCH", e, { body: t, ...r });
        }
        post(e, t, r) {
          return this.makeRequest("POST", e, { body: t, ...r });
        }
        put(e, t, r) {
          return this.makeRequest("PUT", e, { body: t, ...r });
        }
        makeRequest(...e) {
          let t, r, s;
          if (1 === e.length) (t = e[0]), (r = "response");
          else {
            const [a, n, i] = e;
            (t = new u.a(a, n, void 0 !== i.body ? i.body : null, {
              headers: i.headers,
              params: i.params,
              responseType: i.responseType ?? "json",
              withCredentials: i.withCredentials
            })),
              (r = i.observe ?? "body"),
              "json" === i.responseType && "body" === i.observe && (s = i.responseBodyDecoder);
          }
          const d = new c(this.backend, Array.from(this.interceptors.values())),
            l = (0, a.of)(this.addContentTypeRequestHeader(t)).pipe((0, n.b)((e) => d.handle(e)));
          switch (r) {
            case "body":
              switch (t.responseType) {
                case "arraybuffer":
                  return l.pipe((0, i.Gx)((e) => e.arrayBuffer()));
                case "text":
                  return l.pipe((0, i.Gx)((e) => e.text()));
                case "json":
                  return l.pipe((0, i.Gx)((e) => e.json(s)));
                default:
                  (0, o.U)(t.responseType);
              }
              break;
            case "response":
              return l;
            default:
              (0, o.U)(r);
          }
        }
        addContentTypeRequestHeader(e) {
          if (!e.headers.has("content-type")) {
            const t = e.detectContentTypeHeader();
            if (t) return e.clone({ headers: e.headers.set("content-type", t) });
          }
          return e;
        }
      }
      var l = r(22253),
        p = r(57924);
      let h = class extends d {
        constructor(e) {
          super(e);
        }
      };
      h = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [l.j])], h);
    },
    25504: (e, t, r) => {
      "use strict";
      r.d(t, { X: () => o });
      var s = r(88802),
        a = r(22253),
        n = r(99634),
        i = r(73774);
      let o = class {};
      o = (0, s.__decorate)(
        [(0, n.Y)({ providers: [i.e], configurations: { infrastructure: { token: a.j } }, exports: [i.e], sharedModuleName: "http" })],
        o
      );
    },
    64827: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          AcknowledgedChannel: () => U.N,
          AllowedToFail: () => ie.J,
          AppLifeCycle: () => i.d,
          AppLogger: () => a.V,
          AppTimers: () => o.O,
          BadStatus: () => _.R,
          BaseEventEmitter: () => B.f,
          ChannelMessageBroker: () => x.U,
          ChannelState: () => P.D,
          CommandHandler: () => N.W,
          CommandRefresherFactory: () => M.u1,
          ContextLessCqrsClient: () => W.m,
          ContextlessBaseEventEmitter: () => B.C,
          CqrsBroker: () => V.d,
          CqrsClient: () => W.w,
          CqrsCommandRefresher: () => M.Tx,
          CronLowLevelSource: () => Se.R_,
          DefaultEncryptionCodecForDeviceData: () => se.h,
          DefaultEncryptionCodecForUserData: () => se.s,
          EventHandler: () => L.b,
          ExceptionCriticality: () => A.w,
          ExceptionLogger: () => R.v,
          ExceptionLoggingSink: () => C.qD,
          FetchFailedError: () => _.a,
          FrameworkInit: () => l.ar,
          FrameworkRequestContextValues: () => H.l,
          Global: () => l.xB,
          HttpBackend: () => g.j,
          HttpClient: () => b.e,
          HttpHeaders: () => v.W,
          HttpModule: () => T.X,
          HttpParams: () => f.L,
          HttpRequest: () => w.a,
          HttpResponse: () => S.Z,
          HttpStatusCode: () => E.W,
          Injectable: () => l.GS,
          JsonApplicationResourceFetcher: () => Ee.X,
          JsonApplicationResourceLoader: () => _e.K,
          KeyValueStorageFactory: () => re.u,
          KeyValueStorageInfrastructure: () => te.QI,
          ManualTriggeredTimers: () => o.r,
          MemoryChannel: () => P.q,
          MemoryKeyValueStorageInfrastructure: () => ae.s,
          MemoryStoreInfrastructureFactory: () => ne.N,
          MockJsonApplicationResourceFetcher: () => Ee.W,
          Module: () => d.Y,
          NoDynamicChannels: () => D.y,
          NodeConfiguration: () => O.$,
          NodeEventBroker: () => G.a,
          NodeModulesIntrospection: () => p.Q1,
          NodeToModuleEventBroker: () => q,
          NullCronTaskHandler: () => Se.ql,
          NullLogger: () => a.W,
          NullStorage: () => te.hL,
          ParameterProviderType: () => c.j,
          QueryHandler: () => k.e,
          RequestContext: () => H.f,
          RequestContextModule: () => ee.q,
          SingleNodeAppBuilder: () => n.u,
          Store: () => me.y,
          StoreCapacity: () => le.Y,
          StoreFlusher: () => he.X,
          StoreInfrastructureFactory: () => ne.G,
          TaskTrackingModule: () => I.c,
          TimerBasedCronSource: () => Se._C,
          UncaughtErrorSource: () => C.fW,
          createApplicationClient: () => Q,
          createClientFactory: () => $,
          createCqrsClient: () => K.c,
          createCqrsClients: () => K.R,
          createNullAllowedToFail: () => ie.f,
          createSingleChannelListener: () => D.v,
          defineApplication: () => n.t,
          defineBatchExecutor: () => we,
          defineStore: () => de.Q,
          deviceScopedSingletonProvider: () => y.H,
          getQueryValue: () => Z,
          getStoresProviders: () => pe.N,
          isExceptionLogEntry: () => A.h,
          isSendMessageRequest: () => F.F,
          isVersionedData: () => te.Ot,
          mockStore: () => ue,
          provideClass: () => u.$,
          provideValue: () => u.z,
          refresherCreationToken: () => M.b2,
          scopedSingleton: () => m.B,
          sendMessageRequest: () => F.k,
          startApplicationNode: () => s.u,
          startSingleApplicationNode: () => s.W,
          useEventsOfModule: () => d.g,
          userScopedSingletonProvider: () => h.M
        });
      var s = r(49069),
        a = r(26457),
        n = r(96259),
        i = r(43866),
        o = r(21904),
        c = r(17321),
        u = r(31638),
        d = r(99634),
        l = r(57924),
        p = r(22838),
        h = r(97956),
        m = r(63411),
        y = r(38679),
        g = r(22253),
        v = r(4607),
        f = r(69912),
        w = r(4043),
        S = r(12964),
        E = r(25994),
        _ = r(73155),
        b = r(73774),
        T = r(25504),
        A = r(43004),
        C = r(63364),
        R = r(37920),
        I = r(7876),
        x = r(65488),
        P = r(15572),
        D = r(54452),
        U = r(58649),
        F = r(45244),
        O = r(16855),
        N = r(63663),
        k = r(20754),
        L = r(68307),
        M = r(11053),
        V = r(42949),
        G = r(96917),
        j = r(28489);
      class q {
        constructor(e) {
          (this.publishEvent = (e, t, r, s) => this.broker.publishEvent(e, t, r, s)), (this.broker = new G.a(e));
          const t = e
            .getModuleNames()
            .reduce(
              (t, r) => ({ ...t, [r]: Object.keys(e.appDefinition[r].api.events).reduce((e, t) => ((e[t] = []), e), (0, j.Ay)({})) }),
              (0, j.Ay)({})
            );
          this.localSubscribersMap = Object.keys(e.subscriptions)
            .map((e) => e)
            .reduce((t, r) => {
              const s = e.subscriptions[r];
              return (
                Object.keys(s)
                  .map((e) => e)
                  .forEach((e) => {
                    const a = s[e] ?? [],
                      n = t[e];
                    a.forEach((e) => {
                      n[e].push(r);
                    });
                  }),
                t
              );
            }, t);
        }
        connect(e) {
          const { localSubscribersMap: t, broker: r } = this;
          return r.connect({
            onLocalEvent: async (r, s, a, n, i, o) => {
              const c = t[r][a];
              await Promise.all(
                c.map(async (t) => {
                  await e.onEvent(r, t, a, n, i, o);
                })
              );
            }
          });
        }
      }
      var K = r(40945),
        W = r(94189),
        B = r(81459);
      function z(e) {
        const t = (e) => ({
            build: () => e,
            withMockedCommand: (r, s) => ((e.commands[r] = s), t(e)),
            withMockedQuery: (r, s) => ((e.queries[r] = s), t(e))
          }),
          r = { commands: {}, queries: {} };
        for (const t of Object.keys(e.commands))
          r.commands[t] = jest.fn(() => {
            throw new Error(`command ${t} of module ${e.name} is called but not mocked`);
          });
        for (const t of Object.keys(e.queries))
          r.queries[t] = jest.fn(() => {
            throw new Error(`query ${t} of module ${e.name} is called but not mocked`);
          });
        return t(r);
      }
      var H = r(21869);
      const $ = () => {
        const e = (t, r) => {
          const s = new O.$({ appDefinition: t, channels: {}, channelsListener: D.y, currentNode: "", subscriptions: {} }),
            a = new V.d(s);
          let n;
          const i = async () => {
            if (n) return n;
            const e = r.build(),
              t = a.connect({
                onCommand: (t, r, s) => {
                  if (!(t in e)) throw new Error(`${t} is not mocked`);
                  return e[t].commands[r](s);
                },
                onQuery: (t, r, s) => {
                  if (!(t in e)) throw new Error(`${t} is not mocked`);
                  return e[t].queries[r](s);
                }
              });
            return (n = await t.start()), n;
          };
          return {
            buildClient: async (e) => {
              const t = new W.w(a, s, e ?? new H.f());
              return await i(), t;
            },
            buildContextlessClient: async () => {
              const e = new W.m(s, a);
              return await i(), e;
            },
            withMock: (s, a) => {
              const n = { ...t, ...(0, j.Ay)({ [s.name]: { api: s, main: "", queryOnly: [] } }) },
                i = r.withModule(s, a);
              return e(n, i);
            }
          };
        };
        return e(
          {},
          (function () {
            const e = new Map(),
              t = {
                withModule: (r, s) => {
                  const a = r.name;
                  if (void 0 === s) {
                    const s = z(r).build();
                    return e.set(a, s), t;
                  }
                  if ("function" == typeof s) {
                    const n = z(r);
                    return e.set(a, s(n).build()), t;
                  }
                  return e.set(a, s), t;
                },
                build: (t) => {
                  const r = t ? Object.keys(t) : [...e.keys()];
                  return Array.from(r).reduce(
                    (r, s) => ({ ...r, [s]: e.get(s) ?? z(t ? t[s].api : { name: "", commands: {}, events: {}, queries: {} }).build() }),
                    {}
                  );
                }
              };
            return t;
          })()
        );
      };
      function Q({ appDefinition: e, channels: t, channelsListener: r }) {
        const s = new O.$({ appDefinition: e, channels: t, channelsListener: r, currentNode: null, subscriptions: {} }),
          a = new V.d(s),
          n = () => {
            throw new Error("Unexpected request received by detached application client");
          },
          i = a.connect({ onCommand: n, onQuery: n }).start();
        return { client: (0, K.R)(e, a), stop: async () => (await i).stop() };
      }
      var Y = r(27149),
        X = r(60399),
        J = r(89618);
      async function Z(e, t = 1e4) {
        if (!(0, Y.b)(e)) throw new Error("Error in getQueryValue: the argument is not an observable");
        try {
          return await (0, X.z)(e.pipe((0, J.V)({ first: t })));
        } catch (e) {
          throw new Error("Error in getQueryValue: " + e);
        }
      }
      var ee = r(14463),
        te = r(91199),
        re = r(4603),
        se = r(38144),
        ae = r(15524),
        ne = r(83081),
        ie = r(9671),
        oe = r(10722);
      const ce = new ne.N();
      async function ue(e, t) {
        const r = new e("mockedModuleName", e.Definition, ce, "user", (0, ie.f)(), te.hL, new oe.E());
        return t && (await r.set(t)), r;
      }
      var de = r(95681),
        le = r(23347),
        pe = r(5711),
        he = r(71949),
        me = r(49959),
        ye = r(64987);
      const ge = 16,
        ve = 0.5,
        fe = 1.3;
      function we(e) {
        var t;
        const {
          chunkControl: { decrement: r = ve, increment: s = fe, initialSize: a = ge } = { decrement: ve, increment: fe, initialSize: ge }
        } = e;
        const n = new ye.WU();
        return (
          ((t = class {
            constructor(e, t) {
              (this.repository = e), (this.processor = t);
            }
            async dispatchBatch(e) {
              await n.runExclusive(async () => {
                const t = await this.pushItemsInQueue(e);
                for (; t.queue.length > 0; ) await this.processOneChunkFromQueue(t);
              });
            }
            async pushItemsInQueue(t) {
              const r = await this.repository.getBatchState(e.name),
                s = t.filter((e) => !r.queue.find((t) => t === e));
              return s.length && (r.queue.push(...s), await this.repository.setBatchState(e.name, r)), r;
            }
            async processOneChunkFromQueue(t) {
              const n = (function (e) {
                  const { lastStartedChunkFirstId: t, lastStartedChunkSize: n = a } = e;
                  if (!t) return a;
                  const i = !e.queue.find((e) => e === t);
                  return Math.max(1, i ? Math.ceil(n * s) : Math.floor(n * r));
                })(t),
                i = Math.min(n, t.queue.length);
              if (!i) throw new Error("Should have something to process");
              await this.repository.setBatchState(e.name, { ...t, lastStartedChunkSize: i, lastStartedChunkFirstId: t.queue[0] });
              const o = t.queue.splice(0, i);
              await this.processor.processChunk(o), await this.repository.setBatchState(e.name, t);
            }
          }).Definition = e),
          t
        );
      }
      var Se = r(69594),
        Ee = r(75994),
        _e = r(67978);
    },
    37920: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => u, v: () => c });
      var s = r(88802),
        a = r(32875),
        n = r(26457),
        i = r(63364),
        o = r(43004);
      let c = class {
        constructor(e, t) {
          (this.sink = e), (this.logger = t);
        }
        captureException(e, t, r = o.w.CRITICAL) {
          try {
            const s = e instanceof Error ? e : new Error("Invalid exception type"),
              a = this.createExceptionLogEntry(t, s, r);
            return this.sink.logException(a);
          } catch (r) {
            this.logger.error("Failed to capture exception", r, e, t);
          }
          return Promise.resolve();
        }
        createExceptionLogEntry(e, t, r) {
          return {
            callStack: t.stack ?? "",
            criticality: r,
            featuresFlipped: this.mapFeatures(e.featureFlips ?? {}),
            fileLocation: e.fileLocation,
            lineNumber: e.lineNumber,
            message: t.message,
            moduleName: e.moduleName,
            origin: e.origin,
            timestamp: Date.now(),
            useCaseId: e.useCaseId,
            useCaseName: e.useCaseName,
            useCaseStacktrace: e.useCaseStacktrace
          };
        }
        mapFeatures(e) {
          return Object.keys(e).reduce((t, r) => (e[r] ? [r, ...t] : t), []);
        }
      };
      function u() {
        return new c(new i.p$(), new n.W());
      }
      c = (0, s.__decorate)([(0, a.Injectable)(), (0, s.__metadata)("design:paramtypes", [i.qD, n.V])], c);
    },
    63364: (e, t, r) => {
      "use strict";
      r.d(t, { fW: () => n, p$: () => a, qD: () => s });
      class s {}
      class a extends s {
        logException() {
          return Promise.resolve();
        }
        start() {
          return Promise.resolve({ stop: () => Promise.resolve() });
        }
      }
      class n {
        constructor(e) {
          this.events$ = e;
        }
      }
    },
    68475: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => g, x: () => v });
      var s = r(88802),
        a = r(32875),
        n = r(25313),
        i = r(60399),
        o = r(37182),
        c = r(87065),
        u = r(70493),
        d = r(69008),
        l = r(87279),
        p = r(21869),
        h = r(37920),
        m = r(428),
        y = r(94189);
      class g extends Error {
        constructor(e, t) {
          super("ApplicationRequestError"), (this.exception = e), (this.useCaseStacktrace = t);
        }
      }
      let v = class {
        constructor(e, t, r, s) {
          (this.logger = e), (this.useCaseStacktraceRepo = t), (this.cqrsClient = r), (this.requestContextClient = s);
        }
        intercept(e, t) {
          const r = e.getArgByIndex(0);
          return t.handle().pipe((0, o.K)(this.handleException(r)));
        }
        handleException(e) {
          const { useCaseStacktraceRepo: t } = this;
          return (r) => {
            if (t.isInitialUseCase()) {
              const [s, a] = r instanceof g ? [r.exception, r.useCaseStacktrace] : [r, t.read()];
              return this.captureException(e, s, a), (0, n._)(() => s);
            }
            const s = r instanceof g ? r : new g(r, t.read());
            return (0, n._)(() => s);
          };
        }
        async getUserFeatureFlips() {
          if (
            !(await (0, i.z)(this.requestContextClient.queries.activeUser().pipe((0, c.U)((e) => (0, l.d6)(e) && !!(0, l.db)(e).userName))))
          )
            return Promise.resolve({});
          const {
            queries: { userFeatureFlips: e }
          } = this.cqrsClient.getClient(u.cV);
          return await (0, i.z)(e().pipe((0, c.U)((e) => ((0, l.d6)(e) ? (0, l.db)(e) : {}))));
        }
        async captureException(e, t, r) {
          this.logger.captureException(t, {
            moduleName: e.module,
            useCaseName: e.name,
            useCaseId: e.context.get(p.l.UseCaseId),
            featureFlips: await this.getUserFeatureFlips(),
            useCaseStacktrace: r
          });
        }
      };
      v = (0, s.__decorate)(
        [(0, a.Injectable)({ scope: a.Scope.REQUEST }), (0, s.__metadata)("design:paramtypes", [h.v, m.F, y.w, d.Q])],
        v
      );
    },
    43004: (e, t, r) => {
      "use strict";
      var s;
      function a(e) {
        return (
          !(!e || "object" != typeof e) &&
          "criticality" in e &&
          "timestamp" in e &&
          "message" in e &&
          "callStack" in e &&
          (e.criticality === s.CRITICAL || e.criticality === s.WARNING) &&
          "string" == typeof e.message &&
          "string" == typeof e.callStack
        );
      }
      r.d(t, { h: () => a, w: () => s }),
        (function (e) {
          (e.WARNING = "warning"), (e.CRITICAL = "critical");
        })(s || (s = {}));
    },
    428: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => o, U: () => c });
      var s = r(88802),
        a = r(32875),
        n = r(21869);
      const i = "USE_CASE_STACKTRACE";
      let o = class {
        constructor(e) {
          this.requestContext = e;
        }
        isInitialUseCase() {
          return (this.requestContext.get(i) ?? []).length <= 1;
        }
        read() {
          return this.requestContext.getOrAddSync(i, () => []) ?? [];
        }
        append(e) {
          const { requestContext: t } = this,
            r = t.get(i) ?? [];
          t.set(i, [...r, e]);
        }
      };
      o = (0, s.__decorate)([(0, a.Injectable)(), (0, s.__metadata)("design:paramtypes", [n.f])], o);
      const c = new o(new n.f());
    },
    7876: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => b });
      var s = r(88802),
        a = r(49329),
        n = r(99634),
        i = r(42339),
        o = r(87279),
        c = r(63663),
        u = r(25029),
        d = r(95681),
        l = r(23347);
      const p = (e) =>
        "object" == typeof e &&
        null !== e &&
        "swStartTime" in e &&
        "taskTrackingList" in e &&
        "string" == typeof e.swStartTime &&
        "object" == typeof e.taskTrackingList;
      class h extends (0, d.Q)({
        persist: !1,
        initialValue: { swStartTime: "", taskTrackingList: {} },
        scope: u.F.Device,
        storeName: "task-tracking",
        storeTypeGuard: p,
        capacity: l.Y._001KB
      }) {}
      let m = class {
        constructor(e) {
          this.store = e;
        }
        async execute({ body: e }) {
          const t = new Date().toISOString(),
            { taskName: r, feature: s, businessDomain: a } = e,
            n = { taskName: r, feature: s, businessDomain: a, startTime: t, serviceWorkerInterruptionCount: 0 },
            i = await this.store.getState();
          return await this.store.set({ ...i, taskTrackingList: { ...i.taskTrackingList, [t]: n } }), Promise.resolve((0, o.Vp)({ id: t }));
        }
      };
      m = (0, s.__decorate)([(0, c.W)(i.g), (0, s.__metadata)("design:paramtypes", [h])], m);
      var y = r(53576),
        g = r(60765),
        v = r(43866),
        f = r(57924);
      let w = class {
        constructor(e, t, r) {
          (this.store = e), (this.carbonLegacyClient = t), (this.appLifecycle = r);
        }
        onFrameworkInit() {
          this.appLifecycle.addAppReadyHook(async () => {
            const e = await this.store.getState(),
              t = { ...e.taskTrackingList },
              r = Object.keys(e.taskTrackingList).map(async (r) => {
                const { taskName: s, feature: a, businessDomain: n, startTime: i } = e.taskTrackingList[r],
                  o = new g.UserMv3ExtensionTaskInterruptionEvent({
                    businessDomain: n,
                    feature: a,
                    taskName: s,
                    taskStartDateTime: i,
                    serviceWorkerStartDateTime: e.swStartTime
                  }),
                  c = this.carbonLegacyClient;
                await c.commands.carbon({ name: "logEvent", args: [{ event: o }] }), delete t[r];
              });
            await Promise.all(r), await this.store.set({ swStartTime: new Date().toISOString(), taskTrackingList: t });
          });
        }
      };
      w = (0, s.__decorate)([(0, f.ar)(), (0, s.__metadata)("design:paramtypes", [h, y.CarbonLegacyClient, v.d])], w);
      var S = r(29876),
        E = r(26457);
      let _ = class {
        constructor(e, t, r) {
          (this.store = e), (this.carbonLegacyClient = t), (this.logger = r);
        }
        async execute({ body: e }) {
          const { taskTrackingId: t } = e,
            r = await this.store.getState(),
            s = r.taskTrackingList[t];
          if (!s) return this.logger.trace("Trying to track a task that does not exist"), (0, o.Vp)(void 0);
          const { taskName: a, feature: n, businessDomain: i, startTime: c, serviceWorkerInterruptionCount: u } = s,
            d = new g.UserMv3ExtensionTaskReportEvent({
              businessDomain: i,
              feature: n,
              serviceWorkerInterruptionCount: u,
              serviceWorkerStartDateTime: r.swStartTime,
              taskName: a,
              taskStartDateTime: c,
              taskEndDateTime: new Date().toISOString()
            }),
            l = this.carbonLegacyClient;
          await l.commands.carbon({ name: "logEvent", args: [{ event: d }] });
          const p = { ...r.taskTrackingList };
          return delete p[t], await this.store.set({ swStartTime: r.swStartTime, taskTrackingList: p }), (0, o.Vp)(void 0);
        }
      };
      _ = (0, s.__decorate)([(0, c.W)(S.y), (0, s.__metadata)("design:paramtypes", [h, y.CarbonLegacyClient, E.V])], _);
      let b = class {};
      b = (0, s.__decorate)(
        [
          (0, n.Y)({
            api: a.e,
            handlers: { commands: { startTaskTracking: m, terminateTaskTracking: _ }, events: {}, queries: {} },
            stores: [h],
            onFrameworkInit: w,
            providers: []
          })
        ],
        b
      );
    },
    58649: (e, t, r) => {
      "use strict";
      r.d(t, { N: () => f });
      var s = r(6136),
        a = r(98187),
        n = r(15023),
        i = r(30523),
        o = r(16433),
        c = r(89618),
        u = r(37182),
        d = r(17350),
        l = r(97280),
        p = r(42946),
        h = r(162),
        m = r(2049),
        y = r(6220),
        g = r(7074),
        v = r(69183);
      class f {
        constructor(e, t = 3e4) {
          const r = e.status$.pipe((0, s.x)());
          let f = !1;
          const w = new a.x(),
            S = w
              .pipe(
                (0, y.z)(async (s) => {
                  const a = (0, v.Z)();
                  let y = !1;
                  const g = e.messages$.pipe(
                      (0, n.o)(() => !f),
                      (0, i.h)((e) => "acknowledgement" === e.type && e.id === a),
                      (0, o.q)(1),
                      (0, c.V)(t),
                      (0, u.K)(() => d.E),
                      (0, l.d)(1)
                    ),
                    w = g.subscribe(() => {
                      (y = !0), w.unsubscribe();
                    }),
                    S = r
                      .pipe(
                        (0, n.o)(() => !y && !f),
                        (0, p.z)(() => (0, h.D)(e.sendMessage({ type: "send", id: a, message: s.message })))
                      )
                      .subscribe();
                  try {
                    await (0, m.n)(g), S.unsubscribe(), s.resolve();
                  } catch (e) {
                    S.unsubscribe(), s.reject(e);
                  }
                })
              )
              .subscribe();
          (this.stop = () => ((f = !0), S.unsubscribe(), e.stop())),
            (this.send = (e) =>
              new Promise((t, r) => {
                const s = { message: e, resolve: t, reject: r };
                w.next(s);
              })),
            (this.channelState$ = e.status$),
            (this.receivedMessages$ = e.messages$.pipe(
              (0, i.h)((e) => "send" === e.type),
              (0, y.z)(async (t) => {
                if ("send" === t.type) return await e.sendMessage({ type: "acknowledgement", id: t.id }), t.message;
              }),
              (0, g.B)()
            ));
        }
      }
    },
    65488: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => b });
      var s = r(24966),
        a = r(2049),
        n = r(30523),
        i = r(6220),
        o = r(162),
        c = r(87065),
        u = r(37182),
        d = r(69885),
        l = r(59891);
      const p = (e) => {
          if (!e || "object" != typeof e) return !1;
          return "unSubscription" === e.type;
        },
        h = (e, t, r) => {
          const s = new Set(r),
            a = new Map(),
            h = t.receivedMessages$.pipe((0, n.h)(p)).subscribe((e) => {
              const t = a.get(e.id);
              t?.unsubscribe(), a.delete(e.id);
            }),
            m = t.receivedMessages$
              .pipe(
                (0, n.h)((e) => {
                  return (
                    !(!(t = e) || "object" != typeof t) && "start" === t.type && s.has(e.definition.destination) && !a.has(e.definition.id)
                  );
                  var t;
                }),
                (0, i.z)((e) =>
                  (0, o.D)(
                    (async (e) => (
                      a.set(e.definition.id, { unsubscribe: () => {} }),
                      await t.send({ type: "initial-acknowledgement", id: e.definition.id }),
                      e
                    ))(e)
                  )
                )
              )
              .subscribe((r) => {
                const s = r.definition.destination,
                  n = e(s, r.definition.content, r.metadata),
                  p = { type: "end", id: r.definition.id },
                  h = n
                    .pipe(
                      (0, c.U)((e) => ({ id: r.definition.id, data: e, type: "data" })),
                      (0, u.K)((e) => {
                        const t = { id: r.definition.id, type: "error", errorMessage: e.message };
                        return (0, d.of)(t);
                      }),
                      (0, l.l)(p),
                      (0, i.z)((e) => (0, o.D)(t.send(e)))
                    )
                    .subscribe();
                a.set(r.definition.id, {
                  unsubscribe: () => {
                    h.unsubscribe();
                  }
                });
              });
          return {
            unsubscribe: () => {
              m.unsubscribe(), h.unsubscribe();
              for (const e of a.values()) e.unsubscribe();
            }
          };
        };
      var m = r(58376),
        y = r(85390),
        g = r(15023),
        v = r(6136),
        f = r(42946),
        w = r(60399),
        S = r(15572),
        E = r(69183);
      var _ = r(28489);
      class b {
        constructor(e) {
          this.stopped$ = new s.X(!1);
          const t = { routes: (0, _.Ay)({}) };
          this.routes = (() => {
            const { routes: r } = Object.keys(e).reduce((t, r) => {
              const s = e[r];
              if (
                ("local" === s.type &&
                  (t.routes[r] = { send: s.onMessage, trySend: async (...e) => (await (0, a.n)(s.onMessage(...e)), !0) }),
                "remote" === s.type)
              ) {
                const e = ((e, t) => {
                  const r = (r, s, a) => {
                    const i = { content: s, destination: String(r), id: (0, E.Z)() };
                    return new m.y((r) => {
                      let s = { type: "start", definition: i, metadata: a };
                      const u = (0, y.a)({ message: e.receivedMessages$, stopped: t })
                          .pipe(
                            (0, g.o)(({ stopped: e }) => !e),
                            (0, c.U)(({ message: e }) => e)
                          )
                          .subscribe((e) => {
                            var t;
                            (t = e) && "object" == typeof t && "initial-acknowledgement" === t.type && e.id === i.id
                              ? (s = { ...s, metadata: { ...s.metadata, isReminder: !0 } })
                              : ((e) => !(!e || "object" != typeof e) && "data" === e.type)(e) && e.id === i.id
                              ? r.next(e.data)
                              : ((e) => !(!e || "object" != typeof e) && "error" === e.type)(e) && e.id === i.id
                              ? r.error(new Error(e.errorMessage))
                              : ((e) => !(!e || "object" != typeof e) && "end" === e.type)(e) && e.id === i.id && r.complete();
                          }),
                        d = (0, y.a)({
                          sendTimes: e.channelState$.pipe(
                            (0, v.x)(),
                            (0, n.h)((e) => e === S.D.Connected)
                          ),
                          stopped: t
                        })
                          .pipe(
                            (0, g.o)(({ stopped: e }) => !e),
                            (0, f.z)(() => (0, o.D)(e.send(s)))
                          )
                          .subscribe();
                      return () => {
                        e.send({ type: "unSubscription", id: i.id }), d.unsubscribe(), u.unsubscribe();
                      };
                    });
                  };
                  return {
                    send: r,
                    trySend: async (t, s, n) => (await (0, w.z)(e.channelState$)) === S.D.Connected && (await (0, a.n)(r(t, s, n)), !0)
                  };
                })(s.channel, this.stopped$);
                t.routes[r] = e;
              }
              return t;
            }, t);
            return r;
          })();
        }
        connect(e, t) {
          let r = !1;
          return {
            start: () => {
              if (r) throw new Error("Already started");
              r = !0;
              const s = (e) => h((e, t, r) => this.routes[e].send(e, t, r), e, Object.keys(this.routes)),
                a = e.map(s),
                n = new Map(),
                i = t.connectedChannels$.subscribe((e) => {
                  const t = [...n.entries()].filter(([t]) => !(t in e)),
                    r = Object.keys(e).filter((e) => !n.has(e));
                  t.forEach(([e, t]) => {
                    n.delete(e), t.unsubscribe();
                  }),
                    r.forEach((t) => {
                      const r = e[t],
                        a = s(r);
                      n.set(t, a);
                    });
                });
              return Promise.resolve({
                stop: () => ([...a, i, ...n.values()].forEach((e) => e.unsubscribe()), this.stopped$.next(!0), Promise.resolve())
              });
            }
          };
        }
        sendMessage(e, t) {
          return this.routes[e].send(e, t, { isReminder: !1 });
        }
        trySendMessage(e, t) {
          return this.routes[e].trySend(e, t, { isReminder: !1 });
        }
      }
    },
    15572: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => s, q: () => i });
      var s,
        a = r(98187),
        n = r(24966);
      !(function (e) {
        (e.Connected = "Connected"), (e.Disconnected = "Disconnected");
      })(s || (s = {}));
      class i {
        constructor() {
          (this.sentMessages$ = new a.x()),
            (this.receivedMessagesSubject$ = new a.x()),
            (this.channelStateSubject$ = new n.X(s.Disconnected));
        }
        send(e) {
          if (this.channelStateSubject$.value !== s.Connected) throw new Error("Channel is not connected");
          return this.sentMessages$.next(e), Promise.resolve();
        }
        get receivedMessages$() {
          return this.receivedMessagesSubject$;
        }
        get channelState$() {
          return this.channelStateSubject$;
        }
        stop() {
          this.receivedMessages$.complete();
        }
        connect(e) {
          if (this.channelStateSubject$.value === s.Connected) return { disconnect: () => {} };
          const t = this.sentMessages$.subscribe((t) => {
            e.receivedMessages$.next(t);
          });
          return (
            this.channelState$.next(s.Connected),
            {
              disconnect: () => {
                this.channelState$.next(s.Disconnected), t.unsubscribe();
              }
            }
          );
        }
      }
    },
    54452: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => n, y: () => a });
      var s = r(24966);
      const a = { connectedChannels$: new s.X({}) },
        n = (e) => ({ connectedChannels$: new s.X({ channel: e }) });
    },
    45244: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => a, k: () => s });
      const s = ({ channelName: e, message: t }) => ({ channelName: e, message: t, type: "graphene-message" }),
        a = (e) => {
          if (!e || "object" != typeof e) return !1;
          return "graphene-message" === e.type;
        };
    },
    16855: (e, t, r) => {
      "use strict";
      r.d(t, { $: () => s });
      class s {
        constructor(e) {
          (this.appDefinition = e.appDefinition),
            (this.currentNode = e.currentNode),
            (this.channels = e.channels),
            (this.subscriptions = e.subscriptions),
            (this.channelsListener = e.channelsListener);
        }
        getNodeList() {
          return this.currentNode ? [...this.getRemoteNodeList(), this.currentNode] : this.getRemoteNodeList();
        }
        getRemoteNodeList() {
          return Object.keys(this.channels);
        }
        getModuleNames() {
          return Object.keys(this.appDefinition);
        }
      }
    },
    21869: (e, t, r) => {
      "use strict";
      r.d(t, { f: () => a, l: () => s });
      const s = { UseCaseId: "USE_CASE_ID", UserName: "USER_NAME" };
      class a {
        constructor() {
          this.entries = {};
        }
        get(e) {
          return this.entries[e];
        }
        getOrDefault(e, t) {
          return this.entries[e] ?? t;
        }
        getOrFail(e) {
          if (!this.has(e)) throw new Error(`No ${e} in request context`);
          return this.entries[e];
        }
        has(e) {
          return e in this.entries;
        }
        async getOrAdd(e, t) {
          return this.has(e) || this.set(e, await t()), this.get(e);
        }
        getOrAddSync(e, t) {
          return this.has(e) || this.set(e, t()), this.get(e);
        }
        set(e, t) {
          this.entries[e] = t;
        }
        toSerializable() {
          return this.entries;
        }
        static fromSerializable(e) {
          const t = new a();
          for (const [r, s] of Object.entries(e)) t.entries[r] = s;
          return t;
        }
        clone() {
          return a.fromSerializable(JSON.parse(JSON.stringify(this.toSerializable())));
        }
        withValue(e, t) {
          return this.set(e, t), this;
        }
      }
    },
    75994: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => a, X: () => s });
      class s {}
      class a extends s {
        constructor(e) {
          super(), (this.files = e);
        }
        fetch(e) {
          return e in this.files ? Promise.resolve(this.files[e]) : Promise.reject(new Error("404 not found :" + e));
        }
      }
    },
    67978: (e, t, r) => {
      "use strict";
      r.d(t, { K: () => c });
      var s = r(88802),
        a = r(162),
        n = r(25859),
        i = r(57924),
        o = r(75994);
      let c = class {
        constructor(e, t) {
          (this.url = e), (this.fetcher = t), (this.value$ = (0, a.D)((0, n.P)(() => this.get())));
        }
        async load() {
          await this.get();
        }
        async get() {
          const { value: e } = this;
          if (e) return e;
          const t = await this.fetcher.fetch(this.url),
            r = await this.loadResource(t);
          return (this.value = r), r;
        }
      };
      c = (0, s.__decorate)([(0, i.GS)(), (0, s.__metadata)("design:paramtypes", [String, o.X])], c);
    },
    14463: (e, t, r) => {
      "use strict";
      r.d(t, { q: () => E });
      var s = r(88802),
        a = r(87279),
        n = r(8987),
        i = r(87065),
        o = r(6136),
        c = r(25029),
        u = r(95681),
        d = r(23347);
      const l = (e) => !(!e || "object" != typeof e) && "userName" in e;
      class p extends (0, u.Q)({
        initialValue: { userName: void 0 },
        persist: !1,
        scope: c.F.Device,
        storeName: "active-user-store",
        storeTypeGuard: l,
        capacity: d.Y._001KB
      }) {}
      var h = r(20754),
        m = r(63663),
        y = r(81459),
        g = r(57924);
      let v = class extends y.f {};
      v = (0, s.__decorate)([(0, g.GS)()], v);
      let f = class {
        constructor(e) {
          this.activeUserStore = e;
        }
        execute() {
          return this.activeUserStore.state$.pipe(
            (0, i.U)((e) => e.userName),
            (0, o.x)(),
            (0, i.U)((e) => (0, a.Vp)({ userName: e }))
          );
        }
      };
      f = (0, s.__decorate)([(0, h.e)(n.p), (0, s.__metadata)("design:paramtypes", [p])], f);
      let w = class {
        constructor(e, t) {
          (this.activeUserStore = e), (this.eventEmitter = t);
        }
        async execute({ body: { userName: e } }) {
          return (
            await this.activeUserStore.set({ userName: e }),
            e && this.eventEmitter.sendEvent("activeUserSet", { userName: e }),
            (0, a.Vp)(void 0)
          );
        }
      };
      w = (0, s.__decorate)([(0, m.W)(n.r$), (0, s.__metadata)("design:paramtypes", [p, v])], w);
      var S = r(99634);
      let E = class {};
      E = (0, s.__decorate)(
        [
          (0, S.Y)({
            api: n.t$,
            handlers: { commands: { setActiveUser: w }, events: {}, queries: { activeUser: f } },
            stores: [p],
            providers: [v]
          })
        ],
        E
      );
    },
    38144: (e, t, r) => {
      "use strict";
      r.d(t, { h: () => n, s: () => i });
      var s = r(88802),
        a = r(32875);
      let n = class {};
      n = (0, s.__decorate)([(0, a.Injectable)()], n);
      let i = class {};
      i = (0, s.__decorate)([(0, a.Injectable)()], i);
    },
    4603: (e, t, r) => {
      "use strict";
      r.d(t, { u: () => a });
      class s {
        constructor(e, t, r) {
          (this.storage = e), (this.baseKey = t), (this.initialValueFactory = r);
        }
        clear() {
          return this.storage.remove(this.baseKey);
        }
        async read() {
          const e = await this.storage.get(this.baseKey);
          return !e && this.initialValueFactory ? await this.initialValueFactory() : e;
        }
        async write(e) {
          await this.storage.set(this.baseKey, e);
        }
      }
      class a {
        constructor(e) {
          this.storage = e;
        }
        createBackend(e, t, r, a) {
          const n = r ? `${e}.${t}.${r}` : `${e}.${t}`;
          return new s(this.storage, n, a);
        }
      }
    },
    15524: (e, t, r) => {
      "use strict";
      r.d(t, { s: () => s });
      class s {
        constructor() {
          this.memory = new Map();
        }
        set(e, t) {
          return this.memory.set(e, t), Promise.resolve();
        }
        getAllKeys() {
          return Promise.resolve([...this.memory.keys()]);
        }
        remove(e) {
          return this.memory.get(e) ? (this.memory.delete(e), Promise.resolve()) : Promise.resolve();
        }
        get(e) {
          return Promise.resolve(this.memory.get(e));
        }
      }
    },
    91199: (e, t, r) => {
      "use strict";
      function s(e, t) {
        return null !== e && "object" == typeof e && "version" in e && "content" in e && t(e.content);
      }
      r.d(t, { Ot: () => s, QI: () => n, hL: () => a });
      const a = { read: () => Promise.resolve(void 0), write: () => Promise.resolve(), clear: () => Promise.resolve() };
      class n {}
    },
    95681: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => l });
      var s = r(57924),
        a = r(49499),
        n = r(10722),
        i = r(91199);
      class o {
        constructor(e, t, r, s, i) {
          (this.encryptionCodec = e),
            (this.serializationCodec = t),
            (this.transportStorageCodec = r),
            (this.backend = s),
            (this.definition = i),
            (this.codec = (0, a.x)(r, e, t));
          const o = new n.E();
          this.bypassedDecryptionDecoder = (0, a.x)(r, o, t);
        }
        async read() {
          const e = await this.backend.read();
          if (!e) return;
          const { decoded: t, hasBypassedDecryption: r } = await this.decodeData(e),
            { definition: s } = this;
          if (!(0, i.Ot)(t, s.typeGuard)) {
            if (!s.typeGuard(t))
              throw (
                (r && (await this.rawWrite(t)),
                new Error(`Can't migrate non-versioned Storage : Typeguard ${s.typeGuard.name} check failed.`))
              );
            return await this.write(t), t;
          }
          if (t.version < s.schemaVersion) {
            if (!s.migrateStorageSchema) throw (r && (await this.rawWrite(t)), new Error("migrateStorage is undefined"));
            const e = s.migrateStorageSchema(t);
            return await this.write(e), e;
          }
          r && (await this.write(t.content));
          const { content: a } = t;
          if (!s.typeGuard(a)) throw new Error("Type guard failed");
          return a;
        }
        async write(e) {
          const t = { version: this.definition.schemaVersion, content: e };
          await this.rawWrite(t);
        }
        clear() {
          return this.backend.clear();
        }
        async rawWrite(e) {
          const t = await this.codec.encode(e);
          await this.backend.write(t);
        }
        async decodeData(e) {
          const { codec: t, bypassedDecryptionDecoder: r } = this;
          try {
            return { decoded: await t.decode(e), hasBypassedDecryption: !1 };
          } catch (t) {
            try {
              return { decoded: await r.decode(e), hasBypassedDecryption: !0 };
            } catch {
              throw t;
            }
          }
        }
      }
      const c = (e) => {
        var t;
        return (
          ((t = class extends o {
            constructor(t, r, s, a) {
              super(t, r, s, a, e);
            }
          }).Definition = e),
          t
        );
      };
      var u = r(49959);
      const d = (e) =>
        e.persist
          ? {
              persist: !0,
              codec: e.codec,
              scope: e.scope,
              storeName: e.storeName,
              storeTypeGuard: e.storeTypeGuard,
              isCache: e.isCache,
              storage: c(e.storage)
            }
          : { persist: !1, initialValue: e.initialValue, scope: e.scope, storeName: e.storeName };
      function l(e) {
        var t;
        const r = d(e),
          a =
            (((t = class extends u.y {
              constructor(e, t, r, s, a, n, i) {
                super(e, t, r, s, a, n, i);
              }
            }).Definition = r),
            t);
        return (0, s.GS)()(a), a;
      }
    },
    23347: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { Y: () => s }),
        (function (e) {
          (e._001KB = "1KB"), (e._010KB = "10KB"), (e._100KB = "100KB"), (e.Unlimited = "Unlimited");
        })(s || (s = {}));
    },
    71949: (e, t, r) => {
      "use strict";
      r.d(t, { X: () => o });
      var s = r(88802),
        a = r(32875),
        n = r(70695),
        i = r(56860);
      let o = class {
        constructor(e, t, r) {
          (this.moduleRef = e), (this.request = t), (this.storeList = r);
        }
        async prepare() {
          const e = n.ContextIdFactory.getByRequest(this.request);
          this.storeList.instances = await Promise.all(this.storeList.classes.map((t) => this.moduleRef.resolve(t, e, { strict: !1 })));
        }
        async flush() {
          const { instances: e } = this.storeList;
          if (!e.length) throw new Error("Stores not instantiated");
          const t = e.map((e) => e.persist());
          await Promise.all(t);
        }
      };
      o = (0, s.__decorate)(
        [
          (0, a.Injectable)(),
          (0, s.__param)(1, (0, a.Inject)(n.REQUEST)),
          (0, s.__metadata)("design:paramtypes", [n.ModuleRef, Object, i.D])
        ],
        o
      );
    },
    83081: (e, t, r) => {
      "use strict";
      r.d(t, { N: () => i, G: () => n });
      var s = r(24966);
      class a {
        constructor(e) {
          (this.initValue = e), (this.state$ = new s.X(e));
        }
        set(e) {
          return this.state$.next(e), Promise.resolve();
        }
        init(e) {
          return this.state$.next(e), Promise.resolve();
        }
        stop() {
          this.state$.complete();
        }
        getState() {
          return Promise.resolve(this.state$.value);
        }
        clear() {
          return this.state$.next(this.initValue), Promise.resolve();
        }
        clearStorage() {
          return Promise.resolve();
        }
        update(e) {
          return this.set(e(this.state$.value)), Promise.resolve();
        }
        persist() {
          return Promise.resolve();
        }
        load() {
          return Promise.resolve();
        }
      }
      class n {}
      class i extends n {
        createUserScopedInfrastructure() {
          return new a({ timestamp: void 0 });
        }
        createDeviceScopedInfrastructure() {
          return new a({ timestamp: void 0 });
        }
      }
    },
    56860: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => s });
      class s {
        constructor() {
          (this.registeredClasses = []), (this.preparedInstances = []);
        }
        get classes() {
          return this.registeredClasses;
        }
        get instances() {
          return this.preparedInstances;
        }
        set instances(e) {
          this.preparedInstances = e;
        }
        registerClass(e) {
          this.registeredClasses.push(e);
        }
      }
    },
    5711: (e, t, r) => {
      "use strict";
      r.d(t, { N: () => w });
      var s = r(70695),
        a = r(69183),
        n = r(25029),
        i = r(43866),
        o = r(63411),
        c = r(83081),
        u = r(93417),
        d = r(43702),
        l = r(23711),
        p = r(38144),
        h = r(4603),
        m = r(21869);
      const y = { [n.F.Device]: p.h, [n.F.User]: p.s };
      var g = r(9671),
        v = r(97631);
      function f(e) {
        const t = e.Definition.persist
            ? (function (e, t, r) {
                const {
                  EncryptionCodec: s = y[t],
                  SerializationCodec: i = d.b,
                  TransportStorageCodec: c = l.z,
                  initialValue: p,
                  schemaVersion: g
                } = r.Definition;
                class v {
                  constructor(e, t, r, s) {
                    (this.encryptionCodec = e), (this.serializationCodec = t), (this.transportStorageCodec = r), (this.backend = s);
                  }
                }
                class f extends r {
                  constructor(e) {
                    super(e.encryptionCodec, e.serializationCodec, e.transportStorageCodec, e.backend);
                  }
                }
                const w = { token: (0, a.Z)(), inject: [v], asyncFactory: (e) => Promise.resolve(new f(e)) };
                return [
                  {
                    token: v,
                    inject: [u.r, s, i, c, h.u, ...(t === n.F.User ? [m.f] : [])],
                    asyncFactory: async (r, s, a, i, o, c) => {
                      const u = await o.createBackend(r, e, (t === n.F.User ? c?.get(m.l.UserName) : "") ?? "", async () => {
                        const e = { version: g, content: p },
                          t = await a.encode(e),
                          r = await s.encode(t);
                        return await i.encode(r);
                      });
                      return new v(s, a, i, u);
                    }
                  },
                  ...(0, o.B)(t, r, w)
                ];
              })(e.Definition.storeName, e.Definition.scope, e.Definition.storage)
            : [],
          r = {
            token: (0, a.Z)(),
            inject: [
              u.r,
              i.d,
              c.G,
              e.Definition.scope === n.F.User ? m.f : s.REQUEST,
              g.J,
              v.g,
              ...(e.Definition.persist ? [e.Definition.storage, e.Definition.codec] : [])
            ],
            asyncFactory: async (t, r, s, a, i, o, c, u) => {
              const d = new e(t, e.Definition, s, (e.Definition.scope === n.F.User ? a.get(m.l.UserName) : "") ?? "", i, c, u),
                l = async () => {
                  await d.clear(), d.stop();
                };
              if (e.Definition.scope === n.F.User) {
                if (!o) throw new Error("No user scope available");
                o.addCloseHook(l);
              } else r.addShutdownHook(l);
              return await d.load(), d;
            }
          };
        return [...t, ...(0, o.B)(e.Definition.scope, e, r)];
      }
      function w(...e) {
        return e.flatMap((e) => f(e));
      }
    },
    49959: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => l });
      var s = r(24966),
        a = r(85390),
        n = r(87065),
        i = r(6136),
        o = r(30523),
        c = r(60399),
        u = r(25029),
        d = r(95087);
      class l {
        constructor(e, t, r, c, l, p, h) {
          (this.conf = t), (this.allowedToFail = l), (this.storage = p), (this.codec = h);
          (this.infrastructure = (() => {
            switch (t.scope) {
              case u.F.Device:
                return r.createDeviceScopedInfrastructure(e, t.storeName, t.storeTypeGuard);
              case u.F.User:
                if (!c) throw new Error("Attempting to create a user-scoped store without a user");
                return r.createUserScopedInfrastructure(e, t.storeName, c, t.storeTypeGuard);
            }
            (0, d.U)(t.scope);
          })()),
            (this.timeGetter = () => Date.now()),
            (this.localState$ = new s.X({ timestamp: void 0 })),
            (this.mergedState$ = (0, a.a)({ infra: this.infrastructure.state$, current: this.localState$ }).pipe(
              (0, n.U)(({ current: e, infra: t }) => (t.timestamp && (!e.timestamp || t.timestamp > e.timestamp) ? t : e)),
              (0, i.x)()
            ));
          const m = t.persist ? void 0 : t.initialValue;
          this.state$ = this.mergedState$.pipe(
            (0, o.h)((e) => !t.persist || !!e.timestamp),
            (0, n.U)((e) => e.data ?? m)
          );
        }
        getState() {
          return (0, c.z)(this.state$);
        }
        async set(e) {
          await this.setWithoutPersist(e), await this.persist();
        }
        async setWithoutPersist(e) {
          const t = { data: e, timestamp: this.timeGetter() };
          this.localState$.next(t), await this.infrastructure.set(t);
        }
        init(e) {
          const t = { data: e, timestamp: 0 };
          return this.localState$.next(t), Promise.resolve();
        }
        async clear() {
          this.localState$.next({ timestamp: void 0 }), await this.infrastructure.clear();
        }
        async clearStorage() {
          if (!this.storage) throw new Error("Persisted stores should have storage");
          await this.storage.clear();
        }
        stop() {
          this.localState$.complete();
        }
        async update(e) {
          const t = await this.getState();
          await this.set(e(t));
        }
        async load() {
          const e = await this.infrastructure.getState();
          if (e.timestamp) return void this.localState$.next(e);
          const { conf: t, codec: r, storage: s } = this;
          if (!t.persist) return;
          if (!r || !s) throw new Error("Persisted stores should have conf/storage");
          (await this.allowedToFail.conditionallyAllowToFailOne(async () => {
            const e = (await s.read()) ?? t.storage.Definition.initialValue,
              a = await r.decode(e);
            await this.setWithoutPersist(a);
          }, !!t.isCache)) || (await this.setWithoutPersist(await r.decode(t.storage.Definition.initialValue)));
        }
        async persist() {
          const { conf: e, codec: t, storage: r } = this;
          if (!e.persist) return;
          if (!t || !r) throw new Error("Persisted stores should have conf/storage");
          const s = await this.getState(),
            a = await t.encode(s);
          await r.write(a);
        }
      }
    },
    69594: (e, t, r) => {
      "use strict";
      r.d(t, { R_: () => a, _C: () => n, ql: () => s });
      class s {
        run() {
          return Promise.resolve();
        }
        isRunnable() {
          return !1;
        }
      }
      class a {}
      class n extends a {
        constructor(e) {
          super(), (this.alarm$ = e.createObservableTimer(6e4, 6e4));
        }
      }
    },
    33920: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => a, p: () => s });
      const s = { Open: "open", Closed: "closed" };
      class a {
        constructor(e) {
          (this.lifecycle = e),
            (this.status = s.Open),
            (this.onAppShutdown = () => this.close()),
            (this.closeHooks = []),
            e.addShutdownHook(this.onAppShutdown);
        }
        async close() {
          for (; this.closeHooks.length > 0; ) {
            const e = this.closeHooks.pop();
            e && (await e());
          }
          (this.status = s.Closed), this.lifecycle.removeShutdownHook(this.onAppShutdown);
        }
        addCloseHook(e) {
          this.closeHooks.push(e);
        }
      }
    },
    97631: (e, t, r) => {
      "use strict";
      r.d(t, { g: () => p });
      var s = r(88802),
        a = r(78263),
        n = r(30523),
        i = r(16433),
        o = r(32875),
        c = r(87279),
        u = r(69008),
        d = r(33920),
        l = r(43866);
      let p = class extends d.F {
        constructor(e, t, r) {
          super(t),
            (this.requestContext = r),
            r.queries
              .activeUser()
              .pipe((0, a.G)(), (0, n.h)(this.thisUserGotDeactivated(e)), (0, i.q)(1))
              .subscribe(() => {
                this.close();
              });
        }
        thisUserGotDeactivated(e) {
          return ([t, r]) => {
            if (!(0, c.d6)(t) || !(0, c.d6)(r)) return !1;
            const s = (0, c.db)(t).userName,
              a = (0, c.db)(r).userName;
            return s === e && void 0 === a;
          };
        }
      };
      p = (0, s.__decorate)([(0, o.Injectable)(), (0, s.__metadata)("design:paramtypes", [String, l.d, u.Q])], p);
    },
    37204: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.analyticsApi = t.TrackPageViewCommand = t.TrackEventCommand = void 0);
      const s = r(85888),
        a = r(70986);
      class n extends (0, a.defineCommand)({ scope: a.UseCaseScope.Device }) {}
      t.TrackEventCommand = n;
      class i extends (0, a.defineCommand)({ scope: a.UseCaseScope.Device }) {}
      (t.TrackPageViewCommand = i),
        (t.analyticsApi = (0, s.defineModuleApi)({
          commands: { TrackEventCommand: n, TrackPageViewCommand: i },
          events: {},
          name: "analytics",
          queries: {}
        }));
    },
    7022: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
    },
    52389: function (e, t, r) {
      "use strict";
      var s =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, r, s) {
                void 0 === s && (s = r);
                var a = Object.getOwnPropertyDescriptor(t, r);
                (a && !("get" in a ? !t.__esModule : a.writable || a.configurable)) ||
                  (a = {
                    enumerable: !0,
                    get: function () {
                      return t[r];
                    }
                  }),
                  Object.defineProperty(e, s, a);
              }
            : function (e, t, r, s) {
                void 0 === s && (s = r), (e[s] = t[r]);
              }),
        a =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || s(t, e, r);
          };
      Object.defineProperty(t, "__esModule", { value: !0 }), a(r(37204), t), a(r(7022), t);
    },
    82142: (e, t) => {
      "use strict";
      function r(e) {
        const t = (e) => ({
            build: () => e,
            withMockedCommand: (r, s) => ((e.commands[r] = s), t(e)),
            withMockedQuery: (r, s) => ((e.queries[r] = s), t(e))
          }),
          r = { commands: {}, queries: {} };
        for (const t of Object.keys(e.commands))
          r.commands[t] = jest.fn(() => {
            throw new Error(`command ${t} of module ${e.name} is called but not mocked`);
          });
        for (const t of Object.keys(e.queries))
          r.queries[t] = jest.fn(() => {
            throw new Error(`query ${t} of module ${e.name} is called but not mocked`);
          });
        return t(r);
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.appClientMockBuilder = void 0),
        (t.appClientMockBuilder = function () {
          const e = new Map(),
            t = {
              withModule: (s, a) => {
                const n = s.name;
                if (void 0 === a) {
                  const a = r(s).build();
                  return e.set(n, a), t;
                }
                if ("function" == typeof a) {
                  const i = r(s);
                  return e.set(n, a(i).build()), t;
                }
                return e.set(n, a), t;
              },
              build: (t) => {
                const s = t ? Object.keys(t) : [...e.keys()];
                return Array.from(s).reduce(
                  (s, a) => ({ ...s, [a]: e.get(a) ?? r(t ? t[a].api : { name: "", commands: {}, events: {}, queries: {} }).build() }),
                  {}
                );
              }
            };
          return t;
        });
    },
    74833: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.appClientMockBuilder = void 0);
      var s = r(82142);
      Object.defineProperty(t, "appClientMockBuilder", {
        enumerable: !0,
        get: function () {
          return s.appClientMockBuilder;
        }
      });
    },
    54072: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.CommandMessage = void 0);
      const s = r(98653);
      class a extends s.RequestMessage {
        constructor(e) {
          super(), (this.body = e);
        }
      }
      t.CommandMessage = a;
    },
    98653: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.UseCaseScope = t.RequestMessage = void 0);
      (t.RequestMessage = class {}),
        (function (e) {
          (e.User = "user"), (e.Device = "device");
        })(t.UseCaseScope || (t.UseCaseScope = {}));
    },
    85088: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.EMPTY_QUERY_RESULT = t.PAGINATION_START_PAGE_INDEX = t.FilterOperationName = void 0),
        (function (e) {
          (e.Equals = "equals"), (e.Differs = "differs"), (e.Matches = "matches"), (e.In = "in"), (e.Contains = "contains");
        })(t.FilterOperationName || (t.FilterOperationName = {})),
        (t.PAGINATION_START_PAGE_INDEX = 1),
        (t.EMPTY_QUERY_RESULT = { items: [], itemCount: 0, page: t.PAGINATION_START_PAGE_INDEX, pageCount: 1 });
    },
    77939: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.defineCarbonCommand = t.defineCommand = void 0);
      const s = r(54072),
        a = r(98653);
      t.defineCommand = (...[e = { scope: a.UseCaseScope.User }]) => {
        var t;
        return ((t = class extends s.CommandMessage {}).metadata = e), t;
      };
      t.defineCarbonCommand = (e = { scope: a.UseCaseScope.User }) => {
        var t;
        return ((t = class extends s.CommandMessage {}).metadata = e), t;
      };
    },
    1941: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.defineQuery = void 0);
      const s = r(70522),
        a = r(98653);
      t.defineQuery = (e = { scope: a.UseCaseScope.User }) => {
        var t;
        return ((t = class extends s.QueryMessage {}).metadata = e), t;
      };
    },
    70986: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.defineQuery =
          t.defineCarbonCommand =
          t.defineCommand =
          t.UseCaseScope =
          t.FilterOperationName =
          t.EMPTY_QUERY_RESULT =
          t.PAGINATION_START_PAGE_INDEX =
          t.QueryMessage =
          t.CommandMessage =
            void 0);
      var s = r(54072);
      Object.defineProperty(t, "CommandMessage", {
        enumerable: !0,
        get: function () {
          return s.CommandMessage;
        }
      });
      var a = r(70522);
      Object.defineProperty(t, "QueryMessage", {
        enumerable: !0,
        get: function () {
          return a.QueryMessage;
        }
      });
      var n = r(85088);
      Object.defineProperty(t, "PAGINATION_START_PAGE_INDEX", {
        enumerable: !0,
        get: function () {
          return n.PAGINATION_START_PAGE_INDEX;
        }
      });
      var i = r(85088);
      Object.defineProperty(t, "EMPTY_QUERY_RESULT", {
        enumerable: !0,
        get: function () {
          return i.EMPTY_QUERY_RESULT;
        }
      }),
        Object.defineProperty(t, "FilterOperationName", {
          enumerable: !0,
          get: function () {
            return i.FilterOperationName;
          }
        });
      var o = r(98653);
      Object.defineProperty(t, "UseCaseScope", {
        enumerable: !0,
        get: function () {
          return o.UseCaseScope;
        }
      });
      var c = r(77939);
      Object.defineProperty(t, "defineCommand", {
        enumerable: !0,
        get: function () {
          return c.defineCommand;
        }
      }),
        Object.defineProperty(t, "defineCarbonCommand", {
          enumerable: !0,
          get: function () {
            return c.defineCarbonCommand;
          }
        });
      var u = r(1941);
      Object.defineProperty(t, "defineQuery", {
        enumerable: !0,
        get: function () {
          return u.defineQuery;
        }
      });
    },
    70522: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.QueryMessage = void 0);
      const s = r(98653);
      class a extends s.RequestMessage {
        constructor(e) {
          super(), (this.body = e);
        }
      }
      t.QueryMessage = a;
    },
    49631: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.EventMessage = t.defineEvent = void 0);
      var s = r(84776);
      Object.defineProperty(t, "defineEvent", {
        enumerable: !0,
        get: function () {
          return s.defineEvent;
        }
      }),
        Object.defineProperty(t, "EventMessage", {
          enumerable: !0,
          get: function () {
            return s.EventMessage;
          }
        });
    },
    84776: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.defineEvent = t.EventMessage = void 0);
      const s = r(98653);
      class a {
        constructor(e) {
          this.body = e;
        }
      }
      t.EventMessage = a;
      t.defineEvent = (e = { scope: s.UseCaseScope.User }) => {
        var t;
        return ((t = class extends a {}).metadata = e), t;
      };
    },
    90693: function (e, t, r) {
      "use strict";
      var s =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, r, s) {
                void 0 === s && (s = r);
                var a = Object.getOwnPropertyDescriptor(t, r);
                (a && !("get" in a ? !t.__esModule : a.writable || a.configurable)) ||
                  (a = {
                    enumerable: !0,
                    get: function () {
                      return t[r];
                    }
                  }),
                  Object.defineProperty(e, s, a);
              }
            : function (e, t, r, s) {
                void 0 === s && (s = r), (e[s] = t[r]);
              }),
        a =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || s(t, e, r);
          };
      Object.defineProperty(t, "__esModule", { value: !0 }),
        a(r(52389), t),
        a(r(70986), t),
        a(r(35079), t),
        a(r(85888), t),
        a(r(49631), t),
        a(r(74833), t);
    },
    35079: function (e, t, r) {
      "use strict";
      var s =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, r, s) {
                void 0 === s && (s = r);
                var a = Object.getOwnPropertyDescriptor(t, r);
                (a && !("get" in a ? !t.__esModule : a.writable || a.configurable)) ||
                  (a = {
                    enumerable: !0,
                    get: function () {
                      return t[r];
                    }
                  }),
                  Object.defineProperty(e, s, a);
              }
            : function (e, t, r, s) {
                void 0 === s && (s = r), (e[s] = t[r]);
              }),
        a =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || s(t, e, r);
          };
      Object.defineProperty(t, "__esModule", { value: !0 }), a(r(36518), t);
    },
    82397: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.taskTrackingApi = void 0);
      const s = r(85888),
        a = r(96609),
        n = r(7797);
      t.taskTrackingApi = (0, s.defineModuleApi)({
        name: "taskTracking",
        commands: { startTaskTracking: a.StartTaskTrackingCommand, terminateTaskTracking: n.TerminateTaskTrackingCommand },
        events: {},
        queries: {}
      });
    },
    39948: function (e, t, r) {
      "use strict";
      var s =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, r, s) {
                void 0 === s && (s = r);
                var a = Object.getOwnPropertyDescriptor(t, r);
                (a && !("get" in a ? !t.__esModule : a.writable || a.configurable)) ||
                  (a = {
                    enumerable: !0,
                    get: function () {
                      return t[r];
                    }
                  }),
                  Object.defineProperty(e, s, a);
              }
            : function (e, t, r, s) {
                void 0 === s && (s = r), (e[s] = t[r]);
              }),
        a =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || s(t, e, r);
          };
      Object.defineProperty(t, "__esModule", { value: !0 }), a(r(96609), t), a(r(7797), t);
    },
    96609: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.StartTaskTrackingCommand = void 0);
      const s = r(70986);
      class a extends (0, s.defineCommand)({ scope: s.UseCaseScope.Device }) {}
      t.StartTaskTrackingCommand = a;
    },
    7797: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.TerminateTaskTrackingCommand = void 0);
      const s = r(70986);
      class a extends (0, s.defineCommand)({ scope: s.UseCaseScope.Device }) {}
      t.TerminateTaskTrackingCommand = a;
    },
    36518: function (e, t, r) {
      "use strict";
      var s =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, r, s) {
                void 0 === s && (s = r);
                var a = Object.getOwnPropertyDescriptor(t, r);
                (a && !("get" in a ? !t.__esModule : a.writable || a.configurable)) ||
                  (a = {
                    enumerable: !0,
                    get: function () {
                      return t[r];
                    }
                  }),
                  Object.defineProperty(e, s, a);
              }
            : function (e, t, r, s) {
                void 0 === s && (s = r), (e[s] = t[r]);
              }),
        a =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || s(t, e, r);
          };
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.taskTrackingApi = void 0);
      var n = r(82397);
      Object.defineProperty(t, "taskTrackingApi", {
        enumerable: !0,
        get: function () {
          return n.taskTrackingApi;
        }
      }),
        a(r(39948), t);
    },
    17286: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
    },
    24164: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.featureFlipsApi = t.UserFeatureFlipQuery = t.UserFeatureFlipsQuery = void 0);
      const s = r(70986),
        a = r(8369);
      class n extends (0, s.defineQuery)({ scope: s.UseCaseScope.User }) {}
      t.UserFeatureFlipsQuery = n;
      class i extends (0, s.defineQuery)({ scope: s.UseCaseScope.Device }) {}
      (t.UserFeatureFlipQuery = i),
        (t.featureFlipsApi = (0, a.defineModuleApi)({
          commands: {},
          events: {},
          name: "featureFlips",
          queries: { UserFeatureFlipsQuery: n, UserFeatureFlipQuery: i }
        }));
    },
    71057: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.FeatureFlipsClient = void 0);
      const s = r(23767),
        a = r(24164);
      class n extends (0, s.defineModuleClient)(a.featureFlipsApi) {}
      (t.FeatureFlipsClient = n), (0, s.registerModuleClient)(a.featureFlipsApi, n);
    },
    85888: function (e, t, r) {
      "use strict";
      var s =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, r, s) {
                void 0 === s && (s = r);
                var a = Object.getOwnPropertyDescriptor(t, r);
                (a && !("get" in a ? !t.__esModule : a.writable || a.configurable)) ||
                  (a = {
                    enumerable: !0,
                    get: function () {
                      return t[r];
                    }
                  }),
                  Object.defineProperty(e, s, a);
              }
            : function (e, t, r, s) {
                void 0 === s && (s = r), (e[s] = t[r]);
              }),
        a =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || s(t, e, r);
          };
      Object.defineProperty(t, "__esModule", { value: !0 }),
        a(r(8369), t),
        a(r(21697), t),
        a(r(17286), t),
        a(r(6964), t),
        a(r(23767), t),
        a(r(24164), t),
        a(r(71057), t),
        a(r(27646), t);
    },
    23767: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.registerModuleClient = t.defineModuleClient = void 0),
        (t.defineModuleClient = function (e) {
          var t;
          return (
            ((t = class {
              get commands() {
                throw new Error("Not implemented");
              }
              get queries() {
                throw new Error("Not implemented");
              }
            }).api = e),
            t
          );
        }),
        (t.registerModuleClient = function (e, t) {
          e.ClientClass = t;
        });
    },
    8369: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.defineModuleApi = void 0);
      const r = (e, t) =>
        Object.entries(e).reduce(
          (e, [r, s]) => (
            (e[((e, t) => (e.endsWith(t) ? e.charAt(0).toLowerCase() + e.substring(1, e.length - t.length) : e))(r, t)] = s), e
          ),
          {}
        );
      t.defineModuleApi = (e) => ({
        name: e.name,
        commands: r(e.commands, "Command"),
        queries: r(e.queries, "Query"),
        events: r(e.events, "Event")
      });
    },
    6964: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.requestContextApi = t.ActiveUserSetEvent = t.SetActiveUserCommand = t.ActiveUserQuery = void 0);
      const s = r(70986),
        a = r(49631),
        n = r(8369);
      class i extends (0, s.defineQuery)({ scope: s.UseCaseScope.Device }) {}
      t.ActiveUserQuery = i;
      class o extends (0, s.defineCommand)({ scope: s.UseCaseScope.Device }) {}
      t.SetActiveUserCommand = o;
      class c extends (0, a.defineEvent)({ scope: s.UseCaseScope.User }) {}
      (t.ActiveUserSetEvent = c),
        (t.requestContextApi = (0, n.defineModuleApi)({
          commands: { SetActiveUserCommand: o },
          events: { activeUserSet: c },
          name: "requestContext",
          queries: { ActiveUserQuery: i }
        }));
    },
    27646: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.RequestContextClient = void 0);
      const s = r(23767),
        a = r(6964);
      class n extends (0, s.defineModuleClient)(a.requestContextApi) {}
      (t.RequestContextClient = n), (0, s.registerModuleClient)(a.requestContextApi, n);
    },
    21697: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.NullModuleApi = void 0),
        (t.NullModuleApi = { name: "api", commands: {}, events: {}, queries: {} });
    },
    20587: (e, t, r) => {
      "use strict";
      r.d(t, { L5: () => i, Yu: () => c, mf: () => o });
      var s = r(86952),
        a = r(74354),
        n = r(25029);
      class i extends (0, a.g)({ scope: n.F.Device }) {}
      class o extends (0, a.g)({ scope: n.F.Device }) {}
      const c = (0, s.Q)({ commands: { TrackEventCommand: i, TrackPageViewCommand: o }, events: {}, name: "analytics", queries: {} });
    },
    25029: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => a, z: () => s });
      class s {}
      var a;
      !(function (e) {
        (e.User = "user"), (e.Device = "device");
      })(a || (a = {}));
    },
    74354: (e, t, r) => {
      "use strict";
      r.d(t, { g: () => n });
      var s = r(25029);
      class a extends s.z {
        constructor(e) {
          super(), (this.body = e);
        }
      }
      const n = (...[e = { scope: s.F.User }]) => {
        var t;
        return ((t = class extends a {}).metadata = e), t;
      };
    },
    99059: (e, t, r) => {
      "use strict";
      r.d(t, { k: () => n });
      var s = r(25029);
      class a extends s.z {
        constructor(e) {
          super(), (this.body = e);
        }
      }
      const n = (e = { scope: s.F.User }) => {
        var t;
        return ((t = class extends a {}).metadata = e), t;
      };
    },
    88885: (e, t, r) => {
      "use strict";
      r.d(t, { d: () => n });
      var s = r(25029);
      class a {
        constructor(e) {
          this.body = e;
        }
      }
      const n = (e = { scope: s.F.User }) => {
        var t;
        return ((t = class extends a {}).metadata = e), t;
      };
    },
    49329: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => i });
      var s = r(86952),
        a = r(42339),
        n = r(29876);
      const i = (0, s.Q)({
        name: "taskTracking",
        commands: { startTaskTracking: a.g, terminateTaskTracking: n.y },
        events: {},
        queries: {}
      });
    },
    42339: (e, t, r) => {
      "use strict";
      r.d(t, { g: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.Device }) {}
    },
    29876: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => n });
      var s = r(74354),
        a = r(25029);
      class n extends (0, s.g)({ scope: a.F.Device }) {}
    },
    70493: (e, t, r) => {
      "use strict";
      r.d(t, { cV: () => c, fV: () => o, r6: () => i });
      var s = r(99059),
        a = r(25029),
        n = r(86952);
      class i extends (0, s.k)({ scope: a.F.User }) {}
      class o extends (0, s.k)({ scope: a.F.Device }) {}
      const c = (0, n.Q)({
        commands: {},
        events: {},
        name: "featureFlips",
        queries: { UserFeatureFlipsQuery: i, UserFeatureFlipQuery: o }
      });
    },
    21242: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => n });
      var s = r(67837),
        a = r(70493);
      class n extends (0, s.E)(a.cV) {}
      (0, s.K)(a.cV, n);
    },
    67837: (e, t, r) => {
      "use strict";
      function s(e) {
        var t;
        return (
          ((t = class {
            get commands() {
              throw new Error("Not implemented");
            }
            get queries() {
              throw new Error("Not implemented");
            }
          }).api = e),
          t
        );
      }
      function a(e, t) {
        e.ClientClass = t;
      }
      r.d(t, { E: () => s, K: () => a });
    },
    86952: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => a });
      const s = (e, t) =>
          Object.entries(e).reduce(
            (e, [r, s]) => (
              (e[((e, t) => (e.endsWith(t) ? e.charAt(0).toLowerCase() + e.substring(1, e.length - t.length) : e))(r, t)] = s), e
            ),
            {}
          ),
        a = (e) => ({ name: e.name, commands: s(e.commands, "Command"), queries: s(e.queries, "Query"), events: s(e.events, "Event") });
    },
    8987: (e, t, r) => {
      "use strict";
      r.d(t, { W_: () => d, p: () => c, r$: () => u, t$: () => l });
      var s = r(99059),
        a = r(25029),
        n = r(74354),
        i = r(88885),
        o = r(86952);
      class c extends (0, s.k)({ scope: a.F.Device }) {}
      class u extends (0, n.g)({ scope: a.F.Device }) {}
      class d extends (0, i.d)({ scope: a.F.User }) {}
      const l = (0, o.Q)({
        commands: { SetActiveUserCommand: u },
        events: { activeUserSet: d },
        name: "requestContext",
        queries: { ActiveUserQuery: c }
      });
    },
    69008: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => n });
      var s = r(67837),
        a = r(8987);
      class n extends (0, s.E)(a.t$) {}
      (0, s.K)(a.t$, n);
    },
    1665: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => h });
      var s = r(88802),
        a = r(20587),
        n = r(99634),
        i = r(63663),
        o = r(87279),
        c = r(53576),
        u = r(57924);
      let d = class {
        constructor(e) {
          this.carbonLegacyClient = e;
        }
        async trackEvent(e) {
          const { carbon: t } = this.carbonLegacyClient.commands,
            r = await t({ name: "logEvent", args: [{ event: e }] });
          if ((0, o.hx)(r)) throw new Error("TrackEvent from carbon failed");
        }
        async trackPageView(e, t) {
          const { carbon: r } = this.carbonLegacyClient.commands,
            s = await r({ name: "logPageView", args: [{ pageView: e, browseComponent: t }] });
          if ((0, o.hx)(s)) throw new Error("TrackPageView from carbon failed");
        }
      };
      d = (0, s.__decorate)([(0, u.GS)(), (0, s.__metadata)("design:paramtypes", [c.CarbonLegacyClient])], d);
      let l = class {
        constructor(e) {
          this.analyticsService = e;
        }
        async execute({ body: { event: e } }) {
          return await this.analyticsService.trackEvent(e), (0, o.Vp)(void 0);
        }
      };
      l = (0, s.__decorate)([(0, i.W)(a.L5), (0, s.__metadata)("design:paramtypes", [d])], l);
      let p = class {
        constructor(e) {
          this.analyticsService = e;
        }
        async execute({ body: { pageView: e, browseComponent: t } }) {
          return await this.analyticsService.trackPageView(e, t), (0, o.Vp)(void 0);
        }
      };
      p = (0, s.__decorate)([(0, i.W)(a.mf), (0, s.__metadata)("design:paramtypes", [d])], p);
      let h = class {};
      h = (0, s.__decorate)(
        [(0, n.Y)({ api: a.Yu, providers: [d], handlers: { commands: { trackEvent: l, trackPageView: p }, events: {}, queries: {} } })],
        h
      );
    },
    79256: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => i });
      var s = r(88802),
        a = r(57924),
        n = r(114);
      let i = class {
        constructor(e) {
          this.config = e;
        }
        async derive(e, t, r) {
          const { deriveKeyArgon2d: s } = this.config.crypto;
          return await s(e, t, r);
        }
      };
      i = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [n.i])], i);
    },
    114: (e, t, r) => {
      "use strict";
      r.d(t, { i: () => i });
      var s = r(88802),
        a = r(57924);
      const n = {
        computeHash: () => Promise.resolve(new ArrayBuffer(32)),
        decryptAes256: (e, t, r) => Promise.resolve(r),
        deriveKeyArgon2d: () => Promise.resolve(new ArrayBuffer(32)),
        deriveKeyPbkdf2: () => Promise.resolve(new ArrayBuffer(32)),
        encryptAes256: (e, t, r) => Promise.resolve(r),
        generateKeyAes256: () => Promise.resolve(new ArrayBuffer(32)),
        generateKeyPairRsaOaep: () => Promise.resolve({ privateKey: new ArrayBuffer(32), publicKey: new ArrayBuffer(32) }),
        getRandomValues: (e) => new Uint8Array(e),
        signHmacSha: () => Promise.resolve(new ArrayBuffer(32)),
        unsafeComputeMd5Hash: () => new ArrayBuffer(1),
        verifyHmacSha: () => Promise.resolve(!0),
        decryptRsaOaep: function (e, t) {
          return Promise.resolve(t);
        },
        encryptRsaOaep: function (e, t) {
          return Promise.resolve(t);
        },
        signRsassaPkcs1: function (e, t) {
          return Promise.resolve(t);
        }
      };
      let i = class {
        constructor(e) {
          this.crypto = e;
        }
      };
      i = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [Object])], i);
      new i(n);
    },
    37935: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => Q });
      var s = r(88802),
        a = r(99634),
        n = r(79256),
        i = r(114),
        o = r(69858),
        c = r(25594),
        u = r(56268),
        d = r(31222),
        l = r(57924),
        p = r(74017);
      let h = class {
        constructor(e) {
          this.config = e;
        }
        async verify(e, t, r, s = p.x) {
          const { verifyHmacSha: a } = this.config.crypto;
          return await a(e, t, r, s);
        }
      };
      h = (0, s.__decorate)([(0, l.GS)(), (0, s.__metadata)("design:paramtypes", [i.i])], h);
      var m = r(92258),
        y = r(71634),
        g = r(83919),
        v = r(56130),
        f = r(65613),
        w = r(40369),
        S = r(12554),
        E = r(77970),
        _ = r(40173),
        b = r(28008),
        T = r(22513),
        A = r(60733),
        C = r(19603),
        R = r(95087),
        I = r(89685);
      const x = "flexible";
      var P = r(69591);
      const D = "KWC3",
        U = 0;
      var F = r(38291);
      const O = 32,
        N = 4;
      function k(e) {
        const t = e.slice(O, O + N),
          r = (0, I.v)(t);
        var s;
        if (((s = r), [D, F.PD].includes(s))) return r;
      }
      function L(e) {
        const t = k(e);
        return (
          t ||
          ((function (e) {
            const t = new Uint8Array(e).slice(0, 1);
            return (0, I.v)(t.buffer) === P.F;
          })(e)
            ? x
            : void 0)
        );
      }
      var M = r(60745),
        V = r(82933),
        G = r(94805),
        j = r(16698);
      const q = { type: D, derivation: G.Yi, cipher: j.No };
      function K(e) {
        const t = (function ({ transportableData: e, marker: t }) {
          const { derivation: r, type: s } = t,
            { saltLength: a } = r,
            n = U + a + s.length;
          return { salt: e.slice(U, U + a), encipheredContents: e.slice(n) };
        })({ transportableData: e, marker: q });
        return { salt: t.salt, type: D, encipheredContents: t.encipheredContents, derivationConfig: G.Yi, cipherConfig: j.No };
      }
      var W = r(12087);
      async function B(e, t, r, s) {
        const a = K(s),
          { deriveKeyPbkdf2: n } = t,
          { derivationConfig: i, salt: o } = a,
          c = await (0, W.E)(n, r, i, e, o),
          { computeHash: u } = t,
          {
            cipherConfig: {
              ivLength: d,
              bytesToKey: { iterations: l, keyLength: p }
            }
          } = a,
          h = await (async function (e, t, r, s, a, n) {
            const i = (0, V.K)(t, n.slice(0, 8));
            let o = i,
              c = new ArrayBuffer(0);
            for (let t = 0; t < r; t++) {
              const t = await e(o, "SHA-1");
              (c = (0, V.K)(c, t)), (o = (0, V.K)(t, i));
            }
            const u = a + s;
            return Promise.resolve(c.slice(a, u));
          })(u, c, l, d, p, o),
          { decryptAes256: m } = t,
          { encipheredContents: y } = a;
        return m(c, h, y);
      }
      var z = r(7449);
      let H = class {
        constructor(e, t) {
          (this.config = e), (this.derivationCache = t);
        }
        decrypt(e, t) {
          return (async function (e, t, r, s) {
            const a = L(s);
            if (!a) throw new Error("Cannot find marker type");
            switch (a) {
              case D:
                return await B(e, t, r, s);
              case F.PD:
                return await (0, z.I)(e, t, s);
              case x:
                return (0, M.F)(e, t, r, s);
              default:
                (0, R.U)(a);
            }
          })(e, this.config.crypto, this.derivationCache, t);
        }
      };
      H = (0, s.__decorate)([(0, l.GS)(), (0, s.__metadata)("design:paramtypes", [i.i, o.E])], H);
      var $ = r(708);
      let Q = class {};
      Q = (0, s.__decorate)(
        [
          (0, a.Y)({
            sharedModuleName: "cryptography",
            configurations: { infrastructure: { token: i.i } },
            providers: [n.y, o.E, c.a, u._, $.y, d.q, h, m.c, y.$, g.o, v.k, f.n, w.F, C.Y, S.g, E.H, _.e, b.k, T.Z, H, A.f],
            exports: [n.y, o.E, c.a, u._, $.y, d.q, h, m.c, y.$, g.o, v.k, f.n, w.F, C.Y, S.g, E.H, _.e, b.k, T.Z, H, A.f]
          })
        ],
        Q
      );
    },
    69858: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => c });
      var s = r(88802),
        a = r(57924),
        n = r(82933),
        i = r(10370);
      class o {
        constructor() {
          this.derivateKeyCache = new Map();
        }
        getCacheKey(...e) {
          const t = e.reduce((e, t) => (0, n.K)(e, t), new ArrayBuffer(0));
          return (0, i.s)(t);
        }
        getCachedDerivation(e) {
          return this.derivateKeyCache.get(e);
        }
        setCachedDerivation({ cacheKey: e, data: t }) {
          this.getCachedDerivation(e) || this.derivateKeyCache.set(e, t);
        }
      }
      let c = class extends o {};
      c = (0, s.__decorate)([(0, a.GS)()], c);
    },
    25594: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => c });
      var s = r(88802),
        a = r(57924),
        n = r(60745),
        i = r(114),
        o = r(69858);
      let c = class {
        constructor(e, t) {
          (this.config = e), (this.derivationCache = t);
        }
        decrypt(e, t) {
          return (0, n.F)(e, this.config.crypto, this.derivationCache, t);
        }
      };
      c = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [i.i, o.E])], c);
    },
    56268: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => w });
      var s = r(88802),
        a = r(57924),
        n = r(82933),
        i = r(95087),
        o = r(54066),
        c = r(69591),
        u = r(33055),
        d = r(94805);
      function l(e) {
        const t = c.F + e.join(c.F) + c.F;
        return (0, o.u)(t);
      }
      function p({ cipher: e, derivation: t }) {
        const { algorithm: r } = t;
        switch (r) {
          case "argon2d":
            return (function ({ cipher: e, derivation: t }) {
              const { count: r, index: s } = u.ARGON2D_MARKER_SCHEMA,
                a = new Array(r);
              return (
                (a[s.version] = c.g),
                (a[s.derivation] = t.algorithm),
                (a[s.saltLength] = t.saltLength),
                (a[s.tCost] = t.tCost),
                (a[s.mCost] = t.mCost),
                (a[s.parallelism] = t.parallelism),
                (a[s.cipher] = e.algorithm),
                (a[s.mode] = e.mode),
                (a[s.ivLength] = e.ivLength),
                l(a)
              );
            })({ cipher: e, derivation: t });
          case "pbkdf2":
            return (function ({ cipher: e, derivation: t }) {
              const { count: r, index: s } = u.PBKDF2_MARKER_SCHEMA,
                a = new Array(r);
              return (
                (a[s.version] = c.g),
                (a[s.derivation] = t.algorithm),
                (a[s.saltLength] = t.saltLength),
                (a[s.iterations] = t.iterations),
                (a[s.hashAlgorithm] = t.hashAlgorithm),
                (a[s.cipher] = e.algorithm),
                (a[s.mode] = e.mode),
                (a[s.ivLength] = e.ivLength),
                l(a)
              );
            })({ cipher: e, derivation: t });
          case "noderivation":
            return (function ({ cipher: e, derivation: t }) {
              const { count: r, index: s } = u.NODERIVATION_MARKER_SCHEMA,
                a = new Array(r);
              return (
                (a[s.version] = c.g),
                (a[s.derivation] = t.algorithm),
                (a[s.cipher] = e.algorithm),
                (a[s.mode] = e.mode),
                (a[s.ivLength] = e.ivLength),
                l(a)
              );
            })({ cipher: e, derivation: t });
          default:
            (0, i.U)(r);
        }
      }
      var h = r(58396),
        m = r(6424),
        y = r(6752);
      async function g(e, t, r, s, a, i, o) {
        const { algorithm: c } = r,
          u = "pbkdf2" === c || "argon2d" === c;
        if (u && !o?.salt) throw new Error("Need salt for derivation");
        const { deriveKeyArgon2d: l, deriveKeyPbkdf2: g } = t,
          v = u && o?.salt ? await (0, y.b)(e, o.salt, g, l, r, s) : e,
          { mode: f } = a,
          { computeHash: w } = t,
          { encryptionKey: S, signatureKey: E } = "cbchmac64" === f ? await (0, h.U)(v) : await (0, m.Y)(v, w),
          { getRandomValues: _ } = t,
          b = _(a.ivLength),
          { encryptAes256: T } = t,
          A = await T(S, b, i),
          { signHmacSha: C } = t,
          R = (0, n.K)(b, A),
          I = await C(E, R);
        return (function (e) {
          const { encipheredContents: t, cipherConfig: r, derivationConfig: s, salt: a, signature: i, iv: o } = e;
          if ((a?.byteLength ?? 0) !== (0, d.m9)(s))
            throw new Error(`Salt length ${a?.byteLength ?? 0} does not match derivation algorithm ${s.algorithm} expectation`);
          const c = p({ cipher: r, derivation: s });
          return a && "noderivation" !== s.algorithm ? (0, n.K)(c, a, o, i, t) : (0, n.K)(c, o, i, t);
        })({
          type: "flexible",
          version: 1,
          derivationConfig: r,
          cipherConfig: a,
          salt: o?.salt,
          iv: b,
          signature: I,
          encipheredContents: A
        });
      }
      var v = r(114),
        f = r(69858);
      let w = class {
        constructor(e, t) {
          (this.config = e), (this.derivationCache = t);
        }
        async encrypt(e, t, r, s, a) {
          return await g(e, this.config.crypto, r, this.derivationCache, s, t, a);
        }
      };
      w = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [v.i, f.E])], w);
    },
    708: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => c });
      var s = r(88802),
        a = r(57924),
        n = r(60745);
      var i = r(114),
        o = r(69858);
      let c = class {
        constructor(e, t) {
          (this.config = e), (this.derivationCache = t);
        }
        verifySignature(e, t) {
          return (async function (e, t, r, s) {
            const { verifyHmacSha: a } = t,
              { signatureKey: i, signature: o, dataToSign: c } = await (0, n.V)(e, t, r, s);
            return a(i, o, c);
          })(e, this.config.crypto, this.derivationCache, t);
        }
      };
      c = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [i.i, o.E])], c);
    },
    31222: (e, t, r) => {
      "use strict";
      r.d(t, { q: () => o });
      var s = r(88802),
        a = r(57924),
        n = r(74017),
        i = r(114);
      let o = class {
        constructor(e) {
          this.config = e;
        }
        async sign(e, t, r = n.x) {
          const { signHmacSha: s } = this.config.crypto;
          return await s(e, t, r);
        }
      };
      o = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [i.i])], o);
    },
    92258: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => i });
      var s = r(88802),
        a = r(57924),
        n = r(114);
      let i = class {
        constructor(e) {
          this.config = e;
        }
        generate() {
          const { generateKeyAes256: e } = this.config.crypto;
          return e();
        }
      };
      i = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [n.i])], i);
    },
    71634: (e, t, r) => {
      "use strict";
      r.d(t, { $: () => o });
      var s = r(88802),
        a = r(57924),
        n = r(7449),
        i = r(114);
      let o = class {
        constructor(e) {
          this.config = e;
        }
        decrypt(e, t) {
          return (0, n.I)(e, this.config.crypto, t);
        }
      };
      o = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [i.i])], o);
    },
    83919: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => h });
      var s = r(88802),
        a = r(57924),
        n = r(16698),
        i = r(82933),
        o = r(54066),
        c = r(38291);
      var u = r(6424);
      async function d(e, t, r, s, a, n) {
        const { computeHash: d } = t,
          { encryptionKey: l, signatureKey: p } = await (0, u.Y)(e, d),
          { getRandomValues: h } = t,
          { ivLength: m } = s,
          y = h(m),
          { encryptAes256: g } = t,
          v = await g(l, y, a),
          { signHmacSha: f } = t,
          w = (0, i.K)(y, v),
          S = { type: "KWC5", derivationConfig: r, cipherConfig: s, iv: y, signature: await f(p, w), encipheredContents: v },
          { padding: E } = n;
        return (function ({ secureData: e, randomValues: t }) {
          if (t.byteLength !== c.en) throw new Error("Encoding kwc5 requires 16 random bytes");
          const { encipheredContents: r, iv: s, type: a, signature: n } = e,
            u = (0, o.u)(a);
          return (0, i.K)(s, t, u, n, r);
        })({ secureData: S, randomValues: E });
      }
      var l = r(94805),
        p = r(114);
      let h = class {
        constructor(e) {
          this.config = e;
        }
        encrypt(e, t) {
          const { getRandomValues: r } = this.config.crypto,
            s = { padding: r(n.BU.padding) };
          return d(e, this.config.crypto, l.oo, n.BU, t, s);
        }
      };
      h = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [p.i])], h);
    },
    55119: (e, t, r) => {
      "use strict";
      function s() {
        return new Uint32Array([
          57920321, 977424202, 1999259334, 3390546403, 3917439743, 16505144, 3027631148, 3235565160, 2643335823, 1420105356, 998514539,
          2704347781, 1011257802, 823882961, 790991339, 3929284516
        ]).buffer;
      }
      r.d(t, { S: () => s });
    },
    56130: (e, t, r) => {
      "use strict";
      r.d(t, { k: () => o });
      var s = r(88802),
        a = r(57924),
        n = r(25594),
        i = r(55119);
      let o = class {
        constructor(e) {
          this.flexibleDecryptor = e;
        }
        async decrypt(e) {
          const t = (0, i.S)();
          return await this.flexibleDecryptor.decrypt(t, e);
        }
      };
      o = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [n.a])], o);
    },
    65613: (e, t, r) => {
      "use strict";
      r.d(t, { n: () => c });
      var s = r(88802),
        a = r(57924),
        n = r(89685),
        i = r(56130),
        o = r(40369);
      let c = class {
        constructor(e, t) {
          (this.obfuscationKeyDecryptor = e), (this.obfuscationKeyEncryptor = t);
        }
        async encode(e) {
          return await this.obfuscationKeyEncryptor.encrypt(e);
        }
        async decode(e) {
          return (0, n.v)(e).startsWith("$1$noderivation$aes256$cbchmac64$16$") ? await this.obfuscationKeyDecryptor.decrypt(e) : e;
        }
      };
      c = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [i.k, o.F])], c);
    },
    40369: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => u });
      var s = r(88802),
        a = r(57924),
        n = r(94805),
        i = r(16698),
        o = r(56268),
        c = r(55119);
      let u = class {
        constructor(e) {
          this.flexibleEncryptor = e;
        }
        async encrypt(e) {
          const t = (0, c.S)();
          return await this.flexibleEncryptor.encrypt(t, e, n.oo, i.gO);
        }
      };
      u = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [o._])], u);
    },
    19603: (e, t, r) => {
      "use strict";
      r.d(t, { Y: () => i });
      var s = r(88802),
        a = r(57924),
        n = r(114);
      let i = class {
        constructor(e) {
          this.config = e;
        }
        get(e) {
          const { getRandomValues: t } = this.config.crypto;
          return t(e).buffer;
        }
      };
      i = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [n.i])], i);
    },
    12554: (e, t, r) => {
      "use strict";
      r.d(t, { g: () => i });
      var s = r(88802),
        a = r(57924),
        n = r(114);
      let i = class {
        constructor(e) {
          this.config = e;
        }
        decrypt(e, t, r = "SHA-256") {
          const { decryptRsaOaep: s } = this.config.crypto;
          return s(e, t, r);
        }
      };
      i = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [n.i])], i);
    },
    77970: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => i });
      var s = r(88802),
        a = r(57924),
        n = r(114);
      let i = class {
        constructor(e) {
          this.config = e;
        }
        encrypt(e, t, r = "SHA-256") {
          const { encryptRsaOaep: s } = this.config.crypto;
          return s(e, t, r);
        }
      };
      i = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [n.i])], i);
    },
    40173: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => i });
      var s = r(88802),
        a = r(57924),
        n = r(114);
      let i = class {
        constructor(e) {
          this.config = e;
        }
        generate(e = "SHA-256") {
          const { generateKeyPairRsaOaep: t } = this.config.crypto;
          return t(e);
        }
      };
      i = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [n.i])], i);
    },
    28008: (e, t, r) => {
      "use strict";
      r.d(t, { k: () => i });
      var s = r(88802),
        a = r(57924),
        n = r(114);
      let i = class {
        constructor(e) {
          this.config = e;
        }
        async sign(e, t, r = "SHA-256") {
          const { signRsassaPkcs1: s } = this.config.crypto;
          return await s(e, t, r);
        }
      };
      i = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [n.i])], i);
    },
    22513: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => i });
      var s = r(88802),
        a = r(57924),
        n = r(114);
      let i = class {
        constructor(e) {
          this.config = e;
        }
        async compute(e, t) {
          const { computeHash: r } = this.config.crypto;
          return await r(e, t);
        }
      };
      i = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [n.i])], i);
    },
    60733: (e, t, r) => {
      "use strict";
      r.d(t, { f: () => i });
      var s = r(88802),
        a = r(57924),
        n = r(114);
      let i = class {
        constructor(e) {
          this.config = e;
        }
        compute(e) {
          const { unsafeComputeMd5Hash: t } = this.config.crypto;
          return t(e);
        }
      };
      i = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [n.i])], i);
    },
    65255: (e, t, r) => {
      "use strict";
      r.d(t, { w: () => s });
      const s = {
        AuthsyncExtensionArkRelease: "authsync_extension_ark_release",
        B2CWebPostTrialBanner: "b2c_web_postTrialBanner",
        B2CRestrictPasswordFreePlanPhase1: "b2c_web_restrict_password_free_plan_phase1",
        B2CRestrictPasswordFreePlanPhase2: "b2c_web_restrict_password_free_plan_phase2",
        B2CRestrictPasswordFreePlan: "b2c_web_restrict_password_free_plan_dev",
        BBCOM238Duo: "BBCOM-238-duo",
        CollectionsPageEnabled: "vault_web_collectionpage_dev",
        SAEXSendSharing: "SAEXSendSharing",
        DarkwebMonitoringWebRelease: "darkwebMonitoringWebRelease",
        DwiMultipleDomainsProd: "dwi_multiple_domains_prod",
        DisableSecureNotes: "disableSecureNotes",
        EcommerceWebOfferToExtendPhase1: "ecommerce_web_offerToExtend_phase1",
        EcommerceWebChromeratingV2: "ecommerce_web_chromerating_V2",
        EcommerceWebPaywallUpdate: "ecommerce_web_paywall_update",
        EcommerceWebSadPathDev: "ecommerce_web_cancel_subscription_flow_dev",
        EcommerceWebB2BDiscontinuationDev: "ecommerce_web_b2bDiscontinuation_dev",
        EcommerceWebB2BDiscontinuationPhase1: "ecommerce_web_b2bDiscontinuation_phase1",
        EcommerceWebB2BDiscontinuationPhase2: "ecommerce_web_b2bDiscontinuation_phase2",
        EcommerceWebReferralPageUpdate: "ecommerce_web_referralpage_update",
        GrowthproductDSLPaywallDemogorgon: "growthproduct_DSLPaywall_demogorgon",
        ImsWebWeakMpProd: "ims_web_weak_mp_prod",
        ItadminSAEXCryptoMigrationPhase3V1: "itadmin_SAEX_CryptoMigration_Phase3_v1",
        ItadminTacEncryptionserviceSSOmigrationReset: "itadmin_tac_encryptionservice_SSOmigration_reset",
        ItadminTacPhonesupport: "itadmin_tac_phonesupport",
        OnboardingWebTeamsignuppage: "onboarding_web_teamsignuppage",
        PasswordHealthWeb: "passwordHealthWeb",
        SaexOnboardingHubAddPasswords: "saexOnboardingHubAddPasswords",
        SaexSecureNoteAttachmentsForrelease: "saex_SecureNoteAttachments_forrelease",
        SharingVaultWebRestrictSharingToTeamDev: "sharingVault_web_restrictSharingToTeam_dev",
        TechWeekWebDisplayLabs: "techWeek_web_displayLabs",
        TechweekWebAttachmentsForIdsV1: "techweek_web_attachmentsForIds_v1",
        TechweekWebExpiredLabelforIDDev: "techweek_web_expiredLabelforID_dev",
        WebplatformWebPrideColors: "webplatform_web_prideColors",
        WebproductExtensionActivateChangeMasterPasswordRelease: "webproduct_extension_ActivateChangeMasterPassword_release",
        WebproductExtensionShowUserConsentOptions: "webproduct_extension_ShowUserConsentOptions",
        SupportMarkdownInSecureNotes: "webproduct_extension_securenotesmarkdown_dev",
        SharingVaultOtpSetupDev: "sharingVault_web_otp_setup_dev",
        SecretManagementDev: "ace_secrets_vault_dev",
        SetupRolloutCtaProd: "setup_rollout_cta_prod"
      };
    },
    82482: (e, t, r) => {
      "use strict";
      r.d(t, { k: () => M });
      var s = r(88802),
        a = r(99634),
        n = r(70493),
        i = r(8987),
        o = r(1824),
        c = r(85390),
        u = r(16433),
        d = r(87065),
        l = r(30523),
        p = r(68307),
        h = r(9671),
        m = r(22838),
        y = r(20754),
        g = r(69008),
        v = r(87279),
        f = r(60399),
        w = r(57924),
        S = r(48844),
        E = r(61501);
      let _ = class {
        constructor(e) {
          this.serverApiClient = e;
        }
        getFeatureFlipsForActiveUser(e) {
          return (0, f.z)(
            this.serverApiClient.v1.features.getAndEvaluateForUser({ features: e }).pipe(
              (0, S.nb)({
                success: (e) => e.data.enabledFeatures,
                failure: () => {
                  throw new Error("Unable to fetch enabled feature flips for the active user");
                }
              })
            )
          );
        }
        getAvailableFeatureFlips() {
          return (0, f.z)(
            this.serverApiClient.v1.features.listAvailableFeatureFlips({}).pipe(
              (0, S.nb)({
                success: (e) => e.data.features.map((e) => e.name),
                failure: () => {
                  throw new Error("Unable to fetch available feature flips");
                }
              })
            )
          );
        }
      };
      _ = (0, s.__decorate)([(0, w.GS)(), (0, s.__metadata)("design:paramtypes", [E.l])], _);
      var b = r(95681),
        T = r(23347),
        A = r(25029),
        C = r(10722);
      const R = (e) => !(!e || "object" != typeof e) && "featureFlips" in e;
      class I extends (0, b.Q)({
        persist: !0,
        scope: A.F.Device,
        storeName: "feature-flip-store",
        capacity: T.Y._010KB,
        codec: C.E,
        storage: { initialValue: { featureFlips: {} }, schemaVersion: 1, typeGuard: R }
      }) {}
      class x extends (0, b.Q)({
        persist: !0,
        scope: A.F.User,
        storeName: "feature-flip-store",
        capacity: T.Y._010KB,
        codec: C.E,
        storage: { initialValue: { featureFlips: {} }, schemaVersion: 1, typeGuard: R }
      }) {}
      var P;
      !(function (e) {
        (e.Success = "Success"), (e.Pending = "Pending"), (e.Loading = "Loading"), (e.Cache = "Cache");
      })(P || (P = {}));
      class D extends (0, b.Q)({
        persist: !1,
        initialValue: { refreshStatus: P.Pending },
        scope: A.F.Device,
        storeName: "feature-flip-refresh-store",
        capacity: T.Y._001KB
      }) {}
      function U(e, t) {
        return !(!(0, v.d6)(e) || (0, v.db)(e).userName) || !(0, v.d6)(e) || !(0, v.db)(e).userName || [P.Success, P.Cache].includes(t);
      }
      let F = class {
        constructor(e, t, r, s, a, n) {
          (this.allowedToFailForGetAvailableFeatureFlips = e),
            (this.allowedToFailForGetFeatureFlipsForActiveUser = t),
            (this.featureFlipsService = r),
            (this.featureFlipsStore = s),
            (this.featureFlipsRefreshStore = a),
            (this.introspection = n);
        }
        async handle({ body: e }) {
          if (!e.userName)
            return (
              await this.featureFlipsRefreshStore.set({ refreshStatus: P.Pending }),
              void (await this.featureFlipsStore.set({ featureFlips: {} }))
            );
          await this.featureFlipsRefreshStore.set({ refreshStatus: P.Loading });
          const t = this.introspection.modules,
            r = Object.keys(t).reduce((e, r) => {
              const s = t[r];
              if (s.requiredFeatureFlips) for (const t of s.requiredFeatureFlips) e.add(t);
              return e;
            }, new Set()),
            s = Array.from(r);
          let a = [];
          await this.allowedToFailForGetAvailableFeatureFlips.doOne(() =>
            this.featureFlipsService.getAvailableFeatureFlips().then((e) => {
              a = e.filter((e) => r.has(e));
            })
          );
          const n = 0 === a.length ? s : a;
          await this.allowedToFailForGetFeatureFlipsForActiveUser.doOne(async () => {
            try {
              const e = await this.featureFlipsService.getFeatureFlipsForActiveUser(n),
                t = new Set(e),
                r = new Set(a),
                i = s.reduce((e, s) => ((e[s] = t.has(s) || (!r.has(s) && void 0)), e), {});
              await this.featureFlipsStore.set({ featureFlips: i }), await this.featureFlipsRefreshStore.set({ refreshStatus: P.Success });
            } catch (e) {
              throw (await this.featureFlipsRefreshStore.set({ refreshStatus: P.Cache }), e);
            }
          });
        }
      };
      F = (0, s.__decorate)([(0, p.b)(i.W_), (0, s.__metadata)("design:paramtypes", [h.J, h.J, _, x, D, m.Q1])], F);
      let O = class {
        constructor(e, t, r) {
          (this.featureFlipsStore = e), (this.featureFlipsRefreshStore = t), (this.requestContextClient = r);
        }
        execute() {
          return (0, c.a)([
            this.requestContextClient.queries.activeUser().pipe((0, u.q)(1)),
            this.featureFlipsRefreshStore.state$.pipe((0, d.U)((e) => e.refreshStatus)),
            this.featureFlipsStore.state$.pipe((0, d.U)((e) => e.featureFlips))
          ]).pipe(
            (0, l.h)(([e, t]) => U(e, t)),
            (0, d.U)(([e, , t]) => {
              if ((0, v.d6)(e)) return (0, v.db)(e).userName ? (0, v.Vp)(t) : (0, v.Vp)({});
              throw new Error("Cannot determine if user is logged in");
            })
          );
        }
      };
      O = (0, s.__decorate)([(0, y.e)(n.r6), (0, s.__metadata)("design:paramtypes", [x, D, g.Q])], O);
      let N = class {
        constructor(e, t, r) {
          (this.featureFlipsStore = e), (this.featureFlipsRefreshStore = t), (this.requestContextClient = r);
        }
        execute({ body: e }) {
          const { featureFlip: t } = e;
          return (0, c.a)([
            this.requestContextClient.queries.activeUser().pipe((0, u.q)(1)),
            this.featureFlipsRefreshStore.state$.pipe((0, d.U)((e) => e.refreshStatus)),
            this.featureFlipsStore.state$.pipe((0, d.U)((e) => e.featureFlips))
          ]).pipe(
            (0, l.h)(([e, t]) => U(e, t)),
            (0, d.U)(([e, , r]) => {
              if ((0, v.d6)(e)) return (0, v.db)(e).userName ? (0, v.Vp)(r[t]) : (0, v.Vp)(void 0);
              throw new Error("Cannot determine if user is logged in");
            })
          );
        }
      };
      N = (0, s.__decorate)([(0, y.e)(n.fV), (0, s.__metadata)("design:paramtypes", [x, D, g.Q])], N);
      var k = r(65255);
      let L = class {
        constructor(e) {
          this.featureFlipsStoreLegacy = e;
        }
        onFrameworkInit() {
          this.featureFlipsStoreLegacy.clearStorage();
        }
      };
      L = (0, s.__decorate)([(0, w.ar)(), (0, s.__metadata)("design:paramtypes", [I])], L);
      let M = class {};
      M = (0, s.__decorate)(
        [
          (0, a.Y)({
            api: n.cV,
            providers: [_],
            imports: [o.n],
            exports: [_],
            handlers: {
              commands: {},
              queries: { userFeatureFlips: O, userFeatureFlip: N },
              events: { ...(0, a.g)(i.t$, { activeUserSet: F }) }
            },
            stores: [I, x, D],
            requiredFeatureFlips: Object.values(k.w),
            onFrameworkInit: L
          })
        ],
        M
      );
    },
    44985: (e, t, r) => {
      "use strict";
      r.d(t, { i: () => i });
      var s = r(88802),
        a = r(99634),
        n = r(58895);
      let i = class {};
      i = (0, s.__decorate)([(0, a.Y)({ providers: [n.t], exports: [n.t], sharedModuleName: "platformInfo" })], i);
    },
    58895: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => d });
      var s = r(88802),
        a = r(60399),
        n = r(57924),
        i = r(94189),
        o = r(48844),
        c = r(20195),
        u = r(53576);
      let d = class {
        constructor(e) {
          this.client = e;
        }
        getPlatformInfo() {
          return (0, a.z)(
            this.client
              .getClient(u.carbonLegacyApi)
              .queries.getPlatformInfo()
              .pipe((0, o.nb)({ success: (e) => e, failure: c.j }))
          );
        }
      };
      d = (0, s.__decorate)([(0, n.GS)(), (0, s.__metadata)("design:paramtypes", [i.m])], d);
    },
    29659: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => d });
      var s = r(88802),
        a = r(57924),
        n = r(26457),
        i = r(87279),
        o = r(53576),
        c = r(60765),
        u = r(88268);
      let d = class extends u.tI {
        constructor(e, t) {
          super(), (this.carbonLegacyClient = e), (this.appLogger = t);
        }
        async decipher(e, t) {
          const { carbon: r } = this.carbonLegacyClient.commands,
            s = await r({ name: "decipherRemoteFile", args: [{ cipheredFileContent: e, fileMetaData: t }] });
          if ((0, i.hx)(s)) return (0, i.Rn)(c.RemoteFileUpdateError.DecipherError);
          const { carbonResult: a } = (0, i.db)(s);
          return ((e) =>
            "object" == typeof e && null !== e && Object.entries(e).some(([e, t]) => "decipheredFile" === e && t instanceof ArrayBuffer))(a)
            ? (0, i.Vp)(a.decipheredFile)
            : (0, i.Rn)(c.RemoteFileUpdateError.DecipherError);
        }
      };
      d = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [o.CarbonLegacyClient, n.V])], d);
    },
    39995: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => c });
      var s = r(88802),
        a = r(57924),
        n = r(7537),
        i = r(58376),
        o = r(60399);
      let c = class {
        constructor() {
          (this.filesToCheck = {}),
            (this.publishSubscriber = new n.t()),
            (this.updatedFileStream$ = new i.y((e) => {
              this.publishSubscriber.next(e), this.publishSubscriber.complete();
            }));
        }
        publish(e) {
          (0, o.z)(this.publishSubscriber).then((t) => t.next(e));
        }
        fileSubscription(e) {
          return (this.filesToCheck = { ...this.filesToCheck, ...e }), this.updatedFileStream$;
        }
        getFilesToCheck() {
          return this.filesToCheck;
        }
      };
      c = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [])], c);
    },
    47190: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => f });
      var s = r(88802),
        a = r(87279),
        n = r(48844),
        i = r(18533),
        o = r(60765),
        c = r(57924),
        u = r(73774),
        d = r(69885),
        l = r(60399),
        p = r(87065),
        h = r(61501),
        m = r(88268),
        y = r(94143),
        g = r(25994);
      const v = (e) => e[1].status === y.nQ;
      let f = class extends m.gG {
        constructor(e, t) {
          super(), (this.httpClient = e), (this.serverApiClient = t);
        }
        async downloadRemoteFileUpdate(e) {
          const t = await this._getFileMeta(e);
          return (0, a.hx)(t) ? [(0, d.of)(t)] : this._retrieveFilesFromServer((0, a.db)(t));
        }
        _getFileMeta(e) {
          return (0, l.z)(
            this.serverApiClient.v1.file.getFileMeta(e).pipe(
              (0, p.U)((e) => {
                if ((0, a.hx)(e)) return (0, a.Rn)(o.RemoteFileUpdateError.ServerError);
                const t = (0, a.db)(e);
                return (
                  (r = t.data),
                  Object.values(r).every((e) => "object" == typeof e && void 0 !== e.status && y.PQ.has(e.status))
                    ? (0, a.Vp)(t.data)
                    : (0, a.Rn)(o.RemoteFileUpdateError.ServerError)
                );
                var r;
              })
            )
          );
        }
        _retrieveFilesFromServer(e) {
          return Object.entries(e)
            .filter(v)
            .map(([e, t]) => this._getBufferFromURL(e, t));
        }
        _getBufferFromURL(e, t) {
          return this.httpClient
            .get(t.url, { observe: "body", responseType: "arraybuffer" })
            .pipe((0, n.Qn)(this._handleSuccess(e, t)), (0, n.DZ)(this._handleFailure));
        }
        _handleFailure(e) {
          return (0, i.EQ)(e, {
            BadStatus: (e) => (e.response.status === g.W.NotModified ? y.ek : o.RemoteFileUpdateError.DownloadError),
            FetchFailedError: () => o.RemoteFileUpdateError.DownloadError
          });
        }
        _handleSuccess(e, t) {
          return (r) => ({ fileName: e, buffer: r, updatedFile: t });
        }
      };
      f = (0, s.__decorate)([(0, c.GS)(), (0, s.__metadata)("design:paramtypes", [u.e, h.l])], f);
    },
    88268: (e, t, r) => {
      "use strict";
      r.d(t, { gG: () => s, pF: () => n, tI: () => a });
      class s {}
      class a {}
      class n {}
    },
    73881: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => v });
      var s = r(88802),
        a = r(99634),
        n = r(25504),
        i = r(25029),
        o = r(47190),
        c = r(82482),
        u = r(57924),
        d = r(39995),
        l = r(88268);
      let p = class {
        constructor(e, t) {
          (this.remoteFileUpdateService = e), (this.dispatcherService = t);
        }
        run() {
          const e = this.dispatcherService.getFilesToCheck();
          this.remoteFileUpdateService.observeRemoteFileUpdates(e).subscribe((e) => {
            this.dispatcherService.publish(e);
          }),
            this.remoteFileUpdateService.downloadAndDecipherRemoteFiles();
        }
      };
      p = (0, s.__decorate)([(0, u.GS)(), (0, s.__metadata)("design:paramtypes", [l.pF, d.Q])], p);
      var h = r(1824),
        m = r(29659),
        y = r(83958),
        g = r(1665);
      let v = class {};
      v = (0, s.__decorate)(
        [
          (0, a.Y)({
            sharedModuleName: "RemoteFileUpdateModule",
            configurations: {
              remoteFileUpdateInfrastructure: { token: l.pF },
              remoteFileUpdateDownloaderInfrastructure: { token: l.gG },
              decipherInfrastructure: { token: l.tI }
            },
            crons: [{ handler: p, periodInMinutes: 30, name: "RFUCron", scope: i.F.User }],
            providers: [y.U, m.c, o.P, d.Q],
            imports: [c.k, n.X, h.n, g.I],
            exports: [y.U, m.c, o.P, d.Q]
          })
        ],
        v
      );
    },
    83958: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => S });
      var s = r(88802),
        a = r(57924),
        n = r(26457),
        i = r(94189),
        o = r(87279),
        c = r(7537),
        u = r(58376),
        d = r(91501),
        l = r(6220),
        p = r(87065),
        h = r(60399),
        m = r(20587),
        y = r(29659),
        g = r(47190),
        v = r(88268),
        f = r(94143),
        w = r(60765);
      let S = class extends v.pF {
        constructor(e, t, r, s) {
          super(),
            (this.appLogger = e),
            (this.rfuDownloaderService = t),
            (this.rfuDecipheringService = r),
            (this.cqrsClient = s),
            (this._filesToCheck = {}),
            (this._emitDownloadedFilesUpdate$ = new c.t()),
            (this._downloadedFileStream$ = new u.y((e) => {
              this._emitDownloadedFilesUpdate$.next((t) => {
                e.next(t);
              }),
                this._emitDownloadedFilesUpdate$.complete();
            }));
        }
        observeRemoteFileUpdates(e) {
          return (this._filesToCheck = { ...this._filesToCheck, ...e }), this._downloadedFileStream$;
        }
        async downloadAndDecipherRemoteFiles() {
          const e = (await this.rfuDownloaderService.downloadRemoteFileUpdate(this._filesToCheck)).map((e) =>
            this._downloadAndDecipherSingleFile(e)
          );
          (0, d.D)(e).subscribe((e) => {
            const t = e.reduce((e, t) => {
              if ((0, o.hx)(t)) {
                const r = (0, o.Yv)(t);
                return r === f.ek || this.sendRFUEvents(w.FlowStep.Error, r), e;
              }
              const r = (0, o.db)(t);
              return this.sendRFUEvents(w.FlowStep.Complete), { ...e, [r.fileName]: r };
            }, {});
            this._callEmitDownloadedFilesUpdate(t);
          });
        }
        async _applyDecipheringStep(e) {
          const t = e.updatedFile.key ? await this.rfuDecipheringService.decipher(e.buffer, e.updatedFile) : (0, o.Vp)(e.buffer);
          return (0, o.d6)(t) ? (0, o.Vp)({ ...e, buffer: (0, o.db)(t) }) : t;
        }
        _downloadAndDecipherSingleFile(e) {
          return e.pipe(
            (0, l.z)((e) => ((0, o.d6)(e) ? this._applyDecipheringStep((0, o.db)(e)) : Promise.resolve(e))),
            (0, p.U)((e) => {
              if ((0, o.hx)(e)) return e;
              const { fileName: t, updatedFile: r, buffer: s } = (0, o.db)(e);
              return (0, o.Vp)({ fileName: t, revision: r.revision, buffer: s, lastDownloadTimestamp: Date.now() });
            })
          );
        }
        _callEmitDownloadedFilesUpdate(e) {
          return (0, h.z)(this._emitDownloadedFilesUpdate$).then((t) => {
            t(e);
          });
        }
        sendRFUEvents(e, t = undefined) {
          const { trackEvent: r } = this.cqrsClient.getClient(m.Yu).commands;
          r({
            event: new w.UserReceiveRemoteFileUpdateEvent({
              flowStep: e,
              remoteFileUpdateError: t,
              packageSource: w.PackageSource.Graphene
            })
          });
        }
      };
      S = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [n.V, g.P, y.c, i.w])], S);
    },
    94143: (e, t, r) => {
      "use strict";
      r.d(t, { PQ: () => a, ek: () => n, nQ: () => s });
      const s = "update_available",
        a = new Set([s, "not_updated", "not_found", "error_server"]),
        n = "not_modified";
    },
    16988: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => s });
      class s {}
    },
    32697: (e, t, r) => {
      "use strict";
      r.d(t, { u: () => U });
      var s = r(88802),
        a = r(24966),
        n = r(60399),
        i = r(30523),
        o = r(87065),
        c = r(6136),
        u = r(34987),
        d = r(14888),
        l = r(43004),
        p = r(57924),
        h = r(73774),
        m = r(91199),
        y = r(26457),
        g = r(43702);
      var v,
        f = r(23711),
        w = r(49499),
        S = r(87279),
        E = r(58895),
        _ = r(16988),
        b = r(69912);
      function T(e) {
        switch (e) {
          case l.w.CRITICAL:
            return v.ERROR;
          case l.w.WARNING:
            return v.WARNING;
        }
      }
      !(function (e) {
        (e[(e.UNKNOWN = 0)] = "UNKNOWN"), (e[(e.WARNING = 1)] = "WARNING"), (e[(e.ERROR = 2)] = "ERROR");
      })(v || (v = {}));
      const A = (e, t) => ({
        action: "logOnline",
        code: T(t.criticality),
        type: e.platformName,
        version: e.appVersion,
        additionalInfo: JSON.stringify({ manifestVersion: e.manifestVersion, ...(t.origin ? { origin: t.origin } : {}) }),
        browser: e.browser,
        browserVersion: e.browserVersion,
        exceptiontype: t.domainName ?? "grapheneException",
        message: t.message,
        os: e.os,
        osVersion: e.osVersion,
        sessionId: t.sessionId,
        stack: t.callStack,
        initialUseCaseModule: t.moduleName,
        initialUseCaseName: t.useCaseName,
        errorCount: 1,
        featureFlips: (t.featuresFlipped ?? []).join(","),
        line: t.lineNumber,
        file: t.fileLocation
      });
      function C(e, t) {
        return new b.L(
          "string" == typeof (r = A(e, t))
            ? r
            : Object.keys(r).reduce((e, t) => {
                const s = r[t];
                return void 0 === s || (e[t] = "string" == typeof s ? s : JSON.stringify(s)), e;
              }, {})
        );
        var r;
      }
      const R = { "Content-Type": "application/x-www-form-urlencoded" },
        I = ".graphene.exceptionLogs",
        x = new g.b(),
        P = new (class {
          constructor(e) {
            this.typeGuard = e;
          }
          decode(e) {
            if (this.typeGuard(e)) return e;
            throw new Error("Bad type");
          }
          encode(e) {
            return e;
          }
        })(
          (e) =>
            !(!e || "object" != typeof e) &&
            (0 === Object.keys(e).length ||
              (Object.keys(e).every((e) => "string" == typeof e) &&
                Object.values(e).every((e) => {
                  return (
                    !!((t = e) && "object" == typeof t && "entry" in t && "id" in t && "date" in t) &&
                    "string" == typeof t.id &&
                    "number" == typeof t.date &&
                    (0, l.h)(t.entry)
                  );
                  var t;
                })))
        ),
        D = new f.z();
      let U = class {
        constructor(e, t, r, s, n) {
          (this.httpClient = e),
            (this.kvStore = t),
            (this.logger = r),
            (this.settings = s),
            (this.platformInfoService = n),
            (this.queue$ = new a.X({})),
            (this.logExceptionsCount = {}),
            (this.platformInfo = null),
            (this.url = `${this.settings.serverEndpoint ?? "https://kck3hlb9.dashlane.com"}/1/softwarelog/create`),
            (this.codec = (0, w.x)(D, x, P));
        }
        async logException(e) {
          console.error(e);
          const t = this.settings.maxExceptionCountPerSession ?? 10,
            r = e.message.length ? e.message : "UNKNOWN_EXCEPTION";
          if (r in this.logExceptionsCount) {
            const e = this.logExceptionsCount[r];
            if (e === t) return Promise.resolve();
            this.logExceptionsCount[r] = e + 1;
          } else this.logExceptionsCount[r] = 1;
          const s = await this.enqueue(e);
          await (0, n.z)(this.queue$.pipe((0, i.h)((e) => !(s in e) || !!e[s].error)));
        }
        async start() {
          (this.platformInfo = await this.platformInfoService.getPlatformInfo()), await this.loadQueue();
          const e = this.settings.retryDelay ?? 6e4,
            t = this.queue$
              .pipe(
                (0, o.U)((e) => Object.keys(e)),
                (0, c.x)((e, t) => t.every((t) => e.includes(t))),
                (0, u.b)(() => this.processQueue()),
                (0, d.X)({ delay: e })
              )
              .subscribe();
          return {
            stop: async () => {
              t.unsubscribe(), await this.saveQueue();
            }
          };
        }
        async ignoreError(e) {
          try {
            return await e(), !0;
          } catch (e) {
            return this.logger.error("failed to send error log", e), !1;
          }
        }
        async saveQueue() {
          await this.ignoreError(async () => {
            const e = await this.codec.encode(this.queue$.value);
            await this.kvStore.set(I, e);
          });
        }
        async loadQueue() {
          await this.ignoreError(async () => {
            const e = await this.kvStore.get(I);
            if (!e || "" === e) return void this.queue$.next({});
            const t = await this.codec.decode(e),
              r = Date.now() - (this.settings.durationInQueue ?? 864e5);
            for (const e of Object.keys(t)) t[e].date < r && delete t[e];
            this.queue$.next(t);
          });
        }
        async enqueue(e) {
          const t = { date: Date.now(), entry: e, id: `${Date.now()}-${Math.random()}` };
          return (this.queue$.value[t.id] = t), await this.saveQueue(), this.queue$.next(this.queue$.value), t.id;
        }
        async processQueue() {
          const e = this.platformInfo;
          if (!e) throw new Error("No platform info");
          for (; Object.keys(this.queue$.value).length > 0; ) {
            const t = Object.keys(this.queue$.value)[0],
              r = this.queue$.value[t];
            if (
              !(await this.ignoreError(async () => {
                const t = await (0, n.z)(
                  this.httpClient.post(this.url, C(e, r.entry), {
                    headers: { ...R, "Client-Agent": ((s = e), `version:${s.appVersion},platform:${s.platformName}}`) },
                    observe: "response"
                  })
                );
                var s;
                if (!(0, S.d6)(t)) throw new Error("Failed to send log");
              }))
            )
              throw (
                ((this.queue$.value[t].error = !0), this.queue$.next(this.queue$.value), new Error("failed to send an item from the queue"))
              );
            delete this.queue$.value[t], await this.saveQueue();
          }
          this.queue$.next(this.queue$.value);
        }
      };
      U = (0, s.__decorate)([(0, p.GS)(), (0, s.__metadata)("design:paramtypes", [h.e, m.QI, y.V, _.L, E.t])], U);
    },
    64555: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => u });
      var s = r(88802),
        a = r(99634),
        n = r(25504),
        i = r(44985),
        o = r(32697),
        c = r(16988);
      let u = class {};
      u = (0, s.__decorate)(
        [
          (0, a.Y)({
            sharedModuleName: "software-exception-sink",
            imports: [n.X, i.i],
            providers: [o.u],
            exports: [o.u],
            configurations: { settings: { token: c.L } }
          })
        ],
        u
      );
    },
    71993: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => u });
      var s = r(10722),
        a = r(25029),
        n = r(95681),
        i = r(23347);
      const o = { drift: null },
        c = (e) => !(!e || "object" != typeof e || !("drift" in e)) && (null === e.drift || "number" == typeof e.drift);
      class u extends (0, n.Q)({
        storeTypeGuard: c,
        storeName: "clocksync",
        storage: { initialValue: o, schemaVersion: 1, typeGuard: c },
        scope: a.F.Device,
        isCache: !0,
        persist: !0,
        capacity: i.Y._001KB,
        codec: s.E
      }) {}
    },
    60565: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => _e, F: () => be });
      var s = r(88802),
        a = r(60399),
        n = r(89618),
        i = r(57924),
        o = r(73774),
        c = r(9671),
        u = r(37182),
        d = r(69885),
        l = r(14888),
        p = r(34987),
        h = r(87065),
        m = r(87279),
        y = r(18533),
        g = r(48844),
        v = r(4607),
        f = r(4043),
        w = r(25994),
        S = r(64839),
        E = r(96168);
      function _(e, t) {
        return class extends (0, E.Hu)(e, t) {
          constructor(e, t) {
            super(), (this.requestId = e), (this.error = t);
          }
        };
      }
      class b extends _("BusinessError", "Service responded with a business error") {
        constructor(e, t, r, s) {
          super(t, s), (this.code = e), (this.businessMessage = r);
        }
      }
      class T extends _("OutOfBoundsTimestamp", "Client clock is not synced with server clock") {}
      class A extends _("RateLimited", "Request was throttled by Dashlane API rate limiting setup") {}
      class C extends _("InvalidRequest", "The request sent by the client was invalid in its content or shape") {}
      class R extends _("ServiceUnavailable", "The requested endpoint is unavailable temporarily") {}
      class I extends _("InternalServerError", "The server is having an internal issue") {}
      class x extends (0, E.Hu)("UnspecifiedBadStatus", "A non-succesful response") {
        constructor(e) {
          super(), (this.response = e);
        }
      }
      var P = r(95087),
        D = r(64718),
        U = r(43293),
        F = r(54066),
        O = r(96303);
      function N(e) {
        const t = (0, U.N)(e);
        return (0, F.u)(t);
      }
      async function k(e, t) {
        const r = await e.compute(N(t), "SHA-256");
        return (0, O.k)(r);
      }
      function L(e) {
        return e.replace(/[^A-Za-z0-9_.~\\-]/g, (e) => "%" + e.charCodeAt(0).toString(16).toUpperCase());
      }
      function M(e, t) {
        return e.localeCompare(t, "en", { numeric: !0 });
      }
      function V(e) {
        return e.map((e) => e.toLowerCase());
      }
      class G {
        constructor(e) {
          this.secureHasher = e;
        }
        async canonicalizeRequest(e, t) {
          const {
              makeCanonicalBody: r,
              makeCanonicalURI: s,
              makeCanonicalQueryString: a,
              makeCanonicalHeadersString: n,
              makeSignedHeaderNamesString: i
            } = G,
            { body: o, headers: c, method: u, url: d, params: l } = e,
            p = new D.Y(d).getHostname(),
            h = d.indexOf(p),
            m = d.substring(h + p.length),
            y = r(o),
            g = await k(this.secureHasher, y),
            v = t ? V(t) : void 0,
            f = v ? ((w = V(c.keys())), (S = v).length ? w.filter((e) => !S.includes(e)) : w) : [];
          var w, S;
          const E = c.deleteMultiple(f),
            _ = s(m),
            b = a(l),
            T = n(E),
            A = i(E);
          return { canonicalRequest: [u, _, b, T, A, g].join("\n"), signedHeaderNames: A };
        }
        static makeCanonicalURI(e) {
          return (function (e) {
            return e
              .split("/")
              .map((e) => L(e))
              .join("/");
          })(e);
        }
        static makeCanonicalQueryStringPair(e, t) {
          const r = L(e),
            s = Array.isArray(t) ? t : [t];
          return s.sort(M).map((e) => {
            return (t = ((e) => L(e))(e)), [r, t];
            var t;
          });
        }
        static makeCanonicalQueryString(e) {
          return e
            .keys()
            .map(
              (t) =>
                `${(([e, t]) => G.makeCanonicalQueryStringPair(e, t))([t, e.getAll(t) ?? []])
                  .map((e) => e.join("="))
                  .join("&")}`
            )
            .sort(M)
            .join("&");
        }
        static makeCanonicalHeadersString(e) {
          return e
            .keys()
            .map((t) => {
              return (r = t), (s = e.get(t)), `${r.toLowerCase()}:${s.trim().replace(/\s+/g, " ")}\n`;
              var r, s;
            })
            .sort(M)
            .join("");
        }
        static makeSignedHeaderNamesString(e) {
          return e
            .keys()
            .map((e) => e.toLowerCase())
            .sort(M)
            .join(";");
        }
        static makeCanonicalBody(e) {
          return e ? JSON.stringify(e) : "";
        }
      }
      const j = "DL1-HMAC-SHA256";
      class q {
        constructor(e, t) {
          (this.hmacSigner = e), (this.secureHasher = t);
        }
        async signRequest(e, t, r) {
          const s = await k(this.secureHasher, e),
            a = [j, t, s].join("\n"),
            n = this.getFinalSecretKey(r),
            i = (0, F.u)(n),
            o = N(a),
            c = await this.hmacSigner.sign(i, o);
          return (0, O.k)(c);
        }
        getFinalSecretKey(e) {
          const { appSecretKey: t } = e;
          switch (e.type) {
            case S.d.APP:
              return t;
            case S.d.USER_DEVICE: {
              const { deviceSecretKey: r } = e;
              return `${t}\n${r}`;
            }
            case S.d.SESSION: {
              const { sessionSecretKey: r } = e;
              return `${t}\n${r}`;
            }
            case S.d.TEAM_DEVICE: {
              const { teamDeviceSecretKey: r } = e;
              return `${t}\n${r}`;
            }
            case S.d.EXTERNAL: {
              const { tokenSecretKey: r } = e;
              return `${t}\n${r}`;
            }
            case S.d.BACK_OFFICE:
              return t;
            default:
              (0, P.U)(e);
          }
        }
      }
      class K {
        constructor(e, t, r) {
          (this.signatureService = new q(t, e)), (this.canonicalizationService = new G(e)), (this.clockDriftService = r);
        }
        async prepareRequestForAuthorization(e, t) {
          if (t.type === S.d.CUSTOM) throw new Error("Unexpected credentials type provided to standard auth method");
          const r = this.addHostHeader(e),
            { canonicalRequest: s, signedHeaderNames: a } = await this.canonicalizationService.canonicalizeRequest(r),
            n = await this.clockDriftService.getDriftCorrectedTimestamp(),
            i = await this.signatureService.signRequest(s, n, t),
            o = this.buildAuthorizationHeader(t, n, a, i);
          return this.addAuthorizationHeader(e, o);
        }
        addHostHeader(e) {
          const t = new D.Y(e.url).getHostname(),
            r = e.headers.append("host", t);
          return e.clone({ headers: r });
        }
        addAuthorizationHeader(e, t) {
          const r = e.headers.append("authorization", t);
          return e.clone({ headers: r });
        }
        buildAuthorizationHeader(e, t, r, s) {
          const { appAccessKey: a } = e;
          switch (e.type) {
            case S.d.APP:
              return j + " " + [`AppAccessKey=${a}`, `Timestamp=${t}`, `SignedHeaders=${r}`, `Signature=${s}`].join(",");
            case S.d.USER_DEVICE: {
              const { login: n, deviceAccessKey: i } = e;
              return (
                j +
                " " +
                [`Login=${n}`, `AppAccessKey=${a}`, `DeviceAccessKey=${i}`, `Timestamp=${t}`, `SignedHeaders=${r}`, `Signature=${s}`].join(
                  ","
                )
              );
            }
            case S.d.SESSION: {
              const { deviceAccessKey: n, login: i, sessionAccessKey: o } = e;
              return (
                j +
                " " +
                [
                  `Login=${i}`,
                  `AppAccessKey=${a}`,
                  `SessionAccessKey=${o}`,
                  `DeviceAccessKey=${n}`,
                  `Timestamp=${t}`,
                  `SignedHeaders=${r}`,
                  `Signature=${s}`
                ].join(",")
              );
            }
            case S.d.TEAM_DEVICE: {
              const { teamDeviceAccessKey: n, teamUuid: i } = e;
              return (
                j +
                " " +
                [
                  `TeamUuid=${i}`,
                  `AppAccessKey=${a}`,
                  `DeviceAccessKey=${n}`,
                  `Timestamp=${t}`,
                  `SignedHeaders=${r}`,
                  `Signature=${s}`
                ].join(",")
              );
            }
            case S.d.BACK_OFFICE:
              return j + " " + ["Backoffice", `AppAccessKey=${a}`, `Timestamp=${t}`, `SignedHeaders=${r}`, `Signature=${s}`].join(",");
            case S.d.EXTERNAL: {
              const { tokenAccessKey: n } = e;
              return (
                j + " " + [`AppAccessKey=${a}`, `TokenAccessKey=${n}`, `Timestamp=${t}`, `SignedHeaders=${r}`, `Signature=${s}`].join(",")
              );
            }
            default:
              (0, P.U)(e);
          }
        }
      }
      class W {
        constructor(e) {
          this.descriptor = e;
        }
        decode(e) {
          return e;
        }
      }
      class B {
        constructor(e) {
          this.descriptor = e;
        }
        decode(e) {
          return e;
        }
      }
      class z {
        constructor(e, t, r, s, a, n) {
          (this.initHttpRequest = (e) => {
            const { method: t, path: r, version: s } = this.descriptor,
              { baseUrl: a, platformInfo: n } = this.config,
              i = `${a.endsWith("/") ? a : `${a}/`}${s}/${r}`,
              o = new v.W({
                accept: this.descriptor.requestAcceptHeader ?? "application/json",
                "content-type": "application/json; charset=UTF-8",
                "dashlane-client-agent": JSON.stringify({
                  platform: n.platformName,
                  version: n.version,
                  osversion: n.osversion,
                  language: n.language
                })
              });
            return new f.a(t, i, e, { headers: o });
          }),
            (this.prepareRequestForAuthorization = (e) => async (t) => {
              if (this.descriptor.authType === S.d.NONE) return t;
              let r;
              if (this.descriptor.authType === S.d.CUSTOM) {
                r = new (this.getCustomAuthPreparationClass())();
              } else r = this.standardAuthPreparationService;
              const s = this.getSigningCredentials(this.descriptor.authType, e);
              return await r.prepareRequestForAuthorization(t, s);
            }),
            (this.sendHttpRequest = (e) => this.httpClient.request(e)),
            (this.handleSuccess = async (e) => {
              if ("arraybuffer" === this.descriptor.responseType) return (0, m.Vp)(await e.arrayBuffer());
              if ("text" === this.descriptor.responseType) return (0, m.Vp)(await e.text());
              const t = await e.json(this.successBodyDecoder);
              return (0, m.Vp)(t);
            }),
            (this.handleFailure = async (e) =>
              await (0, y.EQ)(e, { BadStatus: this.handleBadStatus, FetchFailedError: (e) => Promise.resolve((0, m.Rn)(e)) })),
            (this.handleBadStatus = async (e) => {
              const { response: t } = e;
              if (t.status === w.W.BadRequest) {
                const { errors: e, requestId: r } = await t.json(this.failureBodyDecoder),
                  s = e[0];
                if ("business_error" === s.type) {
                  const { code: e, message: t } = s;
                  return (0, m.Rn)(new b(e, r, t, s));
                }
                if ("invalid_request_error" === s.type && "out_of_bounds_timestamp" === s.code) throw new T(r, s);
                return (0, m.Rn)(new C(r, s));
              }
              if (t.status === w.W.InternalServerError) {
                const { errors: e, requestId: r } = await t.json(this.failureBodyDecoder);
                return (0, m.Rn)(new I(r, e[0]));
              }
              if (t.status === w.W.ServiceUnavailable) {
                const { errors: e, requestId: r } = await t.json(this.failureBodyDecoder);
                return (0, m.Rn)(new R(r, e[0]));
              }
              if (t.status === w.W.TooManyRequests) {
                const { errors: e, requestId: r } = await t.json(this.failureBodyDecoder);
                return (0, m.Rn)(new A(r, e[0]));
              }
              return (0, m.Rn)(new x(t));
            }),
            (this.notifyWhenClockDriftErrorCompensated = (e) => {
              if (!(e instanceof T)) throw e;
              return this.clockDriftService.refresh().pipe(
                (0, u.K)(() => {
                  throw e;
                })
              );
            }),
            (this.httpClient = e),
            (this.standardAuthPreparationService = new K(t, r, s)),
            (this.clockDriftService = s),
            (this.config = a),
            (this.descriptor = n),
            (this.successBodyDecoder = new W(n)),
            (this.failureBodyDecoder = new B(n));
        }
        executeRequest(e) {
          const { body: t = null, credentials: r } = e;
          return (0, d.of)(this.initHttpRequest(t)).pipe(
            (0, p.b)(this.prepareRequestForAuthorization(r)),
            (0, p.b)(this.sendHttpRequest),
            (0, g.RW)({ success: this.handleSuccess, failure: this.handleFailure }),
            (0, h.U)(this.assertReturnType),
            (0, l.X)({ count: 1, delay: this.notifyWhenClockDriftErrorCompensated })
          );
        }
        getCustomAuthPreparationClass() {
          throw new Error("Unsupported custom authorization level");
        }
        getSigningCredentials(e, t) {
          if (e === S.d.APP || e === S.d.BACK_OFFICE) {
            if (t) throw new Error("Superfluous credentials provided");
            return { type: e, ...this.config.appKeys };
          }
          if (e === S.d.SESSION) {
            if (
              !t ||
              !(function (e) {
                return (
                  "object" == typeof e &&
                  "login" in e &&
                  "string" == typeof e.login &&
                  "deviceAccessKey" in e &&
                  "string" == typeof e.deviceAccessKey &&
                  "sessionAccessKey" in e &&
                  "string" == typeof e.sessionAccessKey &&
                  "sessionSecretKey" in e &&
                  "string" == typeof e.sessionSecretKey
                );
              })(t)
            )
              throw new Error("Invalid session credentials provided");
            return { type: e, ...this.config.appKeys, ...t };
          }
          if (e === S.d.TEAM_DEVICE) {
            if (
              !t ||
              !(function (e) {
                return (
                  "object" == typeof e &&
                  "teamUuid" in e &&
                  "string" == typeof e.teamUuid &&
                  "teamDeviceAccessKey" in e &&
                  "string" == typeof e.teamDeviceAccessKey &&
                  "teamDeviceSecretKey" in e &&
                  "string" == typeof e.teamDeviceSecretKey
                );
              })(t)
            )
              throw new Error("Invalid team device credentials provided");
            return { type: e, ...this.config.appKeys, ...t };
          }
          if (e === S.d.USER_DEVICE) {
            if (
              !t ||
              !(function (e) {
                return (
                  "object" == typeof e &&
                  "login" in e &&
                  "string" == typeof e.login &&
                  "deviceAccessKey" in e &&
                  "string" == typeof e.deviceAccessKey &&
                  "deviceSecretKey" in e &&
                  "string" == typeof e.deviceSecretKey
                );
              })(t)
            )
              throw new Error("Invalid user device credentials provided");
            return { type: e, ...this.config.appKeys, ...t };
          }
          if (e === S.d.EXTERNAL) {
            if (
              !t ||
              !(function (e) {
                return (
                  "object" == typeof e &&
                  "tokenAccessKey" in e &&
                  "string" == typeof e.tokenAccessKey &&
                  "tokenSecretKey" in e &&
                  "string" == typeof e.tokenSecretKey
                );
              })(t)
            )
              throw new Error("Invalid external credentials provided");
            return { type: e, ...this.config.appKeys, ...t };
          }
          return { type: e, ...(t ?? {}), ...this.config.appKeys };
        }
        assertReturnType(e) {
          return e;
        }
      }
      class H {
        constructor(e, t, r, s, a) {
          (this.httpClient = e), (this.clockDriftService = s), (this.secureHasher = t), (this.hmacSigner = r), (this.config = a);
        }
        createExecutor(e) {
          return new z(this.httpClient, this.secureHasher, this.hmacSigner, this.clockDriftService, this.config, e);
        }
      }
      class $ {
        constructor(e, t) {
          (this.timeSyncStore = e), (this.serverClockService = t);
        }
        async getDriftCorrectedTimestamp() {
          const e = (await this.timeSyncStore.getServerToClientClockDrift()) ?? 0;
          return Math.round(this.getUnixTimestamp() - e);
        }
        refresh() {
          return this.serverClockService
            .getServerTime()
            .pipe((0, h.U)(this.mapServerTimestampToClockDrift.bind(this)), (0, p.b)(this.storeUpdatedClockDrift.bind(this)));
        }
        mapServerTimestampToClockDrift(e) {
          const { timestamp: t } = e;
          return this.getUnixTimestamp() - t;
        }
        async storeUpdatedClockDrift(e) {
          await this.timeSyncStore.storeServerToClientClockDrift(e);
        }
        getUnixTimestamp() {
          return Math.round(Date.now() / 1e3);
        }
      }
      var Q = r(73873);
      class Y {
        getServerTime() {
          if (!this.executorFactory) throw new Error("No request executor factory");
          return new Q.q(this.executorFactory).getRemoteTime({}).pipe(
            (0, g.nb)({
              success: (e) => ({ timestamp: e.data.timestamp }),
              failure: (e) => {
                throw e;
              }
            })
          );
        }
        setExecutorFactory(e) {
          this.executorFactory = e;
        }
      }
      var X = r(58895);
      class J {
        constructor(e) {
          this.store = e;
        }
        async getServerToClientClockDrift() {
          const { drift: e } = await this.store.getState();
          return e;
        }
        storeServerToClientClockDrift(e) {
          return this.store.update(() => ({ drift: e }));
        }
      }
      var Z = r(18590),
        ee = r(71993),
        te = r(54404),
        re = r(77837),
        se = r(33027),
        ae = r(9536),
        ne = r(69865),
        ie = r(62361),
        oe = r(4119),
        ce = r(59091),
        ue = r(52839),
        de = r(55127),
        le = r(7181),
        pe = r(91406),
        he = r(84626),
        me = r(42882),
        ye = r(32739);
      const ge = {
        v1: {
          account: te.m,
          accountrecovery: re.u,
          authentication: se.V,
          darkwebmonitoring: ae.D,
          features: ne.A,
          file: ie.$,
          invitation: oe.R,
          payments: ce.H,
          pwleak: ue.J,
          sharingUserdevice: de.b,
          secretTransfer: le.V,
          teams: pe.p,
          time: Q.q,
          useractivity: he.V,
          userconsents: me.G,
          vpn: ye.V
        }
      };
      var ve = r(31222),
        fe = r(22513);
      const we = "CF-Access-Client-Id",
        Se = "CF-Access-Client-Secret";
      class Ee {
        constructor(e) {
          (this.cloudflareKeys = e), (this.id = "ServerApiForStagingInterceptor");
        }
        intercept(e, t) {
          if (e.url.startsWith("https://api.dashlane.com/") || !this.cloudflareKeys) return t(e);
          if (!e.headers.has(we) && !e.headers.has(Se)) {
            const { cloudflareAccessKey: r, cloudflareSecretKey: s } = this.cloudflareKeys;
            return t(e.clone({ headers: e.headers.set(we, r).set(Se, s) }));
          }
          return t(e);
        }
      }
      let _e = class {
        constructor(e, t, r, s, a, n, i) {
          (this.serverApiConfig = e),
            (this.httpClient = t),
            (this.clockDriftStore = r),
            (this.hmacSigner = s),
            (this.secureHasher = a),
            (this.platformInfoService = n),
            (this.allowedToFail = i);
        }
        async init() {
          const { clockDriftStore: e, serverApiConfig: t, secureHasher: r, httpClient: s, hmacSigner: a } = this,
            n = new J(e),
            i = await this.platformInfoService.getPlatformInfo(),
            { appKeys: o, baseUrl: c, cloudflareKeys: u } = t;
          s.addInterceptor(new Ee(u));
          const d = (function (e) {
            const { apis: t, config: r, secureHasher: s, httpClient: a, hmacSigner: n, timeSyncStore: i } = e,
              o = new Y(),
              c = new $(i, o),
              u = new H(a, s, n, c, r);
            return (
              o.setExecutorFactory(u),
              {
                refreshClockDrift: () => c.refresh(),
                v1: Object.keys(t.v1).reduce((e, r) => {
                  const s = t.v1[r];
                  return (e[r] = new s(u)), e;
                }, {})
              }
            );
          })({
            secureHasher: r,
            httpClient: s,
            timeSyncStore: n,
            hmacSigner: a,
            apis: ge,
            config: {
              appKeys: o,
              baseUrl: c,
              platformInfo: {
                platformName: i.platformName,
                version: i.appVersion || "unknown",
                osversion: i.osVersion || "unknown",
                language: i.lang || "unknown"
              }
            }
          });
          await this.initClockDrift(d), (this.rawSdk = d);
        }
        get sdk() {
          if (!this.rawSdk) throw new Error("ConfiguredServerSdk not initialized");
          return this.rawSdk;
        }
        async initClockDrift(e) {
          await this.allowedToFail.doOne(async () => {
            const { drift: t } = await this.clockDriftStore.getState();
            null === t && (await (0, a.z)(e.refreshClockDrift().pipe((0, n.V)({ first: 5e3 }))));
          });
        }
      };
      function be() {
        return {
          token: _e,
          asyncFactory: async (e, t, r, s, a, n, i) => {
            const o = new _e(e, t, r, s, a, n, i);
            return await o.init(), o;
          },
          inject: [Z.$y, o.e, ee.t, ve.q, fe.Z, X.t, c.J]
        };
      }
      _e = (0, s.__decorate)([(0, i.GS)(), (0, s.__metadata)("design:paramtypes", [Z.$y, o.e, ee.t, ve.q, fe.Z, X.t, c.J])], _e);
    },
    63281: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => i });
      var s = r(88802),
        a = r(57924),
        n = r(60565);
      let i = class {
        constructor(e) {
          this.configuredServerSdk = e;
        }
        get v1() {
          return this.configuredServerSdk.sdk.v1;
        }
      };
      i = (0, s.__decorate)([(0, a.GS)(), (0, s.__metadata)("design:paramtypes", [n.E])], i);
    },
    61501: (e, t, r) => {
      "use strict";
      r.d(t, { l: () => M });
      var s = r(88802),
        a = r(34987),
        n = r(57924),
        i = r(64839),
        o = r(24982);
      const c = {
        getAndEvaluateForDevice: {
          method: "POST",
          path: "abtesting/GetAndEvaluateForDevice",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.APP,
          version: o.W.V1
        },
        getAndEvaluateForUser: {
          method: "POST",
          path: "abtesting/GetAndEvaluateForUser",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        },
        listAll: {
          method: "POST",
          path: "abtesting/ListAll",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.APP,
          version: o.W.V1
        },
        reportOfflineExperiments: {
          method: "POST",
          path: "abtesting/ReportOfflineExperiments",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        }
      };
      var u = r(54404),
        d = r(77837),
        l = r(33027);
      const p = {
        createTestBreach: {
          method: "POST",
          path: "breaches-qa/CreateTestBreach",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.APP,
          version: o.W.V1
        }
      };
      var h = r(9536);
      const m = {
        getSubscriptionTokens: {
          method: "POST",
          path: "dataleak/GetSubscriptionTokens",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.APP,
          version: o.W.V1
        },
        status: {
          method: "POST",
          path: "dataleak/Status",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        }
      };
      const y = {
        addTestLeak: {
          method: "POST",
          path: "dataleak-qa/AddTestLeak",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.APP,
          version: o.W.V1
        },
        setTestDataBreach: {
          method: "POST",
          path: "dataleak-qa/SetTestDataBreach",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.APP,
          version: o.W.V1
        }
      };
      const g = {
        checkTeamDeviceInitialization: {
          method: "POST",
          path: "devices/CheckTeamDeviceInitialization",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.TEAM_DEVICE,
          version: o.W.V1
        },
        deactivateDevice: {
          method: "POST",
          path: "devices/DeactivateDevice",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        },
        deactivateDevices: {
          method: "POST",
          path: "devices/DeactivateDevices",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        },
        listDevices: {
          method: "POST",
          path: "devices/ListDevices",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        },
        renameDevice: {
          method: "POST",
          path: "devices/RenameDevice",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        },
        updateDeviceInfo: {
          method: "POST",
          path: "devices/UpdateDeviceInfo",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        }
      };
      const v = {
        accessibleFamilyOffers: {
          method: "POST",
          path: "familyplan/AccessibleFamilyOffers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.APP,
          version: o.W.V1
        },
        completePaidFamilyCreation: {
          method: "POST",
          path: "familyplan/CompletePaidFamilyCreation",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.APP,
          version: o.W.V1
        },
        createFreeFamily: {
          method: "POST",
          path: "familyplan/CreateFreeFamily",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.APP,
          version: o.W.V1
        },
        getFamilyDetails: {
          method: "POST",
          path: "familyplan/GetFamilyDetails",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        },
        invoiceFamilyCreationWithCreditCard: {
          method: "POST",
          path: "familyplan/InvoiceFamilyCreationWithCreditCard",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.APP,
          version: o.W.V1
        },
        joinFamily: {
          method: "POST",
          path: "familyplan/JoinFamily",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.APP,
          version: o.W.V1
        },
        leaveFamily: {
          method: "POST",
          path: "familyplan/LeaveFamily",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        },
        removeFamilyMember: {
          method: "POST",
          path: "familyplan/RemoveFamilyMember",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        },
        resetJoinToken: {
          method: "POST",
          path: "familyplan/ResetJoinToken",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        }
      };
      var f = r(69865),
        w = r(62361),
        S = r(4119);
      const E = {
        getKillSwitches: {
          method: "POST",
          path: "killswitch/GetKillSwitches",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.APP,
          version: o.W.V1
        }
      };
      const _ = {
        requestPairing: {
          method: "POST",
          path: "pairing/RequestPairing",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        }
      };
      var b = r(59091);
      const T = {
        getPremiumStatus: {
          method: "POST",
          path: "premium/GetPremiumStatus",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        },
        getSubscriptionInfo: {
          method: "POST",
          path: "premium/GetSubscriptionInfo",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        }
      };
      var A = r(52839),
        C = r(7181);
      const R = {
        deleteSecureFile: {
          method: "POST",
          path: "securefile/DeleteSecureFile",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        }
      };
      var I = r(55127);
      const x = {
        confirmMasterPasswordChangeDone: {
          method: "POST",
          path: "sync/ConfirmMasterPasswordChangeDone",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        },
        getDataForMasterPasswordChange: {
          method: "POST",
          path: "sync/GetDataForMasterPasswordChange",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        },
        getLatestContent: {
          method: "POST",
          path: "sync/GetLatestContent",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        },
        uploadContent: {
          method: "POST",
          path: "sync/UploadContent",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        },
        uploadDataForCryptoUpdate: {
          method: "POST",
          path: "sync/UploadDataForCryptoUpdate",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        },
        uploadDataForMasterPasswordChange: {
          method: "POST",
          path: "sync/UploadDataForMasterPasswordChange",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: i.d.USER_DEVICE,
          version: o.W.V1
        }
      };
      var P = r(91406),
        D = r(73873),
        U = r(84626),
        F = r(42882),
        O = r(32739);
      const N = {
        abtesting: c,
        account: u.h,
        accountrecovery: d.y,
        authentication: l.k,
        breachesQa: p,
        darkwebmonitoring: h.T,
        dataleak: m,
        dataleakQa: y,
        devices: g,
        familyplan: v,
        features: f.Z,
        file: w._,
        invitation: S.p,
        killswitch: E,
        pairing: _,
        payments: b.l,
        premium: T,
        pwleak: A.D,
        secretTransfer: C.t,
        securefile: R,
        sharingUserdevice: I.T,
        sync: x,
        teams: P.b,
        time: D.i,
        useractivity: U.K,
        userconsents: F._,
        vpn: O.m
      };
      u.m, d.u, l.V, h.D, f.A, w.$, S.R, b.H, A.J, C.V, I.b, P.p, D.q, U.V, F.G, O.V;
      var k = r(60565),
        L = r(21534);
      let M = class {
        constructor(e, t) {
          (this.appliedV1Services = this.buildInjectedServices("v1", e.sdk)), (this.credentialsService = t);
        }
        get v1() {
          return this.appliedV1Services;
        }
        buildInjectedServices(e, t) {
          return Object.keys(t[e]).reduce((r, s) => ({ ...r, [s]: this.buildInjectedApiServices(e, t, s) }), {});
        }
        buildInjectedApiServices(e, t, r) {
          return Object.getOwnPropertyNames(Object.getPrototypeOf(t.v1[r]))
            .filter((e) => "constructor" !== e)
            .reduce((s, a) => ({ ...s, [a]: this.buildInjectedRouteService(t, e, r, a) }), {});
        }
        buildInjectedRouteService(e, t, r, s) {
          const n = N[r][s];
          if (!n) throw new Error("Unable to find endpoint descriptor");
          const { authType: o } = n;
          return (...n) => {
            const c = e[t][r],
              u = c[s].bind(c);
            if (o === i.d.USER_DEVICE) return this.credentialsService.getActiveUserDeviceCredentials().pipe((0, a.b)((e) => u(e, ...n)));
            if ([i.d.NONE, i.d.APP].includes(o)) return u(...n);
            throw new Error("Not supported");
          };
        }
      };
      M = (0, s.__decorate)([(0, n.GS)(), (0, s.__metadata)("design:paramtypes", [k.E, L.n])], M);
    },
    21534: (e, t, r) => {
      "use strict";
      r.d(t, { n: () => l });
      var s = r(88802),
        a = r(87065),
        n = r(34987),
        i = r(87279),
        o = r(57924),
        c = r(94189),
        u = r(18590),
        d = r(8987);
      let l = class {
        constructor(e, t) {
          (this.cqrsClient = e), (this.infra = t);
        }
        getActiveUserDeviceCredentials() {
          const {
            queries: { activeUser: e }
          } = this.cqrsClient.getClient(d.t$);
          return e().pipe(
            (0, a.U)((e) => {
              if ((0, i.d6)(e)) return (0, i.db)(e);
              throw new Error("Failed to get active user");
            }),
            (0, n.b)(({ userName: e }) => {
              if (!e) throw new Error("No active user available");
              return this.infra.getDeviceCredentialsForUser(e);
            })
          );
        }
      };
      l = (0, s.__decorate)([(0, o.GS)(), (0, s.__metadata)("design:paramtypes", [c.w, u.se])], l);
    },
    18590: (e, t, r) => {
      "use strict";
      r.d(t, { $y: () => s, se: () => a });
      class s {
        constructor(e) {
          (this.baseUrl = e.baseUrl), (this.appKeys = e.appKeys), (this.cloudflareKeys = e.cloudflareKeys);
        }
      }
      class a {}
      new (class extends a {
        getDeviceCredentialsForUser(e) {
          return Promise.resolve({ deviceAccessKey: "", deviceSecretKey: "", login: e });
        }
      })();
    },
    1824: (e, t, r) => {
      "use strict";
      r.d(t, { n: () => m });
      var s = r(88802),
        a = r(99634),
        n = r(25504),
        i = r(44985),
        o = r(61501),
        c = r(63281),
        u = r(18590),
        d = r(71993),
        l = r(21534),
        p = r(60565),
        h = r(37935);
      let m = class {};
      m = (0, s.__decorate)(
        [
          (0, a.Y)({
            providers: [c.B, o.l, l.n, (0, p.F)()],
            exports: [c.B, o.l],
            configurations: { serverApi: { token: u.$y }, serverApiInfrastructure: { token: u.se } },
            stores: [d.t],
            sharedModuleName: "webServices",
            imports: [h.D, n.X, i.i]
          })
        ],
        m
      );
    },
    10370: (e, t, r) => {
      "use strict";
      r.d(t, { s: () => n });
      var s = r(46041);
      function a(e) {
        const t = e.length,
          r = [];
        for (let a = 0; a < t; a += 3)
          r.push(s.T[e[a] >> 2]),
            r.push(s.T[((3 & e[a]) << 4) | (e[a + 1] >> 4)]),
            r.push(s.T[((15 & e[a + 1]) << 2) | (e[a + 2] >> 6)]),
            r.push(s.T[63 & e[a + 2]]);
        return r.join("");
      }
      function n(e, t = s.V) {
        const r = new Uint8Array(e),
          n = r.length,
          i = t % 3,
          o = 0 === i ? t : t + (3 - i),
          c = Math.ceil(n / o);
        let u = "",
          d = -1;
        for (; d++ < c; ) {
          const e = d * o,
            t = d === c - 1 ? n : (d + 1) * o,
            s = a(r.slice(e, t));
          u = u.concat(s);
        }
        return n % 3 == 2 ? u.substring(0, u.length - 1) + "=" : n % 3 == 1 ? u.substring(0, u.length - 2) + "==" : u;
      }
    },
    89685: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => a });
      const s = Math.pow(2, 14) - 1;
      function a(e) {
        const t = new Uint8Array(e),
          r = t.length;
        let a = "",
          n = s;
        for (let e = 0; e < r; e += n) {
          e + n > r && (n = r - e);
          const s = t.subarray(e, e + n);
          a += String.fromCharCode(...s);
        }
        return a;
      }
    },
    68376: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => a });
      var s = r(96785);
      function a(e) {
        const t = new Uint8Array(e),
          r = [];
        for (let e = 0; e < t.byteLength; e++) r[e >>> 2] |= t[e] << (24 - (e % 4) * 8);
        return s.lib.WordArray.create(r, t.byteLength);
      }
    },
    66122: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => n });
      var s = r(46041);
      const a = new Uint8Array(256);
      for (let e = 0; e < s.T.length; e++) a[s.T.charCodeAt(e)] = e;
      function n(e) {
        let t = 0.75 * e.length;
        const r = e.length;
        let s,
          n,
          i,
          o,
          c,
          u = 0;
        e.endsWith("=") && (t--, "=" === e[e.length - 2] && t--);
        const d = new ArrayBuffer(t),
          l = new Uint8Array(d);
        for (s = 0; s < r; s += 4)
          (n = a[e.charCodeAt(s)]),
            (i = a[e.charCodeAt(s + 1)]),
            (o = a[e.charCodeAt(s + 2)]),
            (c = a[e.charCodeAt(s + 3)]),
            (l[u++] = (n << 2) | (i >> 4)),
            (l[u++] = ((15 & i) << 4) | (o >> 2)),
            (l[u++] = ((3 & o) << 6) | (63 & c));
        return d;
      }
    },
    96303: (e, t, r) => {
      "use strict";
      function s(e) {
        return Array.prototype.map.call(new Uint8Array(e), (e) => ("00" + e.toString(16)).slice(-2)).join("");
      }
      r.d(t, { k: () => s });
    },
    82933: (e, t, r) => {
      "use strict";
      function s(...e) {
        const t = e.reduce((e, t) => e + t.byteLength, 0),
          r = new Uint8Array(t);
        return e.reduce((e, t) => (r.set(new Uint8Array(t), e), e + t.byteLength), 0), r.buffer;
      }
      r.d(t, { K: () => s });
    },
    46041: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => a, V: () => s });
      const s = Math.pow(10, 6),
        a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    },
    83168: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => i });
      var s = r(3417),
        a = r.n(s),
        n = r(54066);
      function i(e) {
        const { asn1: t, pki: r } = a(),
          s = r.privateKeyFromPem(e),
          i = r.privateKeyToAsn1(s),
          o = r.wrapRsaPrivateKey(i),
          c = t.toDer(o).getBytes();
        return (0, n.u)(c);
      }
    },
    54066: (e, t, r) => {
      "use strict";
      function s(e) {
        const t = new ArrayBuffer(e.length),
          r = new Uint8Array(t);
        for (let t = 0; t < e.length; ++t) r[t] = e.charCodeAt(t);
        return t;
      }
      r.d(t, { u: () => s });
    },
    43293: (e, t, r) => {
      "use strict";
      r.d(t, { N: () => n });
      var s = r(30543),
        a = r(46041);
      function n(e, t = a.V) {
        const r = e.length;
        if (0 === r) return "";
        let n = "",
          i = 0,
          o = Math.min(i + t, r);
        for (; o <= r; ) {
          const a = e.charCodeAt(o - 1);
          if (a >= 55296 && a <= 56319) {
            if ((o++, o > r)) throw new Error("Invalid string provided to utf8ChunkEncode");
            continue;
          }
          const c = e.slice(i, o),
            u = s.encode(c);
          if (((n = n.concat(u)), o === r)) break;
          (i = o), (o = Math.min(i + t, r));
        }
        return n;
      }
    },
    69806: (e, t, r) => {
      "use strict";
      function s(e) {
        const { sigBytes: t, words: r } = e,
          s = new Uint8Array(t);
        let a = 0,
          n = 0;
        for (; a !== t; ) {
          const e = r[n++];
          if (((s[a++] = (4278190080 & e) >>> 24), a === t)) break;
          if (((s[a++] = (16711680 & e) >>> 16), a === t)) break;
          if (((s[a++] = (65280 & e) >>> 8), a === t)) break;
          s[a++] = 255 & e;
        }
        return s.buffer;
      }
      r.d(t, { o: () => s });
    },
    84473: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => n });
      var s = r(75994),
        a = r(92204);
      class n extends s.X {
        async fetch(e) {
          const t = (0, a.A)(e);
          return (await fetch(t)).json();
        }
      }
    },
    37298: (e, t, r) => {
      "use strict";
      r.d(t, { j: () => a });
      var s = r(58376);
      class a {
        constructor(e, t) {
          (this.source = e), (this.filter = t);
          let r = [];
          const a = new Set();
          (this.listener = (e, t) => {
            if (!this.filter(e, t)) return !1;
            a.size ? a.forEach((r) => r.next([e, t])) : r.push([e, t]);
          }),
            (this.events$ = new s.y(
              (e) => (
                a.size || (r.forEach((t) => e.next(t)), (r = [])),
                a.add(e),
                () => {
                  a.delete(e);
                }
              )
            )),
            this.source.addListener(this.listener);
        }
        stop() {
          this.source.removeListener(this.listener);
        }
      }
    },
    64391: (e, t, r) => {
      "use strict";
      r.d(t, { O: () => c, x: () => o });
      var s = r(34064),
        a = r.n(s),
        n = r(68376),
        i = r(69806);
      function o(e, t) {
        if (self.crypto.subtle) return self.crypto.subtle.digest({ name: t }, e);
        if ("SHA-1" === t) {
          const t = (0, n.L)(e),
            r = (0, i.o)(a()(t));
          return Promise.resolve(r);
        }
        return Promise.reject(new Error("Unsupported hash method"));
      }
      function c(e, t) {
        if ("SHA-1" === t) {
          const t = (0, n.L)(e);
          return (0, i.o)(a()(t));
        }
        throw new Error("Unsupported hash method");
      }
    },
    86381: (e, t, r) => {
      "use strict";
      r.d(t, { $: () => n });
      var s = r(22609),
        a = r(83961);
      async function n(e, t, r) {
        const n = await (0, a.Y)(e);
        return self.crypto.subtle.decrypt({ name: s.z, iv: t }, n, r);
      }
    },
    39560: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => a });
      var s = r(83407);
      async function a(e, t, r) {
        const a = { name: s.$, hash: { name: r } },
          n = await self.crypto.subtle.importKey("pkcs8", e, a, !1, ["decrypt"]);
        return self.crypto.subtle.decrypt(a, n, t);
      }
    },
    76254: (e, t, r) => {
      "use strict";
      r.d(t, { f: () => n });
      var s = r(35558),
        a = r.n(s);
      async function n(e, t, r) {
        const { tCost: n, mCost: i, parallelism: o } = r,
          { hash: c } = await a().hash({
            pass: new Uint8Array(e),
            salt: new Uint8Array(t),
            time: n,
            mem: i,
            hashLen: 32,
            parallelism: o,
            type: s.ArgonType.Argon2d
          });
        return c.buffer;
      }
    },
    80954: (e, t, r) => {
      "use strict";
      r.d(t, { x: () => a });
      var s = r(22609);
      async function a(e, t, r) {
        const a = await self.crypto.subtle.importKey("raw", e, "PBKDF2", !1, ["deriveKey"]),
          n = { name: s.z, length: 256 },
          { iterations: i, hashType: o } = r,
          c = { name: "PBKDF2", salt: t, iterations: i, hash: { name: o } },
          u = await self.crypto.subtle.deriveKey(c, a, n, !0, ["encrypt", "decrypt"]);
        return self.crypto.subtle.exportKey("raw", u);
      }
    },
    48264: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => n });
      var s = r(22609),
        a = r(83961);
      async function n(e, t, r) {
        const n = await (0, a.Y)(e);
        return self.crypto.subtle.encrypt({ name: s.z, iv: t }, n, r);
      }
    },
    64396: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => a });
      var s = r(83407);
      async function a(e, t, r) {
        const a = { name: s.$, hash: { name: r } },
          n = await self.crypto.subtle.importKey("spki", e, a, !1, ["encrypt"]);
        return self.crypto.subtle.encrypt(a, n, t);
      }
    },
    420: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => a });
      var s = r(22609);
      async function a() {
        const e = await self.crypto.subtle.generateKey({ name: s.z, length: s.N }, !0, ["encrypt", "decrypt"]);
        return self.crypto.subtle.exportKey("raw", e);
      }
    },
    26857: (e, t, r) => {
      "use strict";
      r.d(t, { Y: () => n });
      var s = r(83407);
      const a = new Uint8Array([1, 0, 1]);
      async function n(e) {
        const t = await self.crypto.subtle.generateKey({ name: s.$, modulusLength: 2048, publicExponent: a, hash: { name: e } }, !0, [
            "encrypt",
            "decrypt"
          ]),
          { privateKey: r, publicKey: n } = t;
        return { privateKey: await self.crypto.subtle.exportKey("pkcs8", r), publicKey: await self.crypto.subtle.exportKey("spki", n) };
      }
    },
    39911: (e, t, r) => {
      "use strict";
      function s(e) {
        const t = new Uint8Array(e);
        return self.crypto.getRandomValues(t);
      }
      r.d(t, { P: () => s });
    },
    83961: (e, t, r) => {
      "use strict";
      r.d(t, { Y: () => a });
      var s = r(22609);
      function a(e) {
        return self.crypto.subtle.importKey("raw", e, s.z, !1, ["encrypt", "decrypt"]);
      }
    },
    48297: (e, t, r) => {
      "use strict";
      function s(e, t) {
        return self.crypto.subtle.importKey("raw", e, { name: "HMAC", hash: { name: t } }, !0, ["sign", "verify"]);
      }
      r.d(t, { r: () => s });
    },
    43838: (e, t, r) => {
      "use strict";
      r.d(t, { n: () => n });
      var s = r(74017),
        a = r(48297);
      async function n(e, t, r = s.x) {
        const n = await (0, a.r)(e, r);
        return self.crypto.subtle.sign({ name: "HMAC", hash: { name: r } }, n, t);
      }
    },
    39387: (e, t, r) => {
      "use strict";
      r.d(t, { f: () => a });
      var s = r(83407);
      async function a(e, t, r) {
        const a = { name: s.x, hash: { name: r } },
          n = await self.crypto.subtle.importKey("pkcs8", e, a, !1, ["sign"]);
        return self.crypto.subtle.sign(a, n, t);
      }
    },
    396: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => o });
      var s = r(81968),
        a = r.n(s),
        n = r(68376),
        i = r(69806);
      function o(e) {
        const t = (0, n.L)(e);
        return (0, i.o)(a()(t));
      }
    },
    57487: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => n });
      var s = r(74017),
        a = r(48297);
      async function n(e, t, r, n = s.x) {
        const i = await (0, a.r)(e, n);
        return self.crypto.subtle.verify({ name: "HMAC", hash: { name: n } }, i, t, r);
      }
    },
    83074: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => m });
      var s = r(87065),
        a = r(93192),
        n = r(90171),
        i = r(47968),
        o = r(37182),
        c = r(69885),
        u = r(51992),
        d = r(73155),
        l = r(12964),
        p = r(4607),
        h = r(87279);
      class m {
        constructor() {
          (this.toHttpResult = (e) => (e instanceof d.a ? (0, h.Rn)(e) : e.ok ? (0, h.Vp)(e) : (0, h.Rn)(new d.R(e)))),
            (this.toHttpResponse = (e) =>
              e instanceof d.a
                ? e
                : new l.Z({
                    body: e.body,
                    url: e.url,
                    status: e.status,
                    statusText: e.statusText,
                    headers: this.mapToHttpHeaders(e.headers)
                  }));
        }
        handle(e) {
          const t = this.getTimeout$(e.timeout),
            r = this.doFetch(e).pipe((0, s.U)(this.toHttpResponse), (0, s.U)(this.toHttpResult));
          return (0, a.S)(t, r);
        }
        getTimeout$(e) {
          return e ? (0, n.H)(e).pipe((0, s.U)(() => (0, h.Rn)(new d.a()))) : i.C;
        }
        doFetch(e) {
          return (0, u.U)(e.url, {
            method: e.method,
            body: e.serializeBody(),
            headers: this.getHeaders(e),
            credentials: e.withCredentials ? "include" : "omit",
            mode: e.mode
          }).pipe(
            (0, o.K)((e) => {
              if (!(e instanceof TypeError)) throw e;
              return (0, c.of)(new d.a());
            })
          );
        }
        mapToHttpHeaders(e) {
          const t = new p.W();
          return e.forEach((e, r) => t.set(r, e)), t;
        }
        getHeaders(e) {
          return e.headers.keys().reduce((t, r) => ({ ...t, [r]: e.headers.get(r) }), {});
        }
      }
    },
    93699: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          BrowserCronSource: () => Pe,
          BrowserPortConnector: () => Ke,
          BrowserPortListener: () => Me.P,
          BrowserPortListenerChannel: () => He,
          BufferedEventStream: () => i.j,
          ExtensionCronSource: () => De.y,
          ExtensionLocalStorageInfrastructure: () => _e.e,
          HttpFetchBackend: () => R.A,
          IndexDbKeyValueStorage: () => Re,
          IndexDbStorage: () => Ce,
          JsonExtensionResourceFetcher: () => n.W,
          JsonWebAppResourceFetcher: () => a,
          PageToWorkerChannel: () => Le,
          computeHash: () => o.x,
          computeHashSynchronous: () => o.O,
          cookieRemoveByDomain: () => H,
          decryptAes256: () => c.$,
          decryptAesEcb256: () => p,
          decryptRsaOaep: () => h.G,
          deriveKeyArgon2d: () => m.f,
          deriveKeyPbkdf2: () => y.x,
          disableBrowserNativeAutofill: () => M,
          enablePrivacyService: () => L,
          encryptAes256: () => g.P,
          encryptRsaOaep: () => v.b,
          generateKeyAes256: () => f.o,
          generateKeyPairRsaOaep: () => w.Y,
          getLanguage: () => U,
          getRandomValues: () => S.P,
          getShortcutValues: () => ae,
          isMv3Environment: () => Ue,
          makeStoreInfrastructure: () => Ee.e,
          signHmacSha: () => E.n,
          signRsassaPkcs1: () => _.f,
          storageLocalItemExists: () => oe,
          unsafeComputeMd5Hash: () => b.H,
          updateToolbarIcon: () => K,
          verifyHmacSha: () => T.o,
          verifyRsassaPkcs1: () => C,
          webappClose: () => Se,
          webappOpen: () => fe
        });
      var s = r(75994);
      class a extends s.X {
        constructor(e) {
          super(), (this.publicPath = e);
        }
        async fetch(e) {
          return (await fetch(new URL(e.replace(/^\/*/, ""), this.publicPath).href)).json();
        }
      }
      var n = r(84473),
        i = r(37298),
        o = r(64391),
        c = r(86381),
        u = r(89685),
        d = r(68376),
        l = r(69806);
      function p(e, t) {
        const r = (0, u.v)(t),
          s = (0, d.L)(e);
        return (0, l.o)(CryptoJS.AES.decrypt(r, s, { mode: CryptoJS.mode.ECB }));
      }
      var h = r(39560),
        m = r(76254),
        y = r(80954),
        g = r(48264),
        v = r(64396),
        f = r(420),
        w = r(26857),
        S = r(39911),
        E = r(43838),
        _ = r(39387),
        b = r(396),
        T = r(57487),
        A = r(83407);
      async function C(e, t, r, s) {
        const a = { name: A.x, hash: { name: s } },
          n = await self.crypto.subtle.importKey("spki", e, a, !1, ["verify"]);
        return self.crypto.subtle.verify(a, n, t, r);
      }
      var R = r(83074);
      const I = new Set(["en", "fr", "es", "ja", "de", "pt", "it", "ko", "zh", "nl", "sv"]),
        x = "en";
      function P(e) {
        return e.substr(0, 2);
      }
      function D(e) {
        const t = P(e);
        return I.has(t);
      }
      function U() {
        const e = [navigator.language].concat(navigator.languages).find(D);
        if (!e) return x;
        if (!e.includes("-")) return e;
        return P(e);
      }
      var F = r(30754),
        O = r(82324),
        N = r(81805);
      const k = " ";
      async function L(e, t) {
        try {
          const { levelOfControl: t } = await (0, F.U)(e);
          if ("controllable_by_this_extension" !== t && "controlled_by_this_extension" !== t) {
            const r = [`Impossible to change browser setting: ${e}.`, `Extension prevented from changing: ${t}`].join(k);
            throw new Error(r);
          }
        } catch (t) {
          if ((0, O.b)(t)) {
            throw new Error(`Browser setting not supported: ${e}`);
          }
          if ((0, O.I)(t)) throw t.runtimeError;
          throw t;
        }
        try {
          await (0, N.t)(e, t);
        } catch (e) {
          throw (0, O.I)(e) ? e.runtimeError : e;
        }
      }
      async function M() {
        const e = ["autofillAddressEnabled", "autofillCreditCardEnabled", "passwordSavingEnabled"].map((e) => L(e, !1));
        await Promise.all(e);
      }
      var V = r(84318),
        G = r(16241);
      const j = { nightly: "icon_nightly_auth", mv2: "icon_auth", mv3: "icon_mv3_auth" },
        q = "icon_not_auth";
      async function K({ isUserAuthenticated: e }) {
        const t = `icons/action/${
            e
              ? (function () {
                  const e = (0, V.W)();
                  return e.name.includes("Nightly") ? j.nightly : e.name.includes("Beta") || 3 === e.manifest_version ? j.mv3 : j.mv2;
                })()
              : q
          }`,
          r = { 16: `${t}.png`, 32: `${t}@2x.png` };
        await (0, G.B)(r);
      }
      var W = r(329),
        B = r(98641);
      function z(e) {
        return `${"http" + (e.secure ? "s" : "")}://${e.domain.startsWith(".") ? e.domain.substring(1) : e.domain}${e.path}`;
      }
      async function H(e) {
        const t = await (0, W.g)({ domain: e });
        return Promise.all(t.map((e) => (0, B.O)({ url: z(e), name: e.name })));
      }
      var $ = r(28509),
        Q = r(839);
      const Y = /^_execute(_browser){0,1}_action$/,
        X = "+";
      var J;
      function Z(e) {
        return Y.test(e.name ?? "");
      }
      function ee(e) {
        const t = e.toUpperCase();
        switch (t) {
          case "⌃":
          case "CTRL":
            return $.isMacOS() ? J.Command : J.Ctrl;
          case "SHIFT":
          case "⇧":
            return J.Shift;
          case "COMMAND":
          case "⌘":
            return J.Command;
          case "MACCTRL":
            return J.MacCtrl;
          default:
            return t;
        }
      }
      function te(e) {
        const t = Object.values(J),
          r = t.indexOf(e);
        return -1 === r ? t.length : r;
      }
      function re(e, t) {
        return te(e) - te(t);
      }
      function se(e) {
        switch (e) {
          case J.Ctrl:
          case J.MacCtrl:
            return "Ctrl";
          case J.Shift:
            return "⇧";
          case J.Command:
            return "⌘";
          default:
            return e;
        }
      }
      async function ae() {
        const e = await new Promise((e, t) => {
            (0, Q.Ez)("commands.getAll")
              ? chrome.commands.getAll((r) => {
                  if (chrome.runtime.lastError) {
                    const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                      r = new Error(`commands/getAll: ${e}`);
                    t(r);
                  } else e(r);
                })
              : t(new Error("No commands.getAll support"));
          }),
          t = e.find(Z)?.shortcut;
        if (!t) return;
        const r = (function (e) {
          return e.split(e.includes(X) ? X : "");
        })(t);
        return r.map(ee).sort(re).map(se);
      }
      !(function (e) {
        (e.Command = "Command"), (e.Ctrl = "Ctrl"), (e.MacCtrl = "MacCtrl"), (e.Shift = "Shift");
      })(J || (J = {}));
      var ne = r(39680),
        ie = r(41808);
      async function oe(e) {
        if ((0, ne.G)()) {
          return (await (0, ne.y)(e)) > 0;
        }
        const t = await (0, ie.U)(e),
          r = void 0 === t[e],
          s = null === t[e];
        return !r && !s;
      }
      var ce = r(92204),
        ue = r(24715),
        de = r(72733),
        le = r(57306),
        pe = r(31460),
        he = r(61222);
      async function me() {
        const e = await (0, he.I)({}),
          t = (0, ce.A)("");
        return e.filter((e) => "string" == typeof e.url && e.url.startsWith(t)).filter((e) => "" !== e.url);
      }
      const ye = "index.html";
      function ge() {
        return `${(0, ce.A)("")}${ye}`;
      }
      function ve({ identifier: e, queryInfo: t, name: r }) {
        const s = ge();
        if (!r) return s;
        const a = e ? `#${r}/${e}` : `#${r}`,
          n = t
            ? `?${(function (e) {
                return Object.keys(e)
                  .map((t) => `${t}=${e[t]}`)
                  .join("&");
              })(t)}`
            : "";
        return encodeURI(`${s}${a}${n}`);
      }
      async function fe({ id: e, query: t, route: r }) {
        const s = ve({ identifier: e, queryInfo: t, name: r }),
          a = await me();
        a.length
          ? await (async function ({ path: e, tabs: t }) {
              const r = await (0, de.T)(),
                s = (function ({ existingTabs: e, focusedWindow: t }) {
                  const r = e.filter((e) => e.active),
                    s = r.find((e) => e.windowId === t.id),
                    a = r.pop(),
                    n = e.pop();
                  return s ?? a ?? n;
                })({ existingTabs: t, focusedWindow: r });
              if (!s) return;
              if ((s.windowId !== r.id && (0, le.V)(s.windowId, { focused: !0 }), !s.id)) return;
              const a = { active: !0, ...(e === ge() ? {} : { url: e }) };
              await (0, pe.V)(s.id, a);
            })({ path: s, tabs: a })
          : await (async function (e) {
              const t = { url: e };
              await (0, ue.U)(t);
            })(s);
      }
      var we = r(49259);
      async function Se() {
        const e = await me();
        if (!e.length) return;
        const t = chrome.tabs.TAB_ID_NONE,
          r = e.map((e) => e.id).filter((e) => "number" == typeof e && e !== t);
        await (0, we.O)(r);
      }
      var Ee = r(42973),
        _e = r(62853),
        be = r(96168),
        Te = r(87279);
      class Ae extends (0, be.Hu)("NotSupported", "Index DB is not supported in this environment") {}
      class Ce {
        constructor(e, t, r) {
          (this.DB_STORE_NAME = e), (this.DB_VERSION = t), (this.DB_OBJECT_STORE_NAME = r);
        }
        getIndexedDB() {
          return new Promise((e, t) => {
            const r = self.indexedDB;
            if (!r) return t(new Error("indexedDB is not supported in this environment"));
            const s = r.open(this.DB_STORE_NAME, this.DB_VERSION);
            (s.onerror = function () {
              "InvalidStateError" === s.error?.name && e((0, Te.Rn)(new Ae())), t(s.error);
            }),
              (s.onupgradeneeded = () => {
                s.result.objectStoreNames.contains(this.DB_OBJECT_STORE_NAME) || s.result.createObjectStore(this.DB_OBJECT_STORE_NAME);
              }),
              (s.onsuccess = function () {
                (s.onsuccess = null), e((0, Te.Vp)(s.result));
              });
          });
        }
        async isSupported() {
          return (0, Te.d6)(await this.getIndexedDB());
        }
        async getStore(e = "readwrite") {
          const t = await this.getIndexedDB();
          if (!(0, Te.d6)(t)) throw new Error("Failed to get db");
          return t.data.transaction([this.DB_OBJECT_STORE_NAME], e).objectStore(this.DB_OBJECT_STORE_NAME);
        }
        async readItem(e) {
          const t = await this.getStore("readonly");
          return new Promise((r) => {
            const s = t.get(e);
            s.onsuccess = () => {
              (s.onsuccess = null), r(s.result);
            };
          });
        }
        async getAllKeys() {
          const e = await this.getStore("readonly");
          return new Promise((t) => {
            const r = e.getAllKeys();
            r.onsuccess = () => {
              t(r.result.map((e) => String(e)));
            };
          });
        }
        async removeItem(e) {
          const t = await this.getStore("readwrite");
          return new Promise((r) => {
            const s = t.delete(e);
            s.onsuccess = () => {
              (s.onsuccess = null), r();
            };
          });
        }
        async writeItem(e, t) {
          const r = await this.getStore("readwrite");
          return new Promise((s) => {
            const a = r.put(t, e);
            a.onsuccess = () => {
              (a.onsuccess = null), s();
            };
          });
        }
        async itemExists(e) {
          const t = await this.readItem(e);
          return null != t;
        }
      }
      class Re {
        constructor() {
          this.storageLayer = new Ce("dashlane-ng", 1, "module-data");
        }
        isSupported() {
          return this.storageLayer.isSupported();
        }
        getAllKeys() {
          return this.storageLayer.getAllKeys();
        }
        async set(e, t) {
          return await this.storageLayer.writeItem(e, t);
        }
        remove(e) {
          return this.storageLayer.removeItem(e);
        }
        async get(e) {
          return (await this.storageLayer.readItem(e)) ?? void 0;
        }
      }
      var Ie = r(69594),
        xe = r(58376);
      class Pe extends Ie.R_ {
        constructor() {
          super(...arguments),
            (this.alarm$ = new xe.y((e) => {
              const t = self.setInterval(() => {
                e.next();
              }, 6e4);
              return () => {
                self.clearInterval(t);
              };
            }));
        }
      }
      var De = r(11565);
      function Ue() {
        return (
          "undefined" != typeof chrome &&
          void 0 !== chrome.runtime &&
          void 0 !== chrome.runtime.getManifest &&
          3 === (0, V.W)().manifest_version
        );
      }
      var Fe = r(15572),
        Oe = r(45244),
        Ne = r(69885),
        ke = r(7074);
      class Le {
        constructor(e, t) {
          (this.worker = e),
            (this.channelName = t),
            (this.status$ = (0, Ne.of)(Fe.D.Connected)),
            (this.messages$ = new xe.y((t) => {
              const r = (e) => {
                (0, Oe.F)(e.data) && !e.origin && t.next(e.data.message);
              };
              return (
                e.addEventListener("message", r),
                () => {
                  e.removeEventListener("message", r);
                }
              );
            }).pipe((0, ke.B)()));
        }
        async sendMessage(e) {
          this.worker.postMessage((0, Oe.k)({ channelName: this.channelName, message: e }));
        }
        stop() {
          return Promise.resolve();
        }
      }
      var Me = r(66917),
        Ve = r(24966),
        Ge = r(97280),
        je = r(6220),
        qe = r(60399);
      class Ke {
        constructor(e) {
          (this.status$ = new Ve.X(Fe.D.Connected)),
            (this.port$ = new xe.y((t) => {
              let r;
              const s = this.status$;
              function a() {
                r?.onDisconnect.removeListener(a);
                const n = (function (e) {
                  if (!(0, Q.Ez)("runtime.connect")) throw new Error("No runtime.connect support");
                  return chrome.runtime.connect(e);
                })({ name: e });
                s.next(Fe.D.Disconnected), n.onDisconnect.addListener(a), t.next(n), s.next(Fe.D.Connected), (r = n);
              }
              return (
                a(),
                () => {
                  r?.onDisconnect.removeListener(a), r?.disconnect();
                }
              );
            }).pipe((0, Ge.d)(1))),
            (this.portSubscription = this.port$.subscribe()),
            (this.messages$ = this.port$.pipe(
              (0, je.z)(
                (t) =>
                  new xe.y((r) => {
                    const s = (t) => {
                      (0, Oe.F)(t) && t.channelName === e && r.next(t.message);
                    };
                    return (
                      t.onMessage.addListener(s),
                      () => {
                        t.onMessage.removeListener(s);
                      }
                    );
                  })
              )
            ));
        }
        async sendMessage(e) {
          const t = await (0, qe.z)(this.port$);
          t.postMessage((0, Oe.k)({ channelName: t.name, message: e }));
        }
        stop() {
          return this.portSubscription.unsubscribe(), this.status$.next(Fe.D.Disconnected), Promise.resolve();
        }
      }
      var We = r(87065),
        Be = r(43978),
        ze = r(17350);
      class He {
        constructor(e) {
          (this.listener = new Me.P(e)),
            (this.channel$ = this.listener.connectedChannels$.pipe(
              (0, We.U)((e) => {
                const t = Object.values(e);
                if (t.length) return t[0];
              }),
              (0, Ge.d)(1)
            )),
            (this.receivedMessages$ = this.channel$.pipe((0, Be.w)((e) => (e ? e.receivedMessages$ : ze.E)))),
            (this.channelState$ = this.channel$.pipe((0, We.U)((e) => (e ? Fe.D.Connected : Fe.D.Disconnected))));
        }
        async send(e) {
          const t = await (0, qe.z)(this.channel$);
          if (!t) throw new Error("Channel is not connected");
          await t.send(e);
        }
        stop() {
          this.listener.stop();
        }
      }
    },
    42973: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => S });
      var s = r(83081),
        a = r(32012),
        n = r(58376),
        i = r(7074),
        o = r(24966),
        c = r(85390),
        u = r(15023),
        d = r(87065),
        l = r(839);
      const p = {
        addListener: function (e) {
          if (!(0, l.qX)(["storage"])) throw new Error("No storage.session.onChanged.addListener support, permission is missing");
          if (!(0, l.Ez)("storage.session.onChanged.addListener")) throw new Error("No storage.session.onChanged.addListener support");
          const t = (t) => {
            if (chrome.runtime.lastError) {
              const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError";
              throw new Error(`storage/session/onChanged: ${e}`);
            }
            return e(t);
          };
          return chrome.storage.session.onChanged.addListener(t), t;
        },
        removeListener: function (e) {
          if (!(0, l.qX)(["storage"])) throw new Error("No storage.session.onChanged.removeListener support, permission is missing");
          if (!(0, l.Ez)("storage.session.onChanged.removeListener"))
            throw new Error("No storage.session.onChanged.removeListener support");
          chrome.storage.session.onChanged.removeListener(e);
        }
      };
      var h = r(56847),
        m = r(52477),
        y = r(15026);
      function g(e) {
        return JSON.parse(JSON.stringify(e));
      }
      class v {
        constructor() {
          this.events$ = new n.y((e) => {
            const t = (t) => {
              e.next(t);
            };
            return p.addListener(t), () => p.removeListener(t);
          }).pipe((0, i.B)());
        }
      }
      class f {
        constructor(e, t, r) {
          (this.stopped$ = new o.X(!1)), (this.key = t), (this.typeGuard = r ?? ((e) => !0));
          const s = new n.y((r) => {
            this.getState().then((e) => {
              r.next(e);
            });
            const s = e.events$.subscribe((e) => {
              if (t in e) {
                const { newValue: s } = e[t];
                return r.next(this.asDataWithTimestamp(s));
              }
            });
            return () => s.unsubscribe();
          });
          this.state$ = (0, c.a)({ state: s, isStopped: this.stopped$ }).pipe(
            (0, u.o)(({ isStopped: e }) => !e, !1),
            (0, d.U)(({ state: e }) => e)
          );
        }
        async update(e) {
          return this.set(e(await this.getState()));
        }
        persist() {
          return Promise.resolve();
        }
        load() {
          return Promise.resolve();
        }
        set(e) {
          return (0, h.t)(g({ [this.key]: e }));
        }
        init(e) {
          return (0, h.t)(g({ [this.key]: e }));
        }
        clear() {
          return (0, m.O)(this.key);
        }
        clearStorage() {
          return Promise.resolve();
        }
        stop() {
          this.stopped$.next(!0);
        }
        async getState() {
          const e = (await (0, y.U)(this.key))[this.key];
          return this.asDataWithTimestamp(e);
        }
        asDataWithTimestamp(e) {
          return e &&
            "object" == typeof e &&
            "timestamp" in e &&
            "number" == typeof e.timestamp &&
            e.timestamp &&
            "data" in e &&
            this.typeGuard(e.data)
            ? { timestamp: e.timestamp, data: e.data }
            : { timestamp: void 0 };
        }
      }
      class w extends s.G {
        constructor() {
          super(...arguments), (this.source = new v());
        }
        createUserScopedInfrastructure(e, t, r, s) {
          const a = `graphene.${e}.${t}.${r}`;
          return new f(this.source, a, s);
        }
        createDeviceScopedInfrastructure(e, t, r) {
          const s = `graphene.${e}.${t}`;
          return new f(this.source, s, r);
        }
      }
      function S() {
        return (0, a.G)() ? new w() : new s.N();
      }
    },
    62853: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => i });
      var s = r(41808),
        a = r(9244),
        n = r(45441);
      class i {
        async getAllKeys() {
          return Object.keys(await (0, s.U)(null));
        }
        async get(e) {
          const t = (await (0, s.U)([e]))[e];
          if (t) {
            if ("string" != typeof t)
              throw new Error(
                `[ChromeLocalStorage] - cannot read content of ${e} properly. Type is\n        ${typeof t} but should be 'string'`
              );
            return t;
          }
        }
        async set(e, t) {
          await (0, a.t)({ [e]: t });
        }
        async remove(e) {
          await (0, n.O)([e]);
        }
      }
    },
    11565: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => p });
      var s = r(69594),
        a = r(58376),
        n = r(97280),
        i = r(839);
      const o = (e) => {
          if (!(0, i.qX)(["alarms"])) throw new Error("No alarms.onAlarm.addListener support, permission is missing");
          if (!(0, i.Ez)("alarms.onAlarm.addListener")) throw new Error("No alarms.onAlarm.addListener support");
          chrome.alarms.onAlarm.addListener(e);
          const t = chrome.runtime.lastError?.message;
          if (t) throw new Error("alarms/onAlarm error:" + t);
        },
        c = (e) => {
          if (!(0, i.qX)(["alarms"])) throw new Error("No alarms.onAlarm.removeListener support, permission is missing");
          if (!(0, i.Ez)("alarms.onAlarm.removeListener")) throw new Error("No alarms.onAlarm.removeListener support");
          chrome.alarms.onAlarm.removeListener(e);
          const t = chrome.runtime.lastError?.message;
          if (t) throw new Error("alarms/onAlarm error:" + t);
        };
      const u = "cron-source",
        d = () =>
          new a.y((e) => {
            const t = (t) => {
              t.name === u && e.next();
            };
            return (
              ((e, t) => {
                if (!(0, i.qX)(["alarms"])) throw new Error("No alarms.create support, permission is missing");
                if (!(0, i.Ez)("alarms.create")) throw new Error("No alarms.create support");
                chrome.alarms.create(e, t);
              })(u, { delayInMinutes: 1, periodInMinutes: 1 }),
              o(t),
              () => {
                c(t);
              }
            );
          }),
        l = () =>
          (0, i.Ez)("alarms.clear") && (0, i.qX)(["alarms"])
            ? d()
            : new a.y((e) => {
                const t = self.setInterval(() => {
                  e.next();
                }, 6e4);
                return () => {
                  self.clearInterval(t);
                };
              });
      class p extends s.R_ {
        constructor() {
          super(...arguments), (this.alarm$ = l().pipe((0, n.d)(1))), (this.subscription = this.alarm$.subscribe());
        }
        stop() {
          this.subscription.unsubscribe();
        }
      }
    },
    66917: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => p });
      var s = r(69183),
        a = r(24966),
        n = r(58376),
        i = r(87065),
        o = r(45244),
        c = r(15572),
        u = r(58649),
        d = r(20500),
        l = r(37298);
      class p {
        constructor(e) {
          this.connectedChannels$ = new a.X({});
          const t = new n.y((t) => {
            const r = {},
              n = (n) => {
                const d = (0, s.Z)();
                if (n.name !== e) return;
                const p = new l.j(
                    { addListener: (e) => n.onMessage.addListener(e), removeListener: (e) => n.onMessage.removeListener(e) },
                    (t) => (0, o.F)(t) && t.channelName === e
                  ),
                  h = new Promise((e) => {
                    const t = () => {
                      n.onDisconnect.removeListener(t), e(null);
                    };
                    n.onDisconnect.addListener(t);
                  }),
                  m = new a.X(c.D.Connected);
                h.then(() => {
                  p.stop(), m.next(c.D.Disconnected), delete r[d], t.next(r);
                });
                const y = {
                    messages$: p.events$.pipe((0, i.U)(([e]) => e.message)),
                    sendMessage: (t) => (n.postMessage((0, o.k)({ channelName: e, message: t })), Promise.resolve()),
                    stop: () => (n.disconnect(), Promise.resolve()),
                    status$: m
                  },
                  g = new u.N(y);
                (r[d] = g), t.next(r);
              };
            return (
              d.b.addListener(n),
              () => {
                d.b.removeListener(n);
              }
            );
          });
          this.subscription = t.subscribe((e) => this.connectedChannels$.next(e));
        }
        stop() {
          this.subscription.unsubscribe();
        }
      }
    },
    23711: (e, t, r) => {
      "use strict";
      r.d(t, { z: () => n });
      var s = r(66122),
        a = r(10370);
      class n {
        decode(e) {
          return (0, s.R)(e);
        }
        encode(e) {
          return (0, a.s)(e);
        }
      }
    },
    49499: (e, t, r) => {
      "use strict";
      function s(...e) {
        const t = [...e].reverse();
        return {
          decode: async (t) => {
            for (const r of e) t = await r.decode(t);
            return t;
          },
          encode: async (e) => {
            for (const r of t) e = await r.encode(e);
            return e;
          }
        };
      }
      r.d(t, { x: () => s });
    },
    43702: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => n });
      var s = r(89685),
        a = r(54066);
      class n {
        decode(e) {
          return JSON.parse((0, s.v)(e));
        }
        encode(e) {
          return (0, a.u)(JSON.stringify(e));
        }
      }
    },
    10722: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => a });
      const s = (e) => e;
      class a {
        constructor() {
          (this.encode = s), (this.decode = s);
        }
      }
    },
    16698: (e, t, r) => {
      "use strict";
      r.d(t, { BU: () => n, No: () => i, Nw: () => s, gO: () => a });
      const s = { algorithm: "aes256", mode: "cbchmac", ivLength: 16 },
        a = { algorithm: "aes256", mode: "cbchmac64", ivLength: 16 },
        n = { algorithm: "aes256", mode: "cbchmac", ivLength: 16, padding: 16, bytesToKey: 0, reuseSalt: !1 },
        i = {
          algorithm: "aes256",
          mode: "cbc",
          ivLength: 16,
          saltLength: 32,
          padding: 0,
          bytesToKey: { algorithm: "sha1", iterations: 3, keyLength: 32 }
        };
    },
    94805: (e, t, r) => {
      "use strict";
      r.d(t, { E1: () => n, Yi: () => o, b9: () => c, m9: () => u, mr: () => a, oo: () => i });
      var s = r(95087);
      const a = { algorithm: "argon2d", saltLength: 16, tCost: 3, mCost: 32768, parallelism: 2 },
        n = { algorithm: "pbkdf2", saltLength: 16, iterations: 2e5, hashAlgorithm: "sha256" },
        i = { algorithm: "noderivation" },
        o = { algorithm: "pbkdf2", saltLength: 32, iterations: 10204, hashAlgorithm: "sha1" };
      function c(e) {
        return ["argon2d", "pbkdf2", "noderivation"].some((t) => t === e);
      }
      function u(e) {
        switch (e.algorithm) {
          case "argon2d":
          case "pbkdf2":
            return e.saltLength;
          case "noderivation":
            return 0;
          default:
            (0, s.U)(e);
        }
      }
    },
    69591: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => s, g: () => a });
      const s = "$",
        a = 1;
    },
    33055: (e, t, r) => {
      "use strict";
      r.d(t, { ARGON2D_MARKER_SCHEMA: () => s, NODERIVATION_MARKER_SCHEMA: () => n, PBKDF2_MARKER_SCHEMA: () => a });
      const s = {
          count: 9,
          index: { version: 0, derivation: 1, saltLength: 2, tCost: 3, mCost: 4, parallelism: 5, cipher: 6, mode: 7, ivLength: 8 }
        },
        a = {
          count: 8,
          index: { version: 0, derivation: 1, saltLength: 2, iterations: 3, hashAlgorithm: 4, cipher: 5, mode: 6, ivLength: 7 }
        },
        n = { count: 5, index: { version: 0, derivation: 1, cipher: 2, mode: 3, ivLength: 4 } };
    },
    38291: (e, t, r) => {
      "use strict";
      r.d(t, { PD: () => s, RB: () => i, en: () => a, jK: () => n });
      const s = "KWC5",
        a = 16,
        n = 32,
        i = 0;
    },
    6752: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => n });
      var s = r(54066);
      var a = r(12087);
      function n(e, t, r, n, i, o) {
        return "pbkdf2" === i.algorithm
          ? (0, a.E)(r, o, i, e, t)
          : (async function (e, t, r, a, n) {
              const { tCost: i, mCost: o, parallelism: c } = r,
                u = (0, s.u)(Object.values(r).join("")),
                d = t.getCacheKey(a, n, u),
                l = t.getCachedDerivation(d);
              if (l) return l;
              const p = { tCost: i, mCost: o, parallelism: c },
                h = await e(a, n, p);
              return t.setCachedDerivation({ cacheKey: d, data: h }), h;
            })(n, o, i, e, t);
      }
    },
    12087: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => n });
      var s = r(54066),
        a = r(95087);
      async function n(e, t, r, n, i) {
        const o = (0, s.u)(Object.values(r).join("")),
          c = t.getCacheKey(n, i, o),
          u = t.getCachedDerivation(c);
        if (u) return u;
        const d = (function (e) {
            switch (e) {
              case "sha1":
                return "SHA-1";
              case "sha256":
                return "SHA-256";
              case "sha384":
                return "SHA-384";
              case "sha512":
                return "SHA-512";
              default:
                (0, a.U)(e);
            }
          })(r.hashAlgorithm),
          l = await e(n, i, { iterations: r.iterations, hashType: d });
        return t.setCachedDerivation({ cacheKey: c, data: l }), l;
      }
    },
    60745: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => V, V: () => M });
      var s = r(82933),
        a = r(89685),
        n = r(95087),
        i = r(94805);
      function o({ transportableData: e, marker: t, metadata: r }) {
        const s = t.length + r.length;
        return e.substring(s);
      }
      var c = r(54066);
      function u({ encipheredContents: e, marker: t, metadata: r }) {
        const { derivation: s, cipher: a, type: n, version: i } = t,
          { iv: o, salt: u, signature: d } = r;
        return {
          type: n,
          version: i,
          derivationConfig: s,
          cipherConfig: a,
          salt: (0, c.u)(u),
          signature: (0, c.u)(d),
          iv: (0, c.u)(o),
          encipheredContents: (0, c.u)(e)
        };
      }
      function d({ str: e, substr: t, occurrence: r }) {
        if (r < 1) return -1;
        let s = 0,
          a = -1;
        for (; s < r; ) {
          if (((a = e.indexOf(t, a + 1)), a < 0)) return a;
          s++;
        }
        return a;
      }
      var l = r(69591);
      function p({ transportableData: e, makeMarker: t, schema: r }) {
        const s = r.count + 1,
          a = d({ str: e, substr: l.F, occurrence: s }),
          n = e.substring(1, a).split(l.F);
        if (n.length !== r.count) throw new Error("Marker and schema length mismatch");
        return t({ bytes: a + 1, markerSchema: r, values: n });
      }
      var h = r(7165);
      const m = h.z.object({ algorithm: h.z.literal("aes256"), mode: h.z.literal("cbchmac"), ivLength: h.z.literal(16) }),
        y = h.z.object({ algorithm: h.z.literal("aes256"), mode: h.z.literal("cbchmac64"), ivLength: h.z.literal(16) }),
        g = h.z.union([m, y]),
        v = h.z.object({
          algorithm: h.z.literal("argon2d"),
          saltLength: h.z.literal(16),
          tCost: h.z.number(),
          mCost: h.z.number(),
          parallelism: h.z.number()
        }),
        f = h.z.object({
          algorithm: h.z.literal("pbkdf2"),
          saltLength: h.z.union([h.z.literal(16), h.z.literal(32)]),
          iterations: h.z.number(),
          hashAlgorithm: h.z.enum(["sha1", "sha256"])
        }),
        w = h.z.object({ algorithm: h.z.literal("noderivation") }),
        S = h.z.literal("flexible"),
        E = h.z.object({ version: h.z.literal(1), type: S, length: h.z.number(), derivation: v, cipher: m });
      function _({ bytes: e, markerSchema: t, values: r }) {
        const { version: s, derivation: a, saltLength: n, tCost: i, mCost: o, parallelism: c, cipher: u, mode: d, ivLength: l } = t.index,
          p = E.safeParse({
            version: Number(r[s]),
            type: "flexible",
            length: e,
            derivation: { algorithm: r[a], saltLength: Number(r[n]), tCost: Number(r[i]), mCost: Number(r[o]), parallelism: Number(r[c]) },
            cipher: { algorithm: r[u], mode: r[d], ivLength: Number(r[l]) }
          });
        if (!p.success) throw new Error(p.error.message);
        return p.data;
      }
      var b = r(33055);
      const T = 32;
      function A({ transportableData: e, marker: t }) {
        const { length: r, derivation: s, cipher: a } = t,
          n = s.saltLength,
          { ivLength: i } = a,
          o = r + 0,
          c = o + n,
          u = c + i;
        return { iv: e.substring(c, c + i), length: n + i + T, salt: e.substring(o, o + n), signature: e.substring(u, u + T) };
      }
      const C = h.z.object({ version: h.z.literal(1), type: S, length: h.z.number(), derivation: w, cipher: g });
      function R({ bytes: e, markerSchema: t, values: r }) {
        const { version: s, cipher: a, mode: n, ivLength: i } = t.index,
          o = C.safeParse({
            version: Number(r[s]),
            type: "flexible",
            length: e,
            derivation: { algorithm: "noderivation" },
            cipher: { algorithm: r[a], mode: r[n], ivLength: Number(r[i]) }
          });
        if (!o.success) throw new Error(o.error.message);
        return o.data;
      }
      function I() {
        return (e) => {
          const t = p({ transportableData: e, makeMarker: R, schema: b.NODERIVATION_MARKER_SCHEMA }),
            r = (function ({ transportableData: e, marker: t }) {
              const { length: r, cipher: s } = t,
                { ivLength: a } = s,
                n = r + 0,
                i = n + a;
              return { iv: e.substring(n, n + a), length: a + T, signature: e.substring(i, i + T) };
            })({ transportableData: e, marker: t });
          return (function ({ encipheredContents: e, marker: t, metadata: r }) {
            const { derivation: s, cipher: a, type: n, version: i } = t,
              { iv: o, signature: u } = r;
            return {
              type: n,
              version: i,
              derivationConfig: s,
              cipherConfig: a,
              signature: (0, c.u)(u),
              iv: (0, c.u)(o),
              encipheredContents: (0, c.u)(e)
            };
          })({ encipheredContents: o({ transportableData: e, marker: t, metadata: r }), marker: t, metadata: r });
        };
      }
      const x = h.z.object({ version: h.z.literal(1), type: S, length: h.z.number(), derivation: f, cipher: m });
      function P({ bytes: e, markerSchema: t, values: r }) {
        const { version: s, derivation: a, saltLength: n, iterations: i, hashAlgorithm: o, cipher: c, mode: u, ivLength: d } = t.index,
          l = x.safeParse({
            version: Number(r[s]),
            type: "flexible",
            length: e,
            derivation: { algorithm: r[a], saltLength: Number(r[n]), iterations: Number(r[i]), hashAlgorithm: r[o] },
            cipher: { algorithm: r[c], mode: r[u], ivLength: Number(r[d]) }
          });
        if (!l.success) throw new Error(l.error.message);
        return l.data;
      }
      function D({ transportableData: e, index: t }) {
        const r = t + 1,
          s = d({ str: e, substr: l.F, occurrence: r }),
          a = d({ str: e, substr: l.F, occurrence: r + 1 });
        if (-1 === s || -1 === a) throw new Error("Marker info indices not found");
        return e.substring(s + 1, a);
      }
      const U = 0,
        F = 1;
      function O(e) {
        switch (e) {
          case "argon2d":
            return (e) => {
              const t = p({ transportableData: e, makeMarker: _, schema: b.ARGON2D_MARKER_SCHEMA }),
                r = A({ transportableData: e, marker: t });
              return u({ encipheredContents: o({ transportableData: e, marker: t, metadata: r }), marker: t, metadata: r });
            };
          case "pbkdf2":
            return (e) => {
              const t = p({ transportableData: e, makeMarker: P, schema: b.PBKDF2_MARKER_SCHEMA }),
                r = A({ transportableData: e, marker: t });
              return u({ encipheredContents: o({ transportableData: e, marker: t, metadata: r }), marker: t, metadata: r });
            };
          case "noderivation":
            return I();
          default:
            (0, n.U)(e);
        }
      }
      var N = r(6424),
        k = r(58396),
        L = r(6752);
      async function M(e, t, r, n) {
        const o = (function (e) {
            const t = (0, a.v)(e),
              r = D({ transportableData: t, index: U });
            if (Number(r) !== l.g) throw new Error("Marker version not supported");
            const s = D({ transportableData: t, index: F });
            if (!(0, i.b9)(s)) throw new Error("Derivation algorithm not supported");
            return O(s)(t);
          })(n),
          { deriveKeyArgon2d: c, deriveKeyPbkdf2: u } = t,
          { derivationConfig: d, salt: p } = o,
          { algorithm: h } = d,
          m = "pbkdf2" === h || "argon2d" === h;
        if (m && !p) throw new Error("Need salt for derivation");
        const y = m && p ? await (0, L.b)(e, p, u, c, d, r) : e,
          { mode: g } = o.cipherConfig,
          { computeHash: v } = t,
          { encryptionKey: f, signatureKey: w } = "cbchmac64" === g ? await (0, k.U)(y) : await (0, N.Y)(y, v),
          { iv: S, encipheredContents: E } = o,
          _ = (0, s.K)(S, E),
          { signature: b } = o;
        return { signatureKey: w, signature: b, dataToSign: _, encryptionKey: f, iv: S, encipheredContents: E };
      }
      async function V(e, t, r, s) {
        const { verifyHmacSha: a } = t,
          { signatureKey: n, signature: i, dataToSign: o, encryptionKey: c, iv: u, encipheredContents: d } = await M(e, t, r, s);
        if (!(await a(n, i, o))) throw new Error("Signature cannot be verified");
        const { decryptAes256: l } = t;
        return l(c, u, d);
      }
    },
    7449: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => d });
      var s = r(82933),
        a = r(94805),
        n = r(16698),
        i = r(38291);
      const o = { type: "KWC5", derivation: a.oo, cipher: n.BU };
      function c(e) {
        const t = (function ({ transportableData: e, marker: t }) {
          const { cipher: r, type: s } = t,
            { ivLength: a } = r,
            n = i.RB + a + i.en + s.length,
            o = n + i.jK;
          return { iv: e.slice(i.RB, i.RB + a), signature: e.slice(n, n + i.jK), encipheredContents: e.slice(o) };
        })({ transportableData: e, marker: o });
        return {
          iv: t.iv,
          type: i.PD,
          signature: t.signature,
          encipheredContents: t.encipheredContents,
          derivationConfig: a.oo,
          cipherConfig: n.BU
        };
      }
      var u = r(6424);
      async function d(e, t, r) {
        const a = c(r),
          { computeHash: n } = t,
          { encryptionKey: i, signatureKey: o } = await (0, u.Y)(e, n),
          { iv: d, encipheredContents: l } = a,
          p = (0, s.K)(d, l),
          { verifyHmacSha: h } = t,
          { signature: m } = a;
        if (!(await h(o, m, p))) throw new Error("Signature cannot be verified");
        const { decryptAes256: y } = t;
        return y(i, d, l);
      }
    },
    58396: (e, t, r) => {
      "use strict";
      function s(e) {
        const t = new Uint8Array(e),
          r = e.byteLength / 2,
          s = t.slice(0, r),
          a = t.slice(r);
        return Promise.resolve({ encryptionKey: s.buffer, signatureKey: a.buffer });
      }
      r.d(t, { U: () => s });
    },
    6424: (e, t, r) => {
      "use strict";
      r.d(t, { Y: () => a });
      const s = "SHA-512";
      async function a(e, t) {
        const r = await t(e, s),
          a = new Uint8Array(r),
          n = r.byteLength / 2,
          i = a.slice(0, n),
          o = a.slice(n, r.byteLength);
        return { encryptionKey: i.buffer, signatureKey: o.buffer };
      }
    },
    22609: (e, t, r) => {
      "use strict";
      r.d(t, { N: () => a, z: () => s });
      const s = "AES-CBC",
        a = 256;
    },
    74017: (e, t, r) => {
      "use strict";
      r.d(t, { x: () => s });
      const s = "SHA-256";
    },
    83407: (e, t, r) => {
      "use strict";
      r.d(t, { $: () => s, x: () => a });
      const s = "RSA-OAEP",
        a = "RSASSA-PKCS1-v1_5";
    },
    22253: (e, t, r) => {
      "use strict";
      r.d(t, { j: () => s });
      class s {}
    },
    4607: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => s });
      class s {
        constructor(e) {
          (this.headers = new Map()),
            (this.normalizedNames = new Map()),
            "string" == typeof e ? this.initFromString(e) : e && this.initFromObject(e);
        }
        has(e) {
          return this.headers.has(e.toLowerCase());
        }
        get(e) {
          const t = this.headers.get(e.toLowerCase());
          return t?.[0] ?? null;
        }
        keys() {
          return Array.from(this.normalizedNames.values());
        }
        getAll(e) {
          return this.headers.get(e.toLowerCase()) ?? null;
        }
        append(e, t) {
          return this.clone({ name: e, value: t, op: 0 });
        }
        set(e, t) {
          return this.clone({ name: e, value: t, op: 1 });
        }
        delete(e, t) {
          return this.clone({ name: e, value: t, op: 2 });
        }
        deleteMultiple(e) {
          return this.clone({ names: e, op: 3 });
        }
        toObject() {
          return Object.fromEntries(this.headers);
        }
        maybeSetNormalizedName(e, t) {
          this.normalizedNames.has(t) || this.normalizedNames.set(t, e);
        }
        clone(e) {
          const t = new s();
          return t.initFromOther(this), t.applyUpdate(e), t;
        }
        applyUpdate(e) {
          switch (e.op) {
            case 0:
            case 1:
              {
                const t = e.name.toLowerCase();
                let r = e.value;
                if (("string" == typeof r && (r = [r]), 0 === r.length)) return;
                this.maybeSetNormalizedName(e.name, t);
                const s = (0 === e.op ? this.headers.get(t) : void 0) ?? [];
                s.push(...r), this.headers.set(t, s);
              }
              break;
            case 2:
              {
                const t = e.name.toLowerCase(),
                  r = e.value;
                if (r) {
                  let e = this.headers.get(t);
                  if (!e) return;
                  const s = Array.isArray(r) ? r : [r];
                  (e = e.filter((e) => !s.includes(e))),
                    0 === e.length ? (this.headers.delete(t), this.normalizedNames.delete(t)) : this.headers.set(t, e);
                } else this.headers.delete(t), this.normalizedNames.delete(t);
              }
              break;
            case 3:
              e.names.forEach((e) => {
                const t = e.toLowerCase();
                this.headers.delete(t), this.normalizedNames.delete(t);
              });
          }
        }
        initFromOther(e) {
          Array.from(e.headers.keys()).forEach((t) => {
            this.headers.set(t, [...e.headers.get(t)]), this.normalizedNames.set(t, e.normalizedNames.get(t));
          });
        }
        initFromObject(e) {
          Object.keys(e).forEach((t) => {
            let r = e[t];
            const s = t.toLowerCase();
            "string" == typeof r && (r = [r]), r.length > 0 && (this.headers.set(s, r), this.maybeSetNormalizedName(t, s));
          });
        }
        initFromString(e) {
          e.split("\n").forEach((e) => {
            const t = e.indexOf(":");
            if (t > 0) {
              const r = e.slice(0, t),
                s = r.toLowerCase(),
                a = e.slice(t + 1).trim();
              this.maybeSetNormalizedName(r, s), this.headers.has(s) ? this.headers.get(s).push(a) : this.headers.set(s, [a]);
            }
          });
        }
      }
    },
    69912: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => a });
      class s {
        encodeKey(e) {
          return this.standardEncoding(e);
        }
        encodeValue(e) {
          return this.standardEncoding(e);
        }
        decodeKey(e) {
          return decodeURIComponent(e);
        }
        decodeValue(e) {
          return decodeURIComponent(e);
        }
        standardEncoding(e) {
          return encodeURIComponent(e).replace(s.STANDARD_ENCODING_REGEX, (e, t) => s.STANDARD_ENCODING_REPLACEMENTS[t] ?? e);
        }
      }
      (s.STANDARD_ENCODING_REGEX = /%(\d[a-f0-9])/gi),
        (s.STANDARD_ENCODING_REPLACEMENTS = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" });
      class a {
        constructor(e = {}, t = {}) {
          (this.map = new Map()),
            (this.encoder = t.encoder ?? new s()),
            "string" == typeof e ? this.initFromString(e) : this.initFromObject(e);
        }
        has(e) {
          return this.map.has(e);
        }
        get(e) {
          const t = this.map.get(e);
          return t?.[0] ?? null;
        }
        getAll(e) {
          return this.map.get(e) ?? null;
        }
        keys() {
          return Array.from(this.map.keys());
        }
        append(e, t) {
          return this.clone({ param: e, value: t, op: 0 });
        }
        appendAll(e) {
          const t = [];
          return (
            Object.keys(e).forEach((r) => {
              const s = e[r];
              Array.isArray(s)
                ? s.forEach((e) => {
                    t.push({ param: r, value: e, op: 0 });
                  })
                : t.push({ param: r, value: s, op: 0 });
            }),
            this.clone(t)
          );
        }
        set(e, t) {
          return this.clone({ param: e, value: t, op: 1 });
        }
        delete(e, t) {
          return this.clone({ param: e, value: t, op: 2 });
        }
        toString() {
          return this.keys()
            .map((e) => {
              const t = this.encoder.encodeKey(e);
              return this.map
                .get(e)
                .map((e) => t + "=" + this.encoder.encodeValue(e))
                .join("&");
            })
            .filter((e) => "" !== e)
            .join("&");
        }
        clone(e) {
          const t = new a({}, { encoder: this.encoder });
          return t.initFromOther(this), t.applyUpdates(Array.isArray(e) ? e : [e]), t;
        }
        initFromOther(e) {
          e.keys().forEach((t) => this.map.set(t, [...e.map.get(t)]));
        }
        initFromObject(e) {
          Object.keys(e).forEach((t) => {
            const r = e[t],
              s = a.isValueArray(r) ? r.map(a.valueToString) : [a.valueToString(r)];
            this.map.set(t, s);
          });
        }
        initFromString(e) {
          const { encoder: t } = this;
          if (e.length > 0) {
            e.replace(/^\?/, "")
              .split("&")
              .forEach((e) => {
                const r = e.indexOf("="),
                  [s, a] = -1 === r ? [t.decodeKey(e), ""] : [t.decodeKey(e.slice(0, r)), t.decodeValue(e.slice(r + 1))],
                  n = this.map.get(s) ?? [];
                n.push(a), this.map.set(s, n);
              });
          }
        }
        applyUpdates(e) {
          e.forEach((e) => {
            switch (e.op) {
              case 0:
              case 1: {
                const t = (0 === e.op ? this.map.get(e.param) : void 0) ?? [];
                t.push(a.valueToString(e.value)), this.map.set(e.param, t);
                break;
              }
              case 2:
                if (void 0 === e.value) {
                  this.map.delete(e.param);
                  break;
                }
                {
                  const t = this.map.get(e.param) ?? [],
                    r = t.indexOf(a.valueToString(e.value));
                  -1 !== r && t.splice(r, 1), t.length > 0 ? this.map.set(e.param, t) : this.map.delete(e.param);
                }
            }
          });
        }
        static valueToString(e) {
          return `${e}`;
        }
        static isValueArray(e) {
          return Array.isArray(e);
        }
      }
    },
    4043: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => n });
      var s = r(4607),
        a = r(69912);
      class n {
        constructor(e, t, r, i) {
          (this.body = null),
            (this.headers = new s.W()),
            (this.withCredentials = !1),
            (this.timeout = void 0),
            (this.responseType = "json"),
            (this.params = new a.L({})),
            (this.url = t),
            (this.method = e),
            n.mightHaveBody(this.method) && (this.body = r ?? null),
            i &&
              ((this.withCredentials = Boolean(i.withCredentials)),
              i.responseType && (this.responseType = i.responseType),
              i.headers && (this.headers = this.getHeadersFromOptions(i.headers)),
              i.params && (this.params = this.getParamsFromOptions(i.params)),
              i.timeout && i.timeout > 0 && (this.timeout = i.timeout),
              i.mode && (this.mode = i.mode)),
            (this.urlWithParams = this.initUrlWithParams());
        }
        serializeBody() {
          return null === this.body
            ? null
            : n.isArrayBuffer(this.body) || "string" == typeof this.body
            ? this.body
            : this.body instanceof a.L
            ? this.body.toString()
            : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body)
            ? JSON.stringify(this.body)
            : this.body.toString();
        }
        detectContentTypeHeader() {
          return null === this.body || n.isArrayBuffer(this.body)
            ? null
            : "string" == typeof this.body
            ? "text/plain"
            : this.body instanceof a.L
            ? "application/x-www-form-urlencoded;charset=UTF-8"
            : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body
            ? "application/json"
            : null;
        }
        clone(e = {}) {
          const t = e.method ?? this.method,
            r = e.url ?? this.url,
            s = e.responseType ?? this.responseType,
            a = void 0 !== e.body ? e.body : this.body,
            i = void 0 !== e.withCredentials ? e.withCredentials : this.withCredentials,
            o = void 0 !== e.timeout ? e.timeout : this.timeout,
            c = e.mode ?? this.mode;
          let u = e.headers ? this.getHeadersFromOptions(e.headers) : this.headers,
            d = e.params ? this.getParamsFromOptions(e.params) : this.params;
          const l = e.setHeaders;
          l && (u = Object.keys(l).reduce((e, t) => e.set(t, l[t]), u));
          const p = e.setParams;
          return (
            p && (d = Object.keys(p).reduce((e, t) => e.set(t, p[t]), d)),
            new n(t, r, a, { params: d, headers: u, responseType: s, withCredentials: i, timeout: o, mode: c })
          );
        }
        getHeadersFromOptions(e) {
          return e instanceof s.W ? e : new s.W(e);
        }
        getParamsFromOptions(e) {
          return e instanceof a.L ? e : new a.L(e);
        }
        initUrlWithParams() {
          const e = this.params.toString();
          if (0 === e.length) return this.url;
          const t = this.url.indexOf("?"),
            r = -1 === t ? "?" : t < this.url.length - 1 ? "&" : "";
          return this.url + r + e;
        }
        static mightHaveBody(e) {
          switch (e) {
            case "DELETE":
            case "GET":
            case "HEAD":
            case "OPTIONS":
              return !1;
            default:
              return !0;
          }
        }
        static isArrayBuffer(e) {
          return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer;
        }
      }
    },
    12964: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => d });
      var s = r(87631),
        a = r(89685),
        n = r(54066),
        i = r(4607),
        o = r(25994);
      async function c(e) {
        const t = e.getReader();
        let r = new Uint8Array(0),
          s = await t.read();
        for (; !s.done; ) {
          const e = new Uint8Array(r.byteLength + s.value.byteLength);
          e.set(r, 0), e.set(s.value, r.byteLength), (r = e), (s = await t.read());
        }
        return r;
      }
      class u {
        constructor(e) {
          (this.bytesRead = 0), (this.data = e);
        }
        pull(e) {
          const { bytesRead: t, data: r } = this;
          if (t >= r.byteLength) return void e.close();
          const s = Math.min(r.byteLength - t, e.desiredSize ?? 1 / 0);
          if (s > 0) {
            const a = new Uint8Array(r, t, s);
            e.enqueue(a), (this.bytesRead += s);
          }
          t >= r.byteLength && e.close();
        }
      }
      class d {
        constructor(e = {}, t = o.W.Ok, r = "OK") {
          (this.headers = e.headers instanceof i.W ? e.headers : new i.W(e.headers)),
            (this.status = void 0 !== e.status ? e.status : t),
            (this.statusText = e.statusText ?? r),
            (this.url = e.url ?? null),
            (this.ok = this.status >= 200 && this.status < 300),
            (this.body = void 0 !== e.body ? e.body : null);
        }
        clone(e = {}) {
          return new d({
            body:
              void 0 !== e.body
                ? e.body
                : null === this.body
                ? null
                : this.body instanceof s.ReadableStream
                ? this.body.tee()[0]
                : this.body,
            headers: e.headers ?? this.headers,
            status: void 0 !== e.status ? e.status : this.status,
            statusText: e.statusText ?? this.statusText,
            url: e.url ?? this.url ?? void 0
          });
        }
        async arrayBuffer() {
          if (null === this.body) throw new Error("Empty response body");
          if ("object" == typeof this.body && "ReadableStream" === this.body.constructor.name) {
            return (await c(this.body)).buffer;
          }
          if (!(this.body instanceof ArrayBuffer)) throw new Error("Unexpected body type, not an ArrayBuffer");
          return this.body;
        }
        async text() {
          if (null === this.body) throw new Error("Empty response body");
          if ("object" == typeof this.body && "ReadableStream" === this.body.constructor.name) {
            const e = await c(this.body);
            return (0, a.v)(e.buffer);
          }
          if ("string" != typeof this.body) throw new Error("Unexpected body type, not a string");
          return this.body;
        }
        async json(e) {
          if (null === this.body) throw new Error("Empty response body");
          if ("object" == typeof this.body && "ReadableStream" === this.body.constructor.name) {
            const t = await c(this.body),
              r = (0, a.v)(t.buffer);
            try {
              const t = JSON.parse(r);
              return e.decode(t);
            } catch (e) {
              throw new Error("Failed to parse response body JSON");
            }
          }
          if (this.body instanceof ArrayBuffer || "string" == typeof this.body) throw new Error("Unexpected body type");
          return e.decode(this.body);
        }
        bodyStream() {
          if (null === this.body) throw new Error("Empty response body");
          if ("object" == typeof this.body && "ReadableStream" === this.body.constructor.name) return this.body;
          if ("string" == typeof this.body) return new s.ReadableStream(new u((0, n.u)(this.body)));
          if (this.body instanceof ArrayBuffer) return new s.ReadableStream(new u(this.body));
          const e = JSON.stringify(this.body);
          return new s.ReadableStream(new u((0, n.u)(e)));
        }
      }
    },
    25994: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { W: () => s }),
        (function (e) {
          (e[(e.Continue = 100)] = "Continue"),
            (e[(e.SwitchingProtocols = 101)] = "SwitchingProtocols"),
            (e[(e.Processing = 102)] = "Processing"),
            (e[(e.EarlyHints = 103)] = "EarlyHints"),
            (e[(e.Ok = 200)] = "Ok"),
            (e[(e.Created = 201)] = "Created"),
            (e[(e.Accepted = 202)] = "Accepted"),
            (e[(e.NonAuthoritativeInformation = 203)] = "NonAuthoritativeInformation"),
            (e[(e.NoContent = 204)] = "NoContent"),
            (e[(e.ResetContent = 205)] = "ResetContent"),
            (e[(e.PartialContent = 206)] = "PartialContent"),
            (e[(e.MultiStatus = 207)] = "MultiStatus"),
            (e[(e.AlreadyReported = 208)] = "AlreadyReported"),
            (e[(e.ImUsed = 226)] = "ImUsed"),
            (e[(e.MultipleChoices = 300)] = "MultipleChoices"),
            (e[(e.MovedPermanently = 301)] = "MovedPermanently"),
            (e[(e.Found = 302)] = "Found"),
            (e[(e.SeeOther = 303)] = "SeeOther"),
            (e[(e.NotModified = 304)] = "NotModified"),
            (e[(e.UseProxy = 305)] = "UseProxy"),
            (e[(e.Unused = 306)] = "Unused"),
            (e[(e.TemporaryRedirect = 307)] = "TemporaryRedirect"),
            (e[(e.PermanentRedirect = 308)] = "PermanentRedirect"),
            (e[(e.BadRequest = 400)] = "BadRequest"),
            (e[(e.Unauthorized = 401)] = "Unauthorized"),
            (e[(e.PaymentRequired = 402)] = "PaymentRequired"),
            (e[(e.Forbidden = 403)] = "Forbidden"),
            (e[(e.NotFound = 404)] = "NotFound"),
            (e[(e.MethodNotAllowed = 405)] = "MethodNotAllowed"),
            (e[(e.NotAcceptable = 406)] = "NotAcceptable"),
            (e[(e.ProxyAuthenticationRequired = 407)] = "ProxyAuthenticationRequired"),
            (e[(e.RequestTimeout = 408)] = "RequestTimeout"),
            (e[(e.Conflict = 409)] = "Conflict"),
            (e[(e.Gone = 410)] = "Gone"),
            (e[(e.LengthRequired = 411)] = "LengthRequired"),
            (e[(e.PreconditionFailed = 412)] = "PreconditionFailed"),
            (e[(e.PayloadTooLarge = 413)] = "PayloadTooLarge"),
            (e[(e.UriTooLong = 414)] = "UriTooLong"),
            (e[(e.UnsupportedMediaType = 415)] = "UnsupportedMediaType"),
            (e[(e.RangeNotSatisfiable = 416)] = "RangeNotSatisfiable"),
            (e[(e.ExpectationFailed = 417)] = "ExpectationFailed"),
            (e[(e.ImATeapot = 418)] = "ImATeapot"),
            (e[(e.MisdirectedRequest = 421)] = "MisdirectedRequest"),
            (e[(e.UnprocessableEntity = 422)] = "UnprocessableEntity"),
            (e[(e.Locked = 423)] = "Locked"),
            (e[(e.FailedDependency = 424)] = "FailedDependency"),
            (e[(e.TooEarly = 425)] = "TooEarly"),
            (e[(e.UpgradeRequired = 426)] = "UpgradeRequired"),
            (e[(e.PreconditionRequired = 428)] = "PreconditionRequired"),
            (e[(e.TooManyRequests = 429)] = "TooManyRequests"),
            (e[(e.RequestHeaderFieldsTooLarge = 431)] = "RequestHeaderFieldsTooLarge"),
            (e[(e.UnavailableForLegalReasons = 451)] = "UnavailableForLegalReasons"),
            (e[(e.InternalServerError = 500)] = "InternalServerError"),
            (e[(e.NotImplemented = 501)] = "NotImplemented"),
            (e[(e.BadGateway = 502)] = "BadGateway"),
            (e[(e.ServiceUnavailable = 503)] = "ServiceUnavailable"),
            (e[(e.GatewayTimeout = 504)] = "GatewayTimeout"),
            (e[(e.HttpVersionNotSupported = 505)] = "HttpVersionNotSupported"),
            (e[(e.VariantAlsoNegotiates = 506)] = "VariantAlsoNegotiates"),
            (e[(e.InsufficientStorage = 507)] = "InsufficientStorage"),
            (e[(e.LoopDetected = 508)] = "LoopDetected"),
            (e[(e.NotExtended = 510)] = "NotExtended"),
            (e[(e.NetworkAuthenticationRequired = 511)] = "NetworkAuthenticationRequired");
        })(s || (s = {}));
    },
    73155: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => a, a: () => n });
      var s = r(96168);
      class a extends (0, s.Hu)("BadStatus", "The HTTP response has a non-successful status code (not 2XX)") {
        constructor(e) {
          super(), (this.response = e);
        }
      }
      class n extends (0, s.Hu)("FetchFailedError", "Something happened while communicating to the server") {}
    },
    96168: (e, t, r) => {
      "use strict";
      r.d(t, { As: () => a, BU: () => n, Hu: () => s });
      const s = (e, t) =>
        class extends Error {
          constructor() {
            super(t), (this.tag = e);
          }
        };
      function a(e, t) {
        return t.includes(e.tag);
      }
      const n = (e) => e.tag;
    },
    20195: (e, t, r) => {
      "use strict";
      function s(e) {
        if (e instanceof Error) throw e;
        if ("string" == typeof e) throw new Error(e);
        throw new Error(e.tag);
      }
      r.d(t, { j: () => s });
    },
    61475: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          FunctionalError: () => s.Hu,
          assertUnreachable: () => n.U,
          concatMapFailure: () => c.Tc,
          concatMapSuccess: () => c.Gx,
          concatMatchResult: () => c.RW,
          createMatchable: () => i.H6,
          failure: () => o.Rn,
          getBrander: () => d.zq,
          getFailure: () => o.Yv,
          getSuccess: () => o.db,
          hasProperty: () => d.l$,
          isFailure: () => o.hx,
          isFunctionalErrorOfType: () => s.As,
          isMatchable: () => i.cw,
          isResult: () => o.AZ,
          isSuccess: () => o.d6,
          mapFailure: () => o.SN,
          mapFailureObservable: () => c.DZ,
          mapResultObservable: () => c.vg,
          mapSuccess: () => o.ty,
          mapSuccessObservable: () => c.Qn,
          mapSuccessResultObservable: () => c.lk,
          match: () => i.EQ,
          matchMap: () => u.G,
          matchResult: () => o.f2,
          matchResultObservable: () => c.nb,
          panic: () => a.j,
          safeCast: () => d.Ay,
          success: () => o.Vp,
          switchMapFailure: () => c.pr,
          switchMapSuccess: () => c.CP,
          switchMatchResult: () => c.bM,
          toFunctionalErrorCode: () => s.BU
        });
      var s = r(96168),
        a = r(20195),
        n = r(95087),
        i = r(18533),
        o = r(87279),
        c = r(48844),
        u = r(25535),
        d = r(28489);
    },
    95087: (e, t, r) => {
      "use strict";
      function s(e, t) {
        throw new Error(t ?? `Unreachable code detected (${e})`);
      }
      r.d(t, { U: () => s });
    },
    25535: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => s });
      const s = (e, t) => t[e]();
    },
    18533: (e, t, r) => {
      "use strict";
      r.d(t, { EQ: () => a, H6: () => s, cw: () => n });
      const s = (e, t) => ({ tag: e, ...t }),
        a = (e, t) => {
          const r = e.tag,
            s = r in t ? t[r] : null;
          if (!s) throw new Error("Unmatchable case");
          return s(e);
        },
        n = (e, ...t) => {
          if ("object" != typeof e || !e) return !1;
          return "tag" in e && t.includes(e.tag);
        };
    },
    48844: (e, t, r) => {
      "use strict";
      r.d(t, {
        CP: () => g,
        DZ: () => d,
        Gx: () => h,
        Qn: () => u,
        RW: () => y,
        Tc: () => m,
        bM: () => f,
        lk: () => p,
        nb: () => c,
        pr: () => v,
        vg: () => l
      });
      var s = r(87065),
        a = r(34987),
        n = r(43978),
        i = r(87279),
        o = r(18533);
      function c(e) {
        return (t) =>
          t.pipe((0, s.U)((t) => (0, o.EQ)(t, { success: ({ data: t }) => e.success(t), failure: ({ error: t }) => e.failure(t) })));
      }
      function u(e) {
        return (t) => t.pipe((0, s.U)((t) => ((0, i.hx)(t) ? t : (0, i.Vp)(e(t.data)))));
      }
      function d(e) {
        return (t) => t.pipe((0, s.U)((t) => ((0, i.d6)(t) ? t : (0, i.Rn)(e(t.error)))));
      }
      function l(e, t) {
        return (r) => r.pipe((0, s.U)((r) => ((0, i.hx)(r) ? (t ? t(r.error) : r) : e(r.data))));
      }
      function p(e) {
        return (t) => t.pipe((0, s.U)((t) => ((0, i.hx)(t) ? t : e(t.data))));
      }
      function h(e) {
        return (t) => t.pipe((0, a.b)(async (t) => ((0, i.hx)(t) ? t : (0, i.Vp)(await e(t.data)))));
      }
      function m(e) {
        return (t) => t.pipe((0, a.b)(async (t) => ((0, i.d6)(t) ? t : (0, i.Rn)(await e(t.error)))));
      }
      function y(e) {
        return (t) => t.pipe((0, a.b)((t) => (0, i.f2)(t, e)));
      }
      function g(e) {
        return (t) => t.pipe((0, n.w)(async (t) => ((0, i.hx)(t) ? t : (0, i.Vp)(await e(t.data)))));
      }
      function v(e) {
        return (t) => t.pipe((0, n.w)(async (t) => ((0, i.d6)(t) ? t : (0, i.Rn)(await e(t.error)))));
      }
      function f(e) {
        return (t) => t.pipe((0, n.w)((t) => (0, i.f2)(t, e)));
      }
    },
    87279: (e, t, r) => {
      "use strict";
      r.d(t, {
        Rn: () => o,
        Yv: () => h,
        db: () => p,
        hx: () => d,
        AZ: () => l,
        d6: () => u,
        SN: () => y,
        ty: () => m,
        f2: () => c,
        Vp: () => i
      });
      var s = r(18533);
      const a = "success",
        n = "failure",
        i = (e) => (0, s.H6)("success", { data: e }),
        o = (e) => (0, s.H6)("failure", { error: e }),
        c = (e, t) => (0, s.EQ)(e, { success: ({ data: e }) => t.success(e), failure: ({ error: e }) => t.failure(e) }),
        u = (e) => e.tag === a,
        d = (e) => e.tag === n,
        l = (e) => (0, s.cw)(e, a, n),
        p = (e) => e.data,
        h = (e) => e.error,
        m = (e, t) => (d(e) ? e : i(t(e.data))),
        y = (e, t) => (u(e) ? e : o(t(e.error)));
    },
    28489: (e, t, r) => {
      "use strict";
      r.d(t, { Ay: () => a, l$: () => n, zq: () => s });
      const s = (e) => (t) => Object.assign(t, { brand: e }),
        a = (e) => e;
      function n(e, t) {
        return t in e;
      }
    },
    54404: (e, t, r) => {
      "use strict";
      r.d(t, { h: () => n, m: () => i });
      var s = r(64839),
        a = r(24982);
      const n = {
        accountInfo: {
          method: "POST",
          path: "account/AccountInfo",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        createUser: {
          method: "POST",
          path: "account/CreateUser",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        createUserWithSso: {
          method: "POST",
          path: "account/CreateUserWithSSO",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        deleteOrResetAccount: {
          method: "POST",
          path: "account/DeleteOrResetAccount",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        forgetUserPii: {
          method: "POST",
          path: "account/ForgetUserPII",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.BACK_OFFICE,
          version: a.W.V1
        },
        getActivity: {
          method: "POST",
          path: "account/GetActivity",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.BACK_OFFICE,
          version: a.W.V1
        },
        getUserTeamDetailsByLogin: {
          method: "POST",
          path: "account/GetUserTeamDetailsByLogin",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        requestAccountCreation: {
          method: "POST",
          path: "account/RequestAccountCreation",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        updateContactInfo: {
          method: "POST",
          path: "account/UpdateContactInfo",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        accountInfo(e) {
          return this.executorFactory.createExecutor(n.accountInfo).executeRequest({ credentials: e });
        }
        createUser(e) {
          return this.executorFactory.createExecutor(n.createUser).executeRequest({ body: e });
        }
        createUserWithSso(e) {
          return this.executorFactory.createExecutor(n.createUserWithSso).executeRequest({ body: e });
        }
        deleteOrResetAccount(e) {
          return this.executorFactory.createExecutor(n.deleteOrResetAccount).executeRequest({ body: e });
        }
        forgetUserPii(e) {
          return this.executorFactory.createExecutor(n.forgetUserPii).executeRequest({ body: e });
        }
        getActivity(e) {
          return this.executorFactory.createExecutor(n.getActivity).executeRequest({ body: e });
        }
        getUserTeamDetailsByLogin(e) {
          return this.executorFactory.createExecutor(n.getUserTeamDetailsByLogin).executeRequest({ body: e });
        }
        requestAccountCreation(e) {
          return this.executorFactory.createExecutor(n.requestAccountCreation).executeRequest({ body: e });
        }
        updateContactInfo(e, t) {
          return this.executorFactory.createExecutor(n.updateContactInfo).executeRequest({ credentials: e, body: t });
        }
      }
    },
    77837: (e, t, r) => {
      "use strict";
      r.d(t, { u: () => i, y: () => n });
      var s = r(64839),
        a = r(24982);
      const n = {
        confirmActivation: {
          method: "POST",
          path: "accountrecovery/ConfirmActivation",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        deactivate: {
          method: "POST",
          path: "accountrecovery/Deactivate",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getEncryptedVaultKey: {
          method: "POST",
          path: "accountrecovery/GetEncryptedVaultKey",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        getStatus: {
          method: "POST",
          path: "accountrecovery/GetStatus",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        requestActivation: {
          method: "POST",
          path: "accountrecovery/RequestActivation",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        confirmActivation(e, t) {
          return this.executorFactory.createExecutor(n.confirmActivation).executeRequest({ credentials: e, body: t });
        }
        deactivate(e, t) {
          return this.executorFactory.createExecutor(n.deactivate).executeRequest({ credentials: e, body: t });
        }
        getEncryptedVaultKey(e) {
          return this.executorFactory.createExecutor(n.getEncryptedVaultKey).executeRequest({ body: e });
        }
        getStatus(e) {
          return this.executorFactory.createExecutor(n.getStatus).executeRequest({ body: e });
        }
        requestActivation(e, t) {
          return this.executorFactory.createExecutor(n.requestActivation).executeRequest({ credentials: e, body: t });
        }
      }
    },
    33027: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => i, k: () => n });
      var s = r(64839),
        a = r(24982);
      const n = {
        completeDeviceRegistrationWithAuthTicket: {
          method: "POST",
          path: "authentication/CompleteDeviceRegistrationWithAuthTicket",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        completeDeviceRegistrationWithToken: {
          method: "POST",
          path: "authentication/CompleteDeviceRegistrationWithToken",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        completeDeviceRegistrationWithTotp: {
          method: "POST",
          path: "authentication/CompleteDeviceRegistrationWithTOTP",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        completeExtraDeviceRegistrationWithToken: {
          method: "POST",
          path: "authentication/CompleteExtraDeviceRegistrationWithToken",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        completeLoginWithAuthTicket: {
          method: "POST",
          path: "authentication/CompleteLoginWithAuthTicket",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        completeLoginWithTotp: {
          method: "POST",
          path: "authentication/CompleteLoginWithTOTP",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        completeRememberMeOpenSession: {
          method: "POST",
          path: "authentication/CompleteRememberMeOpenSession",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.SESSION,
          version: a.W.V1
        },
        completeRememberMeRegistration: {
          method: "POST",
          path: "authentication/CompleteRememberMeRegistration",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        completeTotpActivation: {
          method: "POST",
          path: "authentication/CompleteTOTPActivation",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        completeWebAuthnAuthenticatorRegistration: {
          method: "POST",
          path: "authentication/CompleteWebAuthnAuthenticatorRegistration",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        createSamlSession: {
          method: "POST",
          path: "authentication/CreateSAMLSession",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        createTokenExtAuth: {
          method: "POST",
          path: "authentication/CreateTokenExtAuth",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        deactivateRememberMe: {
          method: "POST",
          path: "authentication/DeactivateRememberMe",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        deactivateTotp: {
          method: "POST",
          path: "authentication/DeactivateTOTP",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        deactivateU2FDevice: {
          method: "POST",
          path: "authentication/DeactivateU2FDevice",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        deactivateWebAuthnAuthenticator: {
          method: "POST",
          path: "authentication/DeactivateWebAuthnAuthenticator",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        destroySamlSession: {
          method: "POST",
          path: "authentication/DestroySAMLSession",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.BACK_OFFICE,
          version: a.W.V1
        },
        get2FaStatus: {
          method: "POST",
          path: "authentication/Get2FAStatus",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        get2FaStatusUnauthenticated: {
          method: "POST",
          path: "authentication/Get2FAStatusUnauthenticated",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        getAuthenticationMethodsForDevice: {
          method: "POST",
          path: "authentication/GetAuthenticationMethodsForDevice",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        getAuthenticationMethodsForLogin: {
          method: "POST",
          path: "authentication/GetAuthenticationMethodsForLogin",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        getAuthenticationMethodsForReset: {
          method: "POST",
          path: "authentication/GetAuthenticationMethodsForReset",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        getAvailableWebAuthnAuthenticators: {
          method: "POST",
          path: "authentication/GetAvailableWebAuthnAuthenticators",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.SESSION,
          version: a.W.V1
        },
        getMasterPasswordCipheringKey: {
          method: "POST",
          path: "authentication/GetMasterPasswordCipheringKey",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.SESSION,
          version: a.W.V1
        },
        getRecoveryPhoneNumber: {
          method: "POST",
          path: "authentication/GetRecoveryPhoneNumber",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getTokensList: {
          method: "GET",
          path: "authentication/GetTokens",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        getTokens: {
          method: "POST",
          path: "authentication/GetTokens",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        getU2FDevices: {
          method: "POST",
          path: "authentication/GetU2FDevices",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getUnauthorizedProfiles: {
          method: "POST",
          path: "authentication/GetUnauthorizedProfiles",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        getUserSsoInfo: {
          method: "POST",
          path: "authentication/GetUserSSOInfo",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.TEAM_DEVICE,
          version: a.W.V1
        },
        getWebAuthnAuthenticators: {
          method: "POST",
          path: "authentication/GetWebAuthnAuthenticators",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        initRememberMasterPassword: {
          method: "POST",
          path: "authentication/InitRememberMasterPassword",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        performDashlaneAuthenticatorVerification: {
          method: "POST",
          path: "authentication/PerformDashlaneAuthenticatorVerification",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        performDuoPushVerification: {
          method: "POST",
          path: "authentication/PerformDuoPushVerification",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        performEmailTokenVerification: {
          method: "POST",
          path: "authentication/PerformEmailTokenVerification",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        performExtraDeviceVerification: {
          method: "POST",
          path: "authentication/PerformExtraDeviceVerification",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        performSsoVerification: {
          method: "POST",
          path: "authentication/PerformSsoVerification",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        performTotpVerification: {
          method: "POST",
          path: "authentication/PerformTotpVerification",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        performU2FVerification: {
          method: "POST",
          path: "authentication/PerformU2FVerification",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        renameWebAuthnAuthenticator: {
          method: "POST",
          path: "authentication/RenameWebAuthnAuthenticator",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        requestDeviceRegistration: {
          method: "POST",
          path: "authentication/RequestDeviceRegistration",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        requestEmailTokenVerification: {
          method: "POST",
          path: "authentication/RequestEmailTokenVerification",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        requestExtraDeviceRegistration: {
          method: "POST",
          path: "authentication/RequestExtraDeviceRegistration",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        requestLogin: {
          method: "POST",
          path: "authentication/RequestLogin",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        requestOtpRecoveryCodesByPhone: {
          method: "POST",
          path: "authentication/RequestOtpRecoveryCodesByPhone",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        requestPushNotificationToken: {
          method: "POST",
          path: "authentication/RequestPushNotificationToken",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        requestTotpActivation: {
          method: "POST",
          path: "authentication/RequestTOTPActivation",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        requestWebauthnOpenSession: {
          method: "POST",
          path: "authentication/RequestWebauthnOpenSession",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.SESSION,
          version: a.W.V1
        },
        requestWebauthnRegistration: {
          method: "POST",
          path: "authentication/RequestWebauthnRegistration",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        resetBlockedToken: {
          method: "POST",
          path: "authentication/ResetBlockedToken",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        updateRecoveryPhoneNumber: {
          method: "POST",
          path: "authentication/UpdateRecoveryPhoneNumber",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        completeDeviceRegistrationWithAuthTicket(e) {
          return this.executorFactory.createExecutor(n.completeDeviceRegistrationWithAuthTicket).executeRequest({ body: e });
        }
        completeDeviceRegistrationWithToken(e) {
          return this.executorFactory.createExecutor(n.completeDeviceRegistrationWithToken).executeRequest({ body: e });
        }
        completeDeviceRegistrationWithTotp(e) {
          return this.executorFactory.createExecutor(n.completeDeviceRegistrationWithTotp).executeRequest({ body: e });
        }
        completeExtraDeviceRegistrationWithToken(e) {
          return this.executorFactory.createExecutor(n.completeExtraDeviceRegistrationWithToken).executeRequest({ body: e });
        }
        completeLoginWithAuthTicket(e) {
          return this.executorFactory.createExecutor(n.completeLoginWithAuthTicket).executeRequest({ body: e });
        }
        completeLoginWithTotp(e) {
          return this.executorFactory.createExecutor(n.completeLoginWithTotp).executeRequest({ body: e });
        }
        completeRememberMeOpenSession(e, t) {
          return this.executorFactory.createExecutor(n.completeRememberMeOpenSession).executeRequest({ credentials: e, body: t });
        }
        completeRememberMeRegistration(e, t) {
          return this.executorFactory.createExecutor(n.completeRememberMeRegistration).executeRequest({ credentials: e, body: t });
        }
        completeTotpActivation(e, t) {
          return this.executorFactory.createExecutor(n.completeTotpActivation).executeRequest({ credentials: e, body: t });
        }
        completeWebAuthnAuthenticatorRegistration(e, t) {
          return this.executorFactory
            .createExecutor(n.completeWebAuthnAuthenticatorRegistration)
            .executeRequest({ credentials: e, body: t });
        }
        createSamlSession(e) {
          return this.executorFactory.createExecutor(n.createSamlSession).executeRequest({ body: e });
        }
        createTokenExtAuth(e) {
          return this.executorFactory.createExecutor(n.createTokenExtAuth).executeRequest({ credentials: e });
        }
        deactivateRememberMe(e, t) {
          return this.executorFactory.createExecutor(n.deactivateRememberMe).executeRequest({ credentials: e, body: t });
        }
        deactivateTotp(e, t) {
          return this.executorFactory.createExecutor(n.deactivateTotp).executeRequest({ credentials: e, body: t });
        }
        deactivateU2FDevice(e, t) {
          return this.executorFactory.createExecutor(n.deactivateU2FDevice).executeRequest({ credentials: e, body: t });
        }
        deactivateWebAuthnAuthenticator(e, t) {
          return this.executorFactory.createExecutor(n.deactivateWebAuthnAuthenticator).executeRequest({ credentials: e, body: t });
        }
        destroySamlSession() {
          return this.executorFactory.createExecutor(n.destroySamlSession).executeRequest({});
        }
        get2FaStatus(e) {
          return this.executorFactory.createExecutor(n.get2FaStatus).executeRequest({ credentials: e });
        }
        get2FaStatusUnauthenticated(e) {
          return this.executorFactory.createExecutor(n.get2FaStatusUnauthenticated).executeRequest({ body: e });
        }
        getAuthenticationMethodsForDevice(e) {
          return this.executorFactory.createExecutor(n.getAuthenticationMethodsForDevice).executeRequest({ body: e });
        }
        getAuthenticationMethodsForLogin(e) {
          return this.executorFactory.createExecutor(n.getAuthenticationMethodsForLogin).executeRequest({ body: e });
        }
        getAuthenticationMethodsForReset(e) {
          return this.executorFactory.createExecutor(n.getAuthenticationMethodsForReset).executeRequest({ body: e });
        }
        getAvailableWebAuthnAuthenticators(e, t) {
          return this.executorFactory.createExecutor(n.getAvailableWebAuthnAuthenticators).executeRequest({ credentials: e, body: t });
        }
        getMasterPasswordCipheringKey(e) {
          return this.executorFactory.createExecutor(n.getMasterPasswordCipheringKey).executeRequest({ credentials: e });
        }
        getRecoveryPhoneNumber(e) {
          return this.executorFactory.createExecutor(n.getRecoveryPhoneNumber).executeRequest({ credentials: e });
        }
        getTokensList() {
          return this.executorFactory.createExecutor(n.getTokensList).executeRequest({});
        }
        getTokens() {
          return this.executorFactory.createExecutor(n.getTokens).executeRequest({});
        }
        getU2FDevices(e) {
          return this.executorFactory.createExecutor(n.getU2FDevices).executeRequest({ credentials: e });
        }
        getUnauthorizedProfiles(e) {
          return this.executorFactory.createExecutor(n.getUnauthorizedProfiles).executeRequest({ body: e });
        }
        getUserSsoInfo(e, t) {
          return this.executorFactory.createExecutor(n.getUserSsoInfo).executeRequest({ credentials: e, body: t });
        }
        getWebAuthnAuthenticators(e) {
          return this.executorFactory.createExecutor(n.getWebAuthnAuthenticators).executeRequest({ credentials: e });
        }
        initRememberMasterPassword(e, t) {
          return this.executorFactory.createExecutor(n.initRememberMasterPassword).executeRequest({ credentials: e, body: t });
        }
        performDashlaneAuthenticatorVerification(e) {
          return this.executorFactory.createExecutor(n.performDashlaneAuthenticatorVerification).executeRequest({ body: e });
        }
        performDuoPushVerification(e) {
          return this.executorFactory.createExecutor(n.performDuoPushVerification).executeRequest({ body: e });
        }
        performEmailTokenVerification(e) {
          return this.executorFactory.createExecutor(n.performEmailTokenVerification).executeRequest({ body: e });
        }
        performExtraDeviceVerification(e) {
          return this.executorFactory.createExecutor(n.performExtraDeviceVerification).executeRequest({ body: e });
        }
        performSsoVerification(e) {
          return this.executorFactory.createExecutor(n.performSsoVerification).executeRequest({ body: e });
        }
        performTotpVerification(e) {
          return this.executorFactory.createExecutor(n.performTotpVerification).executeRequest({ body: e });
        }
        performU2FVerification(e) {
          return this.executorFactory.createExecutor(n.performU2FVerification).executeRequest({ body: e });
        }
        renameWebAuthnAuthenticator(e, t) {
          return this.executorFactory.createExecutor(n.renameWebAuthnAuthenticator).executeRequest({ credentials: e, body: t });
        }
        requestDeviceRegistration(e) {
          return this.executorFactory.createExecutor(n.requestDeviceRegistration).executeRequest({ body: e });
        }
        requestEmailTokenVerification(e) {
          return this.executorFactory.createExecutor(n.requestEmailTokenVerification).executeRequest({ body: e });
        }
        requestExtraDeviceRegistration(e, t) {
          return this.executorFactory.createExecutor(n.requestExtraDeviceRegistration).executeRequest({ credentials: e, body: t });
        }
        requestLogin(e) {
          return this.executorFactory.createExecutor(n.requestLogin).executeRequest({ body: e });
        }
        requestOtpRecoveryCodesByPhone(e) {
          return this.executorFactory.createExecutor(n.requestOtpRecoveryCodesByPhone).executeRequest({ body: e });
        }
        requestPushNotificationToken(e) {
          return this.executorFactory.createExecutor(n.requestPushNotificationToken).executeRequest({ credentials: e });
        }
        requestTotpActivation(e, t) {
          return this.executorFactory.createExecutor(n.requestTotpActivation).executeRequest({ credentials: e, body: t });
        }
        requestWebauthnOpenSession(e) {
          return this.executorFactory.createExecutor(n.requestWebauthnOpenSession).executeRequest({ credentials: e });
        }
        requestWebauthnRegistration(e) {
          return this.executorFactory.createExecutor(n.requestWebauthnRegistration).executeRequest({ credentials: e });
        }
        resetBlockedToken(e) {
          return this.executorFactory.createExecutor(n.resetBlockedToken).executeRequest({ body: e });
        }
        updateRecoveryPhoneNumber(e, t) {
          return this.executorFactory.createExecutor(n.updateRecoveryPhoneNumber).executeRequest({ credentials: e, body: t });
        }
      }
    },
    9536: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => i, T: () => n });
      var s = r(64839),
        a = r(24982);
      const n = {
        confirmRegistration: {
          method: "POST",
          path: "darkwebmonitoring/ConfirmRegistration",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        deregisterEmail: {
          method: "POST",
          path: "darkwebmonitoring/DeregisterEmail",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        listLeaks: {
          method: "POST",
          path: "darkwebmonitoring/ListLeaks",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        listRegistrations: {
          method: "POST",
          path: "darkwebmonitoring/ListRegistrations",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        registerEmail: {
          method: "POST",
          path: "darkwebmonitoring/RegisterEmail",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        confirmRegistration(e) {
          return this.executorFactory.createExecutor(n.confirmRegistration).executeRequest({ body: e });
        }
        deregisterEmail(e, t) {
          return this.executorFactory.createExecutor(n.deregisterEmail).executeRequest({ credentials: e, body: t });
        }
        listLeaks(e, t) {
          return this.executorFactory.createExecutor(n.listLeaks).executeRequest({ credentials: e, body: t });
        }
        listRegistrations(e) {
          return this.executorFactory.createExecutor(n.listRegistrations).executeRequest({ credentials: e });
        }
        registerEmail(e, t) {
          return this.executorFactory.createExecutor(n.registerEmail).executeRequest({ credentials: e, body: t });
        }
      }
    },
    69865: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => i, Z: () => n });
      var s = r(64839),
        a = r(24982);
      const n = {
        getAndEvaluateForUser: {
          method: "POST",
          path: "features/GetAndEvaluateForUser",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        listAvailableFeatureFlips: {
          method: "POST",
          path: "features/ListAvailableFeatureFlips",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        listAvailableLabs: {
          method: "POST",
          path: "features/ListAvailableLabs",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        getAndEvaluateForUser(e, t) {
          return this.executorFactory.createExecutor(n.getAndEvaluateForUser).executeRequest({ credentials: e, body: t });
        }
        listAvailableFeatureFlips() {
          return this.executorFactory.createExecutor(n.listAvailableFeatureFlips).executeRequest({});
        }
        listAvailableLabs(e) {
          return this.executorFactory.createExecutor(n.listAvailableLabs).executeRequest({ body: e });
        }
      }
    },
    62361: (e, t, r) => {
      "use strict";
      r.d(t, { $: () => i, _: () => n });
      var s = r(64839),
        a = r(24982);
      const n = {
        getFileMeta: {
          method: "POST",
          path: "file/GetFileMeta",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        updatedFile: {
          method: "POST",
          path: "file/UpdatedFile",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        getFileMeta(e, t) {
          return this.executorFactory.createExecutor(n.getFileMeta).executeRequest({ credentials: e, body: t });
        }
        updatedFile(e) {
          return this.executorFactory.createExecutor(n.updatedFile).executeRequest({ body: e });
        }
      }
    },
    4119: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => i, p: () => n });
      var s = r(64839),
        a = r(24982);
      const n = {
        getSharingLink: {
          method: "POST",
          path: "invitation/GetSharingLink",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        invite: {
          method: "POST",
          path: "invitation/Invite",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        getSharingLink(e) {
          return this.executorFactory.createExecutor(n.getSharingLink).executeRequest({ body: e });
        }
        invite(e) {
          return this.executorFactory.createExecutor(n.invite).executeRequest({ body: e });
        }
      }
    },
    59091: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => i, l: () => n });
      var s = r(64839),
        a = r(24982);
      const n = {
        accessibleMobileOffers: {
          method: "POST",
          path: "payments/AccessibleMobileOffers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getAccessibleStoreOffers: {
          method: "POST",
          path: "payments/GetAccessibleStoreOffers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getAccessibleWebOffers: {
          method: "POST",
          path: "payments/GetAccessibleWebOffers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        getCustomerInvoice: {
          method: "POST",
          path: "payments/GetCustomerInvoice",
          requestAcceptHeader: "application/pdf",
          responseType: "arraybuffer",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getDefaultWebOffers: {
          method: "POST",
          path: "payments/GetDefaultWebOffers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        getExpectedTaxInformation: {
          method: "POST",
          path: "payments/GetExpectedTaxInformation",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        getProcessOutKeys: {
          method: "POST",
          path: "payments/GetProcessOutKeys",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.NONE,
          version: a.W.V1
        },
        grantFullRefundAndCancelSubscription: {
          method: "POST",
          path: "payments/GrantFullRefundAndCancelSubscription",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        listInvoices: {
          method: "POST",
          path: "payments/ListInvoices",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        accessibleMobileOffers(e, t) {
          return this.executorFactory.createExecutor(n.accessibleMobileOffers).executeRequest({ credentials: e, body: t });
        }
        getAccessibleStoreOffers(e, t) {
          return this.executorFactory.createExecutor(n.getAccessibleStoreOffers).executeRequest({ credentials: e, body: t });
        }
        getAccessibleWebOffers(e) {
          return this.executorFactory.createExecutor(n.getAccessibleWebOffers).executeRequest({ body: e });
        }
        getCustomerInvoice(e, t) {
          return this.executorFactory.createExecutor(n.getCustomerInvoice).executeRequest({ credentials: e, body: t });
        }
        getDefaultWebOffers(e) {
          return this.executorFactory.createExecutor(n.getDefaultWebOffers).executeRequest({ body: e });
        }
        getExpectedTaxInformation(e) {
          return this.executorFactory.createExecutor(n.getExpectedTaxInformation).executeRequest({ body: e });
        }
        getProcessOutKeys() {
          return this.executorFactory.createExecutor(n.getProcessOutKeys).executeRequest({});
        }
        grantFullRefundAndCancelSubscription(e, t) {
          return this.executorFactory.createExecutor(n.grantFullRefundAndCancelSubscription).executeRequest({ credentials: e, body: t });
        }
        listInvoices(e) {
          return this.executorFactory.createExecutor(n.listInvoices).executeRequest({ credentials: e });
        }
      }
    },
    52839: (e, t, r) => {
      "use strict";
      r.d(t, { D: () => n, J: () => i });
      var s = r(64839),
        a = r(24982);
      const n = {
        getHashes: {
          method: "POST",
          path: "pwleak/GetHashes",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        getLastUpdate: {
          method: "POST",
          path: "pwleak/GetLastUpdate",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        getHashes(e) {
          return this.executorFactory.createExecutor(n.getHashes).executeRequest({ body: e });
        }
        getLastUpdate() {
          return this.executorFactory.createExecutor(n.getLastUpdate).executeRequest({});
        }
      }
    },
    7181: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => i, t: () => n });
      var s = r(64839),
        a = r(24982);
      const n = {
        completeKeyExchange: {
          method: "POST",
          path: "secretTransfer/CompleteKeyExchange",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        completeTransfer: {
          method: "POST",
          path: "secretTransfer/CompleteTransfer",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getKeyExchangeTransferInfo: {
          method: "POST",
          path: "secretTransfer/GetKeyExchangeTransferInfo",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        requestTransfer: {
          method: "POST",
          path: "secretTransfer/RequestTransfer",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        startReceiverKeyExchange: {
          method: "POST",
          path: "secretTransfer/StartReceiverKeyExchange",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        startSenderKeyExchange: {
          method: "POST",
          path: "secretTransfer/StartSenderKeyExchange",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        startTransfer: {
          method: "POST",
          path: "secretTransfer/StartTransfer",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        completeKeyExchange(e) {
          return this.executorFactory.createExecutor(n.completeKeyExchange).executeRequest({ body: e });
        }
        completeTransfer(e, t) {
          return this.executorFactory.createExecutor(n.completeTransfer).executeRequest({ credentials: e, body: t });
        }
        getKeyExchangeTransferInfo(e) {
          return this.executorFactory.createExecutor(n.getKeyExchangeTransferInfo).executeRequest({ credentials: e });
        }
        requestTransfer(e) {
          return this.executorFactory.createExecutor(n.requestTransfer).executeRequest({ body: e });
        }
        startReceiverKeyExchange(e) {
          return this.executorFactory.createExecutor(n.startReceiverKeyExchange).executeRequest({ body: e });
        }
        startSenderKeyExchange(e, t) {
          return this.executorFactory.createExecutor(n.startSenderKeyExchange).executeRequest({ credentials: e, body: t });
        }
        startTransfer(e) {
          return this.executorFactory.createExecutor(n.startTransfer).executeRequest({ body: e });
        }
      }
    },
    55127: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => n, b: () => i });
      var s = r(64839),
        a = r(24982);
      const n = {
        acceptCollection: {
          method: "POST",
          path: "sharing-userdevice/AcceptCollection",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        acceptItemGroup: {
          method: "POST",
          path: "sharing-userdevice/AcceptItemGroup",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        acceptUserGroup: {
          method: "POST",
          path: "sharing-userdevice/AcceptUserGroup",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        addItemGroupsToCollection: {
          method: "POST",
          path: "sharing-userdevice/AddItemGroupsToCollection",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        addItems: {
          method: "POST",
          path: "sharing-userdevice/AddItems",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        createCollection: {
          method: "POST",
          path: "sharing-userdevice/CreateCollection",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        createItemGroup: {
          method: "POST",
          path: "sharing-userdevice/CreateItemGroup",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        createTeamAdminsUserGroup: {
          method: "POST",
          path: "sharing-userdevice/CreateTeamAdminsUserGroup",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        createUserGroup: {
          method: "POST",
          path: "sharing-userdevice/CreateUserGroup",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        createUserGroupsItemGroup: {
          method: "POST",
          path: "sharing-userdevice/CreateUserGroupsItemGroup",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        deleteCollection: {
          method: "POST",
          path: "sharing-userdevice/DeleteCollection",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        deleteItemGroup: {
          method: "POST",
          path: "sharing-userdevice/DeleteItemGroup",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        deleteUserGroup: {
          method: "POST",
          path: "sharing-userdevice/DeleteUserGroup",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        postSharingUserdevice: {
          method: "POST",
          path: "sharing-userdevice/Get",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getTeamLogins: {
          method: "POST",
          path: "sharing-userdevice/GetTeamLogins",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getUsersPublicKey: {
          method: "POST",
          path: "sharing-userdevice/GetUsersPublicKey",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        inviteCollectionMembers: {
          method: "POST",
          path: "sharing-userdevice/InviteCollectionMembers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        inviteItemGroupMembers: {
          method: "POST",
          path: "sharing-userdevice/InviteItemGroupMembers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        inviteUserGroupUsers: {
          method: "POST",
          path: "sharing-userdevice/InviteUserGroupUsers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        refuseCollection: {
          method: "POST",
          path: "sharing-userdevice/RefuseCollection",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        refuseItemGroup: {
          method: "POST",
          path: "sharing-userdevice/RefuseItemGroup",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        refuseUserGroup: {
          method: "POST",
          path: "sharing-userdevice/RefuseUserGroup",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        removeItemGroupsFromCollection: {
          method: "POST",
          path: "sharing-userdevice/RemoveItemGroupsFromCollection",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        removeItems: {
          method: "POST",
          path: "sharing-userdevice/RemoveItems",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        renameCollection: {
          method: "POST",
          path: "sharing-userdevice/RenameCollection",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        renameUserGroup: {
          method: "POST",
          path: "sharing-userdevice/RenameUserGroup",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        resendItemGroupInvites: {
          method: "POST",
          path: "sharing-userdevice/ResendItemGroupInvites",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        revokeCollectionMembers: {
          method: "POST",
          path: "sharing-userdevice/RevokeCollectionMembers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        revokeItemGroupMembers: {
          method: "POST",
          path: "sharing-userdevice/RevokeItemGroupMembers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        revokeUserGroupUsers: {
          method: "POST",
          path: "sharing-userdevice/RevokeUserGroupUsers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        updateCollectionMembers: {
          method: "POST",
          path: "sharing-userdevice/UpdateCollectionMembers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        updateItem: {
          method: "POST",
          path: "sharing-userdevice/UpdateItem",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        updateItemGroupMembers: {
          method: "POST",
          path: "sharing-userdevice/UpdateItemGroupMembers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        updateUserGroupUsers: {
          method: "POST",
          path: "sharing-userdevice/UpdateUserGroupUsers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        acceptCollection(e, t) {
          return this.executorFactory.createExecutor(n.acceptCollection).executeRequest({ credentials: e, body: t });
        }
        acceptItemGroup(e, t) {
          return this.executorFactory.createExecutor(n.acceptItemGroup).executeRequest({ credentials: e, body: t });
        }
        acceptUserGroup(e, t) {
          return this.executorFactory.createExecutor(n.acceptUserGroup).executeRequest({ credentials: e, body: t });
        }
        addItemGroupsToCollection(e, t) {
          return this.executorFactory.createExecutor(n.addItemGroupsToCollection).executeRequest({ credentials: e, body: t });
        }
        addItems(e, t) {
          return this.executorFactory.createExecutor(n.addItems).executeRequest({ credentials: e, body: t });
        }
        createCollection(e, t) {
          return this.executorFactory.createExecutor(n.createCollection).executeRequest({ credentials: e, body: t });
        }
        createItemGroup(e, t) {
          return this.executorFactory.createExecutor(n.createItemGroup).executeRequest({ credentials: e, body: t });
        }
        createTeamAdminsUserGroup(e, t) {
          return this.executorFactory.createExecutor(n.createTeamAdminsUserGroup).executeRequest({ credentials: e, body: t });
        }
        createUserGroup(e, t) {
          return this.executorFactory.createExecutor(n.createUserGroup).executeRequest({ credentials: e, body: t });
        }
        createUserGroupsItemGroup(e, t) {
          return this.executorFactory.createExecutor(n.createUserGroupsItemGroup).executeRequest({ credentials: e, body: t });
        }
        deleteCollection(e, t) {
          return this.executorFactory.createExecutor(n.deleteCollection).executeRequest({ credentials: e, body: t });
        }
        deleteItemGroup(e, t) {
          return this.executorFactory.createExecutor(n.deleteItemGroup).executeRequest({ credentials: e, body: t });
        }
        deleteUserGroup(e, t) {
          return this.executorFactory.createExecutor(n.deleteUserGroup).executeRequest({ credentials: e, body: t });
        }
        postSharingUserdevice(e, t) {
          return this.executorFactory.createExecutor(n.postSharingUserdevice).executeRequest({ credentials: e, body: t });
        }
        getTeamLogins(e) {
          return this.executorFactory.createExecutor(n.getTeamLogins).executeRequest({ credentials: e });
        }
        getUsersPublicKey(e, t) {
          return this.executorFactory.createExecutor(n.getUsersPublicKey).executeRequest({ credentials: e, body: t });
        }
        inviteCollectionMembers(e, t) {
          return this.executorFactory.createExecutor(n.inviteCollectionMembers).executeRequest({ credentials: e, body: t });
        }
        inviteItemGroupMembers(e, t) {
          return this.executorFactory.createExecutor(n.inviteItemGroupMembers).executeRequest({ credentials: e, body: t });
        }
        inviteUserGroupUsers(e, t) {
          return this.executorFactory.createExecutor(n.inviteUserGroupUsers).executeRequest({ credentials: e, body: t });
        }
        refuseCollection(e, t) {
          return this.executorFactory.createExecutor(n.refuseCollection).executeRequest({ credentials: e, body: t });
        }
        refuseItemGroup(e, t) {
          return this.executorFactory.createExecutor(n.refuseItemGroup).executeRequest({ credentials: e, body: t });
        }
        refuseUserGroup(e, t) {
          return this.executorFactory.createExecutor(n.refuseUserGroup).executeRequest({ credentials: e, body: t });
        }
        removeItemGroupsFromCollection(e, t) {
          return this.executorFactory.createExecutor(n.removeItemGroupsFromCollection).executeRequest({ credentials: e, body: t });
        }
        removeItems(e, t) {
          return this.executorFactory.createExecutor(n.removeItems).executeRequest({ credentials: e, body: t });
        }
        renameCollection(e, t) {
          return this.executorFactory.createExecutor(n.renameCollection).executeRequest({ credentials: e, body: t });
        }
        renameUserGroup(e, t) {
          return this.executorFactory.createExecutor(n.renameUserGroup).executeRequest({ credentials: e, body: t });
        }
        resendItemGroupInvites(e, t) {
          return this.executorFactory.createExecutor(n.resendItemGroupInvites).executeRequest({ credentials: e, body: t });
        }
        revokeCollectionMembers(e, t) {
          return this.executorFactory.createExecutor(n.revokeCollectionMembers).executeRequest({ credentials: e, body: t });
        }
        revokeItemGroupMembers(e, t) {
          return this.executorFactory.createExecutor(n.revokeItemGroupMembers).executeRequest({ credentials: e, body: t });
        }
        revokeUserGroupUsers(e, t) {
          return this.executorFactory.createExecutor(n.revokeUserGroupUsers).executeRequest({ credentials: e, body: t });
        }
        updateCollectionMembers(e, t) {
          return this.executorFactory.createExecutor(n.updateCollectionMembers).executeRequest({ credentials: e, body: t });
        }
        updateItem(e, t) {
          return this.executorFactory.createExecutor(n.updateItem).executeRequest({ credentials: e, body: t });
        }
        updateItemGroupMembers(e, t) {
          return this.executorFactory.createExecutor(n.updateItemGroupMembers).executeRequest({ credentials: e, body: t });
        }
        updateUserGroupUsers(e, t) {
          return this.executorFactory.createExecutor(n.updateUserGroupUsers).executeRequest({ credentials: e, body: t });
        }
      }
    },
    91406: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => n, p: () => i });
      var s = r(64839),
        a = r(24982);
      const n = {
        accessibleTeamOffers: {
          method: "POST",
          path: "teams/AccessibleTeamOffers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        activateSsoForUsers: {
          method: "POST",
          path: "teams/ActivateSsoForUsers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        addGroupManager: {
          method: "POST",
          path: "teams/AddGroupManager",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        addSeats: {
          method: "POST",
          path: "teams/AddSeats",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        addTeamCaptain: {
          method: "POST",
          path: "teams/AddTeamCaptain",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        changeTeamKeyTeamSignUpPage: {
          method: "POST",
          path: "teams/ChangeTeamKeyTeamSignUpPage",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        changeTierMidCycle: {
          method: "POST",
          path: "teams/ChangeTierMidCycle",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        completeDomainsRegistration: {
          method: "POST",
          path: "teams/CompleteDomainsRegistration",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        computePlanPricing: {
          method: "POST",
          path: "teams/ComputePlanPricing",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        createTeamDeviceAccount: {
          method: "POST",
          path: "teams/CreateTeamDeviceAccount",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        createTeamSignUpPage: {
          method: "POST",
          path: "teams/CreateTeamSignUpPage",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        deactivateDomain: {
          method: "POST",
          path: "teams/DeactivateDomain",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        deactivateSsoForUsers: {
          method: "POST",
          path: "teams/DeactivateSsoForUsers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        deactivateTeamDevice: {
          method: "POST",
          path: "teams/DeactivateTeamDevice",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        deleteTeamVat: {
          method: "POST",
          path: "teams/DeleteTeamVAT",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        editSettings: {
          method: "POST",
          path: "teams/EditSettings",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        extendFreeTrial: {
          method: "POST",
          path: "teams/ExtendFreeTrial",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getAllMemberDeviceInformation: {
          method: "POST",
          path: "teams/GetAllMemberDeviceInformation",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getAuditLogQueryResults: {
          method: "POST",
          path: "teams/GetAuditLogQueryResults",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getAuditLogs: {
          method: "POST",
          path: "teams/GetAuditLogs",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getDarkWebInsightsReportDetails: {
          method: "POST",
          path: "teams/GetDarkWebInsightsReportDetails",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getDarkWebInsightsSummary: {
          method: "POST",
          path: "teams/GetDarkWebInsightsSummary",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getExpectedTaxInformation: {
          method: "POST",
          path: "teams/GetExpectedTaxInformation",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getMidCycleTierUpgradePrice: {
          method: "POST",
          path: "teams/GetMidCycleTierUpgradePrice",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getRecoveryCodesAsTeamCaptain: {
          method: "POST",
          path: "teams/GetRecoveryCodesAsTeamCaptain",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getTeamDevice: {
          method: "POST",
          path: "teams/GetTeamDevice",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getTeamDeviceEncryptedConfiguration: {
          method: "POST",
          path: "teams/GetTeamDeviceEncryptedConfiguration",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getTeamLastUpdateTs: {
          method: "POST",
          path: "teams/GetTeamLastUpdateTs",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getTeamMembers: {
          method: "POST",
          path: "teams/GetTeamMembers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getTeamOffers: {
          method: "POST",
          path: "teams/GetTeamOffers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getTeamReceipts: {
          method: "POST",
          path: "teams/GetTeamReceipts",
          requestAcceptHeader: "application/pdf",
          responseType: "arraybuffer",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getTeamSignUpPage: {
          method: "POST",
          path: "teams/GetTeamSignUpPage",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        getTeamSignUpPageForAdmin: {
          method: "POST",
          path: "teams/GetTeamSignUpPageForAdmin",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getTeamVat: {
          method: "POST",
          path: "teams/GetTeamVAT",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getUserPermissions: {
          method: "POST",
          path: "teams/GetUserPermissions",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        invoiceTeamCreate: {
          method: "POST",
          path: "teams/InvoiceTeamCreate",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        invoiceTeamUpgrade: {
          method: "POST",
          path: "teams/InvoiceTeamUpgrade",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        lastAdSyncDate: {
          method: "POST",
          path: "teams/LastADSyncDate",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        listDomains: {
          method: "POST",
          path: "teams/ListDomains",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        listTeamDevices: {
          method: "POST",
          path: "teams/ListTeamDevices",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        proposeMembers: {
          method: "POST",
          path: "teams/ProposeMembers",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        registerFreeTrial: {
          method: "POST",
          path: "teams/RegisterFreeTrial",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        registerFreeTrialOptionalFields: {
          method: "POST",
          path: "teams/RegisterFreeTrialOptionalFields",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        registerTeamDevice: {
          method: "POST",
          path: "teams/RegisterTeamDevice",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        removeGroupManager: {
          method: "POST",
          path: "teams/RemoveGroupManager",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        report: {
          method: "POST",
          path: "teams/Report",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        reportTeamDeviceError: {
          method: "POST",
          path: "teams/ReportTeamDeviceError",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.TEAM_DEVICE,
          version: a.W.V1
        },
        requestDomainRegistration: {
          method: "POST",
          path: "teams/RequestDomainRegistration",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        requestTeamInviteToken: {
          method: "POST",
          path: "teams/RequestTeamInviteToken",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.APP,
          version: a.W.V1
        },
        startAuditLogsQuery: {
          method: "POST",
          path: "teams/StartAuditLogsQuery",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        storeActivityLogs: {
          method: "POST",
          path: "teams/StoreActivityLogs",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        storeAuditLogs: {
          method: "POST",
          path: "teams/StoreAuditLogs",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        teamStatus: {
          method: "POST",
          path: "teams/TeamStatus",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        toggleTeamSignUpPage: {
          method: "POST",
          path: "teams/ToggleTeamSignUpPage",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        updateTeamDeviceEncryptedConfiguration: {
          method: "POST",
          path: "teams/UpdateTeamDeviceEncryptedConfiguration",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        upsertTeamVat: {
          method: "POST",
          path: "teams/UpsertTeamVAT",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        accessibleTeamOffers(e) {
          return this.executorFactory.createExecutor(n.accessibleTeamOffers).executeRequest({ body: e });
        }
        activateSsoForUsers(e, t) {
          return this.executorFactory.createExecutor(n.activateSsoForUsers).executeRequest({ credentials: e, body: t });
        }
        addGroupManager(e, t) {
          return this.executorFactory.createExecutor(n.addGroupManager).executeRequest({ credentials: e, body: t });
        }
        addSeats(e, t) {
          return this.executorFactory.createExecutor(n.addSeats).executeRequest({ credentials: e, body: t });
        }
        addTeamCaptain(e, t) {
          return this.executorFactory.createExecutor(n.addTeamCaptain).executeRequest({ credentials: e, body: t });
        }
        changeTeamKeyTeamSignUpPage(e) {
          return this.executorFactory.createExecutor(n.changeTeamKeyTeamSignUpPage).executeRequest({ credentials: e });
        }
        changeTierMidCycle(e, t) {
          return this.executorFactory.createExecutor(n.changeTierMidCycle).executeRequest({ credentials: e, body: t });
        }
        completeDomainsRegistration(e) {
          return this.executorFactory.createExecutor(n.completeDomainsRegistration).executeRequest({ credentials: e });
        }
        computePlanPricing(e, t) {
          return this.executorFactory.createExecutor(n.computePlanPricing).executeRequest({ credentials: e, body: t });
        }
        createTeamDeviceAccount(e, t) {
          return this.executorFactory.createExecutor(n.createTeamDeviceAccount).executeRequest({ credentials: e, body: t });
        }
        createTeamSignUpPage(e, t) {
          return this.executorFactory.createExecutor(n.createTeamSignUpPage).executeRequest({ credentials: e, body: t });
        }
        deactivateDomain(e, t) {
          return this.executorFactory.createExecutor(n.deactivateDomain).executeRequest({ credentials: e, body: t });
        }
        deactivateSsoForUsers(e, t) {
          return this.executorFactory.createExecutor(n.deactivateSsoForUsers).executeRequest({ credentials: e, body: t });
        }
        deactivateTeamDevice(e, t) {
          return this.executorFactory.createExecutor(n.deactivateTeamDevice).executeRequest({ credentials: e, body: t });
        }
        deleteTeamVat(e) {
          return this.executorFactory.createExecutor(n.deleteTeamVat).executeRequest({ credentials: e });
        }
        editSettings(e, t) {
          return this.executorFactory.createExecutor(n.editSettings).executeRequest({ credentials: e, body: t });
        }
        extendFreeTrial(e) {
          return this.executorFactory.createExecutor(n.extendFreeTrial).executeRequest({ credentials: e });
        }
        getAllMemberDeviceInformation(e) {
          return this.executorFactory.createExecutor(n.getAllMemberDeviceInformation).executeRequest({ credentials: e });
        }
        getAuditLogQueryResults(e, t) {
          return this.executorFactory.createExecutor(n.getAuditLogQueryResults).executeRequest({ credentials: e, body: t });
        }
        getAuditLogs(e, t) {
          return this.executorFactory.createExecutor(n.getAuditLogs).executeRequest({ credentials: e, body: t });
        }
        getDarkWebInsightsReportDetails(e, t) {
          return this.executorFactory.createExecutor(n.getDarkWebInsightsReportDetails).executeRequest({ credentials: e, body: t });
        }
        getDarkWebInsightsSummary(e, t) {
          return this.executorFactory.createExecutor(n.getDarkWebInsightsSummary).executeRequest({ credentials: e, body: t });
        }
        getExpectedTaxInformation(e, t) {
          return this.executorFactory.createExecutor(n.getExpectedTaxInformation).executeRequest({ credentials: e, body: t });
        }
        getMidCycleTierUpgradePrice(e, t) {
          return this.executorFactory.createExecutor(n.getMidCycleTierUpgradePrice).executeRequest({ credentials: e, body: t });
        }
        getRecoveryCodesAsTeamCaptain(e, t) {
          return this.executorFactory.createExecutor(n.getRecoveryCodesAsTeamCaptain).executeRequest({ credentials: e, body: t });
        }
        getTeamDevice(e, t) {
          return this.executorFactory.createExecutor(n.getTeamDevice).executeRequest({ credentials: e, body: t });
        }
        getTeamDeviceEncryptedConfiguration(e, t) {
          return this.executorFactory.createExecutor(n.getTeamDeviceEncryptedConfiguration).executeRequest({ credentials: e, body: t });
        }
        getTeamLastUpdateTs(e, t) {
          return this.executorFactory.createExecutor(n.getTeamLastUpdateTs).executeRequest({ credentials: e, body: t });
        }
        getTeamMembers(e, t) {
          return this.executorFactory.createExecutor(n.getTeamMembers).executeRequest({ credentials: e, body: t });
        }
        getTeamOffers(e, t) {
          return this.executorFactory.createExecutor(n.getTeamOffers).executeRequest({ credentials: e, body: t });
        }
        getTeamReceipts(e, t) {
          return this.executorFactory.createExecutor(n.getTeamReceipts).executeRequest({ credentials: e, body: t });
        }
        getTeamSignUpPage(e) {
          return this.executorFactory.createExecutor(n.getTeamSignUpPage).executeRequest({ body: e });
        }
        getTeamSignUpPageForAdmin(e) {
          return this.executorFactory.createExecutor(n.getTeamSignUpPageForAdmin).executeRequest({ credentials: e });
        }
        getTeamVat(e) {
          return this.executorFactory.createExecutor(n.getTeamVat).executeRequest({ credentials: e });
        }
        getUserPermissions(e) {
          return this.executorFactory.createExecutor(n.getUserPermissions).executeRequest({ credentials: e });
        }
        invoiceTeamCreate(e) {
          return this.executorFactory.createExecutor(n.invoiceTeamCreate).executeRequest({ body: e });
        }
        invoiceTeamUpgrade(e) {
          return this.executorFactory.createExecutor(n.invoiceTeamUpgrade).executeRequest({ body: e });
        }
        lastAdSyncDate(e) {
          return this.executorFactory.createExecutor(n.lastAdSyncDate).executeRequest({ credentials: e });
        }
        listDomains(e) {
          return this.executorFactory.createExecutor(n.listDomains).executeRequest({ credentials: e });
        }
        listTeamDevices(e) {
          return this.executorFactory.createExecutor(n.listTeamDevices).executeRequest({ credentials: e });
        }
        proposeMembers(e, t) {
          return this.executorFactory.createExecutor(n.proposeMembers).executeRequest({ credentials: e, body: t });
        }
        registerFreeTrial(e) {
          return this.executorFactory.createExecutor(n.registerFreeTrial).executeRequest({ body: e });
        }
        registerFreeTrialOptionalFields(e) {
          return this.executorFactory.createExecutor(n.registerFreeTrialOptionalFields).executeRequest({ body: e });
        }
        registerTeamDevice(e, t) {
          return this.executorFactory.createExecutor(n.registerTeamDevice).executeRequest({ credentials: e, body: t });
        }
        removeGroupManager(e, t) {
          return this.executorFactory.createExecutor(n.removeGroupManager).executeRequest({ credentials: e, body: t });
        }
        report(e, t) {
          return this.executorFactory.createExecutor(n.report).executeRequest({ credentials: e, body: t });
        }
        reportTeamDeviceError(e, t) {
          return this.executorFactory.createExecutor(n.reportTeamDeviceError).executeRequest({ credentials: e, body: t });
        }
        requestDomainRegistration(e, t) {
          return this.executorFactory.createExecutor(n.requestDomainRegistration).executeRequest({ credentials: e, body: t });
        }
        requestTeamInviteToken(e) {
          return this.executorFactory.createExecutor(n.requestTeamInviteToken).executeRequest({ body: e });
        }
        startAuditLogsQuery(e, t) {
          return this.executorFactory.createExecutor(n.startAuditLogsQuery).executeRequest({ credentials: e, body: t });
        }
        storeActivityLogs(e, t) {
          return this.executorFactory.createExecutor(n.storeActivityLogs).executeRequest({ credentials: e, body: t });
        }
        storeAuditLogs(e, t) {
          return this.executorFactory.createExecutor(n.storeAuditLogs).executeRequest({ credentials: e, body: t });
        }
        teamStatus(e) {
          return this.executorFactory.createExecutor(n.teamStatus).executeRequest({ credentials: e });
        }
        toggleTeamSignUpPage(e, t) {
          return this.executorFactory.createExecutor(n.toggleTeamSignUpPage).executeRequest({ credentials: e, body: t });
        }
        updateTeamDeviceEncryptedConfiguration(e, t) {
          return this.executorFactory.createExecutor(n.updateTeamDeviceEncryptedConfiguration).executeRequest({ credentials: e, body: t });
        }
        upsertTeamVat(e, t) {
          return this.executorFactory.createExecutor(n.upsertTeamVat).executeRequest({ credentials: e, body: t });
        }
      }
    },
    73873: (e, t, r) => {
      "use strict";
      r.d(t, { i: () => n, q: () => i });
      var s = r(64839),
        a = r(24982);
      const n = {
        getRemoteTimeList: {
          method: "GET",
          path: "time/GetRemoteTime",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.NONE,
          version: a.W.V1
        },
        getRemoteTime: {
          method: "POST",
          path: "time/GetRemoteTime",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.NONE,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        getRemoteTimeList(e) {
          return this.executorFactory.createExecutor(n.getRemoteTimeList).executeRequest({ body: e });
        }
        getRemoteTime(e) {
          return this.executorFactory.createExecutor(n.getRemoteTime).executeRequest({ body: e });
        }
      }
    },
    84626: (e, t, r) => {
      "use strict";
      r.d(t, { K: () => n, V: () => i });
      var s = r(64839),
        a = r(24982);
      const n = {
        create: {
          method: "POST",
          path: "useractivity/Create",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        create(e, t) {
          return this.executorFactory.createExecutor(n.create).executeRequest({ credentials: e, body: t });
        }
      }
    },
    42882: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => i, _: () => n });
      var s = r(64839),
        a = r(24982);
      const n = {
        getConsents: {
          method: "POST",
          path: "userconsents/GetConsents",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        updateConsents: {
          method: "POST",
          path: "userconsents/UpdateConsents",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        getConsents(e, t) {
          return this.executorFactory.createExecutor(n.getConsents).executeRequest({ credentials: e, body: t });
        }
        updateConsents(e, t) {
          return this.executorFactory.createExecutor(n.updateConsents).executeRequest({ credentials: e, body: t });
        }
      }
    },
    32739: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => i, m: () => n });
      var s = r(64839),
        a = r(24982);
      const n = {
        getCredentials: {
          method: "POST",
          path: "vpn/GetCredentials",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        },
        getVpnSubscriptionInfo: {
          method: "POST",
          path: "vpn/GetVPNSubscriptionInfo",
          requestAcceptHeader: "application/json",
          responseType: "json",
          authType: s.d.USER_DEVICE,
          version: a.W.V1
        }
      };
      class i {
        constructor(e) {
          this.executorFactory = e;
        }
        getCredentials(e, t) {
          return this.executorFactory.createExecutor(n.getCredentials).executeRequest({ credentials: e, body: t });
        }
        getVpnSubscriptionInfo(e) {
          return this.executorFactory.createExecutor(n.getVpnSubscriptionInfo).executeRequest({ credentials: e });
        }
      }
    },
    63877: (e, t, r) => {
      "use strict";
      var s, a, n;
      r.d(t, { ET: () => a, qb: () => n, y3: () => s }),
        (function (e) {
          (e.Admin = "admin"), (e.Limited = "limited");
        })(s || (s = {})),
        (function (e) {
          (e.USER = "USER"), (e.TAC = "TAC"), (e.AD = "AD"), (e.SCIM = "SCIM");
        })(a || (a = {})),
        (function (e) {
          (e.Pending = "pending"), (e.Accepted = "accepted"), (e.Refused = "refused"), (e.Revoked = "revoked");
        })(n || (n = {}));
    },
    64839: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { d: () => s }),
        (function (e) {
          (e.NONE = "NONE"),
            (e.APP = "App"),
            (e.USER_DEVICE = "UserDevice"),
            (e.SESSION = "Session"),
            (e.TEAM_DEVICE = "TeamDevice"),
            (e.BACK_OFFICE = "Backoffice"),
            (e.EXTERNAL = "External"),
            (e.CUSTOM = "Custom");
        })(s || (s = {}));
    },
    24982: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { W: () => s }),
        (function (e) {
          e.V1 = "v1";
        })(s || (s = {}));
    },
    63272: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          getBrowserCountry: () => u,
          getBrowserLanguage: () => c,
          getBrowserName: () => i,
          getBrowserVersion: () => o,
          isChrome: () => d,
          isChromiumEdge: () => y,
          isEdge: () => p,
          isFirefox: () => l,
          isInternetExplorer: () => g,
          isOpera: () => m,
          isSafari: () => h
        });
      var s,
        a = r(96471),
        n = r(64785);
      function i() {
        return (0, n.r)().browser.name ?? "";
      }
      function o() {
        return (0, n.r)().browser.version ?? "";
      }
      function c() {
        const e = (0, a.getNavigator)();
        return e?.language ?? "";
      }
      function u() {
        const e = (0, a.getNavigator)(),
          t = e?.language ?? "";
        let r = "";
        return t.length >= 5 && (r = t.substr(3, 2)), r;
      }
      function d() {
        return i() === s.CHROME;
      }
      function l() {
        return i() === s.FIREFOX;
      }
      function p() {
        return i() === s.EDGE;
      }
      function h() {
        return i() === s.SAFARI;
      }
      function m() {
        return i() === s.OPERA;
      }
      function y() {
        const e = o() ?? "";
        return p() && parseInt(e.split(".")[0], 10) >= 76;
      }
      function g() {
        const e = i();
        return "Internet Explorer" === e ?? "IE" === e;
      }
      !(function (e) {
        (e.CHROME = "Chrome"), (e.FIREFOX = "Firefox"), (e.EDGE = "Edge"), (e.SAFARI = "Safari"), (e.OPERA = "Opera");
      })(s || (s = {}));
    },
    10551: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          getDefaultDeviceName: () => o,
          getDeviceType: () => c,
          isDeviceConsole: () => d,
          isDeviceEmbedded: () => m,
          isDeviceMobile: () => u,
          isDeviceSmartTV: () => p,
          isDeviceTablet: () => l,
          isDeviceWearable: () => h
        });
      var s,
        a = r(63272),
        n = r(28509),
        i = r(64785);
      function o() {
        return `${(0, a.getBrowserName)()} - ${(0, n.getOSName)()}`;
      }
      !(function (e) {
        (e.MOBILE = "mobile"),
          (e.CONSOLE = "console"),
          (e.TABLET = "tablet"),
          (e.SMARTTV = "smarttv"),
          (e.WEARABLE = "wearable"),
          (e.EMBEDDED = "embedded");
      })(s || (s = {}));
      const c = () => (0, i.r)().device.type,
        u = () => c() === s.MOBILE,
        d = () => c() === s.CONSOLE,
        l = () => c() === s.TABLET,
        p = () => c() === s.SMARTTV,
        h = () => c() === s.WEARABLE,
        m = () => c() === s.EMBEDDED;
    },
    33493: (e, t, r) => {
      "use strict";
      r.r(t), r.d(t, { isBrowserEnvironment: () => a, isNodeEnvironment: () => i, isWorkerEnvironment: () => n });
      var s = r(73656);
      function a() {
        return "object" == typeof window;
      }
      function n() {
        return "object" == typeof self && "function" == typeof importScripts;
      }
      function i() {
        return "object" == typeof s && !a() && !n();
      }
    },
    96471: (e, t, r) => {
      "use strict";
      r.r(t), r.d(t, { getNavigator: () => a });
      var s = r(33493);
      function a() {
        return (0, s.isBrowserEnvironment)() ? window.navigator : (0, s.isWorkerEnvironment)() ? self.navigator : void 0;
      }
    },
    50038: (e, t, r) => {
      "use strict";
      r.r(t), r.d(t, { getUserAgent: () => a });
      var s = r(96471);
      function a() {
        const e = (0, s.getNavigator)();
        return e?.userAgent;
      }
    },
    72609: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          browser: () => o,
          cookie: () => s,
          device: () => l,
          env: () => p,
          iframe: () => a,
          navigator: () => m,
          os: () => y,
          storage: () => n,
          url: () => i,
          userAgent: () => P
        });
      var s = {};
      r.r(s), r.d(s, { desktopAnonymousComputerId: () => u, websiteTrackingId: () => d });
      var a = {};
      r.r(a), r.d(a, { isInsideIframe: () => h });
      var n = {};
      r.r(n), r.d(n, { makeBrowserStorage: () => R });
      var i = {};
      r.r(i), r.d(i, { getAuthorityForUrl: () => x, getDomainForUrl: () => I });
      var o = r(63272),
        c = r(75077);
      function u() {
        return c.Q(document.cookie).anonid;
      }
      function d() {
        try {
          const e = c.Q(document.cookie);
          return JSON.parse(e.userFunnelCookie).trackingId;
        } catch (e) {
          return null;
        }
      }
      var l = r(10551),
        p = r(33493);
      function h() {
        return window.location !== window.parent.location;
      }
      var m = r(96471),
        y = r(28509);
      const g = 1,
        v = "dashlane",
        f = "user-data";
      function w() {
        return new Promise((e, t) => {
          const r = (0, p.isBrowserEnvironment)() ? window.indexedDB : (0, p.isWorkerEnvironment)() ? self.indexedDB : null;
          if (!r) return t(new Error("indexedDB is not supported in this environment"));
          const s = r.open(v, g);
          (s.onerror = function () {
            t(s.error);
          }),
            (s.onupgradeneeded = () => {
              s.result.objectStoreNames.contains(f) || s.result.createObjectStore(f);
            }),
            (s.onsuccess = function () {
              (s.onsuccess = null), e(s.result);
            });
        });
      }
      async function S(e = "readwrite") {
        return (await w()).transaction([f], e).objectStore(f);
      }
      async function E(e) {
        const t = await S("readonly");
        return new Promise((r) => {
          const s = t.get(e);
          s.onsuccess = () => {
            (s.onsuccess = null), r(s.result);
          };
        });
      }
      const _ = {
          isSupported: async function () {
            if (!(0, p.isBrowserEnvironment)() && !(0, p.isWorkerEnvironment)()) return !1;
            if (o.isInternetExplorer()) return !1;
            if ((0, p.isBrowserEnvironment)() && !window.indexedDB) return !1;
            if ((0, p.isWorkerEnvironment)() && !self.indexedDB) return !1;
            try {
              return await w(), !0;
            } catch (e) {
              return !1;
            }
          },
          readItem: E,
          writeItem: async function (e, t) {
            const r = await S("readwrite");
            return new Promise((s) => {
              const a = r.put(t, e);
              a.onsuccess = () => {
                (a.onsuccess = null), s();
              };
            });
          },
          removeItem: async function (e) {
            const t = await S("readwrite");
            return new Promise((r) => {
              const s = t.delete(e);
              s.onsuccess = () => {
                (s.onsuccess = null), r();
              };
            });
          },
          itemExists: async function (e) {
            const t = await E(e);
            return null != t;
          }
        },
        b = _,
        T = {
          isSupported: () => Promise.resolve(void 0 !== typeof window && !!window.localStorage),
          readItem: (e) => Promise.resolve(window.localStorage.getItem(e)),
          writeItem: (e, t) => Promise.resolve(window.localStorage.setItem(e, t)),
          removeItem: (e) => Promise.resolve(window.localStorage.removeItem(e)),
          itemExists: (e) => {
            const t = window.localStorage.getItem(e);
            return Promise.resolve(null != t);
          }
        },
        A = {},
        C = {
          isSupported: () => Promise.resolve(!0),
          readItem: (e) => {
            const t = e in A;
            return Promise.resolve(t ? A[e] : null);
          },
          writeItem: (e, t) => ((A[e] = t), Promise.resolve()),
          removeItem: (e) => (delete A[e], Promise.resolve()),
          itemExists: (e) => Promise.resolve(e in A)
        },
        R = async () => {
          try {
            if (await b.isSupported()) return b;
            if (await T.isSupported()) return T;
          } catch (e) {}
          return C;
        },
        I = (e) => {
          if (!e) return null;
          const t = e.trim(),
            r = ["http://", "https://", "ftp://", "ftps://", "file://", "afp://", "smb://"].filter((e) => t.startsWith(e))[0],
            s = r ? t.substr(r.length) : t,
            a = s.indexOf("/"),
            n = a > -1 ? s.slice(0, a) : s,
            i = n.split(""),
            o = i.filter((e) => "." === e),
            c = i.filter((e) => ":" === e),
            u = i.filter((e) => !Number.isNaN(Number(e)));
          if (3 === o.length && (u.length === n.length - 3 || (u.length === n.length - 4 && 1 === c.length))) return n;
          if (!o.length || 1 === o.length) return n;
          const d = n.lastIndexOf("."),
            l = n.slice(0, d),
            p = n.substr(d),
            h = l.lastIndexOf("."),
            m = l.substr(h + 1),
            y = l.slice(0, h);
          if (
            !["co", "com", "fr", "ac", "gov", "org", "edu", "net"].includes(m) &&
            ![
              "judiciary.uk",
              "ltd.uk",
              "me.uk",
              "mod.uk",
              "nhs.uk",
              "nic.uk",
              "parliament.uk",
              "plc.uk",
              "sch.uk",
              "bl.uk",
              "jet.uk",
              "british-library.uk",
              "nls.uk",
              "qc.ca"
            ].includes(m + p)
          )
            return m + p;
          const g = y.lastIndexOf(".");
          return g > -1 ? y.substr(g + 1) + "." + m + p : n;
        },
        x = (e) => {
          const t = (e ?? "").trim();
          if (!t) return null;
          const r = ["afp://", "file://", "ftp://", "ftps://", "http://", "https://", "smb://"].find((e) => t.startsWith(e)),
            s = r ? t.substr(r.length) : t,
            a = s.indexOf("/");
          return a > -1 ? s.slice(0, a) : s;
        };
      var P = r(50038);
    },
    28509: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          getOSName: () => n,
          getOSVersion: () => i,
          isAndroid: () => o,
          isIOS: () => c,
          isLinux: () => l,
          isMacOS: () => d,
          isWindows: () => u
        });
      var s,
        a = r(64785);
      function n() {
        return "Chromium OS" === (0, a.r)().os.name ? "Chrome OS" : (0, a.r)().os.name;
      }
      function i() {
        const { version: e = "" } = (0, a.r)().os;
        return "Mac OS" === n() ? `OS_X_${e.replace(/\./g, "_")}` : e;
      }
      !(function (e) {
        (e.ANDROID = "Android"), (e.IOS = "iOS"), (e.WINDOWS = "Windows"), (e.LINUX = "Linux"), (e.MACOS = "Mac OS");
      })(s || (s = {}));
      const o = () => n() === s.ANDROID,
        c = () => n() === s.IOS,
        u = () => n() === s.WINDOWS,
        d = () => n() === s.MACOS,
        l = () => n() === s.LINUX;
    },
    64785: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => i });
      var s = r(8473),
        a = r.n(s),
        n = r(50038);
      function i() {
        return new (a())((0, n.getUserAgent)(), {
          browser: [
            [/(AVG|Avast)\/([\w.]+)/i],
            [[a().BROWSER.NAME, "Avast"], a().BROWSER.VERSION],
            [/(edge|edgios|edga|edg)\/((\d+)?[\w.]+)/i],
            [[a().BROWSER.NAME, "Edge"], a().BROWSER.VERSION]
          ]
        }).getResult();
      }
    },
    96873: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => a });
      var s = r(839);
      function a(e) {
        return new Promise((t, r) => {
          if (!(0, s.Ez)("action.setBadgeBackgroundColor") && !(0, s.Ez)("browserAction.setBadgeBackgroundColor"))
            return void r(new Error("No setBadgeBackgroundColor support"));
          (chrome.action?.setBadgeBackgroundColor ?? chrome.browserAction.setBadgeBackgroundColor)(e, () => {
            if (chrome.runtime.lastError) {
              const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                t = new Error(`action/setBadgeBackgroundColor: ${e}`);
              r(t);
            } else t();
          });
        });
      }
    },
    86554: (e, t, r) => {
      "use strict";
      r.d(t, { d: () => a });
      var s = r(839);
      function a(e) {
        return new Promise((t, r) => {
          if (!(0, s.Ez)("action.setBadgeText") && !(0, s.Ez)("browserAction.setBadgeText"))
            return void r(new Error("No setBadgeText support"));
          (chrome.action?.setBadgeText ?? chrome.browserAction.setBadgeText)(e, () => {
            if (chrome.runtime.lastError) {
              const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                t = new Error(`action/setBadgeText: ${e}`);
              r(t);
            } else t();
          });
        });
      }
    },
    16241: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => a });
      var s = r(839);
      function a(e, t) {
        return new Promise((r, a) => {
          if (!(0, s.Ez)("action.setIcon") && !(0, s.Ez)("browserAction.setIcon")) return void a(new Error("No action.setIcon support"));
          (chrome.action?.setIcon ?? chrome.browserAction.setIcon)({ path: e, tabId: t }, () => {
            if (chrome.runtime.lastError) {
              const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                t = new Error(`action/setIcon: ${e}`);
              a(t);
            } else r();
          });
        });
      }
    },
    329: (e, t, r) => {
      "use strict";
      r.d(t, { g: () => a });
      var s = r(839);
      function a(e = {}) {
        return new Promise((t, r) => {
          (0, s.qX)(["cookies"])
            ? (0, s.Ez)("cookies.getAll")
              ? chrome.cookies.getAll(e, (e) => {
                  if (chrome.runtime.lastError) {
                    const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                      t = new Error(`cookies/getAll: ${e}`);
                    r(t);
                  } else t(e);
                })
              : r(new Error("No cookies.getAll support"))
            : r(new Error("No cookies.getAll support, permission is missing"));
        });
      }
    },
    98641: (e, t, r) => {
      "use strict";
      r.d(t, { O: () => a });
      var s = r(839);
      function a(e) {
        return new Promise((t, r) => {
          (0, s.qX)(["cookies"])
            ? (0, s.Ez)("cookies.remove")
              ? chrome.cookies.remove(e, (e) => {
                  if (chrome.runtime.lastError) {
                    const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                      t = new Error(`cookies/remove: ${e}`);
                    r(t);
                  } else t(e);
                })
              : r(new Error("No cookies.remove support"))
            : r(new Error("No cookies.remove support, permission is missing"));
        });
      }
    },
    6212: (e, t, r) => {
      "use strict";
      r.d(t, { z: () => a });
      var s = r(839);
      function a() {
        return new Promise((e, t) => {
          (0, s.qX)(["declarativeNetRequest"])
            ? (0, s.Ez)("declarativeNetRequest.getDynamicRules")
              ? chrome.declarativeNetRequest.getDynamicRules((r) => {
                  if (chrome.runtime.lastError) {
                    const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                      r = new Error(`declarativeNetRequest/getDynamicRules: ${e}`);
                    t(r);
                  } else e(r);
                })
              : t(new Error("No declarativeNetRequest.getDynamicRules support"))
            : t(new Error("No declarativeNetRequest.getDynamicRules support, permission is missing"));
        });
      }
    },
    25417: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => a });
      var s = r(839);
      function a() {
        return (0, s.Ez)("declarativeNetRequest") && (0, s.qX)(["declarativeNetRequest"]);
      }
    },
    84867: (e, t, r) => {
      "use strict";
      r.d(t, { O: () => a });
      var s = r(839);
      function a(e) {
        return new Promise((t, r) => {
          (0, s.qX)(["declarativeNetRequest"])
            ? (0, s.Ez)("declarativeNetRequest.updateDynamicRules")
              ? chrome.declarativeNetRequest.updateDynamicRules(e, () => {
                  if (chrome.runtime.lastError) {
                    const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                      t = new Error(`declarativeNetRequest/updateDynamicRules: ${e}`);
                    r(t);
                  } else t();
                })
              : r(new Error("No declarativeNetRequest.updateDynamicRules support"))
            : r(new Error("No declarativeNetRequest.updateDynamicRules support, permission is missing"));
        });
      }
    },
    839: (e, t, r) => {
      "use strict";
      r.d(t, { Ez: () => n, qX: () => a });
      var s = r(84318);
      function a(e) {
        const t = (0, s.W)().permissions ?? [];
        return e.every((e) => t.includes(e));
      }
      function n(e) {
        if ("undefined" == typeof chrome) return !1;
        const t = e.split(".").reduce((e, t) => e?.[t], chrome);
        return Boolean(t);
      }
    },
    13090: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => a });
      var s = r(839);
      const a = {
        addListener: function (e) {
          if (!(0, s.qX)(["idle"])) throw new Error("No idle.onStateChanged.addListener support, permission is missing");
          if (!(0, s.Ez)("idle.onStateChanged.addListener")) throw new Error("No idle.onStateChanged.addListener support");
          const t = (t) => {
            if (chrome.runtime.lastError) {
              const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError";
              throw new Error(`idle/onStateChanged: ${e}`);
            }
            return e(t);
          };
          return chrome.idle.onStateChanged.addListener(t), t;
        },
        removeListener: function (e) {
          if (!(0, s.qX)(["idle"])) throw new Error("No idle.onStateChanged.removeListener support, permission is missing");
          if (!(0, s.Ez)("idle.onStateChanged.removeListener")) throw new Error("No idle.onStateChanged.removeListener support");
          chrome.idle.onStateChanged.removeListener(e);
        }
      };
    },
    54422: (e, t, r) => {
      "use strict";
      r.d(t, { X: () => a });
      var s = r(839);
      function a(e) {
        if (!(0, s.qX)(["idle"])) throw new Error("No idle.setDetectionInterval support, permission is missing");
        if (!(0, s.Ez)("idle.setDetectionInterval")) throw new Error("No idle.setDetectionInterval support");
        chrome.idle.setDetectionInterval(e);
      }
    },
    82324: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => a, b: () => n });
      var s = r(74972);
      function a(e) {
        if ("object" != typeof e || !e) return !1;
        return !!("reason" in e) && e.reason === s.$.RuntimeError;
      }
      function n(e) {
        if ("object" != typeof e || !e) return !1;
        return !!("reason" in e) && e.reason === s.$.SettingNotSupported;
      }
    },
    30754: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => i });
      var s = r(839),
        a = r(74972);
      const n = { reason: a.$.SettingNotSupported };
      function i(e) {
        return new Promise((t, r) => {
          (0, s.qX)(["privacy"]) && (0, s.Ez)(`privacy.services.${e}.get`)
            ? chrome.privacy.services[e].get({}, (e) => {
                if (chrome.runtime.lastError) {
                  const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                    t = { reason: a.$.RuntimeError, runtimeError: new Error(e) };
                  r(t);
                } else t(e);
              })
            : r(n);
        });
      }
    },
    74972: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { $: () => s }),
        (function (e) {
          (e.RuntimeError = "runtimeError"), (e.SettingNotSupported = "settingNotSupported");
        })(s || (s = {}));
    },
    81805: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => i });
      var s = r(839),
        a = r(74972);
      const n = { reason: a.$.SettingNotSupported };
      function i(e, t) {
        return new Promise((r, i) => {
          (0, s.qX)(["privacy"]) && (0, s.Ez)(`privacy.services.${e}.set`)
            ? chrome.privacy.services[e].set({ value: t }, () => {
                if (chrome.runtime.lastError) {
                  const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                    t = { reason: a.$.RuntimeError, runtimeError: new Error(e) };
                  i(t);
                } else r();
              })
            : i(n);
        });
      }
    },
    84318: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => a });
      var s = r(839);
      function a() {
        if (!(0, s.Ez)("runtime.getManifest")) throw new Error("No runtime.getManifest support");
        return chrome.runtime.getManifest();
      }
    },
    92204: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => a });
      var s = r(839);
      function a(e) {
        if (!(0, s.Ez)("runtime.getURL")) throw new Error("No runtime.getURL support");
        return chrome.runtime.getURL(e);
      }
    },
    20500: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => a });
      var s = r(839);
      const a = {
        addListener: function (e) {
          if (!(0, s.Ez)("runtime.onConnect.addListener")) throw new Error("No runtime.onConnect.addListener support");
          const t = (t) => {
            if (chrome.runtime.lastError) {
              const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError";
              throw new Error(`runtime/onConnect: ${e}`);
            }
            return e(t);
          };
          return chrome.runtime.onConnect.addListener(t), t;
        },
        removeListener: function (e) {
          if (!(0, s.Ez)("runtime.onConnect.removeListener")) throw new Error("No runtime.onConnect.removeListener support");
          chrome.runtime.onConnect.removeListener(e);
        }
      };
    },
    23386: (e, t, r) => {
      "use strict";
      r.d(t, { Y: () => a });
      var s = r(839);
      const a = {
        addListener: function (e) {
          if (!(0, s.Ez)("runtime.onInstalled.addListener")) throw new Error("No runtime.onInstalled.addListener support");
          chrome.runtime.onInstalled.addListener((t) => {
            if (chrome.runtime.lastError) {
              const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError";
              throw new Error(`runtime/onInstalled: ${e}`);
            }
            return e(t);
          });
        }
      };
    },
    56386: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => a });
      var s = r(839);
      function a() {
        if (!(0, s.Ez)("runtime.reload")) throw new Error("No runtime.reload support");
        chrome.runtime.reload();
      }
    },
    2927: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => a });
      var s = r(839);
      function a(e) {
        if (!(0, s.Ez)("runtime.setUninstallURL")) throw new Error("No runtime.setUninstallURL support");
        chrome.runtime.setUninstallURL(e);
      }
    },
    21763: (e, t, r) => {
      "use strict";
      r.d(t, { k: () => n });
      var s = r(839);
      const a = (e, t) => () => {
        if (chrome.runtime.lastError) {
          const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
            r = new Error(`scripting/executeScript: ${e}`);
          t(r);
        } else e();
      };
      function n(e, t) {
        return (0, s.Ez)("scripting.executeScript")
          ? (function (e, t) {
              return new Promise((r, s) => {
                const n = t ?? a(r, s);
                chrome.scripting.executeScript(e, n);
              });
            })(e, t)
          : (0, s.Ez)("tabs.executeScript")
          ? (function (e, t) {
              return new Promise((r, s) => {
                const n = t ?? a(r, s),
                  i = { allFrames: e.target.allFrames, file: void 0, frameId: e.target.frameIds?.[0], runAt: "document_start" };
                "func" in e ? (i.code = e.func.toString()) : (i.file = e.files[0]), chrome.tabs.executeScript(e.target.tabId, i, n);
              });
            })(e, t)
          : Promise.reject(new Error("No scripting.executeScript support"));
      }
    },
    39680: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => a, y: () => n });
      var s = r(839);
      function a() {
        return !!chrome.storage?.local.getBytesInUse;
      }
      function n(e) {
        return new Promise((t, r) => {
          (0, s.qX)(["storage"])
            ? (0, s.Ez)("storage.local.getBytesInUse")
              ? chrome.storage.local.getBytesInUse(e, (e) => {
                  if (chrome.runtime.lastError) {
                    const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                      t = new Error(`storage/local/getBytesInUse: ${e}`);
                    r(t);
                  } else t(e);
                })
              : r(new Error("No storage.local.getBytesInUse support"))
            : r(new Error("No storage.local.getBytesInUse support, permission is missing"));
        });
      }
    },
    41808: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => a });
      var s = r(839);
      function a(e) {
        return new Promise((t, r) => {
          (0, s.qX)(["storage"])
            ? (0, s.Ez)("storage.local.get")
              ? chrome.storage.local.get(e, (e) => {
                  if (chrome.runtime.lastError) {
                    const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                      t = new Error(`storage/local/get: ${e}`);
                    r(t);
                  } else t(e);
                })
              : r(new Error("No storage.local.get support"))
            : r(new Error("No storage.local.get support, permission is missing"));
        });
      }
    },
    45441: (e, t, r) => {
      "use strict";
      r.d(t, { O: () => a });
      var s = r(839);
      function a(e) {
        return new Promise((t, r) => {
          (0, s.qX)(["storage"])
            ? (0, s.Ez)("storage.local.remove")
              ? chrome.storage.local.remove(e, () => {
                  if (chrome.runtime.lastError) {
                    const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                      t = new Error(`storage/local/remove: ${e}`);
                    r(t);
                  } else t();
                })
              : r(new Error("No storage.local.remove support"))
            : r(new Error("No storage.local.remove support, permission is missing"));
        });
      }
    },
    9244: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => a });
      var s = r(839);
      function a(e) {
        return new Promise((t, r) => {
          (0, s.qX)(["storage"])
            ? (0, s.Ez)("storage.local.set")
              ? chrome.storage.local.set(e, () => {
                  if (chrome.runtime.lastError) {
                    const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                      t = new Error(`storage/local/set: ${e}`);
                    r(t);
                  } else t();
                })
              : r(new Error("No storage.local.set support"))
            : r(new Error("No storage.local.set support, permission is missing"));
        });
      }
    },
    15026: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => a });
      var s = r(839);
      function a(e) {
        return new Promise((t, r) => {
          (0, s.qX)(["storage"])
            ? (0, s.Ez)("storage.session.get")
              ? chrome.storage.session.get(e, (e) => {
                  if (chrome.runtime.lastError) {
                    const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                      t = new Error(`storage/session/get: ${e}`);
                    r(t);
                  }
                  t(e);
                })
              : r(new Error("No storage.session.get support"))
            : r(new Error("No storage.session.get support, permission is missing"));
        });
      }
    },
    32012: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => n });
      var s = r(839),
        a = r(84318);
      function n() {
        return (0, s.Ez)("storage.session") && (0, s.qX)(["storage"]) && 3 === (0, a.W)().manifest_version;
      }
    },
    52477: (e, t, r) => {
      "use strict";
      r.d(t, { O: () => a });
      var s = r(839);
      function a(e) {
        return new Promise((t, r) => {
          (0, s.qX)(["storage"])
            ? (0, s.Ez)("storage.session.remove")
              ? chrome.storage.session.remove(e, () => {
                  if (chrome.runtime.lastError) {
                    const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                      t = new Error(`storage/session/remove: ${e}`);
                    r(t);
                  }
                  t();
                })
              : r(new Error("No storage.session.remove support"))
            : r(new Error("No storage.session.remove support, permission is missing"));
        });
      }
    },
    56847: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => a });
      var s = r(839);
      function a(e) {
        return new Promise((t, r) => {
          (0, s.qX)(["storage"])
            ? (0, s.Ez)("storage.session.set")
              ? chrome.storage.session.set(e, () => {
                  if (chrome.runtime.lastError) {
                    const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                      t = new Error(`storage/session/set: ${e}`);
                    r(t);
                  }
                  t();
                })
              : r(new Error("No storage.session.set support"))
            : r(new Error("No storage.session.set support, permission is missing"));
        });
      }
    },
    24715: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => a });
      var s = r(839);
      function a(e) {
        return new Promise((t, r) => {
          (0, s.Ez)("tabs.create")
            ? chrome.tabs.create(e, (e) => {
                if (chrome.runtime.lastError) {
                  const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                    t = new Error(`tabs/create: ${e}`);
                  r(t);
                } else t(e);
              })
            : r(new Error("No tabs.create support"));
        });
      }
    },
    61222: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => a });
      var s = r(839);
      function a(e) {
        return new Promise((t, r) => {
          (0, s.qX)(["tabs"])
            ? (0, s.Ez)("tabs.query")
              ? chrome.tabs.query(e, (e) => {
                  if (chrome.runtime.lastError) {
                    const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                      t = new Error(`tabs/query: ${e}`);
                    r(t);
                  } else t(e);
                })
              : r(new Error("No tabs.query support"))
            : r(new Error("No tabs.query support, permission is missing"));
        });
      }
    },
    49259: (e, t, r) => {
      "use strict";
      r.d(t, { O: () => a });
      var s = r(839);
      function a(e) {
        return new Promise((t, r) => {
          (0, s.Ez)("tabs.remove")
            ? chrome.tabs.remove(e, () => {
                if (chrome.runtime.lastError) {
                  const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                    t = new Error(`tabs/remove: ${e}`);
                  r(t);
                } else t();
              })
            : r(new Error("No tabs.remove support"));
        });
      }
    },
    31460: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => a });
      var s = r(839);
      function a(e, t) {
        return new Promise((r, a) => {
          (0, s.Ez)("tabs.update")
            ? chrome.tabs.update(e, t, (e) => {
                if (chrome.runtime.lastError) {
                  const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                    t = new Error(`tabs/update: ${e}`);
                  a(t);
                } else r(e);
              })
            : a(new Error("No tabs.update support"));
        });
      }
    },
    48291: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => n });
      var s = r(65881),
        a = r(839);
      const n = {
        addListener: function (e, t, r) {
          const n = r?.includes(s.X.Blocking) ? ["webRequest", "webRequestBlocking"] : ["webRequest"];
          if (!(0, a.qX)(n)) throw new Error("No webRequest.onBeforeRequest.addListener support, permission is missing");
          if (!(0, a.Ez)("webRequest.onBeforeRequest.addListener")) throw new Error("No webRequest.onBeforeRequest.addListener support");
          const i = (t) => {
            if (chrome.runtime.lastError) {
              const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError";
              throw new Error(`webRequest/onBeforeRequest: ${e}`);
            }
            return e(t);
          };
          return chrome.webRequest.onBeforeRequest.addListener(i, t, r), i;
        },
        hasListener: function (e) {
          if (!(0, a.qX)(["webRequest", "webRequestBlocking"]))
            throw new Error("No webRequest.onBeforeRequest.hasListener support, permission is missing");
          if (!(0, a.Ez)("webRequest.onBeforeRequest.hasListener")) throw new Error("No webRequest.onBeforeRequest support");
          return chrome.webRequest.onBeforeRequest.hasListener(e);
        },
        removeListener: function (e) {
          if (!(0, a.qX)(["webRequest"])) throw new Error("No webRequest.onBeforeRequest.removeListener support, permission is missing");
          if (!(0, a.Ez)("webRequest.onBeforeRequest.removeListener")) throw new Error("No webRequest.onBeforeRequest support");
          chrome.webRequest.onBeforeRequest.removeListener(e);
        }
      };
    },
    65881: (e, t, r) => {
      "use strict";
      var s;
      r.d(t, { X: () => s }),
        (function (e) {
          (e.Blocking = "blocking"), (e.RequestBody = "requestBody");
        })(s || (s = {}));
    },
    72733: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => a });
      var s = r(839);
      function a(e) {
        return new Promise((t, r) => {
          if (!(0, s.Ez)("windows.getCurrent")) return void r(new Error("No windows.getCurrent support"));
          const a = (e) => {
            if (chrome.runtime.lastError) {
              const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                t = new Error(`windows/getCurrent: ${e}`);
              r(t);
            } else t(e);
          };
          e ? chrome.windows.getCurrent(e, a) : chrome.windows.getCurrent(a);
        });
      }
    },
    57306: (e, t, r) => {
      "use strict";
      r.d(t, { V: () => a });
      var s = r(839);
      function a(e, t) {
        return new Promise((r, a) => {
          (0, s.Ez)("windows.update")
            ? chrome.windows.update(e, t, (e) => {
                if (chrome.runtime.lastError) {
                  const e = chrome.runtime.lastError.message ?? "Unknown chrome.runtime.lastError",
                    t = new Error(`windows/update: ${e}`);
                  a(t);
                } else r(e);
              })
            : a(new Error("No windows.update support"));
        });
      }
    },
    34573: () => {},
    19381: () => {},
    86585: () => {},
    1342: () => {},
    22324: () => {},
    17978: () => {},
    98814: () => {},
    97961: () => {},
    3275: () => {},
    63619: () => {},
    25387: () => {},
    46332: () => {},
    48263: () => {},
    1973: () => {},
    43350: () => {}
  }
]);
