/** @file automatically generated, do not edit it. */
/******/ (() => {
  // webpackBootstrap
  /******/ var __webpack_modules__ = {
    /***/ 51: /***/ (__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {
      "use strict";

      // UNUSED EXPORTS: default

      // EXTERNAL MODULE: external "React"
      var external_React_ = __webpack_require__(363);
      var external_React_default = __webpack_require__.n(external_React_);
      // EXTERNAL MODULE: external "ReactDOM"
      var external_ReactDOM_ = __webpack_require__(533);
      var external_ReactDOM_default = __webpack_require__.n(external_ReactDOM_);
      // EXTERNAL MODULE: ./js/chat/ui/conversations.jsx + 20 modules
      var conversations = __webpack_require__(978); // CONCATENATED MODULE: ./js/chat/chatRouting.jsx
      var _class;
      class ChatRouting {
        constructor(megaChatInstance) {
          this.megaChat = megaChatInstance;
        }
        openCustomView(sectionName) {
          const megaChat = this.megaChat;
          megaChat.routingSection = sectionName;
          megaChat.hideAllChats();
          delete megaChat.lastOpenedChat;
        }
        route(resolve, reject, location, event, isLandingPage) {
          if (!M.chat) {
            console.error("This function is meant to navigate within the chat...");
            return;
          }
          const args = String(location || "")
            .split("/")
            .map(String.trim)
            .filter(String);
          if (args[0] === "fm") {
            args.shift();
          }
          if (args[0] === "chat") {
            args.shift();
          }
          if (args[0] && args[0].length > 8 && args[0].substring(0, 8) === "contacts") {
            location = location.replace(args[0], "contacts");
            args[0] = "contacts";
          }
          const [section] = args;
          const { megaChat } = this;
          if (d) {
            megaChat.logger.warn("navigate(%s)", location, args);
          }
          args.route = {
            location,
            section,
            args
          };
          if (isLandingPage) {
            megaChat.eventuallyInitMeetingUI();
          }
          megaChat.routingSection = "chat";
          megaChat.routingSubSection = null;
          megaChat.routingParams = null;
          const handler = ChatRouting.gPageHandlers[section || "start"];
          if (handler) {
            handler.call(this, args.route).then(resolve).catch(reject);
            resolve = null;
          } else {
            let roomId = String(args[(section === "c" || section === "g" || section === "p") | 0] || "");
            if (roomId.includes("#")) {
              let key = roomId.split("#");
              roomId = key[0];
              key = key[1];
              megaChat.publicChatKeys[roomId] = key;
              roomId = megaChat.handleToId[roomId] || roomId;
            }
            const room = megaChat.getChatById(roomId);
            if (room) {
              room.show();
              args.route.location = room.getRoomUrl();
            } else if (!roomId || roomId === u_handle || roomId.length !== 11) {
              ChatRouting.gPageHandlers.redirect(args.route, "fm/chat").then(resolve).catch(reject);
              resolve = null;
            } else if (section === "p") {
              megaChat.smartOpenChat([u_handle, roomId], "private", undefined, undefined, undefined, true).then(resolve).catch(reject);
              resolve = null;
            } else {
              megaChat.plugins.chatdIntegration
                .openChat(roomId)
                .then((chatId) => {
                  megaChat.getChatById(chatId).show();
                  return chatId;
                })
                .catch((ex) => {
                  if (d && ex !== ENOENT) {
                    console.warn('If "%s" is a chat, something went wrong..', roomId, ex);
                  }
                  if (page !== location) {
                    return EEXPIRED;
                  }
                  megaChat.cleanup(true);
                  if (ex === ENOENT && megaChat.publicChatKeys[roomId]) {
                    msgDialog("warninga", l[20641], l[20642], 0, () => {
                      loadSubPage(is_chatlink ? "start" : "fm/chat", event);
                    });
                  } else {
                    if (String(location).startsWith("chat")) {
                      location = "fm/chat";
                    }
                    loadSubPage(location, location.includes("chat") ? "override" : event);
                  }
                  return EACCESS;
                })
                .then(resolve)
                .catch(reject);
              resolve = null;
            }
          }
          if (resolve) {
            onIdle(resolve);
          }
          megaChat.safeForceUpdate();
          if (args.route.location !== location) {
            location = args.route.location;
          }
          const method =
            page === "chat" || page === "fm/chat" || page === location || (event && event.type === "popstate")
              ? "replaceState"
              : "pushState";
          mBroadcaster.sendMessage("beforepagechange", location);
          M.currentdirid = String((page = location)).replace("fm/", "");
          if (location.substr(0, 13) === "chat/contacts") {
            location = "fm/" + location;
          }
          history[method](
            {
              subpage: location
            },
            "",
            (hashLogic ? "#" : "/") + location
          );
          mBroadcaster.sendMessage("pagechange", page);
        }
        initFmAndChat(targetChatId) {
          assert(!fminitialized);
          return new Promise((res, rej) => {
            M.currentdirid = targetChatId ? "fm/chat/" + targetChatId : undefined;
            loadSubPage("fm");
            mBroadcaster.once("chat_initialized", () => {
              authring.onAuthringReady().then(res, rej);
            });
          });
        }
        reinitAndOpenExistingChat(chatId, publicChatHandle = false, cbBeforeOpen = undefined) {
          const chatUrl = "fm/chat/c/" + chatId;
          publicChatHandle = publicChatHandle || megaChat.initialPubChatHandle;
          megaChat.destroy();
          is_chatlink = false;
          loadingDialog.pshow();
          return new Promise((resolve, reject) => {
            this.initFmAndChat(chatId)
              .always(() => {
                megaChat.initialPubChatHandle = publicChatHandle;
                megaChat.initialChatId = chatId;
                const next = () => {
                  mBroadcaster.once("pagechange", () => {
                    onIdle(() => {
                      loadingDialog.phide();
                      megaChat
                        .renderListing(chatUrl, true)
                        .catch((ex) => {
                          console.error("Failed to megaChat.renderListing:", ex);
                          reject(ex);
                        })
                        .always(() => {
                          megaChat.updateKeysInProtocolHandlers();
                          const chatRoom = megaChat.getChatById(chatId);
                          assert(chatRoom);
                          if (chatRoom.state === ChatRoom.STATE.READY) {
                            resolve(chatRoom);
                          } else {
                            chatRoom.rebind("onMessagesHistoryDone.reinitAndOpenExistingChat", () => {
                              if (chatRoom.state === ChatRoom.STATE.READY) {
                                resolve(chatRoom);
                                chatRoom.unbind("onMessagesHistoryDone.reinitAndOpenExistingChat");
                              }
                            });
                          }
                        });
                    });
                  });
                  loadSubPage(chatUrl);
                };
                if (cbBeforeOpen) {
                  cbBeforeOpen().then(next, (ex) => {
                    console.error("Failed to execute `cbBeforeOpen`, got a reject of the returned promise:", ex);
                  });
                } else {
                  next();
                }
              })
              .catch((ex) => reject(ex));
          });
        }
        reinitAndJoinPublicChat(chatId, initialPubChatHandle, publicChatKey) {
          initialPubChatHandle = initialPubChatHandle || megaChat.initialPubChatHandle;
          megaChat.destroy();
          is_chatlink = false;
          loadingDialog.pshow();
          return new Promise((res, rej) => {
            this.initFmAndChat(chatId).then(() => {
              megaChat.initialPubChatHandle = initialPubChatHandle;
              megaChat.initialChatId = chatId;
              const mciphReq = megaChat.plugins.chatdIntegration.getMciphReqFromHandleAndKey(initialPubChatHandle, publicChatKey);
              const isReady = (chatRoom) => {
                if (chatRoom.state === ChatRoom.STATE.READY) {
                  res(chatRoom);
                  loadingDialog.phide();
                } else {
                  chatRoom.rebind("onMessagesHistoryDone.reinitAndOpenExistingChat", () => {
                    if (chatRoom.state === ChatRoom.STATE.READY) {
                      res(chatRoom);
                      loadingDialog.phide();
                      chatRoom.unbind("onMessagesHistoryDone.reinitAndOpenExistingChat");
                    }
                  });
                }
              };
              const join = () => {
                const existingRoom = megaChat.getChatById(chatId);
                if (!existingRoom) {
                  megaChat.rebind("onRoomInitialized.reinitAndJoinPublicChat", (e, megaRoom) => {
                    if (megaRoom.chatId === chatId) {
                      megaRoom.setActive();
                      isReady(megaRoom);
                      megaChat.unbind("onRoomInitialized.reinitAndJoinPublicChat");
                    }
                  });
                } else {
                  existingRoom.setActive();
                  isReady(existingRoom);
                }
              };
              join();
              asyncApiReq(mciphReq)
                .then(join)
                .catch((ex) => {
                  if (ex === EEXIST) {
                    join();
                  } else {
                    loadingDialog.phide();
                    console.error("Bad response for mciphReq:", mciphReq, ex);
                    rej(ex);
                  }
                });
            });
          });
        }
      }
      _class = ChatRouting;
      ChatRouting.gPageHandlers = {
        async start({ location }) {
          return megaChat.onChatsHistoryReady(15e3).then(() => {
            return page === location ? megaChat.renderListing() : EACCESS;
          });
        },
        async redirect(target, path = "fm/chat") {
          target.location = path;
          return _class.gPageHandlers.start(target);
        },
        async new_meeting(target) {
          megaChat.trigger("onStartNewMeeting");
          return _class.gPageHandlers.redirect(target);
        },
        async contacts({ section, args }) {
          this.openCustomView(section);
          const [, target = ""] = args;
          if (target.length === 11) {
            megaChat.routingSubSection = "contact";
            megaChat.routingParams = target;
          } else if (target === "received" || target === "sent") {
            megaChat.routingSubSection = target;
          }
        }
      };
      // EXTERNAL MODULE: ./js/chat/ui/messages/scheduleMetaChange.jsx
      var scheduleMetaChange = __webpack_require__(97);
      // EXTERNAL MODULE: ./js/chat/chatRoom.jsx + 1 modules
      var chat_chatRoom = __webpack_require__(804); // CONCATENATED MODULE: ./js/chat/meetingsManager.jsx
      class Occurrence {
        constructor(megaChat, occurrence) {
          const { decodeData } = megaChat.plugins.meetingsManager;
          this.megaChat = megaChat;
          this.id = occurrence.id;
          this.uid = `${occurrence.cid}-${occurrence.o || occurrence.s}`;
          this.chatId = occurrence.cid;
          this.parentId = occurrence.p;
          this.start = occurrence.s * 1000;
          this.startInitial = parseInt(occurrence.o) * 1000 || undefined;
          this.end = occurrence.e * 1000;
          this.timezone = decodeData(occurrence.tz);
          this.title = decodeData(occurrence.t);
          this.description = decodeData(occurrence.d);
          this.ownerHandle = occurrence.u;
          this.flags = occurrence.f;
          this.canceled = occurrence.c;
          this.scheduledMeeting = occurrence.scheduledMeeting;
        }
        get isUpcoming() {
          return !this.canceled && this.end > Date.now();
        }
        cancel() {
          const { encodeData } = this.megaChat.plugins.meetingsManager;
          const req = {
            a: "mcsmp",
            p: this.parentId || this.id,
            ...(this.parentId && {
              id: this.id
            }),
            cid: this.chatId,
            o: this.start / 1000,
            s: this.start / 1000,
            e: this.end / 1000,
            tz: encodeData(this.timezone),
            t: encodeData(this.title),
            d: encodeData(this.description) || "",
            f: this.scheduledMeeting.flags,
            c: 1
          };
          asyncApiReq(req).catch((ex) => console.error("Occurrence > cancel ->", ex));
        }
        update(startDateTime, endDateTime) {
          const { encodeData } = this.megaChat.plugins.meetingsManager;
          const req = {
            a: "mcsmp",
            cid: this.chatId,
            p: this.parentId || this.id,
            ...(this.parentId && {
              id: this.id
            }),
            o: this.start / 1000,
            s: startDateTime / 1000,
            e: endDateTime / 1000,
            tz: encodeData(this.timezone),
            t: encodeData(this.title),
            d: encodeData(this.description) || "",
            f: this.scheduledMeeting.flags
          };
          asyncApiReq(req).catch((ex) => console.error("Occurrence > update ->", ex));
        }
      }
      class ScheduledMeeting {
        constructor(megaChat, meetingInfo, fromActionPacket) {
          const { decodeData } = megaChat.plugins.meetingsManager;
          this.megaChat = megaChat;
          this.id = meetingInfo.id;
          this.chatId = meetingInfo.cid;
          this.parentId = meetingInfo.p;
          this.start = meetingInfo.s * 1000;
          this.startInitial = parseInt(meetingInfo.o) * 1000 || undefined;
          this.end = meetingInfo.e * 1000;
          this.timezone = decodeData(meetingInfo.tz);
          this.title = decodeData(meetingInfo.t);
          this.description = decodeData(meetingInfo.d);
          this.flags = meetingInfo.f;
          this.canceled = meetingInfo.c;
          this.recurring = meetingInfo.r && {
            frequency: meetingInfo.r.f || undefined,
            interval: meetingInfo.r.i || 0,
            end: meetingInfo.r.u * 1000 || undefined,
            weekDays: meetingInfo.r.wd || [],
            monthDays: meetingInfo.r.md || [],
            offset:
              meetingInfo.r.mwd && meetingInfo.r.mwd.length
                ? {
                    value: meetingInfo.r.mwd[0][0],
                    weekDay: meetingInfo.r.mwd[0][1]
                  }
                : []
          };
          this.occurrences = new MegaDataMap();
          this.nextOccurrenceStart = this.start;
          this.nextOccurrenceEnd = this.end;
          this.ownerHandle = meetingInfo.u;
          this.chatRoom = meetingInfo.chatRoom;
          this.chatRoom.scheduledMeeting = this.isRoot ? this : this.parent;
          if (fromActionPacket) {
            this.initializeFromActionPacket();
          }
        }
        get isRoot() {
          return !this.parentId;
        }
        get isCanceled() {
          return !!this.canceled;
        }
        get isPast() {
          const end = this.isRecurring ? this.recurring.end : this.end;
          return end < Date.now();
        }
        get isUpcoming() {
          return !this.isCanceled && !this.isPast;
        }
        get isRecurring() {
          return !!this.recurring;
        }
        get isNear() {
          return this.start - Date.now() < ChatRoom.SCHEDULED_MEETINGS_INTERVAL;
        }
        get iAmOwner() {
          if (this.ownerHandle) {
            return this.ownerHandle === u_handle;
          }
          return null;
        }
        get parent() {
          return this.isRoot ? null : this.megaChat.plugins.meetingsManager.getMeetingById(this.parentId);
        }
        setNextOccurrence() {
          if (this.occurrences && this.occurrences.length) {
            const nextOccurrences = Object.values(this.occurrences)
              .filter((o) => o.isUpcoming)
              .sort((a, b) => a.start - b.start);
            this.nextOccurrenceStart = nextOccurrences[0].start;
            this.nextOccurrenceEnd = nextOccurrences[0].end;
            return {
              start: this.nextOccurrenceStart,
              end: this.nextOccurrenceEnd
            };
          }
          return null;
        }
        async getOccurrences(options) {
          const { from, to, count } = options || {};
          const { meetingsManager } = this.megaChat.plugins;
          const req = {
            a: "mcsmfo",
            cid: this.chatId,
            ...(from && {
              cf: Math.round(from / 1000)
            }),
            ...(to && {
              ct: Math.round(to / 1000)
            }),
            ...(count && {
              cc: count
            })
          };
          if (is_chatlink) {
            req.ph = is_chatlink.ph;
            delete req.cid;
          }
          const occurrences = await asyncApiReq(req);
          if (Array.isArray(occurrences)) {
            for (let i = 0; i < occurrences.length; i++) {
              const occurrence = new Occurrence(this.megaChat, {
                scheduledMeeting: this,
                ...occurrences[i]
              });
              this.occurrences.set(occurrence.uid, occurrence);
            }
            this.setNextOccurrence();
            this.megaChat.trigger(meetingsManager.EVENTS.OCCURRENCES_UPDATE, this);
          }
          return this.occurrences;
        }
        getOccurrencesById(occurrenceId) {
          const occurrences = Object.values(this.occurrences.toJS()).filter((o) => o.id === occurrenceId);
          return occurrences.length ? occurrences : false;
        }
        initializeFromActionPacket() {
          const { megaChat, isUpcoming, isCanceled, isRecurring, parent } = this;
          if ((isUpcoming && isRecurring) || parent) {
            return parent
              ? (() => {
                  const { chatId, start, startInitial } = this;
                  const occurrences = Object.values(parent.occurrences);
                  const currentIndex = occurrences.findIndex((o) => o.uid === `${chatId}-${(startInitial || start) / 1000}`);
                  const previous = occurrences[currentIndex - 1];
                  return parent
                    .getOccurrences({
                      from: previous ? previous.start : Date.now(),
                      count: occurrences.length - currentIndex
                    })
                    .catch(nop);
                })()
              : this.getOccurrences().catch(nop);
          }
          megaChat.trigger(megaChat.plugins.meetingsManager.EVENTS[isCanceled ? "CANCEL" : "INITIALIZE"], this);
        }
        isSameAsOpts(opts) {
          const { timezone, startDateTime, endDateTime, topic, description, f, recurring } = opts;
          if (this.timezone !== timezone || this.start !== startDateTime || this.end !== endDateTime) {
            return false;
          }
          if (this.title !== topic) {
            return false;
          }
          if (this.description !== description) {
            return false;
          }
          if (this.flags !== f) {
            return false;
          }
          if (!!this.recurring ^ !!recurring) {
            return false;
          }
          if (this.recurring) {
            if (this.recurring.frequency !== recurring.frequency || this.recurring.interval !== (recurring.interval || 0)) {
              return false;
            }
            if (this.recurring.end !== recurring.end) {
              return false;
            }
            let diff = array.diff(this.recurring.weekDays, recurring.weekDays || []);
            if (diff.removed.length + diff.added.length) {
              return false;
            }
            diff = array.diff(this.recurring.monthDays, recurring.monthDays || []);
            if (diff.removed.length + diff.added.length) {
              return false;
            }
            if (
              (Array.isArray(this.recurring.offset) && !Array.isArray(recurring.offset)) ||
              (!Array.isArray(this.recurring.offset) && Array.isArray(recurring.offset))
            ) {
              return false;
            }
            if (
              (this.recurring.offset.value || 0) !== (recurring.offset.value || 0) ||
              (this.recurring.offset.weekDay || 0) !== (recurring.offset.weekDay || 0)
            ) {
              return false;
            }
          }
          return true;
        }
      }
      class MeetingsManager {
        constructor(megaChat) {
          this.EVENTS = {
            INITIALIZE: "onMeetingInitialize",
            EDIT: "onMeetingEdit",
            CANCEL: "onMeetingCancel",
            LEAVE: "onMeetingLeave",
            OCCURRENCES_UPDATE: "onOccurrencesUpdate"
          };
          this.startDayStrings = [
            l.schedule_occur_sun,
            l.schedule_occur_mon,
            l.schedule_occur_tue,
            l.schedule_occur_wed,
            l.schedule_occur_thu,
            l.schedule_occur_fri,
            l.schedule_occur_sat
          ];
          this.midDayStrings = [
            l.schedule_occur_sun_mid,
            l.schedule_occur_mon_mid,
            l.schedule_occur_tue_mid,
            l.schedule_occur_wed_mid,
            l.schedule_occur_thu_mid,
            l.schedule_occur_fri_mid,
            l.schedule_occur_sat_mid
          ];
          this.NOTIF_TITLES = {
            recur: {
              desc: {
                update: l.schedule_notif_update_desc
              },
              name: {
                update: l.schedule_mgmt_title
              },
              time: {
                occur: l.schedule_mgmt_update_occur,
                all: l.schedule_mgmt_update_recur
              },
              convert: l.schedule_mgmt_update_convert_recur,
              inv: l.schedule_notif_invite_recur,
              multi: l.schedule_notif_update_multi,
              cancel: {
                occur: l.schedule_mgmt_cancel_occur,
                all: l.schedule_mgmt_cancel_recur
              }
            },
            once: {
              desc: {
                update: l.schedule_notif_update_desc
              },
              name: {
                update: l.schedule_mgmt_title
              },
              time: {
                occur: "",
                all: l.schedule_mgmt_update
              },
              convert: l.schedule_mgmt_update_convert,
              inv: l.schedule_notif_invite,
              multi: l.schedule_notif_update_multi,
              cancel: {
                occur: "",
                all: l.schedule_mgmt_cancel
              }
            }
          };
          this.OCCUR_STRINGS = {
            recur: {
              daily: {
                continuous: {
                  occur: l.schedule_recur_time_daily_cont,
                  skip: l.scheduled_recur_time_daily_skip_cont
                },
                limited: {
                  occur: l.schedule_recur_time_daily,
                  skip: l.scheduled_recur_time_daily_skip
                }
              },
              weekly: {
                continuous: {
                  list: l.schedule_recur_time_week_cont_list,
                  spec: l.schedule_recur_time_week_cont
                },
                limited: {
                  list: l.schedule_recur_time_week_list,
                  spec: l.schedule_recur_time_week
                }
              },
              monthly: {
                continuous: {
                  num: l.schedule_recur_time_num_day_month_cont,
                  pos: [
                    [
                      l.schedule_recur_time_first_day_month_6_cont,
                      l.schedule_recur_time_first_day_month_0_cont,
                      l.schedule_recur_time_first_day_month_1_cont,
                      l.schedule_recur_time_first_day_month_2_cont,
                      l.schedule_recur_time_first_day_month_3_cont,
                      l.schedule_recur_time_first_day_month_4_cont,
                      l.schedule_recur_time_first_day_month_5_cont
                    ],
                    [
                      l.schedule_recur_time_second_day_month_6_cont,
                      l.schedule_recur_time_second_day_month_0_cont,
                      l.schedule_recur_time_second_day_month_1_cont,
                      l.schedule_recur_time_second_day_month_2_cont,
                      l.schedule_recur_time_second_day_month_3_cont,
                      l.schedule_recur_time_second_day_month_4_cont,
                      l.schedule_recur_time_second_day_month_5_cont
                    ],
                    [
                      l.schedule_recur_time_third_day_month_6_cont,
                      l.schedule_recur_time_third_day_month_0_cont,
                      l.schedule_recur_time_third_day_month_1_cont,
                      l.schedule_recur_time_third_day_month_2_cont,
                      l.schedule_recur_time_third_day_month_3_cont,
                      l.schedule_recur_time_third_day_month_4_cont,
                      l.schedule_recur_time_third_day_month_5_cont
                    ],
                    [
                      l.schedule_recur_time_fourth_day_month_6_cont,
                      l.schedule_recur_time_fourth_day_month_0_cont,
                      l.schedule_recur_time_fourth_day_month_1_cont,
                      l.schedule_recur_time_fourth_day_month_2_cont,
                      l.schedule_recur_time_fourth_day_month_3_cont,
                      l.schedule_recur_time_fourth_day_month_4_cont,
                      l.schedule_recur_time_fourth_day_month_5_cont
                    ],
                    [
                      l.schedule_recur_time_fifth_day_month_6_cont,
                      l.schedule_recur_time_fifth_day_month_0_cont,
                      l.schedule_recur_time_fifth_day_month_1_cont,
                      l.schedule_recur_time_fifth_day_month_2_cont,
                      l.schedule_recur_time_fifth_day_month_3_cont,
                      l.schedule_recur_time_fifth_day_month_4_cont,
                      l.schedule_recur_time_fifth_day_month_5_cont
                    ]
                  ],
                  last: [
                    l.schedule_recur_time_fifth_day_month_6_cont,
                    l.schedule_recur_time_fifth_day_month_0_cont,
                    l.schedule_recur_time_fifth_day_month_1_cont,
                    l.schedule_recur_time_fifth_day_month_2_cont,
                    l.schedule_recur_time_fifth_day_month_3_cont,
                    l.schedule_recur_time_fifth_day_month_4_cont,
                    l.schedule_recur_time_fifth_day_month_5_cont
                  ]
                },
                limited: {
                  num: l.schedule_recur_time_num_day_month,
                  pos: [
                    [
                      l.schedule_recur_time_first_day_month_6,
                      l.schedule_recur_time_first_day_month_0,
                      l.schedule_recur_time_first_day_month_1,
                      l.schedule_recur_time_first_day_month_2,
                      l.schedule_recur_time_first_day_month_3,
                      l.schedule_recur_time_first_day_month_4,
                      l.schedule_recur_time_first_day_month_5
                    ],
                    [
                      l.schedule_recur_time_second_day_month_6,
                      l.schedule_recur_time_second_day_month_0,
                      l.schedule_recur_time_second_day_month_1,
                      l.schedule_recur_time_second_day_month_2,
                      l.schedule_recur_time_second_day_month_3,
                      l.schedule_recur_time_second_day_month_4,
                      l.schedule_recur_time_second_day_month_5
                    ],
                    [
                      l.schedule_recur_time_third_day_month_6,
                      l.schedule_recur_time_third_day_month_0,
                      l.schedule_recur_time_third_day_month_1,
                      l.schedule_recur_time_third_day_month_2,
                      l.schedule_recur_time_third_day_month_3,
                      l.schedule_recur_time_third_day_month_4,
                      l.schedule_recur_time_third_day_month_5
                    ],
                    [
                      l.schedule_recur_time_fourth_day_month_6,
                      l.schedule_recur_time_fourth_day_month_0,
                      l.schedule_recur_time_fourth_day_month_1,
                      l.schedule_recur_time_fourth_day_month_2,
                      l.schedule_recur_time_fourth_day_month_3,
                      l.schedule_recur_time_fourth_day_month_4,
                      l.schedule_recur_time_fourth_day_month_5
                    ],
                    [
                      l.schedule_recur_time_fifth_day_month_6,
                      l.schedule_recur_time_fifth_day_month_0,
                      l.schedule_recur_time_fifth_day_month_1,
                      l.schedule_recur_time_fifth_day_month_2,
                      l.schedule_recur_time_fifth_day_month_3,
                      l.schedule_recur_time_fifth_day_month_4,
                      l.schedule_recur_time_fifth_day_month_5
                    ]
                  ],
                  last: [
                    l.schedule_recur_time_last_day_month_6,
                    l.schedule_recur_time_last_day_month_0,
                    l.schedule_recur_time_last_day_month_1,
                    l.schedule_recur_time_last_day_month_2,
                    l.schedule_recur_time_last_day_month_3,
                    l.schedule_recur_time_last_day_month_4,
                    l.schedule_recur_time_last_day_month_5
                  ]
                }
              },
              [scheduleMetaChange["default"].MODE.CANCELLED]: {
                occur: l.schedule_occurrence_time,
                all: ""
              }
            },
            once: {
              [scheduleMetaChange["default"].MODE.CREATED]: {
                occur: l.schedule_occurrence_time
              },
              [scheduleMetaChange["default"].MODE.EDITED]: {
                occur: l.schedule_occurrence_time_recur
              },
              [scheduleMetaChange["default"].MODE.CANCELLED]: {
                occur: ""
              }
            }
          };
          this.megaChat = megaChat;
          this.scheduledMeetings = megaChat.scheduledMeetings || new MegaDataMap();
          this._goneOccurrences = {};
          this.megaChat.rebind(this.EVENTS.CANCEL, ({ data }) => this.archiveMeeting(data));
          this.megaChat.rebind(this.EVENTS.LEAVE, ({ data }) => this.detachMeeting(data));
          this.megaChat.rebind(`${this.EVENTS.OCCURRENCES_UPDATE}.tracker`, ({ data }) => {
            if (!this._goneOccurrences[data.chatId]) {
              return;
            }
            const { chatId } = data;
            for (const scheduledId of Object.keys(this._goneOccurrences[chatId])) {
              if (this._goneOccurrences[chatId][scheduledId] === -1) {
                this._goneOccurrences[chatId][scheduledId] = this.scheduledMeetings[scheduledId] ? 0 : 1;
              }
            }
          });
        }
        checkForNotifications() {
          const time = Date.now();
          const upcomingMeetings = Object.values(this.scheduledMeetings.toJS()).filter((c) => c.isUpcoming);
          for (const meeting of upcomingMeetings) {
            if (pushNotificationSettings.isAllowedForChatId(meeting.chatId)) {
              if (meeting.nextOccurrenceStart >= time + 9e5 && meeting.nextOccurrenceStart <= time + 96e4) {
                const ss = Math.floor(meeting.nextOccurrenceStart / 1000);
                const ns = Math.floor(time / 1000) + 900;
                if (ss - ns <= 10) {
                  this.megaChat.trigger("onScheduleUpcoming", meeting);
                } else {
                  tSleep(ss - ns).always(() => {
                    this.megaChat.trigger("onScheduleUpcoming", meeting);
                  });
                }
              } else if (meeting.nextOccurrenceStart >= time && meeting.nextOccurrenceStart < time + 6e4) {
                const ss = Math.floor(meeting.nextOccurrenceStart / 1000);
                const ns = Math.floor(time / 1000);
                tSleep(ss - ns).always(() => {
                  this.megaChat.trigger("onScheduleStarting", meeting);
                });
              }
            }
          }
        }
        encodeData(data) {
          return data && base64urlencode(to8(data));
        }
        decodeData(data) {
          return data && from8(base64urldecode(data));
        }
        getMeetingById(meetingId) {
          return this.scheduledMeetings[meetingId];
        }
        getMeetingOrOccurrenceParent(meetingId) {
          const meeting = this.scheduledMeetings[meetingId];
          if (!meeting) {
            return false;
          }
          if (meeting.parentId) {
            return this.getMeetingOrOccurrenceParent(meeting.parentId);
          }
          return meeting;
        }
        getRoomByMeetingId() {}
        async createMeeting(meetingInfo) {
          await this.megaChat.createAndShowGroupRoomFor(meetingInfo.participants, meetingInfo.topic, {
            keyRotation: false,
            createChatLink: meetingInfo.link,
            isMeeting: true,
            openInvite: meetingInfo.openInvite,
            waitingRoom: meetingInfo.waitingRoom,
            scheduledMeeting: {
              a: "mcsmp",
              s: meetingInfo.startDateTime / 1000,
              e: meetingInfo.endDateTime / 1000,
              tz: this.encodeData(meetingInfo.timezone),
              t: this.encodeData(meetingInfo.topic),
              d: this.encodeData(meetingInfo.description),
              f: meetingInfo.sendInvite ? 0x01 : 0x00,
              ...(meetingInfo.recurring && {
                r: {
                  f: meetingInfo.recurring.frequency,
                  wd: meetingInfo.recurring.weekDays,
                  md: meetingInfo.recurring.monthDays,
                  mwd: meetingInfo.recurring.offset,
                  ...(meetingInfo.recurring.end && {
                    u: meetingInfo.recurring.end / 1000
                  }),
                  ...(meetingInfo.recurring.interval && {
                    i: meetingInfo.recurring.interval
                  })
                }
              })
            }
          });
        }
        async updateMeeting(meetingInfo, chatRoom) {
          const { scheduledMeeting, chatId, publicLink, options, topic } = chatRoom;
          await megaChat.plugins.chatdIntegration.updateScheduledMeeting(meetingInfo, scheduledMeeting.id, chatId);
          const nextParticipants = meetingInfo.participants;
          const prevParticipants = chatRoom.getParticipantsExceptMe();
          const participantsDiff = JSON.stringify(nextParticipants) !== JSON.stringify(prevParticipants);
          if (participantsDiff) {
            const removed = prevParticipants.filter((h) => !nextParticipants.includes(h));
            const added = nextParticipants.filter((h) => !prevParticipants.includes(h));
            if (removed.length) {
              for (let i = removed.length; i--; ) {
                chatRoom.trigger("onRemoveUserRequest", [removed[i]]);
              }
            }
            if (added.length) {
              chatRoom.trigger("onAddUserRequest", [added]);
            }
          }
          if (!!meetingInfo.link !== !!publicLink) {
            chatRoom.updatePublicHandle(!meetingInfo.link, meetingInfo.link);
          }
          if (meetingInfo.waitingRoom !== options[chat_chatRoom.MCO_FLAGS.WAITING_ROOM]) {
            chatRoom.toggleWaitingRoom();
          }
          if (meetingInfo.openInvite !== options[chat_chatRoom.MCO_FLAGS.OPEN_INVITE]) {
            chatRoom.toggleOpenInvite();
          }
        }
        cancelMeeting(scheduledMeeting, chatId) {
          return this.megaChat.plugins.chatdIntegration.cancelScheduledMeeting(scheduledMeeting, chatId);
        }
        deleteMeeting(scheduledMeetingId, chatId) {
          return this.megaChat.plugins.chatdIntegration.deleteScheduledMeeting(scheduledMeetingId, chatId);
        }
        attachMeeting(meetingInfo, fromActionPacket) {
          const chatRoom = meetingInfo.chatRoom || this.megaChat.getChatById(meetingInfo.cid);
          if (chatRoom) {
            const scheduledMeeting = new ScheduledMeeting(
              this.megaChat,
              {
                chatRoom,
                ...meetingInfo
              },
              fromActionPacket
            );
            this.scheduledMeetings.set(meetingInfo.id, scheduledMeeting);
            return scheduledMeeting;
          }
        }
        detachMeeting(scheduledMeeting) {
          if (scheduledMeeting) {
            this.archiveMeeting(scheduledMeeting);
            scheduledMeeting.chatRoom.scheduledMeeting = null;
            this.scheduledMeetings.remove(scheduledMeeting.id);
            if (fmdb) {
              fmdb.del("mcsm", scheduledMeeting.id);
            }
          }
        }
        archiveMeeting(scheduledMeeting) {
          const { chatRoom } = scheduledMeeting;
          tSleep(2).then(() => (chatRoom.hasUserMessages() ? null : chatRoom.archive()));
        }
        getOccurrenceStrings(meta) {
          const res = [];
          const { prevTiming, timeRules, mode, occurrence, recurring, converted } = meta;
          const { MODE } = scheduleMetaChange["default"];
          if (!mode) {
            return res;
          }
          const { OCCUR_STRINGS } = this;
          let string;
          if (recurring) {
            res.push(this._parseOccurrence(timeRules, mode, occurrence));
            if (prevTiming && !(occurrence && mode === MODE.CANCELLED)) {
              res.push(this._parseOccurrence(prevTiming, mode, occurrence));
            }
          } else {
            const { startTime, endTime } = timeRules;
            string = OCCUR_STRINGS.once[mode].occur;
            res.push(
              string
                .replace("%1", toLocaleTime(startTime))
                .replace("%2", toLocaleTime(endTime))
                .replace("%6", time2date(startTime, 20))
                .replace("%s", time2date(startTime, 11))
            );
            if (prevTiming) {
              const { startTime: pStartTime, endTime: pEndTime } = prevTiming;
              if (converted) {
                res.push(this._parseOccurrence(prevTiming, mode, occurrence));
              } else {
                res.push(
                  string
                    .replace("%1", toLocaleTime(pStartTime))
                    .replace("%2", toLocaleTime(pEndTime))
                    .replace("%6", time2date(pStartTime, 20))
                    .replace("%s", time2date(pStartTime, 11))
                );
              }
            }
          }
          return res;
        }
        _parseOccurrence(timeRules, mode, occurrence) {
          const { startTime, endTime, days, dayInt, interval, month, recurEnd, skipDay } = timeRules;
          const { recur, once } = this.OCCUR_STRINGS;
          const occurrenceEnd = recurEnd ? "limited" : "continuous";
          let string = "";
          if (recur[mode]) {
            return occurrence
              ? recur[mode].occur
                  .replace("%1", toLocaleTime(startTime))
                  .replace("%2", toLocaleTime(endTime))
                  .replace("%s", time2date(startTime, 11))
              : recur[mode].all;
          } else if (month) {
            const { count, occur } = month;
            string =
              count < 0
                ? mega.icu.format(recur.monthly[occurrenceEnd].last[occur], interval)
                : mega.icu.format(recur.monthly[occurrenceEnd].pos[count][occur], interval);
            return string
              .replace("%1", toLocaleTime(startTime))
              .replace("%2", toLocaleTime(endTime))
              .replace("%3", time2date(startTime, 2))
              .replace("%4", time2date(recurEnd, 2));
          } else if (days) {
            if (days.length > 1) {
              if (days.length === 7) {
                return recur.daily[occurrenceEnd].occur
                  .replace("%1", toLocaleTime(startTime))
                  .replace("%2", toLocaleTime(endTime))
                  .replace("%3", time2date(startTime, 2))
                  .replace("%4", time2date(recurEnd, 2));
              }
              const weekDays = days.map((day, idx) => {
                if (idx) {
                  return this.midDayStrings[day];
                }
                return this.startDayStrings[day];
              });
              string = mega.icu.format(recur.weekly[occurrenceEnd].list, interval);
              string = mega.utils.trans.listToString(weekDays, string);
            } else {
              string = mega.icu.format(recur.weekly[occurrenceEnd].spec, interval).replace("%s", this.startDayStrings[days[0]]);
            }
            return string
              .replace("%1", toLocaleTime(startTime))
              .replace("%2", toLocaleTime(endTime))
              .replace("%3", time2date(startTime, 2))
              .replace("%4", time2date(recurEnd, 2));
          } else if (dayInt) {
            string = mega.icu.format(recur.monthly[occurrenceEnd].num, interval);
            return string
              .replace("%1", toLocaleTime(startTime))
              .replace("%2", toLocaleTime(endTime))
              .replace("%3", time2date(startTime, 2))
              .replace("%4", time2date(recurEnd, 2))
              .replace("%5", dayInt);
          } else if (skipDay) {
            string = mega.icu.format(recur.daily[occurrenceEnd].skip, interval);
            return string
              .replace("%1", toLocaleTime(startTime))
              .replace("%2", toLocaleTime(endTime))
              .replace("%3", time2date(startTime, 2))
              .replace("%4", time2date(recurEnd, 2));
          }
          string = once[mode].occur;
          return string
            .replace("%1", toLocaleTime(startTime))
            .replace("%2", toLocaleTime(endTime))
            .replace("%6", time2date(startTime, 20))
            .replace("%s", time2date(startTime, 11));
        }
        getFormattingMeta(scheduledId, data, chatRoom) {
          const { MODE } = scheduleMetaChange["default"];
          const meta = {
            userId: data.sender || false,
            timeRules: {},
            mode: MODE.EDITED,
            handle: scheduledId,
            cid: chatRoom.chatId
          };
          const changeSet = data.schedChange || data.cs || false;
          if (changeSet) {
            const { s, e, c, r, t, d: desc } = changeSet;
            let onlyTitle = typeof t !== "undefined";
            if (Array.isArray(c) && c[1]) {
              meta.mode = MODE.CANCELLED;
            }
            if (Array.isArray(s)) {
              meta.prevTiming = {
                startTime: s[0]
              };
              meta.timeRules.startTime = s[1] || s[0];
            }
            if (Array.isArray(e)) {
              meta.prevTiming.endTime = e[0];
              meta.timeRules.endTime = e[1] || e[0];
              onlyTitle = false;
            }
            if (desc) {
              meta.description = true;
              onlyTitle = false;
            }
            if (Array.isArray(r)) {
              const parseR = (r) => (r ? (typeof r === "string" ? JSON.parse(r) : r) : false);
              const prev = parseR(r[0]);
              const next = parseR(r[1]);
              if (r.length === 1) {
                meta.converted = false;
                meta.timeRules = this._recurringTimings(prev, meta.timeRules || {});
                meta.prevTiming = this._recurringTimings(prev, meta.prevTiming);
                meta.recurring = r[0] !== "";
              } else {
                meta.converted = !!(!!prev ^ !!next);
                if (prev) {
                  meta.prevTiming = this._recurringTimings(prev, meta.prevTiming || {});
                }
                meta.timeRules = this._recurringTimings(next, meta.timeRules || {});
                meta.recurring = next !== false;
              }
              onlyTitle = false;
            }
            const meeting = this.getMeetingOrOccurrenceParent(scheduledId);
            if (!meeting || meeting.id !== scheduledId) {
              meta.occurrence = true;
              meta.recurring = true;
            }
            if (Array.isArray(t)) {
              meta.topicChange = true;
              meta.onlyTitle = onlyTitle;
              meta.topic = this.decodeData(t[1]);
              meta.oldTopic = this.decodeData(t[0]);
            }
            return meta;
          }
          return this.noCsMeta(scheduledId, data, chatRoom);
        }
        _recurringTimings(meta, obj) {
          if (!meta) {
            return obj;
          }
          obj.recurEnd = meta.u || false;
          obj.interval = meta.i || 1;
          if (meta.wd) {
            obj.days = meta.wd.sort((a, b) => a - b).map((wd) => (wd === 7 ? 0 : wd));
          }
          if (meta.md) {
            obj.dayInt = meta.md[0];
          }
          if (meta.mwd) {
            obj.month = meta.mwd.map((oc) => {
              return {
                count: (oc[0] || 1) - 1,
                occur: oc[1] ? (oc[1] === 7 ? 0 : oc[1]) : 1
              };
            })[0];
          }
          if (meta.f === "d" && meta.i > 1) {
            obj.skipDay = true;
          } else if (meta.f === "d" && meta.i === 1) {
            obj.days = [1, 2, 3, 4, 5, 6, 0];
          }
          return obj;
        }
        noCsMeta(scheduledId, data, chatRoom) {
          const meta = {
            timeRules: {},
            userId: data.sender || false,
            ap: data,
            handle: scheduledId,
            cid: chatRoom.chatId
          };
          if (!this.getMeetingOrOccurrenceParent(scheduledId) && !chatRoom.scheduledMeeting) {
            const res = this._checkOccurrenceAwait(chatRoom, scheduledId, meta);
            if (res) {
              return res;
            }
          }
          const meeting = this.getMeetingOrOccurrenceParent(scheduledId) || chatRoom.scheduledMeeting;
          assert(meeting, `Invalid scheduled meeting state for ${scheduledId} msg`);
          const toS = (ms) => Math.floor(ms / 1000);
          const { MODE } = scheduleMetaChange["default"];
          meta.timeRules.startTime = toS(meeting.start);
          meta.timeRules.endTime = toS(meeting.end);
          meta.topic = meeting.title;
          meta.recurring = !!meeting.recurring;
          meta.mode = meeting.canceled ? MODE.CANCELLED : MODE.CREATED;
          meta.occurrence = meta.recurring && meeting.id !== scheduledId;
          if (!meta.occurrence && !meeting.canceled) {
            meta.mode = MODE.CREATED;
          }
          const cal = (ms) => {
            const date = new Date(ms);
            return {
              date: date.getDate(),
              month: time2date(toS(ms), 12)
            };
          };
          if (meta.occurrence) {
            const occurrences = meeting.getOccurrencesById(scheduledId);
            if (!occurrences) {
              meta.mode = MODE.EDITED;
              const res = this._checkOccurrenceAwait(chatRoom, scheduledId, meta);
              if (res) {
                return res;
              }
              meta.ap = data;
              return meta;
            }
            meta.mode = occurrences.some((o) => o.canceled) ? MODE.CANCELLED : MODE.EDITED;
            meta.calendar = cal(occurrences[0].start);
            const timeDiff = meta.timeRules.endTime - meta.timeRules.startTime;
            meta.timeRules.startTime = toS(occurrences[0].start);
            meta.timeRules.endTime = toS(occurrences[0].end);
            if (occurrences.length === 1 && occurrences[0].startInitial) {
              meta.prevTiming = {
                startTime: toS(occurrences[0].startInitial)
              };
              meta.prevTiming.endTime = meta.prevTiming.startTime + timeDiff;
            }
          } else if (meta.recurring) {
            const { end, weekDays = [], interval, monthDays = [], offset, frequency } = meeting.recurring;
            meta.recurring = true;
            meta.timeRules.recurEnd = end ? toS(end) : false;
            meta.timeRules.interval = interval || 1;
            if (frequency === "d" && interval > 1) {
              meta.timeRules.skipDay = true;
            } else if (frequency === "d" && interval === 1) {
              meta.timeRules.days = [1, 2, 3, 4, 5, 6, 0];
            }
            if (weekDays.length) {
              meta.timeRules.days = weekDays.sort((a, b) => a - b).map((wd) => (wd === 7 ? 0 : wd));
            }
            if (monthDays.length) {
              meta.timeRules.dayInt = monthDays[0];
            }
            if (!Array.isArray(offset)) {
              meta.timeRules.month = {
                count: (offset.value || 1) - 1,
                occur: offset.weekDay ? (offset.weekDay === 7 ? 0 : offset.weekDay) : 1
              };
            }
            meta.calendar = cal(meeting.start);
          } else {
            meta.calendar = cal(meeting.start);
          }
          if (!meta.occurrence && meeting.canceled && $.len(meta.timeRules)) {
            meta.mode = MODE.CREATED;
          }
          delete meta.ap;
          return meta;
        }
        _checkOccurrenceAwait(chatRoom, scheduledId, meta) {
          if (!this._goneOccurrences[chatRoom.chatId]) {
            this._goneOccurrences[chatRoom.chatId] = {};
          }
          if (typeof this._goneOccurrences[chatRoom.chatId][scheduledId] === "undefined") {
            this._goneOccurrences[chatRoom.chatId][scheduledId] = -1;
            return meta;
          }
          const datum = this._goneOccurrences[chatRoom.chatId];
          if (datum[scheduledId] === -1) {
            return meta;
          } else if (datum[scheduledId] === 1) {
            meta.gone = true;
            return meta;
          }
          return false;
        }
        areMetaObjectsSame(obj1, obj2) {
          if ((obj1 && !obj2) || (!obj1 && obj2)) {
            return false;
          }
          const keys = Object.keys(obj1);
          if (keys.length !== $.len(obj2)) {
            return false;
          }
          const diff = array.diff(keys, Object.keys(obj2));
          if (diff.removed.length + diff.added.length) {
            return false;
          }
          for (const key of keys) {
            if (!obj2.hasOwnProperty(key)) {
              return false;
            }
            if (obj1[key] instanceof Object && obj2[key] instanceof Object) {
              if (!this.areMetaObjectsSame(obj1[key], obj2[key])) {
                return false;
              }
            } else if (Array.isArray(obj1[key]) && Array.isArray(obj2[key])) {
              const keyDiff = array.diff(obj1[key], obj2[key]);
              if (keyDiff.removed.length + keyDiff.added.length) {
                return false;
              }
            } else if (obj1[key] !== obj2[key]) {
              return false;
            }
          }
          return true;
        }
      }
      const meetingsManager = MeetingsManager;
      window.MeetingsManager = MeetingsManager;
      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js
      var applyDecoratedDescriptor = __webpack_require__(229);
      // EXTERNAL MODULE: ./js/chat/mixins.js
      var mixins = __webpack_require__(503); // CONCATENATED MODULE: ./js/chat/chatOnboarding.jsx
      var _dec, chatOnboarding_class;

      let ChatOnboarding =
        ((_dec = (0, mixins.M9)(1000)),
        ((chatOnboarding_class = class ChatOnboarding {
          constructor(megaChat) {
            this.finished = false;
            this.currentChatIsScheduled = false;
            if (u_type === 3 && !is_mobile) {
              this.scheduledOccurrencesMap = {
                flag: OBV4_FLAGS.CHAT_SCHEDULE_OCCUR,
                actions: [
                  {
                    type: "showDialog",
                    dialogClass: "mcob",
                    dialogTitle: l.onboard_megachat_dlg7b_title,
                    dialogDesc: l.onboard_megachat_dlg7b_text,
                    targetElmClass: `.conversationsApp .conversation-panel:not(.hidden)
                                 .chatroom-occurrences-panel .chat-dropdown.header`,
                    targetElmPosition: "left",
                    ignoreBgClick: true,
                    markComplete: true
                  }
                ]
              };
              this.feedbackMap = {
                flag: OBV4_FLAGS.CHAT_FEEDBACK_NEW,
                actions: [
                  {
                    type: "showDialog",
                    dialogClass: "mcob",
                    dialogTitle: l.onboard_megachat_dlg10_title,
                    dialogDesc: l.onboard_megachat_dlg10_text,
                    targetElmClass: "#fmholder button.js-more-menu.js-top-buttons",
                    targetElmPosition: "left bottom",
                    targetHotSpot: true,
                    markComplete: true,
                    skipHidden: true,
                    ignoreBgClick: ".conversationsApp",
                    dialogNext: l[726]
                  }
                ]
              };
              this.state = {
                [OBV4_FLAGS.CHAT]: -1,
                [OBV4_FLAGS.CHAT_SCHEDULE_NEW]: -1,
                [OBV4_FLAGS.CHAT_SCHEDULE_ADDED]: -1,
                [OBV4_FLAGS.CHAT_SCHEDULE_OCCUR]: -1,
                [OBV4_FLAGS.CHAT_SCHEDULE_CONF]: -1,
                [OBV4_FLAGS.CHAT_FEEDBACK_NEW]: -1,
                [OBV4_FLAGS.CHAT_CONTACT_PANE]: -1
              };
              this.actions = {
                [OBV4_FLAGS.CHAT_SCHEDULE_OCCUR]: null,
                [OBV4_FLAGS.CHAT_FEEDBACK_NEW]: null
              };
              this.megaChat = megaChat;
              this.flagMap = attribCache.bitMapsManager.exists("obv4")
                ? attribCache.bitMapsManager.get("obv4")
                : new MegaDataBitMap("obv4", false, Object.values(OBV4_FLAGS));
              const keys = Object.keys(this.state);
              const promises = keys.map((key) => this.flagMap.get(key));
              Promise.allSettled(promises).then((res) => {
                for (let i = 0; i < res.length; ++i) {
                  const v = res[i];
                  if (v.status === "fulfilled") {
                    this.handleFlagChange(null, null, keys[i], v.value);
                  }
                }
              });
              this.interval = setInterval(() => {
                if (!$.dialog) {
                  this._checkAndShowStep();
                }
              }, 10000);
              this.initListeners();
            }
          }
          initListeners() {
            this.flagMap.addChangeListener((...args) => this.handleFlagChange(...args));
            this.megaChat.chatUIFlags.addChangeListener(
              SoonFc(200, () => {
                if (this.megaChat.chatUIFlags.convPanelCollapse && $.dialog === "onboardingDialog") {
                  closeDialog();
                }
                this._checkAndShowStep();
              })
            );
            this.megaChat.addChangeListener(() => {
              const room = this.megaChat.getCurrentRoom();
              if (!room) {
                return;
              }
              if (
                $.dialog === "onboardingDialog" &&
                ((this.currentChatIsScheduled && !room.scheduledMeeting) || this.occurrenceDialogShown ^ this.willShowOccurrences)
              ) {
                closeDialog();
              }
              this.currentChatIsScheduled = !!room.scheduledMeeting;
              this.checkAndShowStep();
            });
            this.schedListeners = [
              `${this.megaChat.plugins.meetingsManager.EVENTS.INITIALIZE}.chatonboard`,
              `${this.megaChat.plugins.meetingsManager.EVENTS.OCCURRENCES_UPDATE}.chatonboard`
            ];
            for (const event of this.schedListeners) {
              this.megaChat.rebind(event, () => this.handleNewScheduledMeeting());
            }
          }
          handleNewScheduledMeeting() {
            if (this.state[OBV4_FLAGS.CHAT_SCHEDULE_NEW] !== 1) {
              this.flagMap.set(OBV4_FLAGS.CHAT_SCHEDULE_NEW, 1).always(() => {
                this.flagMap.safeCommit();
                if ($.dialog === "onboardingDialog") {
                  closeDialog();
                }
                this.checkAndShowStep();
              });
            }
            for (const event of this.schedListeners) {
              this.megaChat.off(event);
            }
            if (M.chat && megaChatIsReady) {
              this.checkAndShowStep();
            }
            delete this.schedListeners;
          }
          showOccurrencesDialog() {
            if (this.state[OBV4_FLAGS.CHAT_SCHEDULE_CONF] === 1) {
              this.scheduledOccurrencesMap.actions[0].skipHidden = true;
              this.scheduledOccurrencesMap.actions[0].dialogNext = l[81];
              if (
                this.actions[OBV4_FLAGS.CHAT_SCHEDULE_OCCUR] &&
                typeof this.actions[OBV4_FLAGS.CHAT_SCHEDULE_OCCUR].map.skipHidden === "undefined"
              ) {
                delete this.actions[OBV4_FLAGS.CHAT_SCHEDULE_OCCUR];
              }
            }
            if (!this.actions[OBV4_FLAGS.CHAT_SCHEDULE_OCCUR]) {
              const parent = {
                markDone: () => {
                  this.flagMap.set(OBV4_FLAGS.CHAT_SCHEDULE_OCCUR, 1).always(() => {
                    this.flagMap.safeCommit();
                    this.occurrenceDialogShown = false;
                    this.checkAndShowStep();
                  });
                },
                markDeactive: () => {
                  this.occurrenceDialogShown = false;
                },
                toNextAction: nop,
                $obControlPanel: $(".onboarding-control-panel", fmholder),
                parentSection: {
                  showConfirmDismiss: () => {
                    this.flagMap.setSync(OBV4_FLAGS.CHAT_SCHEDULE_OCCUR, 1);
                    this.flagMap.commit().always(() => {
                      this.flagMap.setSync(OBV4_FLAGS.CHAT, 1);
                      this.flagMap.safeCommit();
                    });
                  },
                  startNextOpenSteps: nop,
                  hotspotNextStep: nop,
                  parent: {}
                }
              };
              this.actions[OBV4_FLAGS.CHAT_SCHEDULE_OCCUR] = new OnboardV4Action(parent, this.scheduledOccurrencesMap.actions[0]);
            }
            if ($.dialog === "onboardingDialog") {
              closeDialog();
            }
            $(".chat-dropdown.header:not(.expanded)", ".chatroom-occurrences-panel").filter(":visible").click();
            this.actions[OBV4_FLAGS.CHAT_SCHEDULE_OCCUR].execute();
            this.occurrenceDialogShown = true;
          }
          showNewUserFeedbackDialog() {
            if (!this.actions[OBV4_FLAGS.CHAT_FEEDBACK_NEW]) {
              const parent = {
                markDone: () => {
                  this.flagMap.set(OBV4_FLAGS.CHAT_FEEDBACK_NEW, 1).always(() => {
                    this.flagMap.safeCommit();
                    delete mega.ui.onboarding.$hotSpotNode;
                    this.checkAndShowStep();
                  });
                },
                markDeactive: () => {
                  delete mega.ui.onboarding.$hotSpotNode;
                },
                toNextAction: nop,
                $obControlPanel: $(".onboarding-control-panel", fmholder),
                parentSection: {
                  showConfirmDismiss: nop,
                  startNextOpenSteps: nop,
                  hotspotNextStep: nop,
                  parent: {}
                }
              };
              this.actions[OBV4_FLAGS.CHAT_FEEDBACK_NEW] = new OnboardV4Action(parent, this.feedbackMap.actions[0]);
            }
            if ($.dialog === "onboardingDialog") {
              closeDialog();
            }
            this.actions[OBV4_FLAGS.CHAT_FEEDBACK_NEW].execute();
            mega.ui.onboarding.$hotSpotNode = $(this.feedbackMap.actions[0].targetElmClass);
          }
          checkAndShowStep() {
            this._checkAndShowStep();
          }
          _shouldSkipShow() {
            if (!M.chat || !mega.ui.onboarding || $.dialog || loadingDialog.active || u_type < 3 || is_mobile || $.msgDialog) {
              return true;
            }
            this.$topRightMenu = this.$topRightMenu || $(".top-menu-popup", "#topmenu");
            if (!this.$topRightMenu.hasClass("o-hidden")) {
              return true;
            }
            this.$topAccDropdown = this.$topAccDropdown || $(".js-dropdown-account", "#topmenu");
            if (this.$topAccDropdown.hasClass("show")) {
              return true;
            }
            this.$topNotifDropdown = this.$topNotifDropdown || $(".js-dropdown-notification", "#topmenu");
            if (this.$topNotifDropdown.hasClass("show")) {
              return true;
            }
            this.$searchPanel = this.$searchPanel || $(".search-panel", ".conversationsApp");
            return this.$searchPanel.hasClass("expanded");
          }
          _checkAndShowStep() {
            if (this._shouldSkipShow()) {
              return;
            }
            const { sections } = mega.ui.onboarding;
            if (!sections) {
              return;
            }
            const { chat: obChat } = sections;
            if (!obChat) {
              return;
            }
            if (this.state[OBV4_FLAGS.CHAT_FEEDBACK_NEW] !== 1 && this.state[OBV4_FLAGS.CHAT_CONTACT_PANE] === 1) {
              this.showNewUserFeedbackDialog();
              return;
            }
            const room = this.megaChat.getCurrentRoom();
            if (
              room &&
              room.scheduledMeeting &&
              room.scheduledMeeting.recurring &&
              this.state[OBV4_FLAGS.CHAT_SCHEDULE_ADDED] === 1 &&
              this.state[OBV4_FLAGS.CHAT_SCHEDULE_OCCUR] !== 1 &&
              !this.megaChat.chatUIFlags.convPanelCollapse
            ) {
              this.showOccurrencesDialog();
              return;
            }
            if (this.state[OBV4_FLAGS.CHAT]) {
              return;
            }
            this.showDefaultNextStep(obChat);
          }
          showDefaultNextStep(obChat) {
            const nextIdx = obChat.searchNextOpenStep();
            if (
              nextIdx !== false &&
              (!this.$obDialog || !this.$obDialog.is(":visible")) &&
              (this.obToggleDrawn || $(".toggle-panel-heading", ".conversationsApp").length)
            ) {
              this.obToggleDrawn = true;
              if (obChat.steps && obChat.steps[nextIdx] && obChat.steps[nextIdx].isComplete) {
                return;
              }
              if (!megaChat.hasSupportForCalls && obChat.steps[nextIdx].map.flag === OBV4_FLAGS.CHAT_SCHEDULE_START) {
                this.flagMap.isReady().always(() => {
                  this.flagMap.setSync(OBV4_FLAGS.CHAT_SCHEDULE_START, 1);
                  this.flagMap.safeCommit();
                  this._checkAndShowStep();
                });
                return;
              }
              if (
                obChat.steps[nextIdx].map.flag === OBV4_FLAGS.CHAT_SCHEDULE_ADDED &&
                this.hasDisplayableScheduleMeeting &&
                !this.isMeetingsTab
              ) {
                this.megaChat.trigger(conversations.FP.NAV_RENDER_VIEW, conversations.nk.MEETINGS);
              }
              const res = obChat.startNextOpenSteps(nextIdx);
              if (obChat.steps[nextIdx].map.flag === OBV4_FLAGS.CHAT_SCHEDULE_CONF && res !== false) {
                $(".chat-dropdown.header:not(.expanded)", ".chatroom-options-panel").filter(":visible").click();
              }
              this.$obDialog = this.$obDialog || $("#ob-dialog");
            }
          }
          handleFlagChange(...args) {
            if (args.length >= 4 && typeof args[2] === "string" && typeof args[3] === "number" && this.state.hasOwnProperty(args[2])) {
              if (d) {
                console.debug(`Chat onboarding flag ${args[2]}: ${this.state[args[2]]} -> ${args[3]}`);
              }
              this.state[args[2]] = args[3];
              if (args[2] === OBV4_FLAGS.CHAT && args[3] === 1 && this.interval) {
                clearInterval(this.interval);
                delete this.interval;
              }
            }
          }
          get hasDisplayableScheduleMeeting() {
            return !!Object.values(this.megaChat.chats.toJS()).filter(
              (c) => c.isDisplayable() && c.isMeeting && c.scheduledMeeting && c.scheduledMeeting.isUpcoming
            ).length;
          }
          get isMeetingsTab() {
            this.$meetingsTab = this.$meetingsTab || $(".lhp-nav .lhp-meetings-tab", ".conversationsApp");
            return this.$meetingsTab.hasClass("active");
          }
          get willShowOccurrences() {
            if (!this.currentChatIsScheduled) {
              return false;
            }
            if (this.state[OBV4_FLAGS.CHAT_SCHEDULE_OCCUR] === 1) {
              return false;
            }
            if (this.state[OBV4_FLAGS.CHAT_SCHEDULE_ADDED] === 0) {
              return false;
            }
            return !!this.megaChat.getCurrentRoom().scheduledMeeting.recurring;
          }
          get canShowScheduledNew() {
            return this.state[OBV4_FLAGS.CHAT_FEEDBACK_NEW] === 1 && this.state[OBV4_FLAGS.CHAT_CONTACT_PANE] === 1;
          }
          destroy() {
            if (this.interval) {
              clearInterval(this.interval);
              delete this.interval;
            }
            if (this.schedListeners) {
              for (const event of this.schedListeners) {
                this.megaChat.off(event);
              }
              delete this.schedListeners;
            }
          }
        }),
        (0, applyDecoratedDescriptor.Z)(
          chatOnboarding_class.prototype,
          "checkAndShowStep",
          [_dec],
          Object.getOwnPropertyDescriptor(chatOnboarding_class.prototype, "checkAndShowStep"),
          chatOnboarding_class.prototype
        ),
        chatOnboarding_class));

      // EXTERNAL MODULE: ./js/chat/ui/meetings/call.jsx + 23 modules
      var call = __webpack_require__(689); // CONCATENATED MODULE: ./js/chat/chat.jsx
      __webpack_require__(62);
      __webpack_require__(804);
      __webpack_require__(336);

      const EMOJI_DATASET_VERSION = 5;
      const CHAT_ONHISTDECR_RECNT = "onHistoryDecrypted.recent";
      const LOAD_ORIGINALS = {
        "image/gif": 25e6,
        "image/png": 2e5,
        "image/webp": 2e5
      };
      var CHATUIFLAGS_MAPPING = {
        convPanelCollapse: "cPC"
      };
      function Chat() {
        var self = this;
        this.is_initialized = false;
        this.logger = MegaLogger.getLogger("chat");
        this.mbListeners = [];
        this.chats = new MegaDataMap();
        this.scheduledMeetings = new MegaDataMap();
        this.chatUIFlags = new MegaDataMap();
        this.initChatUIFlagsManagement();
        this.currentlyOpenedChat = null;
        this.currentlyOpenedView = null;
        this.lastOpenedChat = null;
        this.archivedChatsCount = 0;
        this.FORCE_EMAIL_LOADING = localStorage.fel;
        this._imageLoadCache = Object.create(null);
        this._imagesToBeLoaded = Object.create(null);
        this._imageAttributeCache = Object.create(null);
        this._queuedMccPackets = [];
        this._queuedMcsmPackets = {};
        this._queuedMessageUpdates = [];
        this._queuedChatRoomEvents = Object.create(null);
        this.handleToId = Object.create(null);
        this.publicChatKeys = Object.create(null);
        this.SOUNDS = {
          ALERT: "alert_info_message",
          ERROR: "error_message",
          INCOMING_MSG: "incoming_chat_message",
          INCOMING_CONTACT: "incoming_contact_request",
          INCOMING_FILE: "incoming_file_transfer",
          INCOMING_CALL: "incoming_voice_video_call",
          HANG_OUT: "hang_out",
          CALL_JOIN: "user_join_call",
          CALL_LEFT: "user_left_call",
          CALL_END: "end_call",
          CALL_JOIN_WAITING: "user_join_waiting",
          RECONNECT: "reconnecting"
        };
        this.options = {
          delaySendMessageIfRoomNotAvailableTimeout: 3000,
          plugins: {
            chatdIntegration: ChatdIntegration,
            callManager2: CallManager2,
            urlFilter: UrlFilter,
            emoticonShortcutsFilter: EmoticonShortcutsFilter,
            emoticonsFilter: EmoticonsFilter,
            callFeedback: CallFeedback,
            presencedIntegration: PresencedIntegration,
            persistedTypeArea: PersistedTypeArea,
            btRtfFilter: BacktickRtfFilter,
            rtfFilter: RtfFilter,
            richpreviewsFilter: RichpreviewsFilter,
            chatToastIntegration: ChatToastIntegration,
            chatStats: ChatStats,
            geoLocationLinks: GeoLocationLinks,
            meetingsManager: meetingsManager,
            chatOnboarding: ChatOnboarding
          },
          chatNotificationOptions: {
            textMessages: {
              "incoming-chat-message": {
                title: l.notif_title_incoming_msg,
                icon: function (notificationObj) {
                  return notificationObj.options.icon;
                },
                body: function (notificationObj, params) {
                  return l.notif_body_incoming_msg.replace("%s", params.from);
                }
              },
              "incoming-attachment": {
                title: l.notif_title_incoming_attch,
                icon: function (notificationObj) {
                  return notificationObj.options.icon;
                },
                body: function (notificationObj, params) {
                  return mega.icu.format(l.notif_body_incoming_attch, params.attachmentsCount).replace("%s", params.from);
                }
              },
              "incoming-voice-video-call": {
                title: l[17878] || "Incoming call",
                icon: function (notificationObj) {
                  return notificationObj.options.icon;
                },
                body: function (notificationObj, params) {
                  return l[5893].replace("[X]", params.from);
                }
              },
              "call-terminated": {
                title: l.notif_title_call_term,
                icon: function (notificationObj) {
                  return notificationObj.options.icon;
                },
                body: function (notificationObj, params) {
                  return l[5889].replace("[X]", params.from);
                }
              },
              "screen-share-error": {
                title: l.screenshare_failed_notif || "You are no longer sharing your screen",
                icon: (notificationObj) => {
                  return notificationObj.options.icon;
                },
                body: ""
              },
              "upcoming-scheduled-occurrence": {
                title: ({ options }) => {
                  return options.meeting.title;
                },
                icon: `${staticpath}/images/mega/mega-icon.svg`,
                body: l.notif_body_scheduled_upcoming
              },
              "starting-scheduled-occurrence": {
                title: ({ options }) => {
                  return options.meeting.title;
                },
                icon: `${staticpath}/images/mega/mega-icon.svg`,
                body: l.notif_body_scheduled_starting
              }
            },
            sounds: Object.values(this.SOUNDS)
          },
          chatStoreOptions: {
            autoPurgeMaxMessagesPerRoom: 1024
          }
        };
        this.plugins = {};
        self.filePicker = null;
        self._chatsAwaitingAps = {};
        MegaDataObject.call(this, {
          currentlyOpenedChat: null,
          activeCall: null,
          routingSection: null,
          routingSubSection: null,
          routingParams: null
        });
        this.routing = new ChatRouting(this);
        Object.defineProperty(this, "hasSupportForCalls", {
          get: function () {
            return (
              typeof SfuClient !== "undefined" &&
              typeof TransformStream !== "undefined" &&
              window.RTCRtpSender &&
              !!RTCRtpSender.prototype.createEncodedStreams
            );
          }
        });
        this.minuteClockInterval = setInterval(() => {
          this._syncChats();
        }, 6e4);
        return this;
      }
      inherits(Chat, MegaDataObject);
      Object.defineProperty(Chat, "mcf", {
        value: Object.create(null)
      });
      Object.defineProperty(Chat, "mcsm", {
        value: Object.create(null)
      });
      Chat.prototype.init = promisify(function (resolve, reject) {
        var self = this;
        if (self.is_initialized) {
          self.destroy();
        }
        if (d) {
          console.time("megachat:plugins:init");
        }
        self.plugins = Object.create(null);
        self.plugins.chatNotifications = new ChatNotifications(self, self.options.chatNotificationOptions);
        self.plugins.chatNotifications.notifications.rebind("onAfterNotificationCreated.megaChat", function () {
          self.updateSectionUnreadCount();
        });
        Object.keys(self.options.plugins).forEach((plugin) => {
          self.plugins[plugin] = new self.options.plugins[plugin](self);
        });
        if (d) {
          console.timeEnd("megachat:plugins:init");
        }
        var $body = $(document.body);
        $body.rebind("mousedown.megachat", ".top-user-status-popup .dropdown-item", function () {
          var presence = $(this).data("presence");
          self._myPresence = presence;
          var targetPresence = PresencedIntegration.cssClassToPresence(presence);
          self.plugins.presencedIntegration.setPresence(targetPresence);
          if (targetPresence !== UserPresence.PRESENCE.OFFLINE) {
            Object.keys(self.plugins.chatdIntegration.chatd.shards).forEach(function (k) {
              var v = self.plugins.chatdIntegration.chatd.shards[k];
              v.connectionRetryManager.requiresConnection();
            });
          }
        });
        self.$container = $(".fm-chat-block");
        if (!is_chatlink) {
          $(".activity-status-block, .activity-status").removeClass("hidden");
          $(".js-dropdown-account .status-dropdown").removeClass("hidden");
        }
        $body.rebind("mouseover.notsentindicator", ".tooltip-trigger", function () {
          var $this = $(this);
          var $notification = $(".tooltip." + $this.attr("data-tooltip")).removeClass("hidden");
          var iconTopPos = $this.offset().top;
          var iconLeftPos = $this.offset().left;
          var notificatonHeight = $notification.outerHeight() + 10;
          var notificatonWidth = $notification.outerWidth() / 2 - 10;
          $notification.offset({
            top: iconTopPos - notificatonHeight,
            left: iconLeftPos - notificatonWidth
          });
        });
        $body.rebind("mouseout.notsentindicator click.notsentindicator", ".tooltip-trigger", function () {
          var $notification = $(".tooltip");
          $notification.addClass("hidden").removeAttr("style");
        });
        if (is_chatlink) {
          const { ph, key } = is_chatlink;
          Chat.mcf[ph] = key;
          this.publicChatKeys[ph] = key;
        }
        const promises = [];
        const rooms = Object.keys(Chat.mcf);
        for (let i = rooms.length; i--; ) {
          const roomId = rooms[i];
          const room = Chat.mcf[roomId];
          if (!this.publicChatKeys[rooms[i]]) {
            promises.push(self.plugins.chatdIntegration.openChat(room, true));
          }
          delete Chat.mcf[rooms[i]];
        }
        Promise.allSettled(promises)
          .then(function (res) {
            const pub = Object.keys(self.publicChatKeys);
            return Promise.allSettled(
              [res].concat(
                pub.map((pch) => {
                  return self.plugins.chatdIntegration.openChat(pch, true);
                })
              )
            );
          })
          .then(function (res) {
            res = res[0].value.concat(res.slice(1));
            self.logger.info("chats settled...", res);
            if (is_mobile) {
              return;
            }
            self.$conversationsAppInstance = external_ReactDOM_default().render(
              (self.$conversationsApp = external_React_default().createElement(conversations.ZP.ConversationsApp, {
                megaChat: self,
                routingSection: self.routingSection,
                routingSubSection: self.routingSubSection,
                routingParams: self.routingParams
              })),
              (self.domSectionNode = document.querySelector(
                !is_chatlink ? ".section.conversations" : ".chat-links-preview > .chat-app-container"
              ))
            );
            self
              .onChatsHistoryReady()
              .then(() => {
                const room = self.getCurrentRoom();
                if (room) {
                  room.scrollToChat();
                }
                return room;
              })
              .dump("on-chat-history-loaded");
            self.is_initialized = true;
            self.registerUploadListeners();
            self.trigger("onInit");
            mBroadcaster.sendMessage("chat_initialized");
            setInterval(self.removeMessagesByRetentionTime.bind(self, null), 2e4);
            self.autoJoinIfNeeded();
            const scheduledMeetings = Object.values(Chat.mcsm);
            if (scheduledMeetings && scheduledMeetings.length) {
              for (let i = scheduledMeetings.length; i--; ) {
                const scheduledMeeting = scheduledMeetings[i];
                self.plugins.meetingsManager.attachMeeting(scheduledMeeting);
                delete Chat.mcsm[scheduledMeeting.id];
              }
            }
            if (notify) {
              notify.countAndShowNewNotifications();
            }
            return true;
          })
          .then(resolve)
          .catch(reject);
      });
      Chat.prototype.showUpgradeDialog = function () {
        return is_extension
          ? msgDialog("warningb", l[1900], l[8841])
          : msgDialog("confirmation", l[1900], l[8840], "", (cb) => cb && location.reload());
      };
      Chat.prototype._syncChats = function () {
        if (!this.is_initialized) {
          return;
        }
        this.plugins.meetingsManager.checkForNotifications();
        const { chats, logger } = this;
        if (chats && chats.length) {
          chats.forEach(({ chatId, scheduledMeeting }) => {
            const dnd = pushNotificationSettings.getDnd(chatId);
            if (dnd && dnd < unixtime()) {
              pushNotificationSettings.disableDnd(chatId);
              if (logger) {
                logger.debug(`Chat.prototype._syncDnd chatId=${chatId}`);
              }
            }
            const { isUpcoming, chatRoom, id } = scheduledMeeting || {};
            if (isUpcoming) {
              scheduledMeeting.setNextOccurrence();
              chatRoom.trackDataChange();
              if (logger) {
                logger.debug(`Chat.prototype.__syncScheduledMeetings id=${id} chatId=${chatId}`);
              }
            }
          });
        }
      };
      Chat.prototype.loadChatUIFlagsFromConfig = function (val) {
        var hadChanged = false;
        var flags = val || mega.config.get("cUIF");
        if (flags) {
          if (typeof flags !== "object") {
            flags = {};
          }
          Object.keys(CHATUIFLAGS_MAPPING).forEach((k) => {
            var v = flags[CHATUIFLAGS_MAPPING[k]];
            hadChanged = (v !== undefined && this.chatUIFlags.set(k, v) !== false) || hadChanged;
          });
        }
        return hadChanged;
      };
      Chat.prototype.cleanup = function (clean) {
        const room = this.getCurrentRoom();
        if (room) {
          room.hide();
        }
        const { $conversationsAppInstance: app } = this;
        if (app) {
          tryCatch(() => app.forceUpdate())();
        }
        M.chat = false;
        this.routingParams = null;
        this.routingSection = null;
        this.routingSubSection = null;
        if (clean) {
          M.currentdirid = page = false;
        }
      };
      Chat.prototype.initChatUIFlagsManagement = function () {
        var self = this;
        self.loadChatUIFlagsFromConfig();
        this.chatUIFlags.addChangeListener(function (hashmap, extraArg) {
          var flags = mega.config.get("cUIF") || {};
          var hadChanged = false;
          var hadLocalChanged = false;
          Object.keys(CHATUIFLAGS_MAPPING).forEach(function (k) {
            if (flags[CHATUIFLAGS_MAPPING[k]] !== self.chatUIFlags[k]) {
              if (extraArg === 0xdead) {
                self.chatUIFlags._data[k] = flags[CHATUIFLAGS_MAPPING[k]];
                hadLocalChanged = true;
              } else {
                flags[CHATUIFLAGS_MAPPING[k]] = self.chatUIFlags[k];
                hadChanged = true;
              }
            }
          });
          if (hadLocalChanged) {
            if (extraArg !== 0xdead) {
              self.chatUIFlags.trackDataChange(0xdead);
            }
            $.tresizer();
          }
          if (extraArg === 0xdead) {
            return;
          }
          if (hadChanged) {
            mega.config.set("cUIF", flags);
          }
        });
        this.mbListeners.push(
          mBroadcaster.addListener(
            "fmconfig:cUIF",
            tryCatch((v) => {
              if (self.loadChatUIFlagsFromConfig(v)) {
                self.chatUIFlags.trackDataChange(0xdead);
              }
            })
          ),
          mBroadcaster.addListener("statechange", (state) => {
            this.trigger("viewstateChange", state);
          })
        );
      };
      Chat.prototype.unregisterUploadListeners = function (destroy) {
        "use strict";

        var self = this;
        mBroadcaster.removeListener(self._uplDone);
        mBroadcaster.removeListener(self._uplError);
        mBroadcaster.removeListener(self._uplAbort);
        mBroadcaster.removeListener(self._uplFAError);
        mBroadcaster.removeListener(self._uplFAReady);
        if (destroy) {
          mBroadcaster.removeListener(self._uplStart);
        }
        delete self._uplError;
      };
      Chat.prototype.registerUploadListeners = function () {
        "use strict";

        var self = this;
        var logger = d && MegaLogger.getLogger("chatUploadListener", false, self.logger);
        self.unregisterUploadListeners(true);
        var forEachChat = function (chats, callback) {
          var result = 0;
          if (!Array.isArray(chats)) {
            chats = [chats];
          }
          for (var i = chats.length; i--; ) {
            var room = self.getRoomFromUrlHash(chats[i]);
            if (room) {
              callback(room, ++result);
            }
          }
          return result;
        };
        var lookupPendingUpload = function (id) {
          console.assert((id | 0) > 0 || String(id).length === 8, "Invalid lookupPendingUpload arguments...");
          for (var uid in ulmanager.ulEventData) {
            if (ulmanager.ulEventData[uid].faid === id || ulmanager.ulEventData[uid].h === id) {
              return uid;
            }
          }
        };
        var unregisterListeners = function () {
          if (!$.len(ulmanager.ulEventData)) {
            self.unregisterUploadListeners();
          }
        };
        var onUploadComplete = function (ul) {
          if (ulmanager.ulEventData[ul && ul.uid]) {
            forEachChat(ul.chat, function (room) {
              if (d) {
                logger.debug("Attaching node[%s] to chat room[%s]...", ul.h, room.chatId, ul.uid, ul, M.d[ul.h]);
              }
              room.attachNodes([ul.h]).catch(dump);
            });
            delete ulmanager.ulEventData[ul.uid];
            unregisterListeners();
          }
        };
        var onUploadCompletion = function (uid, handle, faid, chat) {
          if (!chat) {
            if (d > 1) {
              logger.debug("ignoring upload:completion that is unrelated to chat.", arguments);
            }
            return;
          }
          const n = M.getNodeByHandle(handle);
          const ul = ulmanager.ulEventData[uid] || false;
          if (d) {
            logger.info("upload:completion", uid, handle, faid, ul, n);
          }
          if (!ul) {
            if (d) {
              logger.error("Upload event data store missing...", uid, n, ul);
            }
          } else {
            ul.h = handle;
            if (ul.efa && !n) {
              logger.error("Invalid state, efa set on deduplication?", ul.efa, ul);
              ul.efa = 0;
            }
            if (ul.efa && (!n.fa || String(n.fa).split("/").length < ul.efa)) {
              ul.faid = faid;
              if (d) {
                logger.info("Waiting for file attribute to arrive.", handle, ul);
              }
            } else {
              onUploadComplete(ul);
            }
          }
        };
        var onUploadError = function (uid, error) {
          var ul = ulmanager.ulEventData[uid];
          if (d) {
            logger.debug(error === -0xdeadbeef ? "upload:abort" : "upload.error", uid, error, [ul]);
          }
          if (ul) {
            delete ulmanager.ulEventData[uid];
            unregisterListeners();
          }
        };
        var onAttributeReady = function (handle, fa) {
          delay("chat:fa-ready:" + handle, function () {
            var uid = lookupPendingUpload(handle);
            var ul = ulmanager.ulEventData[uid] || false;
            if (d) {
              logger.debug("fa:ready", handle, fa, uid, ul);
            }
            if (ul.h && String(fa).split("/").length >= ul.efa) {
              onUploadComplete(ul);
            } else if (d) {
              logger.debug("Not enough file attributes yet, holding...", ul);
            }
          });
        };
        var onAttributeError = function (faid, error, onStorageAPIError, nFAiled) {
          var uid = lookupPendingUpload(faid);
          var ul = ulmanager.ulEventData[uid] || false;
          if (d) {
            logger.debug("fa:error", faid, error, onStorageAPIError, uid, ul, nFAiled, ul.efa);
          }
          if (ul) {
            ul.efa = Math.max(0, ul.efa - nFAiled) | 0;
            if (ul.h) {
              const n = M.getNodeByHandle(ul.h);
              if (!ul.efa || (n.fa && String(n.fa).split("/").length >= ul.efa)) {
                onUploadComplete(ul);
              }
            }
          }
        };
        var registerLocalListeners = function () {
          self._uplError = mBroadcaster.addListener("upload:error", onUploadError);
          self._uplAbort = mBroadcaster.addListener("upload:abort", onUploadError);
          self._uplFAReady = mBroadcaster.addListener("fa:ready", onAttributeReady);
          self._uplFAError = mBroadcaster.addListener("fa:error", onAttributeError);
          self._uplDone = mBroadcaster.addListener("upload:completion", onUploadCompletion);
        };
        self._uplStart = mBroadcaster.addListener("upload:start", function (data) {
          if (d) {
            logger.info("onUploadStart", [data]);
          }
          var notify = function (room) {
            room.onUploadStart(data);
          };
          for (var k in data) {
            var chats = data[k].chat;
            if (chats && forEachChat(chats, notify) && !self._uplError) {
              registerLocalListeners();
            }
          }
        });
      };
      Chat.prototype.getRoomFromUrlHash = function (urlHash) {
        if (urlHash.indexOf("#") === 0) {
          urlHash = urlHash.subtr(1, urlHash.length);
        }
        if (urlHash.indexOf("chat/g/") > -1 || urlHash.indexOf("chat/c/") > -1) {
          var foundRoom = null;
          urlHash = urlHash.replace("chat/g/", "").replace("chat/c/", "");
          megaChat.chats.forEach(function (room) {
            if (!foundRoom && room.chatId === urlHash) {
              foundRoom = room;
            }
          });
          return foundRoom;
        } else if (urlHash.indexOf("chat/p/") > -1) {
          var contactHash = urlHash.replace("chat/p/", "");
          if (!contactHash) {
            return;
          }
          var chatRoom = this.getPrivateRoom(contactHash);
          return chatRoom;
        } else if (urlHash.indexOf("chat/") > -1 && urlHash[13] === "#") {
          var foundRoom = null;
          var pubHandle = urlHash.replace("chat/", "").split("#")[0];
          urlHash = urlHash.replace("chat/g/", "");
          var chatIds = megaChat.chats.keys();
          for (var i = 0; i < chatIds.length; i++) {
            var cid = chatIds[i];
            var room = megaChat.chats[cid];
            if (room.publicChatHandle === pubHandle) {
              foundRoom = room;
              break;
            }
          }
          return foundRoom;
        } else {
          return null;
        }
      };
      Chat.prototype.updateSectionUnreadCount = SoonFc(function () {
        var self = this;
        if (!self.favico) {
          assert(Favico, "Favico.js is missing.");
          $('link[rel="icon"]').attr("href", (location.hostname === "mega.nz" ? "https://mega.nz/" : bootstaticpath) + "favicon.ico");
          self.favico = new Favico({
            type: "rectangle",
            animation: "popFade",
            bgColor: "#fff",
            textColor: "#d00"
          });
        }
        var unreadCount = 0;
        const notifications = {
          chats: 0,
          meetings: 0
        };
        var havePendingCall = false;
        self.chats.forEach((chatRoom) => {
          if (chatRoom.isArchived() || chatRoom.state === ChatRoom.STATE.LEFT) {
            return;
          }
          const unreads = parseInt(chatRoom.messagesBuff.getUnreadCount(), 10);
          unreadCount += unreads;
          if (unreads) {
            notifications[chatRoom.isMeeting ? "meetings" : "chats"] += unreads;
          }
          if (!havePendingCall && chatRoom.havePendingCall() && chatRoom.uniqueCallParts && !chatRoom.uniqueCallParts[u_handle]) {
            havePendingCall = true;
          }
        });
        unreadCount = unreadCount > 9 ? "9+" : unreadCount;
        var haveContents = false;
        if (havePendingCall) {
          haveContents = true;
          $(".new-messages-indicator .chat-pending-call").removeClass("hidden");
          $(".new-messages-indicator .chat-pending-call").removeClass("call-exists");
        } else {
          $(".new-messages-indicator .chat-pending-call").addClass("hidden").removeClass("call-exists");
        }
        if (self._lastUnreadCount !== unreadCount) {
          if (unreadCount && (unreadCount === "9+" || unreadCount > 0)) {
            $(".new-messages-indicator .chat-unread-count").removeClass("hidden").text(unreadCount);
          } else {
            $(".new-messages-indicator .chat-unread-count").addClass("hidden");
          }
          self._lastUnreadCount = unreadCount;
          delay("notifFavicoUpd", () => {
            self.favico.reset();
            self.favico.badge(unreadCount);
          });
        }
        if (
          !this._lastNotifications ||
          this._lastNotifications.chats !== notifications.chats ||
          this._lastNotifications.meetings !== notifications.meetings
        ) {
          this._lastNotifications = notifications;
          megaChat.trigger("onUnreadCountUpdate", notifications);
        }
        if (unreadCount && (unreadCount === "9+" || unreadCount > 0)) {
          haveContents = true;
        }
        if (!haveContents) {
          $(".new-messages-indicator").addClass("hidden");
        } else {
          $(".new-messages-indicator").removeClass("hidden");
        }
      }, 100);
      Chat.prototype.dropAllDatabases = promisify(function (resolve, reject) {
        const chatd = this.plugins.chatdIntegration.chatd || false;
        const promises = [];
        if (chatd.chatdPersist) {
          promises.push(chatd.chatdPersist.drop());
        }
        if ("messagesQueueKvStorage" in chatd) {
          promises.push(chatd.messagesQueueKvStorage.destroy());
        }
        if (Reactions.ready) {
          promises.push(Reactions._db.destroy());
        }
        if (PersistedTypeArea.ready) {
          promises.push(PersistedTypeArea._db.destroy());
        }
        Promise.allSettled(promises).then(resolve).catch(reject);
      });
      Chat.prototype.destroy = function (isLogout) {
        var self = this;
        if (self.is_initialized === false) {
          return;
        }
        self.isLoggingOut = isLogout;
        for (let i = 0; i < this.mbListeners.length; i++) {
          mBroadcaster.removeListener(this.mbListeners[i]);
        }
        self.unregisterUploadListeners(true);
        self.trigger("onDestroy", [isLogout]);
        try {
          if (
            self.$conversationsAppInstance &&
            external_ReactDOM_default().findDOMNode(self.$conversationsAppInstance) &&
            external_ReactDOM_default().findDOMNode(self.$conversationsAppInstance).parentNode
          ) {
            external_ReactDOM_default().unmountComponentAtNode(
              external_ReactDOM_default().findDOMNode(self.$conversationsAppInstance).parentNode
            );
          }
        } catch (e) {
          console.error("Failed do destroy chat dom:", e);
        }
        self.chats.forEach(function (room, roomJid) {
          if (!isLogout) {
            room.destroy(false, true);
          }
          self.chats.remove(roomJid);
        });
        self.is_initialized = false;
        if (self.plugins.chatdIntegration && self.plugins.chatdIntegration.chatd && self.plugins.chatdIntegration.chatd.shards) {
          var shards = self.plugins.chatdIntegration.chatd.shards;
          Object.keys(shards).forEach(function (k) {
            shards[k].connectionRetryManager.options.functions.forceDisconnect();
          });
        }
        for (const pluginName in self.plugins) {
          const plugin = self.plugins[pluginName];
          if (plugin.destroy) {
            plugin.destroy();
          }
        }
        if (this.minuteClockInterval) {
          clearInterval(this.minuteClockInterval);
        }
      };
      Chat.prototype.getContacts = function () {
        var results = [];
        M.u.forEach(function (k, v) {
          if (v.c == 1 || v.c == 2) {
            results.push(v);
          }
        });
        return results;
      };
      Chat.prototype.userPresenceToCssClass = function (presence) {
        if (presence === UserPresence.PRESENCE.ONLINE) {
          return "online";
        } else if (presence === UserPresence.PRESENCE.AWAY) {
          return "away";
        } else if (presence === UserPresence.PRESENCE.DND) {
          return "busy";
        } else if (presence === UserPresence.PRESENCE.OFFLINE) {
          return "offline";
        } else {
          return "black";
        }
      };
      Chat.prototype._renderMyStatus = function () {
        var self = this;
        if (!self.is_initialized) {
          return;
        }
        if (typeof megaChat.userPresence === "undefined") {
          return;
        }
        var $status = $(".activity-status-block .activity-status", "body");
        $(".top-user-status-popup .dropdown-item").removeClass("active");
        $status.removeClass("online").removeClass("away").removeClass("busy").removeClass("offline").removeClass("black");
        var actualPresence = self.plugins.presencedIntegration.getMyPresenceSetting();
        var userPresenceConRetMan = megaChat.userPresence.connectionRetryManager;
        var presence = self.plugins.presencedIntegration.getMyPresence();
        var cssClass = PresencedIntegration.presenceToCssClass(presence);
        if (userPresenceConRetMan.getConnectionState() !== ConnectionRetryManager.CONNECTION_STATE.CONNECTED) {
          cssClass = "offline";
        }
        const $activityStatus = $(".activity-text", ".js-topbar");
        if (actualPresence === UserPresence.PRESENCE.ONLINE) {
          $('.top-user-status-popup .dropdown-item[data-presence="chat"]').addClass("active");
          $activityStatus.text(l[5923]);
        } else if (actualPresence === UserPresence.PRESENCE.AWAY) {
          $('.top-user-status-popup .dropdown-item[data-presence="away"]').addClass("active");
          $activityStatus.text(l[5924]);
        } else if (actualPresence === UserPresence.PRESENCE.DND) {
          $('.top-user-status-popup .dropdown-item[data-presence="dnd"]').addClass("active");
          $activityStatus.text(l[5925]);
        } else if (actualPresence === UserPresence.PRESENCE.OFFLINE) {
          $('.top-user-status-popup .dropdown-item[data-presence="unavailable"]').addClass("active");
          $activityStatus.text(l[5926]);
        } else {
          $('.top-user-status-popup .dropdown-item[data-presence="unavailable"]').addClass("active");
          $activityStatus.text(l[5926]);
        }
        $status.addClass(cssClass);
        if (userPresenceConRetMan.getConnectionState() === ConnectionRetryManager.CONNECTION_STATE.CONNECTING) {
          $status.parent().addClass("fadeinout");
        } else {
          $status.parent().removeClass("fadeinout");
        }
      };
      Chat.prototype.renderMyStatus = SoonFc(Chat.prototype._renderMyStatus, 100);
      Chat.prototype.openChat = function (
        userHandles,
        type,
        chatId,
        chatShard,
        chatdUrl,
        setAsActive,
        chatHandle,
        publicChatKey,
        ck,
        isMeeting,
        mcoFlags
      ) {
        var self = this;
        var room = false;
        type = type || "private";
        setAsActive = setAsActive === true;
        var roomId = chatId;
        if (!publicChatKey && chatHandle && self.publicChatKeys[chatHandle]) {
          if (type !== "public") {
            console.error("this should never happen.", type);
            type = "public";
          }
          publicChatKey = self.publicChatKeys[chatHandle];
        }
        var $promise = new MegaPromise();
        if (type === "private") {
          this.initContacts(userHandles, 2);
          roomId = array.one(userHandles, u_handle);
          if (!roomId) {
            $promise.reject();
            return $promise;
          }
          if (self.chats[roomId]) {
            $promise.resolve(roomId, self.chats[roomId]);
            return [roomId, self.chats[roomId], $promise];
          }
        } else {
          assert(roomId, "Tried to create a group chat, without passing the chatId.");
          roomId = chatId;
        }
        if (type === "group" || type === "public") {
          if (d) {
            console.time("openchat:" + chatId + "." + type);
          }
          const newUsers = this.initContacts(userHandles);
          if (newUsers.length) {
            var chats = self.chats._data;
            if (d) {
              console.debug("openchat:%s.%s: processing %s new users...", chatId, type, newUsers.length);
            }
            for (var k in chats) {
              var chatRoom = self.chats[k];
              var participants = array.to.object(chatRoom.getParticipantsExceptMe());
              for (var j = newUsers.length; j--; ) {
                var u = newUsers[j];
                if (participants[u]) {
                  chatRoom.trackDataChange();
                  break;
                }
              }
            }
            self.renderMyStatus();
          }
          if (d) {
            console.timeEnd("openchat:" + chatId + "." + type);
          }
          if (type === "group") {
            ChatdIntegration._ensureKeysAreLoaded([], userHandles, chatHandle).catch(dump);
          }
          ChatdIntegration._ensureContactExists(userHandles, chatHandle);
        }
        if (self.chats[roomId]) {
          room = self.chats[roomId];
          if (setAsActive) {
            room.show();
          }
          $promise.resolve(roomId, room);
          return [roomId, room, $promise];
        }
        if (setAsActive && self.currentlyOpenedChat && self.currentlyOpenedChat !== roomId) {
          self.hideChat(self.currentlyOpenedChat);
          self.currentlyOpenedChat = null;
        }
        room = new ChatRoom(
          self,
          roomId,
          type,
          userHandles,
          unixtime(),
          undefined,
          chatId,
          chatShard,
          chatdUrl,
          null,
          chatHandle,
          publicChatKey,
          ck,
          isMeeting,
          0,
          mcoFlags
        );
        self.chats.set(room.roomId, room);
        if ((setAsActive && !self.currentlyOpenedChat) || self.currentlyOpenedChat === room.roomId) {
          room.setActive();
        }
        room.showAfterCreation = setAsActive !== false;
        return [
          roomId,
          room,
          new Promise((resolve, reject) => {
            this.trigger("onRoomInitialized", [room, resolve, reject]);
            room.setState(ChatRoom.STATE.JOINING);
            const q = this._queuedChatRoomEvents[chatId];
            if (q) {
              delete this._queuedChatRoomEvents[chatId];
              for (let i = 0; i < q.length; ++i) {
                const [event, data] = q[i];
                if (d) {
                  this.logger.debug(`Dispatching deferred event '${event}'`, data);
                }
                room.trigger(event, data);
              }
              q.timer.abort();
            }
            this.processQueuedMcsmPackets();
          })
        ];
      };
      Chat.prototype.initContacts = function (userHandles, c) {
        const newUsers = [];
        for (let i = userHandles.length; i--; ) {
          const u = userHandles[i];
          const e = u in M.u;
          M.addUser(
            e
              ? {
                  u
                }
              : {
                  u,
                  c
                },
            e || !newUsers.push(u)
          );
        }
        return newUsers;
      };
      Chat.prototype.proxyUserChangeToRooms = function (handle) {
        delay(
          `chat:proxy-user-change-to-rooms.${handle}`,
          () => {
            const rooms = Object.values(this.chats);
            if (d) {
              this.logger.debug("userChange", handle);
            }
            for (let i = rooms.length; i--; ) {
              const chatRoom = rooms[i];
              if (handle in chatRoom.members) {
                chatRoom.trackDataChange("user-updated", handle);
              }
            }
          },
          350
        );
      };
      Chat.prototype.smartOpenChat = function (...args) {
        var self = this;
        if (typeof args[0] === "string") {
          args[0] = [u_handle, args[0]];
          if (args.length < 2) {
            args.push("private");
          }
        }
        return new Promise((resolve, reject) => {
          var waitForReadyState = function (aRoom, aShow) {
            var verify = function () {
              return aRoom.state === ChatRoom.STATE.READY;
            };
            var ready = function () {
              if (aShow) {
                aRoom.show();
              }
              resolve(aRoom);
            };
            if (verify()) {
              return ready();
            }
            const { roomId } = aRoom;
            createTimeoutPromise(verify, 300, 3e4, false, `waitForReadyState(${roomId})`).then(ready).catch(reject);
          };
          if (args[0].length === 2 && args[1] === "private") {
            var chatRoom = self.chats[array.one(args[0], u_handle)];
            if (chatRoom) {
              if (args[5]) {
                chatRoom.show();
              }
              return waitForReadyState(chatRoom, args[5]);
            }
          }
          var result = self.openChat.apply(self, args);
          if (result instanceof MegaPromise) {
            result.then(reject).catch(reject);
          } else if (!Array.isArray(result)) {
            reject(EINTERNAL);
          } else {
            var room = result[1];
            var roomId = result[0];
            var promise = result[2];
            if (!(promise instanceof Promise)) {
              self.logger.error("Unexpected openChat() response...");
              return reject(EINTERNAL);
            }
            self.logger.debug('Waiting for chat "%s" to be ready...', roomId, [room]);
            promise
              .then((aRoom) => {
                const aRoomId = aRoom && aRoom.roomId;
                if (aRoomId !== roomId || (room && room !== aRoom) || !(aRoom instanceof ChatRoom)) {
                  self.logger.error("Unexpected openChat() procedure...", aRoomId, [aRoom]);
                  return reject(EINTERNAL);
                }
                waitForReadyState(aRoom);
              })
              .catch((ex) => {
                if (ex === EACCESS) {
                  room.destroy();
                }
                reject(ex);
              });
          }
        });
      };
      Chat.prototype.hideAllChats = function () {
        var self = this;
        self.chats.forEach((chatRoom) => {
          if (chatRoom.isCurrentlyActive) {
            chatRoom.hide();
          }
        });
      };
      Chat.prototype.retrieveSharedFilesHistory = async function (len = 47, chatRoom = null) {
        chatRoom = len instanceof ChatRoom ? len : chatRoom || this.getCurrentRoom();
        return chatRoom.messagesBuff.retrieveSharedFilesHistory(len);
      };
      Chat.prototype.getCurrentRoom = function () {
        return this.chats[this.currentlyOpenedChat];
      };
      Chat.prototype.getCurrentMeeting = function () {
        const chatRoom = this.getCurrentRoom();
        return (chatRoom && chatRoom.scheduledMeeting) || null;
      };
      Chat.prototype.getCurrentRoomJid = function () {
        return this.currentlyOpenedChat;
      };
      Chat.prototype.hideChat = function (roomJid) {
        var self = this;
        var room = self.chats[roomJid];
        if (room) {
          room.hide();
        } else {
          self.logger.warn("Room not found: ", roomJid);
        }
      };
      Chat.prototype.sendMessage = function (roomJid, val) {
        const fail = (ex) => {
          this.logger.error(`sendMessage(${roomJid}) failed.`, ex);
        };
        if (!this.chats[roomJid]) {
          this.logger.warn("Queueing message for room: ", roomJid, val);
          const timeout = this.options.delaySendMessageIfRoomNotAvailableTimeout;
          return createTimeoutPromise(() => !!this.chats[roomJid], 500, timeout)
            .then(() => {
              return this.chats[roomJid].sendMessage(val);
            })
            .catch(fail);
        }
        return this.chats[roomJid].sendMessage(val).catch(fail);
      };
      Chat.prototype.processNewUser = function (u, isNewChat) {
        var self = this;
        if (self.plugins.presencedIntegration) {
          var user = M.u[u] || false;
          if (user.c === 1) {
            self.plugins.presencedIntegration.addContact(u, isNewChat);
          }
        }
        self.chats.forEach(function (chatRoom) {
          if (chatRoom.getParticipantsExceptMe().indexOf(u) > -1) {
            chatRoom.trackDataChange();
          }
        });
        self.renderMyStatus();
      };
      Chat.prototype.processRemovedUser = function (u) {
        var self = this;
        if (self.plugins.presencedIntegration) {
          self.plugins.presencedIntegration.removeContact(u);
        }
        self.chats.forEach(function (chatRoom) {
          if (chatRoom.getParticipantsExceptMe().indexOf(u) > -1) {
            chatRoom.trackDataChange();
          }
        });
        self.renderMyStatus();
      };
      Chat.prototype.refreshConversations = function () {
        var self = this;
        if (!u_type && !self.$container && !megaChatIsReady) {
          $(".fm-chat-block").hide();
          return false;
        }
        $(".section.conversations .fm-chat-is-loading").addClass("hidden");
        if (self.$container.parent(".section.conversations .fm-right-files-block").length == 0) {
          $(".section.conversations .fm-right-files-block").append(self.$container);
        }
        self.$leftPane = self.$leftPane || $(".conversationsApp .fm-left-panel");
        if (is_chatlink || megaChat._joinDialogIsShown) {
          self.$leftPane.addClass("hidden");
        } else {
          self.$leftPane.removeClass("hidden");
        }
      };
      Chat.prototype.navigate = function megaChatNavigate(location, event, isLandingPage) {
        return new Promise((resolve, reject) => {
          this.routing.route(resolve, reject, location, event, isLandingPage);
        });
      };
      if (is_mobile) {
        Chat.prototype.navigate = function (location, event, isLandingPage) {
          if (d) {
            this.logger.warn("mobile-nop navigate(%s)", location, event, isLandingPage);
          }
          if (is_chatlink) {
            mobile.chatlink.show(is_chatlink.ph, is_chatlink.key);
          } else {
            loadSubPage("fm", event);
          }
          return Promise.resolve();
        };
      }
      Chat.prototype.renderListing = async function megaChatRenderListing(location, isInitial) {
        if (!isInitial && !M.chat) {
          console.debug("renderListing: Not in chat.");
          throw EACCESS;
        }
        M.hideEmptyGrids();
        this.refreshConversations();
        this.hideAllChats();
        $(".files-grid-view").addClass("hidden");
        $(".fm-blocks-view").addClass("hidden");
        $(".fm-chat-block").addClass("hidden");
        $(".fm-right-files-block").addClass("hidden");
        $(".fm-right-files-block.in-chat").removeClass("hidden");
        $(".nw-conversations-item").removeClass("selected");
        $(".fm-empty-conversations").removeClass("hidden");
        M.onSectionUIOpen("conversations");
        let room;
        if (!location && this.chats.length) {
          const valid = (room) => room && room._leaving !== true && room.isDisplayable() && room;
          room = valid(this.chats[this.lastOpenedChat]);
          if (!room) {
            let idx = 0;
            const rooms = Object.values(this.chats)
              .filter((r) => r.isMeeting === !!this.currentlyOpenedView)
              .sort(M.sortObjFn("lastActivity", -1));
            do {
              room = valid(rooms[idx]);
            } while (!room && ++idx < rooms.length);
          }
          if (room) {
            location = room.getRoomUrl();
          }
        }
        if (location) {
          $(".fm-empty-conversations").addClass("hidden");
          return this.navigate(location, undefined, isInitial).catch((ex) => {
            if (d) {
              this.logger.warn("Failed to navigate to %s...", location, room, ex);
            }
            if (!room) {
              return this.renderListing(null);
            }
            onIdle(() => {
              room.destroy();
            });
            throw ex;
          });
        }
        return ENOENT;
      };
      Chat.prototype.setAttachments = function (roomId) {
        "use strict";

        if (M.chat) {
          if (d) {
            console.assert(this.chats[roomId] && this.chats[roomId].isCurrentlyActive, "check this...");
          }
          M.v = Object.values(M.chc[roomId] || {});
          if (M.v.length) {
            var _this$chats$roomId;
            const sv =
              (_this$chats$roomId = this.chats[roomId]) == null ||
              (_this$chats$roomId = _this$chats$roomId.messagesBuff) == null ||
              (_this$chats$roomId = _this$chats$roomId.sharedFiles) == null
                ? void 0
                : _this$chats$roomId._sortedVals;
            if (sv && sv.length === M.v.length) {
              M.v.sort((a, b) => sv.indexOf(a.m) - sv.indexOf(b.m));
            } else {
              if (d) {
                this.logger.info("falling back to order-value sorting.", sv);
              }
              M.v.sort(M.sortObjFn("co"));
            }
            for (var i = M.v.length; i--; ) {
              var n = M.v[i];
              if (!n.revoked && !n.seen) {
                n.seen = -1;
                if (String(n.fa).indexOf(":1*") > 0) {
                  this._enqueueImageLoad(n);
                }
              }
            }
            if ($.triggerSlideShow) {
              delay("chat:refresh-slideshow-on-single-entry", () => {
                const { slideshowid: id } = window;
                if (id && $.triggerSlideShow === id) {
                  slideshow(id);
                }
                delete $.triggerSlideShow;
              });
            }
          }
        } else if (d) {
          console.warn("Not in chat...");
        }
      };
      Chat.prototype._enqueueMessageUpdate = function (message) {
        this._queuedMessageUpdates.push(message);
        delay(
          "chat:enqueue-message-updates",
          () => {
            var queue = this._queuedMessageUpdates;
            this._queuedMessageUpdates = [];
            for (var i = queue.length; i--; ) {
              queue[i].trackDataChange();
            }
          },
          400
        );
      };
      Chat.prototype._enqueueImageLoad = function (n) {
        "use strict";
        var cc = previews[n.h] || previews[n.hash];
        if (cc) {
          if (cc.poster) {
            n.src = cc.poster;
          } else {
            if (cc.full && n.mime !== "image/png" && n.mime !== "image/webp") {
              cc = cc.prev || false;
            }
            if (String(cc.type).startsWith("image/")) {
              n.src = cc.src;
            }
          }
        }
        var cached = n.src;
        if (String(n.fa).indexOf(":1*") > 0) {
          var load = false;
          var dedup = true;
          if (this._imageAttributeCache[n.fa]) {
            this._imageAttributeCache[n.fa].push(n.ch);
          } else {
            this._imageAttributeCache[n.fa] = [n.ch];
            load = !cached;
          }
          if (this._imageLoadCache[n.fa]) {
            this._imageLoadCache[n.fa].push(n.ch);
          } else {
            this._imageLoadCache[n.fa] = [n.ch];
            if (load) {
              this._imagesToBeLoaded[n.fa] = n;
              dedup = false;
            }
          }
          if (dedup) {
            cached = true;
          } else {
            delay("chat:enqueue-image-load", this._doLoadImages.bind(this), 350);
          }
        }
        if (cached) {
          this._doneLoadingImage(n.fa);
        }
      };
      Chat.prototype._doLoadImages = function () {
        "use strict";

        var self = this;
        var originals = Object.create(null);
        var imagesToBeLoaded = self._imagesToBeLoaded;
        self._imagesToBeLoaded = Object.create(null);
        var chatImageParser = function (h, data) {
          var n = M.chd[(self._imageLoadCache[h] || [])[0]] || false;
          if (n && data !== 0xdead) {
            n.src = mObjectURL([data.buffer || data], "image/jpeg");
            n.srcBuffer = data;
          } else if (d) {
            console.warn("Failed to load image for %s", h, n);
          }
          self._doneLoadingImage(h);
        };
        for (var k in imagesToBeLoaded) {
          var node = imagesToBeLoaded[k];
          var mime = filemime(node);
          if (node.s < LOAD_ORIGINALS[mime]) {
            originals[node.fa] = node;
            delete imagesToBeLoaded[k];
          }
        }
        var onSuccess = function (ctx, origNodeHandle, data) {
          chatImageParser(origNodeHandle, data);
        };
        var onError = function (origNodeHandle) {
          chatImageParser(origNodeHandle, 0xdead);
        };
        var loadOriginal = function (n) {
          const origFallback = (ex) => {
            const type = String(n.fa).indexOf(":1*") > 0 ? 1 : 0;
            if (d) {
              console.debug("Failed to load original image on chat.", n.h, n, ex);
            }
            imagesToBeLoaded[n.fa] = originals[n.fa];
            delete originals[n.fa];
            delay("ChatRoom[" + self.roomId + "]:origFallback" + type, function () {
              api_getfileattr(imagesToBeLoaded, type, onSuccess, onError);
            });
          };
          M.gfsfetch(n.h, 0, -1)
            .then(function (data) {
              var handler = is_image(n);
              if (typeof handler === "function") {
                handler(data, (buffer) => {
                  if (buffer) {
                    chatImageParser(n.fa, buffer);
                  } else {
                    origFallback(EFAILED);
                  }
                });
              } else {
                chatImageParser(n.fa, data);
              }
            })
            .catch(origFallback);
        };
        if ($.len(originals)) {
          Object.values(originals).map(loadOriginal);
        }
        api_getfileattr(imagesToBeLoaded, 1, onSuccess, onError);
        [imagesToBeLoaded, originals].forEach(function (obj) {
          Object.keys(obj).forEach(function (handle) {
            self._startedLoadingImage(handle);
          });
        });
        imagesToBeLoaded = Object.create(null);
      };
      Chat.prototype._getImageNodes = function (h, src) {
        var nodes = this._imageLoadCache[h] || [];
        var handles = [].concat(nodes);
        for (var i = nodes.length; i--; ) {
          var n = M.chd[nodes[i]] || false;
          if (this._imageAttributeCache[n.fa]) {
            handles = handles.concat(this._imageAttributeCache[n.fa]);
          }
        }
        handles = array.unique(handles);
        nodes = handles.map(function (ch) {
          var n = M.chd[ch] || false;
          if (src && n.src) {
            Object.assign(src, n);
          }
          return n;
        });
        return nodes;
      };
      Chat.prototype._startedLoadingImage = function (h) {
        "use strict";

        var nodes = this._getImageNodes(h);
        for (var i = nodes.length; i--; ) {
          var n = nodes[i];
          if (!n.src && n.seen !== 2) {
            var imgNode = document.getElementById(n.ch);
            if (imgNode && (imgNode = imgNode.querySelector("img"))) {
              imgNode.parentNode.parentNode.classList.add("thumb-loading");
            }
          }
        }
      };
      Chat.prototype._doneLoadingImage = function (h) {
        var self = this;
        var setSource = function (n, img, src) {
          var message = n.mo;
          img.onload = function () {
            img.onload = null;
            n.srcWidth = this.naturalWidth;
            n.srcHeight = this.naturalHeight;
            if (message) {
              self._enqueueMessageUpdate(message);
            }
          };
          img.setAttribute("src", src);
        };
        var root = {};
        var nodes = this._getImageNodes(h, root);
        var src = root.src;
        for (var i = nodes.length; i--; ) {
          var n = nodes[i];
          var imgNode = document.getElementById(n.ch);
          if (imgNode && (imgNode = imgNode.querySelector("img"))) {
            var parent = imgNode.parentNode;
            var container = parent.parentNode;
            if (src) {
              container.classList.add("thumb");
              parent.classList.remove("no-thumb");
            } else {
              container.classList.add("thumb-failed");
            }
            n.seen = 2;
            container.classList.remove("thumb-loading");
            setSource(n, imgNode, src || window.noThumbURI || "");
          }
          if (src) {
            n.src = src;
            if (root.srcBuffer && root.srcBuffer.byteLength) {
              n.srcBuffer = root.srcBuffer;
            }
            if (n.srcBuffer && !previews[n.h] && is_image3(n)) {
              preqs[n.h] = 1;
              previewimg(n.h, n.srcBuffer, "image/jpeg");
              previews[n.h].fromChat = Date.now();
            }
          }
          delete n.mo;
        }
        if (src) {
          mBroadcaster.sendMessage("chat_image_preview");
        }
      };
      Chat.prototype.onChatsHistoryReady = promisify(function (resolve, reject, timeout) {
        if (this.allChatsHadInitialLoadedHistory()) {
          return resolve();
        }
        let timer = null;
        const chatd = this.plugins.chatdIntegration.chatd;
        const eventName = "onMessagesHistoryDone.ochr" + makeid(16);
        const ready = () => {
          queueMicrotask(resolve);
          chatd.off(eventName);
          if (timer) {
            timer.abort();
            timer = null;
          }
        };
        chatd.on(eventName, () => {
          if (this.allChatsHadInitialLoadedHistory()) {
            ready();
          }
        });
        if (timeout > 0) {
          (timer = tSleep(timeout / 1e3)).then(ready);
        }
      });
      Chat.prototype.allChatsHadLoadedHistory = function () {
        var chatIds = this.chats.keys();
        for (var i = chatIds.length; i--; ) {
          var room = this.chats[chatIds[i]];
          if (room.isLoading()) {
            return false;
          }
        }
        return true;
      };
      Chat.prototype.allChatsHadInitialLoadedHistory = function () {
        var self = this;
        var chatIds = self.chats.keys();
        for (var i = chatIds.length; i--; ) {
          var room = self.chats[chatIds[i]];
          if (room.chatId && room.initialMessageHistLoaded === false) {
            return false;
          }
        }
        return true;
      };
      Chat.prototype.getPrivateRoom = function (h) {
        "use strict";

        return this.chats[h] || false;
      };
      Chat.prototype.createAndShowPrivateRoom = promisify(function (resolve, reject, h) {
        M.openFolder("chat/p/" + h)
          .then(() => {
            const room = this.getPrivateRoom(h);
            assert(room, "room not found..");
            resolve(room);
          })
          .catch(reject);
      });
      Chat.prototype.createAndShowGroupRoomFor = function (contactHashes, topic, opts = {}) {
        this.trigger("onNewGroupChatRequest", [
          contactHashes,
          {
            topic: topic || "",
            ...opts
          }
        ]);
      };
      Chat.prototype.createAndStartMeeting = function (topic, audio, video) {
        megaChat.createAndShowGroupRoomFor([], topic, {
          keyRotation: false,
          createChatLink: true,
          isMeeting: true
        });
        megaChat.rebind("onRoomInitialized.meetingCreate", function (e, room) {
          room.rebind("onNewMeetingReady.meetingCreate", function () {
            room.startCall(audio, video);
          });
        });
      };
      Chat.prototype._destroyAllChatsFromChatd = function () {
        var self = this;
        asyncApiReq({
          a: "mcf",
          v: Chatd.VERSION
        }).then((r) => {
          r.c.forEach(function (chatRoomMeta) {
            if (chatRoomMeta.g === 1) {
              chatRoomMeta.u.forEach(function (u) {
                if (u.u !== u_handle) {
                  api_req({
                    a: "mcr",
                    id: chatRoomMeta.id,
                    u: u.u,
                    v: Chatd.VERSION
                  });
                }
              });
              api_req({
                a: "mcr",
                id: chatRoomMeta.id,
                u: u_handle,
                v: Chatd.VERSION
              });
            }
          });
        });
      };
      Chat.prototype._leaveAllGroupChats = function () {
        asyncApiReq({
          a: "mcf",
          v: Chatd.VERSION
        }).then((r) => {
          r.c.forEach(function (chatRoomMeta) {
            if (chatRoomMeta.g === 1) {
              asyncApiReq({
                a: "mcr",
                id: chatRoomMeta.id,
                v: Chatd.VERSION
              });
            }
          });
        });
      };
      Chat.prototype.getEmojiDataSet = async function (name) {
        assert(name === "categories" || name === "emojis", "Invalid emoji dataset name passed.");
        if (!this._emojiDataLoading) {
          this._emojiDataLoading = Object.create(null);
        }
        if (!this._emojiData) {
          this._emojiData = {
            emojisUtf: Object.create(null),
            emojisSlug: Object.create(null)
          };
        }
        if (this._emojiData[name]) {
          return this._emojiData[name];
        }
        if (this._emojiDataLoading[name]) {
          return this._emojiDataLoading[name];
        }
        if (name === "categories") {
          this._emojiData[name] = ["people", "nature", "food", "activity", "travel", "objects", "symbols", "flags"];
          return this._emojiData[name];
        }
        const { promise } = mega;
        this._emojiDataLoading[name] = promise;
        M.xhr({
          type: "json",
          url: `${staticpath}js/chat/emojidata/${name}_v${EMOJI_DATASET_VERSION}.json`
        })
          .then((ev, data) => {
            if (!data) {
              promise.reject(EFAILED);
              return;
            }
            this._emojiData[name] = data;
            delete this._emojiDataLoading[name];
            if (name === "emojis") {
              this._mapEmojisToAliases();
            }
            promise.resolve(data);
          })
          .catch((ex, error) => {
            if (d) {
              this.logger.warn('Failed to load emoji data "%s": %s', name, error, [ex]);
            }
            delete this._emojiDataLoading[name];
            promise.reject(error || ex);
          });
        return promise;
      };
      Chat.prototype._mapEmojisToAliases = function () {
        const { emojis } = this._emojiData;
        if (emojis) {
          this._emojiData.emojisUtf = Object.create(null);
          this._emojiData.emojisSlug = Object.create(null);
          for (let i = emojis.length; i--; ) {
            const emoji = emojis[i];
            this._emojiData.emojisUtf[emoji.u] = emoji;
            this._emojiData.emojisSlug[emoji.n] = emoji;
          }
        }
      };
      Chat.prototype.isValidEmojiSlug = function (slug) {
        var self = this;
        var emojiData = self._emojiData.emojis;
        if (!emojiData) {
          self.getEmojiDataSet("emojis");
          return false;
        }
        for (var i = 0; i < emojiData.length; i++) {
          if (emojiData[i].n === slug) {
            return true;
          }
        }
      };
      Chat.prototype.getPresence = function (user_handle) {
        if (user_handle && this.plugins.presencedIntegration) {
          return this.plugins.presencedIntegration.getPresence(user_handle);
        }
      };
      Chat.prototype.getPresenceAsCssClass = function (user_handle) {
        var presence = this.getPresence(user_handle);
        return this.presenceStringToCssClass(presence);
      };
      Chat.prototype.presenceStringToCssClass = function (presence) {
        if (presence === UserPresence.PRESENCE.ONLINE) {
          return "online";
        } else if (presence === UserPresence.PRESENCE.AWAY) {
          return "away";
        } else if (presence === UserPresence.PRESENCE.DND) {
          return "busy";
        } else if (!presence || presence === UserPresence.PRESENCE.OFFLINE) {
          return "offline";
        } else {
          return "black";
        }
      };
      Chat.prototype.generateTempMessageId = function (roomId, messageAndMeta) {
        var messageIdHash = u_handle + roomId;
        if (messageAndMeta) {
          messageIdHash += messageAndMeta;
        }
        return "m" + fastHashFunction(messageIdHash) + "_" + unixtime();
      };
      Chat.prototype.getChatById = function (chatdId) {
        var self = this;
        if (self.chats[chatdId]) {
          return self.chats[chatdId];
        } else if (self.chatIdToRoomId && self.chatIdToRoomId[chatdId] && self.chats[self.chatIdToRoomId[chatdId]]) {
          return self.chats[self.chatIdToRoomId[chatdId]];
        }
        if (this.chats[this.handleToId[chatdId]]) {
          return this.chats[this.handleToId[chatdId]];
        }
        var found = false;
        self.chats.forEach(function (chatRoom) {
          if (!found && chatRoom.chatId === chatdId) {
            found = chatRoom;
            return false;
          }
        });
        return found;
      };
      Chat.prototype.getMessageByMessageId = async function (chatId, messageId) {
        const chatRoom = this.getChatById(chatId);
        const msg = chatRoom.messagesBuff.getMessageById(messageId);
        if (msg) {
          return msg;
        }
        const { chatdPersist } = this.plugins.chatdIntegration.chatd;
        if (chatdPersist) {
          const [msg] = (await chatdPersist.getMessageByMessageId(chatId, messageId).catch(dump)) || [];
          if (msg) {
            return Message.fromPersistableObject(chatRoom, msg);
          }
        }
        if (d) {
          this.logger.debug("getMessageByMessageId: Cannot find %s on %s", messageId, chatId);
        }
        return Promise.reject(ENOENT);
      };
      Chat.prototype.haveAnyActiveCall = function () {
        var self = this;
        var chatIds = self.chats.keys();
        for (var i = 0; i < chatIds.length; i++) {
          if (self.chats[chatIds[i]].haveActiveCall()) {
            return true;
          }
        }
        return false;
      };
      Chat.prototype.haveAnyOnHoldCall = function () {
        var self = this;
        var chatIds = self.chats.keys();
        for (var i = 0; i < chatIds.length; i++) {
          if (self.chats[chatIds[i]].haveActiveOnHoldCall()) {
            return true;
          }
        }
        return false;
      };
      Chat.prototype.openChatAndSendFilesDialog = function (user_handle) {
        "use strict";

        this.smartOpenChat(user_handle)
          .then(function (room) {
            if (room.$rConversationPanel && room.$rConversationPanel.isMounted()) {
              room.trigger("openSendFilesDialog");
            } else {
              room.one("onComponentDidMount.sendFilesDialog", () => {
                room.trigger("openSendFilesDialog");
              });
            }
            room.setActive();
          })
          .catch(this.logger.error.bind(this.logger));
      };
      Chat.prototype.openChatAndAttachNodes = async function (targets, nodes, silent) {
        const promises = [];
        if (d) {
          console.group("Attaching nodes to chat room(s)...", targets, nodes);
        }
        const attachNodes = (roomId) =>
          this.smartOpenChat(roomId)
            .then((room) => {
              return room.attachNodes(nodes).then((res) => {
                if (res !== EBLOCKED) {
                  return room;
                }
              });
            })
            .catch((ex) => {
              if (d) {
                this.logger.warn("Cannot openChat for %s and hence nor attach nodes to it.", roomId, ex);
              }
              throw ex;
            });
        if (!Array.isArray(targets)) {
          targets = [targets];
        }
        for (let i = targets.length; i--; ) {
          promises.push(attachNodes(targets[i]));
        }
        const result = (await Promise.allSettled(promises)).map((e) => e.value).filter(Boolean);
        for (let i = result.length; i--; ) {
          if (result[i] instanceof ChatRoom) {
            const room = result[i];
            showToast("send-chat", nodes.length > 1 ? l[17767] : l[17766]);
            if (!silent) {
              await M.openFolder(room.getRoomUrl().replace("fm/", "")).catch(dump);
            }
            break;
          }
        }
        if (d) {
          console.groupEnd();
        }
        return result;
      };
      Chat.prototype.toggleUIFlag = function (name) {
        this.chatUIFlags.set(name, this.chatUIFlags[name] ? 0 : 1);
      };
      Chat.prototype.onSnActionPacketReceived = function () {
        if (this._queuedMccPackets.length > 0) {
          var aps = this._queuedMccPackets;
          this._queuedMccPackets = [];
          for (var i = 0; i < aps.length; i++) {
            mBroadcaster.sendMessage("onChatdChatUpdatedActionPacket", aps[i]);
          }
        }
        this.processQueuedMcsmPackets();
      };
      Chat.prototype.processQueuedMcsmPackets = function () {
        const aps = Object.values(this._queuedMcsmPackets);
        if (aps.length) {
          for (let i = 0; i < aps.length; i++) {
            const ap = aps[i];
            const { type, data } = ap;
            const { meetingsManager } = this.plugins;
            if (type === "mcsmp") {
              const chatRoom = this.getChatById(data.cid);
              if (chatRoom) {
                const scheduledMeeting = meetingsManager.attachMeeting(data, true);
                delete this._queuedMcsmPackets[scheduledMeeting.id];
                return scheduledMeeting.iAmOwner
                  ? null
                  : notify.notifyFromActionPacket({
                      ...data,
                      a: type
                    });
              }
            }
            if (type === "mcsmr") {
              meetingsManager.detachMeeting(data);
              delete this._queuedMcsmPackets[data.id];
            }
          }
        }
      };
      Chat.prototype.getFrequentContacts = function () {
        if (Chat._frequentsCache) {
          return Chat._frequentsCache;
        }
        var chats = this.chats;
        var recentContacts = {};
        var promises = [];
        var finishedLoadingChats = {};
        var loadingMoreChats = {};
        var _calculateLastTsFor = function (r, maxMessages) {
          var mb = r.messagesBuff;
          var len = mb.messages.length;
          var msgs = mb.messages.slice(Math.max(0, len - maxMessages), len);
          for (var i = 0; i < msgs.length; i++) {
            var msg = msgs[i];
            var contactHandle = msg.userId === mega.BID && msg.meta ? msg.meta.userId : msg.userId;
            if (r.type === "private" && contactHandle === u_handle) {
              contactHandle = contactHandle || r.getParticipantsExceptMe()[0];
            }
            if (
              contactHandle !== mega.BID &&
              contactHandle !== strongvelope.COMMANDER &&
              contactHandle in M.u &&
              M.u[contactHandle].c === 1 &&
              contactHandle !== u_handle
            ) {
              if (!recentContacts[contactHandle] || recentContacts[contactHandle].ts < msg.delay) {
                recentContacts[contactHandle] = {
                  userId: contactHandle,
                  ts: msg.delay
                };
              }
            }
          }
        };
        var _histDecryptedCb = function () {
          var mb = this.messagesBuff;
          if (!loadingMoreChats[this.chatId] && mb.messages.length < 32 && mb.haveMoreHistory()) {
            loadingMoreChats[this.chatId] = true;
            mb.retrieveChatHistory(false);
          } else {
            this.unbind(CHAT_ONHISTDECR_RECNT);
            _calculateLastTsFor(this, 32);
            delete loadingMoreChats[this.chatId];
            finishedLoadingChats[this.chatId] = true;
            mb.detachMessages();
          }
        };
        var _checkFinished = function (chatId) {
          return function () {
            return finishedLoadingChats[chatId] === true;
          };
        };
        chats.forEach((chatRoom) => {
          const name = `getFrequentContacts(${chatRoom.roomId})`;
          if (chatRoom.isLoading()) {
            finishedLoadingChats[chatRoom.chatId] = false;
            chatRoom.rebind(CHAT_ONHISTDECR_RECNT, _histDecryptedCb);
            promises.push(createTimeoutPromise(_checkFinished(chatRoom.chatId), 300, 10000, false, name));
          } else if (chatRoom.messagesBuff.messages.length < 32 && chatRoom.messagesBuff.haveMoreHistory()) {
            loadingMoreChats[chatRoom.chatId] = true;
            finishedLoadingChats[chatRoom.chatId] = false;
            chatRoom.messagesBuff.retrieveChatHistory(false);
            chatRoom.rebind(CHAT_ONHISTDECR_RECNT, _histDecryptedCb);
            promises.push(createTimeoutPromise(_checkFinished(chatRoom.chatId), 300, 15000, false, name));
          } else {
            _calculateLastTsFor(chatRoom, 32);
          }
        });
        Chat._frequentsCache = new Promise((resolve, reject) => {
          Promise.allSettled(promises)
            .then(() => {
              const result = Object.values(recentContacts)
                .sort((a, b) => (a.ts < b.ts ? 1 : b.ts < a.ts ? -1 : 0))
                .reverse();
              tSleep(300).then(() => {
                delete Chat._frequentsCache;
              });
              return result;
            })
            .then(resolve)
            .catch(reject);
        });
        return Chat._frequentsCache;
      };
      Chat.prototype.eventuallyAddDldTicketToReq = function (req) {
        if (!u_handle) {
          return;
        }
        var currentRoom = this.getCurrentRoom();
        if (
          currentRoom &&
          currentRoom.type === "public" &&
          currentRoom.publicChatHandle &&
          (is_chatlink || (currentRoom.membersSetFromApi && !currentRoom.membersSetFromApi.members[u_handle]))
        ) {
          req["cauth"] = currentRoom.publicChatHandle;
        }
      };
      Chat.prototype.safeForceUpdate = SoonFc(60, function forceAppUpdate() {
        if (this.$conversationsAppInstance) {
          this.$conversationsAppInstance.forceUpdate();
        }
      });
      Chat.prototype.removeMessagesByRetentionTime = function (chatId) {
        if (this.chats.length > 0) {
          if (chatId) {
            if (this.logger && d > 3) {
              this.logger.debug(`Chat.prototype.removeMessagesByRetentionTime chatId=${chatId}`);
            }
            var room = this.getChatById(chatId);
            if (room) {
              room.removeMessagesByRetentionTime();
            }
            return;
          }
          let chatIds = this.chats.keys();
          for (var i = 0; i < chatIds.length; i++) {
            let chatRoom = this.chats[chatIds[i]];
            if (chatRoom.retentionTime > 0 && chatRoom.state === ChatRoom.STATE.READY) {
              if (this.logger && d > 3) {
                this.logger.debug(`Chat.prototype.removeMessagesByRetentionTime roomId=${chatRoom.roomId}`);
              }
              chatRoom.removeMessagesByRetentionTime();
            }
          }
        }
      };
      Chat.prototype.loginOrRegisterBeforeJoining = function (chatHandle, forceRegister, forceLogin, notJoinReq, onLoginSuccessCb) {
        if (!chatHandle && page !== "securechat" && (page === "chat" || page.indexOf("chat") > -1)) {
          chatHandle = getSitePath().split("chat/")[1].split("#")[0];
        }
        assert(chatHandle, "missing chat handle when calling megaChat.loginOrRegisterBeforeJoining");
        const chatRoom = megaChat.getCurrentRoom();
        var chatKey = "#" + window.location.hash.split("#").pop();
        var finish = function (stay) {
          if (!notJoinReq) {
            localStorage.autoJoinOnLoginChat = JSON.stringify([chatHandle, unixtime(), chatKey, chatRoom.chatId]);
          }
          if (!stay) {
            window.location.reload();
          }
          return stay;
        };
        var doShowLoginDialog = function () {
          mega.ui
            .showLoginRequiredDialog({
              minUserType: 3,
              skipInitialDialog: 1,
              onLoginSuccessCb: onLoginSuccessCb
            })
            .done(() => {
              if (page !== "login" && onLoginSuccessCb) {
                onLoginSuccessCb();
              }
            });
        };
        var doShowRegisterDialog = function () {
          mega.ui.showRegisterDialog({
            title: l[5840],
            onCreatingAccount: function () {},
            onLoginAttemptFailed: function () {
              msgDialog("warninga:" + l[171], l[1578], l[218], null, function (e) {
                if (e) {
                  $(".pro-register-dialog").addClass("hidden");
                  if (signupPromptDialog) {
                    signupPromptDialog.hide();
                  }
                  doShowLoginDialog();
                }
              });
            },
            onAccountCreated: function (gotLoggedIn, registerData) {
              if (finish(!gotLoggedIn)) {
                security.register.cacheRegistrationData(registerData);
                mega.ui.sendSignupLinkDialog(registerData);
                megaChat.destroy();
              }
            },
            onLoginSuccessCb: onLoginSuccessCb
          });
        };
        if (u_handle && u_handle !== "AAAAAAAAAAA") {
          return finish();
        }
        if (forceRegister) {
          return doShowRegisterDialog();
        } else if (forceLogin) {
          return doShowLoginDialog();
        }
        if (u_wasloggedin()) {
          doShowLoginDialog();
        } else {
          doShowRegisterDialog();
        }
      };
      Chat.prototype.highlight = (text, matches, dontEscape) => {
        if (text && matches) {
          text = dontEscape ? text : escapeHTML(text);
          const tags = [];
          text = text.replace(/<[^>]+>/g, (match) => "@@!" + (tags.push(match) - 1) + "!@@").split(" ");
          const done = [];
          for (let i = 0; i < matches.length; i++) {
            const match = matches[i].str;
            if (!done.includes(match)) {
              done.push(match);
              for (let j = 0; j < text.length; j++) {
                const word = text[j];
                const wordNormalized = ChatSearch._normalize_str(word);
                const matchPos = wordNormalized.indexOf(match);
                if (matchPos > -1) {
                  const split = wordNormalized.split(match);
                  text[j] =
                    wordNormalized === word ? split.join(`[$]${match}[/$]`) : megaChat._highlightDiacritics(word, matchPos, split, match);
                }
              }
            }
          }
          text = text.join(" ").replace(/\@\@\!\d+\!\@\@/g, (match) => {
            return tags[parseInt(match.replace("@@!", "").replace("!@@"), 10)];
          });
          return text.replace(/\[\$]/g, "<strong>").replace(/\[\/\$]/g, "</strong>");
        }
        return null;
      };
      Chat.prototype._highlightDiacritics = function (word, matchPos, split, match) {
        const parts = [];
        const origMatch = word.substring(matchPos, matchPos + match.length);
        let pos = 0;
        for (let k = 0; k < split.length; k++) {
          parts.push(word.substring(pos, pos + split[k].length));
          pos = pos + split[k].length + match.length;
        }
        return parts.join(`[$]${origMatch}[/$]`);
      };
      Chat.prototype.html = function (content) {
        if (content) {
          return this.plugins.emoticonsFilter.processHtmlMessage(escapeHTML(content));
        }
        return null;
      };
      Chat.prototype.updateKeysInProtocolHandlers = function () {
        this.chats.forEach((r) => {
          let ph = r.protocolHandler;
          if (ph) {
            ph.reinitWithNewData(u_handle, u_privCu25519, u_privEd25519, u_pubEd25519, ph.chatMode);
          }
        });
      };
      Chat.prototype.eventuallyInitMeetingUI = function () {
        if (!window.location.hash) {
          return;
        }
        let loc = page.split("#")[0];
        loc = loc.replace("fm/", "/");
        if (loc.indexOf("chat/") === 0) {
          this.initialPubChatHandle = loc.substr(5).split("?")[0];
        }
      };
      Chat.prototype.enqueueChatRoomEvent = function (eventName, eventData) {
        if (!this.is_initialized) {
          return;
        }
        const { chatId } = eventData;
        if (!this._queuedChatRoomEvents[chatId]) {
          this._queuedChatRoomEvents[chatId] = [];
          (this._queuedChatRoomEvents[chatId].timer = tSleep(15)).then(() => {
            if (d) {
              this.logger.warn("Timer ran out, events lost...", this._queuedChatRoomEvents[chatId]);
            }
            delete this._queuedChatRoomEvents[chatId];
          });
        }
        this._queuedChatRoomEvents[chatId].push([eventName, eventData]);
      };
      Chat.prototype.autoJoinIfNeeded = function () {
        const rawAutoLoginInfo = localStorage.autoJoinOnLoginChat;
        if (u_type && rawAutoLoginInfo) {
          var autoLoginChatInfo = tryCatch(JSON.parse.bind(JSON))(rawAutoLoginInfo) || false;
          if (unixtime() - 7200 < autoLoginChatInfo[1]) {
            const req = this.plugins.chatdIntegration.getMciphReqFromHandleAndKey(autoLoginChatInfo[0], autoLoginChatInfo[2].substr(1));
            megaChat.rebind("onRoomInitialized.autoJoin", (e, megaRoom) => {
              if (megaRoom.chatId === autoLoginChatInfo[3]) {
                megaRoom.setActive();
                megaChat.unbind("onRoomInitialized.autoJoin");
                localStorage.removeItem("autoJoinOnLoginChat");
              }
            });
            asyncApiReq(req).catch(dump);
          } else {
            localStorage.removeItem("autoJoinOnLoginChat");
          }
        }
      };
      Chat.prototype.openScheduledMeeting = function (meetingId, toCall) {
        const meeting = this.scheduledMeetings[meetingId];
        if (!meeting) {
          console.warn("Meeting does not exist", meetingId);
          return;
        }
        window.focus();
        meeting.chatRoom.activateWindow();
        meeting.chatRoom.show();
        if (toCall && this.hasSupportForCalls) {
          this.openScheduledMeeting._queue = this.openScheduledMeeting._queue || [];
          this.openScheduledMeeting._queue.push(meetingId);
          delay("megachat:openScheduledMeetingCall", () => {
            const meetingId = this.openScheduledMeeting._queue[0];
            delete this.openScheduledMeeting._queue;
            const meetingRoom = this.scheduledMeetings[meetingId].chatRoom;
            meetingRoom.activateWindow();
            meetingRoom.show();
            const haveCall = this.haveAnyActiveCall();
            if (haveCall && window.sfuClient) {
              const { chatRoom } = this.activeCall;
              if (chatRoom && chatRoom.chatId === meetingRoom.chatId) {
                const peers = chatRoom.getCallParticipants();
                if (peers.includes(u_handle)) {
                  return d && console.warn("Already in this call");
                }
              }
            }
            (0, call.xt)(true, meetingRoom)
              .then(() => meetingRoom.startAudioCall(true))
              .catch((ex) => d && console.warn("Already in a call.", ex));
          });
        }
      };
      window.Chat = Chat;
      if (false) {
      }
      const chat = {
        Chat
      };

      /***/
    },

    /***/ 62: /***/ () => {
      (function () {
        var ChatGlobalEventManager = function () {};
        lazy(ChatGlobalEventManager.prototype, "listeners", function () {
          window.addEventListener("hashchange", (ev) => this.triggered(ev));
          $(window).rebind("resize.chatGlobalEventManager", (ev) => this.triggered(ev));
          var listeners = Object.create(null);
          listeners.resize = Object.create(null);
          listeners.hashchange = Object.create(null);
          return listeners;
        });
        ChatGlobalEventManager.prototype.addEventListener = function (eventName, namespace, cb) {
          this.listeners[eventName][namespace] = this.listeners[namespace] || cb;
        };
        ChatGlobalEventManager.prototype.removeEventListener = function (eventName, namespace) {
          delete this.listeners[eventName][namespace];
        };
        ChatGlobalEventManager.prototype.triggered = SoonFc(140, function _chatEVDispatcher(ev) {
          if (M.chat) {
            var listeners = this.listeners[ev.type];
            for (var k in listeners) {
              listeners[k](ev);
            }
          }
        });
        window.chatGlobalEventManager = new ChatGlobalEventManager();
      })();

      /***/
    },

    /***/ 804: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      // ESM COMPAT FLAG
      __webpack_require__.r(__webpack_exports__);

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, {
        MCO_FLAGS: () => MCO_FLAGS,
        RETENTION_FORMAT: () => RETENTION_FORMAT,
        default: () => chatRoom
      }); // CONCATENATED MODULE: ./js/chat/utils.jsx

      async function prepareExportIo(dl) {
        const { zname, size } = dl;
        if (
          window.isSecureContext &&
          typeof showSaveFilePicker === "function" &&
          typeof FileSystemFileHandle !== "undefined" &&
          "createWritable" in FileSystemFileHandle.prototype &&
          typeof FileSystemWritableFileStream !== "undefined" &&
          "seek" in FileSystemWritableFileStream.prototype
        ) {
          const file = await window
            .showSaveFilePicker({
              suggestedName: zname
            })
            .catch(dump);
          if (file) {
            const stream = await file.createWritable().catch(dump);
            if (stream) {
              return {
                stream,
                write: function (data, position, done) {
                  this.stream
                    .write({
                      type: "write",
                      position,
                      data
                    })
                    .then(done)
                    .catch(dump);
                },
                download: function () {
                  this.abort();
                },
                abort: function () {
                  this.stream.close();
                },
                setCredentials: function () {
                  this.begin();
                }
              };
            }
          }
        }
        if (MemoryIO.usable() && Math.min(MemoryIO.fileSizeLimit, 94371840) > size) {
          return new MemoryIO("chat_0", dl);
        } else if (window.requestFileSystem) {
          return new FileSystemAPI("chat_0", dl);
        }
        throw new Error("Download methods are unsupported");
      }
      function prepareExportStreams(attachNodes, onEmpty) {
        const CHUNK_SIZE = 1048576;
        const nextChunk = async function (controller, handle, start, size) {
          const fetched = await M.gfsfetch(handle, start, start + size).catch((ex) => {
            if (ex === EOVERQUOTA || Object(ex.target).status === 509) {
              return controller.error(ex);
            }
          });
          const input = (fetched && fetched.buffer) || new ArrayBuffer(0);
          if (!fetched || !fetched.buffer) {
            onEmpty(size);
          }
          controller.enqueue(new Uint8Array(input));
        };
        return attachNodes.map((node) => {
          return {
            name: node.name,
            lastModified: new Date((node.mtime || node.ts) * 1000),
            input: new ReadableStream({
              offset: 0,
              start(controller) {
                this.offset = Math.min(node.s, CHUNK_SIZE);
                return nextChunk(controller, node.h, 0, this.offset);
              },
              pull(controller) {
                if (this.offset >= node.s) {
                  controller.close();
                  return;
                }
                if (node.s - this.offset >= CHUNK_SIZE) {
                  const chunk = nextChunk(controller, node.h, this.offset, CHUNK_SIZE);
                  this.offset += CHUNK_SIZE;
                  return chunk;
                }
                const chunk = nextChunk(controller, node.h, this.offset, node.s - this.offset);
                this.offset = node.s;
                return chunk;
              }
            })
          };
        });
      } // CONCATENATED MODULE: ./js/chat/chatRoom.jsx
      const RETENTION_FORMAT = {
        HOURS: "hour",
        DAYS: "day",
        WEEKS: "week",
        MONTHS: "month",
        DISABLED: "none"
      };
      const MCO_FLAGS = {
        OPEN_INVITE: "oi",
        SPEAK_REQUEST: "sr",
        WAITING_ROOM: "w"
      };
      window.RETENTION_FORMAT = RETENTION_FORMAT;
      window.MCO_FLAGS = MCO_FLAGS;
      var ChatRoom = function (
        megaChat,
        roomId,
        type,
        users,
        ctime,
        lastActivity,
        chatId,
        chatShard,
        chatdUrl,
        noUI,
        publicChatHandle,
        publicChatKey,
        ck,
        isMeeting,
        retentionTime,
        mcoFlags
      ) {
        var self = this;
        this.logger = MegaLogger.getLogger("room[" + roomId + "]", {}, megaChat.logger);
        this.megaChat = megaChat;
        MegaDataObject.call(this, {
          state: null,
          users: [],
          roomId: null,
          type: null,
          messages: [],
          ctime: 0,
          lastActivity: 0,
          callRequest: null,
          isCurrentlyActive: false,
          _messagesQueue: [],
          unreadCount: 0,
          chatId: undefined,
          chatdUrl: undefined,
          chatShard: undefined,
          members: {},
          membersSet: false,
          membersLoaded: false,
          topic: "",
          flags: 0x00,
          publicLink: null,
          observers: 0,
          dnd: null,
          alwaysNotify: null,
          retentionTime: 0,
          activeCallIds: null,
          meetingsLoading: null,
          options: {},
          scheduledMeeting: undefined
        });
        this.roomId = roomId;
        this.instanceIndex = ChatRoom.INSTANCE_INDEX++;
        this.type = type;
        this.ctime = ctime;
        this.lastActivity = lastActivity ? lastActivity : 0;
        this.chatd = megaChat.plugins.chatdIntegration.chatd;
        this.chatId = chatId;
        this.chatIdBin = chatId ? base64urldecode(chatId) : "";
        this.chatShard = chatShard;
        this.chatdUrl = chatdUrl;
        this.publicLink = null;
        this.publicChatHandle = publicChatHandle;
        this.publicChatKey = publicChatKey;
        this.ck = ck;
        this.scrolledToBottom = 1;
        this.callRequest = null;
        this.shownMessages = {};
        this.retentionTime = retentionTime;
        this.activeSearches = 0;
        this.activeCallIds = new MegaDataMap(this);
        this.ringingCalls = new MegaDataMap(this);
        this.ringingCalls.addChangeListener(() => {
          megaChat.safeForceUpdate();
        });
        this.isMeeting = isMeeting;
        this.members = Object.create(null);
        Object.defineProperty(this.members, "hasOwnProperty", {
          value(p) {
            return p in this;
          }
        });
        if (type === "private") {
          users.forEach(function (userHandle) {
            self.members[userHandle] = 3;
          });
        } else {
          users.forEach(function (userHandle) {
            self.members[userHandle] = 0;
          });
        }
        this.options = {};
        mcoFlags = mcoFlags || {};
        for (const flag of Object.values(MCO_FLAGS)) {
          this.options[flag] = mcoFlags[flag] || 0;
        }
        this.setState(ChatRoom.STATE.INITIALIZED);
        this.isCurrentlyActive = false;
        if (d) {
          this.rebind("onStateChange.chatRoomDebug", function (e, oldState, newState) {
            self.logger.debug("Will change state from: ", ChatRoom.stateToText(oldState), " to ", ChatRoom.stateToText(newState));
          });
        }
        self.rebind("onStateChange.chatRoom", function (e, oldState, newState) {
          if (newState === ChatRoom.STATE.READY && !self.isReadOnly() && self.chatd && self.isOnline() && self.chatIdBin) {
            if (d > 2) {
              self.logger.warn("Restoring persisted messages...", self.type, self.isCurrentlyActive);
            }
            var cim = self.getChatIdMessages();
            cim.restore(true);
          }
        });
        self.rebind("onMessagesBuffAppend.lastActivity", function (e, msg) {
          if (is_chatlink) {
            return;
          }
          var ts = msg.delay ? msg.delay : msg.ts;
          if (!ts) {
            return;
          }
          var contactForMessage = msg && Message.getContactForMessage(msg);
          if (contactForMessage && contactForMessage.u !== u_handle) {
            if (!contactForMessage.ats || contactForMessage.ats < ts) {
              contactForMessage.ats = ts;
            }
          }
          if (self.lastActivity && self.lastActivity >= ts) {
            return;
          }
          self.lastActivity = ts;
          if (msg.userId === u_handle) {
            self.didInteraction(u_handle, ts);
            return;
          }
          if (self.type === "private") {
            var targetUserId = self.getParticipantsExceptMe()[0];
            var targetUserNode;
            if (M.u[targetUserId]) {
              targetUserNode = M.u[targetUserId];
            } else if (msg.userId) {
              targetUserNode = M.u[msg.userId];
            } else {
              console.error("Missing participant in a 1on1 room.");
              return;
            }
            assert(targetUserNode && targetUserNode.u, "No hash found for participant");
            assert(M.u[targetUserNode.u], "User not found in M.u");
            if (targetUserNode) {
              self.didInteraction(targetUserNode.u, self.lastActivity);
            }
          } else if (self.type === "group" || self.type === "public") {
            var contactHash;
            if (msg.authorContact) {
              contactHash = msg.authorContact.u;
            } else if (msg.userId) {
              contactHash = msg.userId;
            }
            if (contactHash && M.u[contactHash]) {
              self.didInteraction(contactHash, self.lastActivity);
            }
            assert(contactHash, "Invalid hash for user (extracted from inc. message)");
          } else {
            throw new Error("Not implemented");
          }
        });
        self.rebind("onMembersUpdated.coreRoomDataMngmt", function (e, eventData) {
          if (self.state === ChatRoom.STATE.LEFT && eventData.priv >= 0 && eventData.priv < 255) {
            self.membersLoaded = false;
            self.setState(ChatRoom.STATE.JOINING, true);
          }
          var queuedMembersUpdatedEvent = false;
          if (self.membersLoaded === false) {
            if (eventData.priv >= 0 && eventData.priv < 255) {
              var addParticipant = function addParticipant() {
                self.protocolHandler.addParticipant(eventData.userId);
                self.members[eventData.userId] = eventData.priv;
                ChatdIntegration._ensureContactExists([eventData.userId]);
                self.trigger("onMembersUpdatedUI", eventData);
              };
              if (is_chatlink) {
                megaChat.initContacts([eventData.userId]);
              }
              ChatdIntegration._waitForProtocolHandler(self, addParticipant);
              queuedMembersUpdatedEvent = true;
            }
          } else if (eventData.priv === 255 || eventData.priv === -1) {
            var deleteParticipant = function deleteParticipant() {
              if (eventData.userId === u_handle) {
                Object.keys(self.members).forEach(function (userId) {
                  self.protocolHandler.removeParticipant(userId);
                  delete self.members[userId];
                });
              } else {
                self.protocolHandler.removeParticipant(eventData.userId);
                delete self.members[eventData.userId];
              }
              self.trigger("onMembersUpdatedUI", eventData);
            };
            ChatdIntegration._waitForProtocolHandler(self, deleteParticipant);
            queuedMembersUpdatedEvent = true;
          }
          if (eventData.userId === u_handle) {
            self.membersLoaded = true;
          }
          if (!queuedMembersUpdatedEvent) {
            self.members[eventData.userId] = eventData.priv;
            self.trigger("onMembersUpdatedUI", eventData);
          }
        });
        if (is_chatlink && !is_chatlink.callId && !this.options.w) {
          const unbind = () => {
            self.unbind("onMessagesHistoryDone.chatlinkAlreadyIn");
            self.unbind("onMembersUpdated.chatlinkAlreadyIn");
          };
          self.rebind("onMembersUpdated.chatlinkAlreadyIn", (e, eventData) => {
            if (eventData.userId === u_handle && eventData.priv >= 0) {
              unbind();
              return this.megaChat.routing.reinitAndOpenExistingChat(this.chatId, this.publicChatHandle);
            }
          });
          self.rebind("onMessagesHistoryDone.chatlinkAlreadyIn", (e, data) => {
            if (!data.chatdPersist) {
              unbind();
            }
          });
        }
        self.rebind("onMembersUpdatedUI.chatRoomMembersSync", function (e, eventData) {
          if (eventData.userId === u_handle) {
            self.messagesBuff.joined = true;
            if (eventData.priv === 255 || eventData.priv === -1) {
              if (self.state === ChatRoom.STATE.JOINING) {
                self.setState(ChatRoom.STATE.LEFT);
              }
            } else {
              if (self.state === ChatRoom.STATE.JOINING) {
                self.setState(ChatRoom.STATE.READY);
              }
            }
          }
          self.trackDataChange();
        });
        self.getParticipantsExceptMe().forEach(function (userHandle) {
          var contact = M.u[userHandle];
          if (contact && contact.c) {
            getLastInteractionWith(contact.u);
          }
        });
        self.megaChat.trigger("onRoomCreated", [self]);
        if (this.type === "public" && self.megaChat.publicChatKeys[self.chatId]) {
          self.publicChatKey = self.megaChat.publicChatKeys[self.chatId];
        }
        $(window).rebind("focus." + self.roomId, function () {
          if (self.isCurrentlyActive) {
            self.trigger("onChatShown");
          }
        });
        self.megaChat.rebind("onRoomDestroy." + self.roomId, function (e, room) {
          if (room.roomId == self.roomId) {
            $(window).off("focus." + self.roomId);
          }
        });
        self.rebind("onClientLeftCall.chatRoom", () => self.callParticipantsUpdated());
        self.rebind("onClientJoinedCall.chatRoom", () => self.callParticipantsUpdated());
        self.rebind("onCallParticipantsUpdated.chatRoom", () => self.callParticipantsUpdated());
        self.initialMessageHistLoaded = false;
        var timer = null;
        var _historyIsAvailable = (ev) => {
          self.initialMessageHistLoaded = ev ? true : -1;
          if (timer) {
            timer.abort();
            timer = null;
          }
          self.unbind("onMarkAsJoinRequested.initHist");
          self.unbind("onHistoryDecrypted.initHist");
          self.unbind("onMessagesHistoryDone.initHist");
          self.megaChat.safeForceUpdate();
        };
        self.rebind("onHistoryDecrypted.initHist", _historyIsAvailable);
        self.rebind("onMessagesHistoryDone.initHist", _historyIsAvailable);
        self.rebind("onMarkAsJoinRequested.initHist", () => {
          (timer = tSleep(300)).then(() => {
            if (d) {
              self.logger.warn("Timed out waiting to load hist for:", self.chatId || self.roomId);
            }
            timer = null;
            _historyIsAvailable(false);
          });
        });
        self.rebind("onRoomDisconnected", () => {
          if (!self.call) {
            for (const activeCallId of self.activeCallIds.keys()) {
              self.activeCallIds.remove(activeCallId);
            }
          }
        });
        this.membersSetFromApi = new ChatRoom.MembersSet(this);
        if (publicChatHandle) {
          this.onPublicChatRoomInitialized();
        }
        return this;
      };
      inherits(ChatRoom, MegaDataObject);
      ChatRoom.STATE = {
        INITIALIZED: 5,
        JOINING: 10,
        JOINED: 20,
        READY: 150,
        ENDED: 190,
        LEAVING: 200,
        LEFT: 250
      };
      ChatRoom.INSTANCE_INDEX = 0;
      ChatRoom.ANONYMOUS_PARTICIPANT = mega.BID;
      ChatRoom.ARCHIVED = 0x01;
      ChatRoom.TOPIC_MAX_LENGTH = 30;
      ChatRoom.SCHEDULED_MEETINGS_INTERVAL = 1.8e6;
      ChatRoom._fnRequireParticipantKeys = function (fn, scope) {
        return function (...args) {
          const participants = this.protocolHandler.getTrackedParticipants();
          return ChatdIntegration._ensureKeysAreLoaded(undefined, participants)
            .then(() => {
              return fn.apply(scope || this, args);
            })
            .catch((ex) => {
              this.logger.error("Failed to retrieve keys..", ex);
            });
        };
      };
      ChatRoom.MembersSet = function (chatRoom) {
        this.chatRoom = chatRoom;
        this.members = {};
      };
      ChatRoom.MembersSet.PRIVILEGE_STATE = {
        NOT_AVAILABLE: -5,
        OPERATOR: 3,
        FULL: 2,
        READONLY: 0,
        LEFT: -1
      };
      ChatRoom.encryptTopic = function (protocolHandler, newTopic, participants, isPublic = false) {
        if (protocolHandler instanceof strongvelope.ProtocolHandler && participants.size > 0) {
          const topic = protocolHandler.embeddedEncryptTo(
            newTopic,
            strongvelope.MESSAGE_TYPES.TOPIC_CHANGE,
            participants,
            undefined,
            isPublic
          );
          if (topic) {
            return base64urlencode(topic);
          }
        }
        return false;
      };
      ChatRoom.MembersSet.prototype.trackFromActionPacket = function (ap, isMcf) {
        var self = this;
        var apMembers = {};
        (ap.u || []).forEach(function (r) {
          apMembers[r.u] = r.p;
        });
        Object.keys(self.members).forEach(function (u_h) {
          if (typeof apMembers[u_h] === "undefined") {
            self.remove(u_h);
          } else if (apMembers[u_h] !== self.members[u_h]) {
            self.update(u_h, apMembers[u_h]);
          }
        });
        Object.keys(apMembers).forEach(function (u_h) {
          if (typeof self.members[u_h] === "undefined") {
            var priv2 = apMembers[u_h];
            !isMcf ? self.add(u_h, priv2) : self.init(u_h, priv2);
          } else if (apMembers[u_h] !== self.members[u_h]) {
            self.update(u_h, apMembers[u_h]);
          }
        });
        if (!isMcf && ap.m === 1 && !ap.n && ap.url && ap.ou !== u_handle && typeof ap.p === "undefined" && !ap.topicChange) {
          self.chatRoom.trigger("onMeAdded", ap.ou);
        }
      };
      ChatRoom.MembersSet.prototype.init = function (handle, privilege) {
        this.members[handle] = privilege;
        this.chatRoom.trackDataChange();
      };
      ChatRoom.MembersSet.prototype.update = function (handle, privilege) {
        this.members[handle] = privilege;
        this.chatRoom.trackDataChange();
      };
      ChatRoom.MembersSet.prototype.add = function (handle, privilege) {
        this.members[handle] = privilege;
        if (handle === u_handle) {
          this.chatRoom.trigger("onMeJoined");
        }
        this.chatRoom.trackDataChange();
      };
      ChatRoom.MembersSet.prototype.remove = function (handle) {
        delete this.members[handle];
        if (handle === u_handle) {
          this.chatRoom.trigger("onMeLeft");
        }
        this.chatRoom.trackDataChange();
      };
      ChatRoom.prototype.trackMemberUpdatesFromActionPacket = function (ap, isMcf) {
        if (!ap.u) {
          return;
        }
        if (this.membersSetFromApi) {
          this.membersSetFromApi.trackFromActionPacket(ap, isMcf);
        }
      };
      ChatRoom.prototype.getCallParticipants = function () {
        var ids = this.activeCallIds.keys();
        if (ids.length === 0) {
          return [];
        }
        return this.activeCallIds[ids[0]];
      };
      ChatRoom.prototype.getChatIdMessages = function () {
        return this.chatd.chatIdMessages[this.chatIdBin];
      };
      ChatRoom.prototype.getRetentionFormat = function (retentionTime) {
        retentionTime = retentionTime || this.retentionTime;
        switch (true) {
          case retentionTime === 0:
            return RETENTION_FORMAT.DISABLED;
          case retentionTime % daysToSeconds(30) === 0 || retentionTime >= 31536000:
            return RETENTION_FORMAT.MONTHS;
          case retentionTime % daysToSeconds(7) === 0:
            return RETENTION_FORMAT.WEEKS;
          case retentionTime % daysToSeconds(1) === 0:
            return RETENTION_FORMAT.DAYS;
          default:
            return RETENTION_FORMAT.HOURS;
        }
      };
      ChatRoom.prototype.getRetentionTimeFormatted = function (retentionTime) {
        retentionTime = retentionTime || this.retentionTime;
        switch (this.getRetentionFormat(retentionTime)) {
          case RETENTION_FORMAT.MONTHS:
            return Math.floor(secondsToDays(retentionTime) / 30);
          case RETENTION_FORMAT.WEEKS:
            return secondsToDays(retentionTime) / 7;
          case RETENTION_FORMAT.DAYS:
            return secondsToDays(retentionTime);
          case RETENTION_FORMAT.HOURS:
            return secondsToHours(retentionTime);
          case RETENTION_FORMAT.DISABLED:
            return 0;
        }
      };
      ChatRoom.prototype.getRetentionLabel = function (retentionTime) {
        retentionTime = retentionTime || this.retentionTime;
        const days = secondsToDays(retentionTime);
        const months = Math.floor(days / 30);
        const hours = secondsToHours(retentionTime);
        switch (this.getRetentionFormat(retentionTime)) {
          case RETENTION_FORMAT.DISABLED:
            return l[7070];
          case RETENTION_FORMAT.MONTHS:
            return mega.icu.format(l.months_chat_history_plural, months);
          case RETENTION_FORMAT.WEEKS:
            return mega.icu.format(l.weeks_chat_history_plural, days / 7);
          case RETENTION_FORMAT.DAYS:
            return mega.icu.format(l.days_chat_history_plural, days);
          case RETENTION_FORMAT.HOURS:
            return mega.icu.format(l.hours_chat_history_plural, hours);
        }
      };
      ChatRoom.prototype.setRetention = function (time) {
        asyncApiReq({
          a: "mcsr",
          id: this.chatId,
          d: time,
          ds: 1
        });
      };
      ChatRoom.prototype.removeMessagesByRetentionTime = function () {
        var self = this;
        var messages = self.messagesBuff.messages;
        if (messages.length === 0 || this.retentionTime === 0) {
          return;
        }
        var newest = messages.getItem(messages.length - 1);
        var lowestValue = newest.orderValue;
        var deleteFrom = null;
        var lastMessage = null;
        var deletePreviousTo = (new Date() - self.retentionTime * 1000) / 1000;
        let cp = self.megaChat.plugins.chatdIntegration.chatd.chatdPersist;
        var finished = false;
        if (typeof cp !== "undefined") {
          var done = function (message) {
            if (message) {
              if (self.retentionTime > 0 && self.messagesBuff.messages.length > 0) {
                self.messagesBuff._removeMessagesBefore(message.messageId);
              }
              cp.removeMessagesBefore(self.chatId, message.orderValue);
            }
          };
          if (newest.delay < deletePreviousTo) {
            cp.clearChatHistoryForChat(self.chatId);
            return;
          }
          var removeMsgs = function () {
            cp._paginateMessages(lowestValue, Chatd.MESSAGE_HISTORY_LOAD_COUNT, self.chatId).then(function (messages) {
              messages = messages[0];
              if (messages.length) {
                for (let i = 0; i < messages.length; i++) {
                  let message = messages[i];
                  if (message.msgObject.delay < deletePreviousTo) {
                    deleteFrom = lastMessage || message;
                    break;
                  }
                  lastMessage = message;
                  lowestValue = message.orderValue;
                }
              } else {
                finished = true;
              }
              if (!finished && !deleteFrom) {
                onIdle(removeMsgs);
              } else {
                done(deleteFrom);
              }
            });
          };
          removeMsgs();
        }
        if (self.retentionTime > 0 && self.messagesBuff.messages.length > 0) {
          var message;
          while ((message = self.messagesBuff.messages.getItem(0))) {
            if (message.delay < deletePreviousTo) {
              if (!self.messagesBuff.messages.removeByKey(message.messageId)) {
                break;
              }
            } else {
              break;
            }
          }
        }
      };
      ChatRoom.prototype.isOnline = function () {
        var shard = this.chatd.shards[this.chatShard];
        return shard ? shard.isOnline() : false;
      };
      ChatRoom.prototype.isOnlineForCalls = function () {
        var chatdChat = this.getChatIdMessages();
        if (!chatdChat) {
          return false;
        }
        return chatdChat.loginState() >= LoginState.HISTDONE;
      };
      ChatRoom.prototype.isArchived = function () {
        var self = this;
        return self.flags & ChatRoom.ARCHIVED;
      };
      ChatRoom.prototype.isAnonymous = function () {
        return (
          is_chatlink &&
          this.type === "public" &&
          this.publicChatHandle &&
          this.publicChatKey &&
          this.publicChatHandle === megaChat.initialPubChatHandle
        );
      };
      ChatRoom.prototype.isDisplayable = function () {
        return !this.isArchived() || this.call;
      };
      ChatRoom.prototype.persistToFmdb = function () {
        var self = this;
        if (fmdb) {
          var users = [];
          if (self.members) {
            Object.keys(self.members).forEach(function (user_handle) {
              users.push({
                u: user_handle,
                p: self.members[user_handle]
              });
            });
          }
          if (self.chatId && self.chatShard !== undefined) {
            var roomInfo = {
              id: self.chatId,
              cs: self.chatShard,
              g: self.type === "group" || self.type === "public" ? 1 : 0,
              u: users,
              ts: self.ctime,
              ct: self.ct,
              ck: self.ck ? self.ck : null,
              f: self.flags,
              m: self.type === "public" ? 1 : 0
            };
            fmdb.add("mcf", {
              id: roomInfo.id,
              d: roomInfo
            });
          }
        }
      };
      ChatRoom.prototype.updateFlags = function (f, updateUI) {
        var self = this;
        var flagChange = self.flags !== f;
        self.flags = f;
        if (self.isArchived()) {
          megaChat.archivedChatsCount++;
        } else {
          megaChat.archivedChatsCount--;
        }
        self.persistToFmdb();
        if (updateUI && flagChange) {
          if (
            megaChat.currentlyOpenedChat &&
            megaChat.chats[megaChat.currentlyOpenedChat] &&
            megaChat.chats[megaChat.currentlyOpenedChat].chatId === self.chatId
          ) {
            loadSubPage("fm/chat/");
          } else {
            megaChat.refreshConversations();
          }
          if (megaChat.$conversationsAppInstance) {
            megaChat.safeForceUpdate();
          }
        }
        this.trackDataChange();
      };
      ChatRoom.stateToText = function (state) {
        var txt = null;
        $.each(ChatRoom.STATE, function (k, v) {
          if (state === v) {
            txt = k;
            return false;
          }
        });
        return txt;
      };
      ChatRoom.prototype.setState = function (newState, isRecover) {
        var self = this;
        assert(newState, "Missing state");
        if (newState === self.state) {
          self.logger.debug("Ignoring .setState, newState === oldState, current state: ", self.getStateAsText());
          return;
        }
        if (self.state) {
          assert(
            (newState === ChatRoom.STATE.JOINING && isRecover) ||
              (newState === ChatRoom.STATE.INITIALIZED && isRecover) ||
              newState > self.state,
            "Invalid state change. Current:" + ChatRoom.stateToText(self.state) + "to" + ChatRoom.stateToText(newState)
          );
        }
        var oldState = self.state;
        self.state = newState;
        self.trigger("onStateChange", [oldState, newState]);
      };
      ChatRoom.prototype.getStateAsText = function () {
        var self = this;
        return ChatRoom.stateToText(self.state);
      };
      ChatRoom.prototype.getParticipants = function () {
        var self = this;
        return Object.keys(self.members);
      };
      ChatRoom.prototype.getParticipantsExceptMe = function (userHandles) {
        var res = clone(userHandles || this.getParticipants());
        array.remove(res, u_handle, true);
        return res;
      };
      ChatRoom.prototype.getParticipantsTruncated = function (maxMembers = 5, maxLength = ChatRoom.TOPIC_MAX_LENGTH) {
        var truncatedParticipantNames = [];
        const members = Object.keys(this.members);
        for (var i = 0; i < members.length; i++) {
          var handle = members[i];
          var name = M.getNameByHandle(handle);
          if (!handle || !name || handle === u_handle) {
            continue;
          }
          if (i > maxMembers) {
            break;
          }
          truncatedParticipantNames.push(name.length > maxLength ? name.substr(0, maxLength) + "..." : name);
        }
        if (truncatedParticipantNames.length === maxMembers) {
          truncatedParticipantNames.push("...");
        }
        return truncatedParticipantNames.join(", ");
      };
      ChatRoom.prototype.getRoomTitle = function () {
        const formattedDate = l[19077].replace("%s1", new Date(this.ctime * 1000).toLocaleString());
        if (this.type === "private") {
          const participants = this.getParticipantsExceptMe();
          return participants && Array.isArray(participants) ? M.getNameByHandle(participants[0]) : formattedDate;
        }
        if (this.topic === "" || !this.topic) {
          return this.getParticipantsTruncated() || formattedDate;
        }
        const formattedTopic = this.getTruncatedRoomTopic();
        const isCanceled = this.scheduledMeeting && this.scheduledMeeting.isCanceled;
        return isCanceled ? `${formattedTopic} ${l.canceled_meeting}` : formattedTopic;
      };
      ChatRoom.prototype.getTruncatedRoomTopic = function (maxLength = ChatRoom.TOPIC_MAX_LENGTH) {
        return this.topic && this.topic.length > maxLength ? this.topic.substr(0, maxLength) + "..." : this.topic;
      };
      ChatRoom.prototype.setRoomTitle = function (newTopic, allowEmpty) {
        var self = this;
        newTopic = allowEmpty ? newTopic : String(newTopic);
        if ((allowEmpty || newTopic.trim().length > 0) && newTopic !== self.getRoomTitle()) {
          self.scrolledToBottom = true;
          var participants = self.protocolHandler.getTrackedParticipants();
          return ChatdIntegration._ensureKeysAreLoaded(undefined, participants)
            .then(() => {
              var topic = self.protocolHandler.embeddedEncryptTo(
                newTopic,
                strongvelope.MESSAGE_TYPES.TOPIC_CHANGE,
                participants,
                undefined,
                self.type === "public"
              );
              if (topic) {
                return asyncApiReq({
                  a: "mcst",
                  id: self.chatId,
                  ct: base64urlencode(topic),
                  v: Chatd.VERSION
                });
              }
            })
            .catch(dump);
        } else {
          return false;
        }
      };
      ChatRoom.prototype.leave = function (notify) {
        assert(this.type === "group" || this.type === "public", `Can't leave room "${this.roomId}" of type "${this.type}"`);
        this._leaving = true;
        this.topic = "";
        if (notify) {
          this.trigger("onLeaveChatRequested");
        }
        if (this.state !== ChatRoom.STATE.LEFT) {
          this.setState(ChatRoom.STATE.LEAVING);
          this.setState(ChatRoom.STATE.LEFT);
        }
      };
      ChatRoom.prototype.archive = function () {
        var self = this;
        var mask = 0x01;
        var flags = ChatRoom.ARCHIVED;
        asyncApiReq({
          a: "mcsf",
          id: self.chatId,
          m: 1,
          f: flags,
          v: Chatd.VERSION
        }).then((r) => {
          if (r === 0) {
            self.updateFlags(flags, true);
          }
        });
      };
      ChatRoom.prototype.unarchive = function () {
        var self = this;
        var mask = 0x01;
        var flags = 0x00;
        asyncApiReq({
          a: "mcsf",
          id: self.chatId,
          m: 1,
          f: 0,
          v: Chatd.VERSION
        }).then((res) => {
          if (res === 0) {
            self.updateFlags(0, true);
          }
        });
      };
      ChatRoom.prototype.destroy = function (notifyOtherDevices, noRedirect) {
        var self = this;
        self.megaChat.trigger("onRoomDestroy", [self]);
        var mc = self.megaChat;
        var roomJid = self.roomId;
        if (!self.stateIsLeftOrLeaving()) {
          self.leave(notifyOtherDevices);
        } else if (self.type === "public" && self.publicChatHandle) {
          if (typeof self.members[u_handle] === "undefined") {
            self.megaChat.plugins.chatdIntegration.handleLeave(self);
          }
        }
        if (self.isCurrentlyActive) {
          self.isCurrentlyActive = false;
        }
        Soon(function () {
          mc.chats.remove(roomJid);
          if (!noRedirect && u_type === 3) {
            loadSubPage("fm/chat");
          }
        });
      };
      ChatRoom.prototype.updatePublicHandle = async function (remove, cim) {
        if (!remove && this.publicLink) {
          return this.publicLink;
        }
        return asyncApiReq({
          a: "mcph",
          id: this.chatId,
          v: Chatd.VERSION,
          cim: cim ? 1 : 0,
          d: remove ? 1 : undefined
        })
          .then((res) => {
            assert((remove && res === 0) || (Array.isArray(res) && res[1].length === 8));
            this.publicLink = remove ? null : `chat/${res[1]}#${this.protocolHandler.getUnifiedKey()}`;
          })
          .catch((ex) => {
            this.logger.warn("updatePublicHandle", ex);
            this.publicLink = null;
          });
      };
      ChatRoom.prototype.iAmInRoom = function () {
        return !(!this.members.hasOwnProperty(u_handle) || this.members[u_handle] === -1);
      };
      ChatRoom.prototype.joinViaPublicHandle = function () {
        var self = this;
        if (!fminitialized && is_chatlink) {
          if (u_type) {
            return new Promise((res, rej) => {
              self.megaChat.plugins.chatdIntegration.joinChatViaPublicHandle(self).then(
                () => {
                  self.megaChat.routing.reinitAndOpenExistingChat(self.chatId, self.publicChatHandle).then(res, rej);
                },
                (ex) => {
                  console.error("Failed joining a chat room (u_type)", ex);
                  rej(ex);
                }
              );
            });
          }
          return;
        }
        if (!self.iAmInRoom() && self.type === "public" && self.publicChatHandle) {
          return megaChat.plugins.chatdIntegration.joinChatViaPublicHandle(self);
        }
        return Promise.reject();
      };
      ChatRoom.prototype.switchOffPublicMode = ChatRoom._fnRequireParticipantKeys(function () {
        let { topic, protocolHandler, chatId } = this;
        if (topic) {
          topic = protocolHandler.embeddedEncryptTo(
            topic,
            strongvelope.MESSAGE_TYPES.TOPIC_CHANGE,
            protocolHandler.getTrackedParticipants(),
            true,
            false
          );
          topic = base64urlencode(topic);
        }
        return asyncApiReq({
          a: "mcscm",
          id: chatId,
          ct: topic || undefined,
          v: Chatd.VERSION
        }).then(() => {
          protocolHandler.switchOffOpenMode();
        });
      });
      ChatRoom.prototype.show = function () {
        var self = this;
        if (self.isCurrentlyActive) {
          return false;
        }
        self.megaChat.hideAllChats();
        if (d) {
          self.logger.debug(" ---- show");
        }
        $.tresizer();
        onIdle(function () {
          self.scrollToChat();
          self.trackDataChange();
        });
        self.isCurrentlyActive = true;
        self.lastShownInUI = Date.now();
        self.megaChat.setAttachments(self.roomId);
        self.megaChat.lastOpenedChat = self.roomId;
        self.megaChat.currentlyOpenedChat = self.roomId;
        self.trigger("activity");
        self.trigger("onChatShown");
        var tmp = self.megaChat.domSectionNode;
        if (self.type === "public") {
          tmp.classList.remove("privatechat");
        } else {
          tmp.classList.add("privatechat");
        }
        if ((tmp = tmp.querySelector(".conversation-panels"))) {
          tmp.classList.remove("hidden");
          if ((tmp = tmp.querySelector('.conversation-panel[data-room-id="' + self.chatId + '"]'))) {
            tmp.classList.remove("hidden");
          }
        }
        if ((tmp = document.getElementById("conversation_" + self.roomId))) {
          tmp.classList.add("active");
        }
      };
      ChatRoom.prototype.scrollToChat = function () {
        this._scrollToOnUpdate = true;
        if (megaChat.$chatTreePanePs) {
          var li = document.querySelector("ul.conversations-pane li#conversation_" + this.roomId);
          if (li) {
            var pos = li.offsetTop;
            if (!verge.inViewport(li, -72)) {
              var treePane = document.querySelector(".conversationsApp .fm-tree-panel");
              var wrapOuterHeight = $(treePane).outerHeight();
              var itemOuterHeight = $("li:first", treePane).outerHeight();
              megaChat.$chatTreePanePs.doProgramaticScroll(Math.max(0, pos - wrapOuterHeight / 2 + itemOuterHeight), true);
              this._scrollToOnUpdate = false;
            }
          }
        }
      };
      ChatRoom.prototype.isActive = function () {
        return document.hasFocus() && this.isCurrentlyActive;
      };
      ChatRoom.prototype.setActive = function () {
        loadSubPage(this.getRoomUrl());
      };
      ChatRoom.prototype.isLoading = function () {
        var mb = this.messagesBuff;
        return mb.messagesHistoryIsLoading() || mb.isDecrypting;
      };
      ChatRoom.prototype.getRoomUrl = function (getRawLink) {
        var self = this;
        if (self.type === "private") {
          var participants = self.getParticipantsExceptMe();
          var contact = M.u[participants[0]];
          if (contact) {
            return "fm/chat/p/" + contact.u;
          }
        } else if (!getRawLink && is_chatlink && self.type === "public" && self.publicChatHandle && self.publicChatKey) {
          return "chat/" + self.publicChatHandle + "#" + self.publicChatKey;
        } else if (self.type === "public") {
          return "fm/chat/c/" + self.roomId;
        } else if (self.type === "group" || self.type === "public") {
          return "fm/chat/g/" + self.roomId;
        } else {
          throw new Error("Can't get room url for unknown room type.");
        }
      };
      ChatRoom.prototype.activateWindow = function () {
        var self = this;
        loadSubPage(self.getRoomUrl());
      };
      ChatRoom.prototype.hide = function () {
        var self = this;
        if (d) {
          self.logger.debug(" ---- hide", self.isCurrentlyActive);
        }
        self.isCurrentlyActive = false;
        self.lastShownInUI = Date.now();
        if (self.megaChat.currentlyOpenedChat === self.roomId) {
          self.megaChat.currentlyOpenedChat = null;
        }
        var tmp = self.megaChat.domSectionNode.querySelector('.conversation-panel[data-room-id="' + self.chatId + '"]');
        if (tmp) {
          tmp.classList.add("hidden");
        }
        if ((tmp = document.getElementById("conversation_" + self.roomId))) {
          tmp.classList.remove("active");
        }
        self.trigger("onChatHidden", self.isCurrentlyActive);
      };
      ChatRoom.prototype.appendMessage = function (message) {
        var self = this;
        if (message.deleted) {
          return false;
        }
        if (self.shownMessages[message.messageId]) {
          return false;
        }
        if (!message.orderValue) {
          var mb = self.messagesBuff;
          if (mb.messages.length > 0) {
            var prevMsg = mb.messages.getItem(mb.messages.length - 1);
            if (!prevMsg) {
              self.logger.error(
                "self.messages got out of sync...maybe there are some previous JS exceptions that caused that? note that messages may be displayed OUT OF ORDER in the UI."
              );
            } else {
              var nextVal = prevMsg.orderValue + 0.1;
              if (!prevMsg.sent) {
                var cid = megaChat.plugins.chatdIntegration.chatd.chatIdMessages[self.chatIdBin];
                if (cid && cid.highnum) {
                  nextVal = ++cid.highnum;
                }
              }
              message.orderValue = nextVal;
            }
          }
        }
        message.source = Message.SOURCE.SENT;
        self.trigger("onMessageAppended", message);
        self.messagesBuff.messages.push(message);
        self.shownMessages[message.messageId] = true;
      };
      ChatRoom.prototype.getNavElement = function () {
        var self = this;
        return $('.nw-conversations-item[data-room-id="' + self.chatId + '"]');
      };
      ChatRoom.prototype.sendMessage = function (message) {
        var self = this;
        var megaChat = this.megaChat;
        var messageId = megaChat.generateTempMessageId(self.roomId, message);
        var msgObject = new Message(self, self.messagesBuff, {
          messageId: messageId,
          userId: u_handle,
          message: message,
          textContents: message,
          delay: unixtime(),
          sent: Message.STATE.NOT_SENT
        });
        self.trigger("onSendMessage");
        self.appendMessage(msgObject);
        return self
          ._sendMessageToTransport(msgObject)
          .then((internalId) => {
            if (!internalId) {
              this.logger.warn(`Got unexpected(?) 'sendingnum'...`, internalId);
            }
            msgObject.internalId = internalId;
            msgObject.orderValue = internalId;
            return internalId || -0xbadf;
          })
          .catch((ex) => {
            this.logger.error(`sendMessage failed..`, msgObject, ex);
          });
      };
      ChatRoom.prototype._sendMessageToTransport = function (messageObject) {
        var self = this;
        var megaChat = this.megaChat;
        megaChat.trigger("onPreBeforeSendMessage", messageObject);
        megaChat.trigger("onBeforeSendMessage", messageObject);
        megaChat.trigger("onPostBeforeSendMessage", messageObject);
        return megaChat.plugins.chatdIntegration.sendMessage(self, messageObject);
      };
      ChatRoom.prototype._sendNodes = function (nodeids, users) {
        var promises = [];
        var self = this;
        if (self.type === "public") {
          nodeids.forEach(function (nodeId) {
            promises.push(
              asyncApiReq({
                a: "mcga",
                n: nodeId,
                u: strongvelope.COMMANDER,
                id: self.chatId,
                v: Chatd.VERSION
              })
            );
          });
        } else {
          users.forEach(function (uh) {
            nodeids.forEach(function (nodeId) {
              promises.push(
                asyncApiReq({
                  a: "mcga",
                  n: nodeId,
                  u: uh,
                  id: self.chatId,
                  v: Chatd.VERSION
                })
              );
            });
          });
        }
        return Promise.allSettled(promises);
      };
      ChatRoom.prototype.attachNodes = async function (nodes, names) {
        if (!Array.isArray(nodes)) {
          nodes = [nodes];
        }
        const handles = new Set();
        for (let i = nodes.length; i--; ) {
          const n = nodes[i];
          const h = String((crypto_keyok(n) && n.h) || n);
          if (!M.getNodeByHandle(h)) {
            handles.add(h);
          }
        }
        if (handles.size) {
          await dbfetch.acquire([...handles]);
        }
        return this._attachNodes(nodes, names);
      };
      ChatRoom.prototype._attachNodes = mutex("chatroom-attach-nodes", function _(resolve, reject, nodes, names) {
        var i;
        var step = 0;
        var users = [];
        var self = this;
        let result = null;
        var copy = Object.create(null);
        var send = Object.create(null);
        let link = Object.create(null);
        let nmap = Object.create(null);
        var members = self.getParticipantsExceptMe();
        var attach = (nodes) => {
          console.assert(self.type === "public" || users.length, "No users to send to?!");
          return this._sendNodes(nodes, users).then(() => {
            for (var i = nodes.length; i--; ) {
              const n = nmap[nodes[i]] || M.getNodeByHandle(nodes[i]);
              console.assert(n.h, `Node not found... ${nodes[i]}`);
              if (n.h) {
                const name = (names && (names[n.hash] || names[n.h])) || n.name;
                self.sendMessage(
                  Message.MANAGEMENT_MESSAGE_TYPES.MANAGEMENT +
                    Message.MANAGEMENT_MESSAGE_TYPES.ATTACHMENT +
                    JSON.stringify([
                      {
                        h: n.h,
                        k: n.k,
                        t: n.t,
                        s: n.s,
                        fa: n.fa,
                        ts: n.ts,
                        hash: n.hash,
                        name
                      }
                    ])
                );
              }
            }
          });
        };
        var done = function () {
          if (--step < 1) {
            nmap = null;
            resolve(result);
          }
        };
        var fail = function (ex) {
          if (ex === EBLOCKED) {
            result = ex;
          } else if (d) {
            _.logger.error(ex);
          }
          done();
        };
        if (d && !_.logger) {
          _.logger = new MegaLogger("attachNodes", {}, self.logger);
        }
        for (i = members.length; i--; ) {
          var usr = M.getUserByHandle(members[i]);
          if (usr.u) {
            users.push(usr.u);
          }
        }
        for (i = nodes.length; i--; ) {
          const h = nodes[i];
          const n = crypto_keyok(h) ? h : M.getNodeByHandle(h);
          if (n.t) {
            link[n.h] = 1;
            continue;
          }
          if (n.hash) {
            nmap[n.hash] = n;
            if (names && names[n.h]) {
              names[n.hash] = names[n.h];
            }
          }
          let op = send;
          if (!n.ch && (n.u !== u_handle || M.getNodeRoot(n.h) === "shares")) {
            op = copy;
          }
          op[n.h] = 1;
          nmap[n.h] = n;
        }
        copy = Object.keys(copy);
        send = Object.keys(send);
        link = Object.keys(link);
        if (d) {
          _.logger.debug("copy:%d, send:%d, link:%d", copy.length, send.length, link.length, copy, send, link);
        }
        if (link.length) {
          ++step;
          Promise.resolve(mega.fileRequestCommon.storage.isDropExist(link))
            .then((res) => {
              if (res.length) {
                return mega.fileRequest.showRemoveWarning(res);
              }
            })
            .then(() => {
              const createLink = (h) => M.createPublicLink(h).then(({ link }) => this.sendMessage(link));
              return Promise.all(link.map(createLink));
            })
            .then(done)
            .catch(fail);
        }
        if (send.length) {
          step++;
          attach(send).then(done).catch(fail);
        }
        if (copy.length) {
          step++;
          this._copyNodesToAttach(copy, nmap)
            .then((res) => attach(res))
            .then(done)
            .catch(fail);
        }
        if (!step) {
          if (d) {
            _.logger.warn("Nothing to do here...");
          }
          queueMicrotask(done);
        }
      });
      ChatRoom.prototype._copyNodesToAttach = async function (copy, nmap) {
        const { h: target } = await M.myChatFilesFolder.get(true);
        if (!M.c[target]) {
          await dbfetch.get(target);
        }
        const dir = Object.keys(M.c[target] || {});
        const rem = [];
        for (let i = copy.length; i--; ) {
          const n = nmap[copy[i]] || M.getNodeByHandle(copy[i]);
          console.assert(n.h, `Node not found.. ${copy[i]}`);
          for (let y = dir.length; y--; ) {
            const b = M.getNodeByHandle(dir[y]);
            if (n.h === b.h || b.hash === n.hash) {
              if (d) {
                this.logger.info("deduplication %s:%s", n.h, b.h, [n], [b]);
              }
              rem.push(n.h);
              copy.splice(i, 1);
              break;
            }
          }
        }
        let res = [];
        if (copy.length) {
          res = await M.copyNodes(copy, target);
        } else if (d) {
          this.logger.info("No new nodes to copy.", rem);
        }
        assert(Array.isArray(res), `Unexpected response, ${(res && res.message) || res}`, res);
        const [h] = res;
        res = [...rem, ...res];
        assert(res.length, "Unexpected condition... nothing to attach ?!");
        for (let i = res.length; i--; ) {
          const n = nmap[res[i]] || M.getNodeByHandle(res[i]);
          if (n.fv) {
            if (d) {
              this.logger.info("Skipping file-version %s", n.h, n);
            }
            res.splice(i, 1);
          }
        }
        if (h && !res.length) {
          if (d) {
            this.logger.info("Adding nothing but a file-version?..", h);
          }
          res = [h];
        }
        return res;
      };
      ChatRoom.prototype.onUploadStart = function (data) {
        var self = this;
        if (d) {
          self.logger.debug("onUploadStart", data);
        }
      };
      ChatRoom.prototype.uploadFromComputer = function () {
        this.scrolledToBottom = true;
        $("#fileselect1").trigger("click");
      };
      ChatRoom.prototype.attachContacts = function (ids) {
        for (let i = 0; i < ids.length; i++) {
          const nodeId = ids[i];
          const node = M.u[nodeId];
          this.sendMessage(
            Message.MANAGEMENT_MESSAGE_TYPES.MANAGEMENT +
              Message.MANAGEMENT_MESSAGE_TYPES.CONTACT +
              JSON.stringify([
                {
                  u: node.u,
                  email: node.m,
                  name: node.name || node.m
                }
              ])
          );
        }
      };
      ChatRoom.prototype.getMessageById = function (messageId) {
        var self = this;
        var msgs = self.messagesBuff.messages;
        var msgKeys = msgs.keys();
        for (var i = 0; i < msgKeys.length; i++) {
          var k = msgKeys[i];
          var v = msgs[k];
          if (v && v.messageId === messageId) {
            return v;
          }
        }
        return false;
      };
      ChatRoom.prototype.hasUserMessages = function () {
        const { messages } = this.messagesBuff;
        return !!messages.length && messages.some((m) => m.messageHtml);
      };
      ChatRoom.prototype.renderContactTree = function () {
        var self = this;
        var $navElement = self.getNavElement();
        var $count = $(".nw-conversations-unread", $navElement);
        var count = self.messagesBuff.getUnreadCount();
        if (count > 0) {
          $count.text(count > 9 ? "9+" : count);
          $navElement.addClass("unread");
        } else if (count === 0) {
          $count.text("");
          $navElement.removeClass("unread");
        }
        $navElement.data("chatroom", self);
      };
      ChatRoom.prototype.getUnreadCount = function () {
        var self = this;
        return self.messagesBuff.getUnreadCount();
      };
      ChatRoom.prototype.recover = function () {
        var self = this;
        self.callRequest = null;
        if (self.state !== ChatRoom.STATE.LEFT) {
          self.membersLoaded = false;
          self.setState(ChatRoom.STATE.JOINING, true);
          self.megaChat.trigger("onRoomCreated", [self]);
          return MegaPromise.resolve();
        } else {
          return MegaPromise.reject();
        }
      };
      ChatRoom.prototype.showMissingUnifiedKeyDialog = function () {
        return msgDialog(
          `warningb:!^${l[82]}!${l[23433]}`,
          null,
          l[200],
          l.chat_key_failed_dlg_text,
          (reload) => (reload ? M.reload() : null),
          1
        );
      };
      ChatRoom.prototype.hasInvalidKeys = function () {
        if (!is_chatlink && this.type === "public") {
          const { unifiedKey } = this.protocolHandler || {};
          if (!unifiedKey || (unifiedKey && unifiedKey.length !== 16) || !this.ck || (this.ck && this.ck.length !== 32)) {
            console.error("Error instantiating room/call -- missing `unifiedKey`/malformed `ck` for public chat.");
            const { master, slaves } = mBroadcaster.crossTab;
            eventlog(
              99751,
              JSON.stringify([
                1,
                buildVersion.website || "dev",
                String(this.chatId).length | 0,
                this.type | 0,
                this.isMeeting | 0,
                typeof unifiedKey,
                String(unifiedKey || "").length | 0,
                typeof this.ck,
                String(this.ck).length | 0,
                !!master | 0,
                Object(slaves).length | 0
              ])
            );
            return true;
          }
        }
        return false;
      };
      ChatRoom.prototype.joinCall = ChatRoom._fnRequireParticipantKeys(function (audio, video, callId) {
        if (!megaChat.hasSupportForCalls || this.activeCallIds.length === 0 || this.meetingsLoading) {
          return;
        }
        if (this.hasInvalidKeys()) {
          return this.showMissingUnifiedKeyDialog();
        }
        this.meetingsLoading = {
          title: l.joining,
          audio,
          video
        };
        callId = callId || this.activeCallIds.keys()[0];
        return asyncApiReq({
          a: "mcmj",
          cid: this.chatId,
          mid: callId
        }).then((r) => {
          this.startOrJoinCall(callId, r.url, audio, video);
        });
      });
      ChatRoom.prototype.startOrJoinCall = function (callId, url, audio, video) {
        tryCatch(
          () => {
            const call = (this.call = megaChat.activeCall = megaChat.plugins.callManager2.createCall(this, callId));
            const sfuClient =
              (window.sfuClient =
              call.sfuClient =
                new SfuClient(
                  u_handle,
                  call,
                  this.protocolHandler.chatMode === strongvelope.CHAT_MODE.PUBLIC && str_to_ab(this.protocolHandler.unifiedKey),
                  {
                    speak: true,
                    moderator: true
                  }
                ));
            call.setSfuClient(sfuClient);
            sfuClient.muteAudio(!audio);
            sfuClient.muteCamera(!video);
            return sfuClient.connect(url, callId, {
              isGroup: this.type !== "private"
            });
          },
          (ex) => {
            this.call = megaChat.activeCall = null;
            this.meetingsLoading = false;
            console.error("Failed to start/join call:", ex);
          }
        )();
      };
      ChatRoom.prototype.rejectCall = function (callId) {
        if (this.activeCallIds.length === 0) {
          return;
        }
        callId = callId || this.activeCallIds.keys()[0];
        if (this.type === "private") {
          return asyncApiReq({
            a: "mcme",
            cid: this.chatId,
            mid: callId
          });
        }
        const shard = this.chatd.shards[this.chatShard];
        if (shard) {
          shard.sendCallReject(base64urldecode(this.chatId), base64urldecode(callId));
        }
        return Promise.resolve();
      };
      ChatRoom.prototype.ringUser = function (userId, callId, callstate) {
        assert(userId, "Missing user handle.");
        assert(callId, "Missing chat handle.");
        assert(this.type !== "private", "Unexpected chat type.");
        const shard = this.chatd.shards[this.chatShard];
        if (shard) {
          api
            .req({
              a: "mcru",
              u: userId,
              cid: this.chatId
            })
            .then(() => shard.ringUser(this.chatIdBin, base64urldecode(userId), base64urldecode(callId), callstate))
            .catch(dump);
        }
      };
      ChatRoom.prototype.endCallForAll = function (callId) {
        if (this.activeCallIds.length && this.type !== "private") {
          callId = callId || this.activeCallIds.keys()[0];
          asyncApiReq({
            a: "mcme",
            cid: this.chatId,
            mid: callId
          });
          eventlog(99761, JSON.stringify([this.chatId, callId, this.isMeeting | 0]));
        }
      };
      ChatRoom.prototype.startAudioCall = function (scheduled) {
        return this.startCall(true, false, scheduled);
      };
      ChatRoom.prototype.startVideoCall = function (scheduled) {
        return this.startCall(true, true, scheduled);
      };
      ChatRoom.prototype.startCall = ChatRoom._fnRequireParticipantKeys(function (audio, video, scheduled) {
        if (!megaChat.hasSupportForCalls || this.meetingsLoading) {
          return;
        }
        if (this.activeCallIds.length > 0) {
          this.joinCall(this.activeCallIds.keys()[0]);
          return;
        }
        if (this.hasInvalidKeys()) {
          return this.showMissingUnifiedKeyDialog();
        }
        this.meetingsLoading = {
          title: l.starting,
          audio,
          video
        };
        const opts = {
          a: "mcms",
          cid: this.chatId,
          sm: scheduled && this.scheduledMeeting && this.scheduledMeeting.id
        };
        if (localStorage.sfuId) {
          opts.sfu = parseInt(localStorage.sfuId, 10);
        }
        return asyncApiReq(opts)
          .then((r) => {
            this.startOrJoinCall(r.callId, r.sfu, audio, video);
          })
          .catch((ex) => {
            this.meetingsLoading = false;
            this.logger.error(`Failed to start call: ${ex}`);
          });
      });
      ChatRoom.prototype.subscribeForCallEvents = function () {
        const callMgr = megaChat.plugins.callManager2;
        this.rebind("onChatdPeerJoinedCall.callManager", (e, data) => {
          if (!this.activeCallIds.exists(data.callId)) {
            this.activeCallIds.set(data.callId, []);
          }
          this.activeCallIds.set(data.callId, [...this.activeCallIds[data.callId], ...data.participants]);
          const parts = data.participants;
          for (var i = 0; i < parts.length; i++) {
            if (this.type === "private" || (parts[i] === u_handle && this.ringingCalls.exists(data.callId))) {
              this.ringingCalls.remove(data.callId);
              callMgr.trigger("onRingingStopped", {
                callId: data.callId,
                chatRoom: this
              });
            }
          }
          this.callParticipantsUpdated();
        });
        this.rebind("onChatdPeerLeftCall.callManager", (e, data) => {
          if (!this.activeCallIds[data.callId]) {
            return;
          }
          const parts = data.participants;
          for (var i = 0; i < parts.length; i++) {
            array.remove(this.activeCallIds[data.callId], parts[i], true);
            if (parts[i] === u_handle && this.ringingCalls.exists(data.callId)) {
              this.ringingCalls.remove(data.callId);
              callMgr.trigger("onRingingStopped", {
                callId: data.callId,
                chatRoom: this
              });
            }
          }
          this.callParticipantsUpdated();
        });
        this.rebind("onCallLeft.callManager", (e, data) => {
          console.warn("onCallLeft:", JSON.stringify(data));
          const { call } = this;
          if (!call || call.callId !== data.callId) {
            if (d) {
              console.warn("... no active call or event not for it");
            }
            return;
          }
          this.meetingsLoading = false;
          call.hangUp(data.reason);
          megaChat.activeCall = this.call = null;
        });
        this.rebind("onChatdCallEnd.callManager", (e, data) => {
          if (d) {
            console.warn("onChatdCallEnd:", JSON.stringify(data));
          }
          this.meetingsLoading = false;
          this.activeCallIds.remove(data.callId);
          this.stopRinging(data.callId);
          this.callParticipantsUpdated();
        });
        this.rebind("onCallState.callManager", function (e, data) {
          assert(this.activeCallIds[data.callId], `unknown call: ${data.callId}`);
          callMgr.onCallState(data, this);
          this.callParticipantsUpdated();
        });
        this.rebind("onRoomDisconnected.callManager", function () {
          this.activeCallIds.clear();
          if (navigator.onLine) {
            return;
          }
          if (this.call) {
            this.trigger("ChatDisconnected", this);
          }
          this.callParticipantsUpdated();
        });
        this.rebind("onStateChange.callManager", function (e, oldState, newState) {
          if (newState === ChatRoom.STATE.LEFT && this.call) {
            this.call.hangUp(SfuClient.TermCode.kLeavingRoom);
          }
        });
        this.rebind("onCallPeerLeft.callManager", (e, data) => {
          const { call } = this;
          if (call.isDestroyed || call.hasOtherParticipant() || SfuClient.isTermCodeRetriable(data.reason)) {
            return;
          }
          if (this.type === "private") {
            return this.trigger("onCallLeft", {
              callId: call.callId
            });
          }
          setTimeout(() => {
            if (this.call === call) {
              this.call.initCallTimeout();
            }
          }, 3000);
        });
        this.rebind("onMeAdded", (e, addedBy) => {
          if (this.activeCallIds.length > 0) {
            const callId = this.activeCallIds.keys()[0];
            if (this.ringingCalls.exists(callId)) {
              return;
            }
            this.ringingCalls.set(callId, addedBy);
            this.megaChat.trigger("onIncomingCall", [this, callId, addedBy, callMgr]);
            this.fakedLocalRing = true;
            setTimeout(() => {
              delete this.fakedLocalRing;
              if (this.ringingCalls.exists(callId)) {
                callMgr.trigger("onRingingStopped", {
                  callId: callId,
                  chatRoom: this
                });
              }
            }, 30e3);
          }
        });
      };
      ChatRoom.prototype.stateIsLeftOrLeaving = function () {
        return (
          this.state == ChatRoom.STATE.LEFT ||
          this.state == ChatRoom.STATE.LEAVING ||
          (!is_chatlink &&
            this.state === ChatRoom.STATE.READY &&
            this.membersSetFromApi &&
            !this.membersSetFromApi.members.hasOwnProperty(u_handle)) ||
          (is_chatlink && !this.members.hasOwnProperty(u_handle))
        );
      };
      ChatRoom.prototype._clearChatMessagesFromChatd = function () {
        this.chatd.shards[this.chatShard].retention(base64urldecode(this.chatId), 1);
      };
      ChatRoom.prototype.isReadOnly = function () {
        if (this.type === "private") {
          var members = this.getParticipantsExceptMe();
          if (members[0] && !M.u[members[0]].c) {
            return true;
          }
        }
        return (
          (this.members && this.members[u_handle] <= 0) ||
          !this.members.hasOwnProperty(u_handle) ||
          this.privateReadOnlyChat ||
          this.state === ChatRoom.STATE.LEAVING ||
          this.state === ChatRoom.STATE.LEFT
        );
      };
      ChatRoom.prototype.iAmOperator = function () {
        return this.type === "private" || (this.members && this.members[u_handle] === ChatRoom.MembersSet.PRIVILEGE_STATE.OPERATOR);
      };
      ChatRoom.prototype.iAmReadOnly = function () {
        return this.type !== "private" && this.members && this.members[u_handle] === ChatRoom.MembersSet.PRIVILEGE_STATE.READONLY;
      };
      ChatRoom.prototype.iAmWaitingRoomPeer = function () {
        return this.options.w && !this.iAmOperator();
      };
      ChatRoom.prototype.didInteraction = function (user_handle, ts) {
        var self = this;
        var newTs = ts || unixtime();
        if (user_handle === u_handle) {
          Object.keys(self.members).forEach(function (user_handle) {
            var contact = M.u[user_handle];
            if (contact && user_handle !== u_handle && contact.c === 1) {
              setLastInteractionWith(contact.u, "1:" + newTs);
            }
          });
        } else {
          var contact = M.u[user_handle];
          if (contact && user_handle !== u_handle && contact.c === 1) {
            setLastInteractionWith(contact.u, "1:" + newTs);
          }
        }
      };
      ChatRoom.prototype.retrieveAllHistory = function () {
        var self = this;
        self.messagesBuff.retrieveChatHistory().done(function () {
          if (self.messagesBuff.haveMoreHistory()) {
            self.retrieveAllHistory();
          }
        });
      };
      ChatRoom.prototype.seedRoomKeys = async function (keys) {
        assert(Array.isArray(keys) && keys.length, `Invalid keys parameter for seedRoomKeys.`, keys);
        if (d > 2) {
          this.logger.warn("Seeding room keys...", keys);
        }
        const promises = [ChatdIntegration._ensureKeysAreLoaded(keys, undefined, this.publicChatHandle)];
        if (!this.protocolHandler) {
          promises.push(ChatdIntegration._waitForProtocolHandler(this));
        }
        if (!this.notDecryptedKeys) {
          this.notDecryptedKeys = Object.create(null);
        }
        for (let i = keys.length; i--; ) {
          const { key, keyid, keylen, userId } = keys[i];
          this.notDecryptedKeys[`${userId}-${keyid}`] = {
            userId,
            keyid,
            keylen,
            key
          };
        }
        const promise = (this._keysAreSeeding = Promise.all(promises)
          .then(() => {
            const res = this.protocolHandler.seedKeys(keys);
            for (let i = res.length; i--; ) {
              delete this.notDecryptedKeys[res[i]];
            }
            return res;
          })
          .catch((ex) => {
            this.logger.error("Failed to seed room keys!", ex, keys);
            throw ex;
          })
          .finally(() => {
            if (promise === this._keysAreSeeding) {
              delete this._keysAreSeeding;
            }
          }));
        return promise;
      };
      ChatRoom.prototype.truncate = function () {
        var self = this;
        var chatMessages = self.messagesBuff.messages;
        if (chatMessages.length > 0) {
          var lastChatMessageId = null;
          var i = chatMessages.length - 1;
          while (lastChatMessageId == null && i >= 0) {
            var message = chatMessages.getItem(i);
            if (message instanceof Message && message.dialogType !== "truncated") {
              lastChatMessageId = message.messageId;
            }
            i--;
          }
          if (lastChatMessageId) {
            asyncApiReq({
              a: "mct",
              id: self.chatId,
              m: lastChatMessageId,
              v: Chatd.VERSION
            }).catch((ex) => {
              if (ex === -2) {
                msgDialog("warninga", l[135], l[8880]);
              }
            });
          }
        }
      };
      ChatRoom.prototype.getActiveCalls = function () {
        return this.activeCallIds.map((parts, id) => {
          return parts.indexOf(u_handle) > -1 ? id : undefined;
        });
      };
      ChatRoom.prototype.haveActiveCall = function () {
        return this.getActiveCalls().length > 0;
      };
      ChatRoom.prototype.haveActiveOnHoldCall = function () {
        let activeCallIds = this.getActiveCalls();
        for (var i = 0; i < activeCallIds.length; i++) {
          let call = megaChat.plugins.callManager2.calls[this.chatId + "_" + activeCallIds[i]];
          if (call && call.av & SfuClient.Av.onHold) {
            return true;
          }
        }
        return false;
      };
      ChatRoom.prototype.havePendingGroupCall = function () {
        if (this.type !== "group" && this.type !== "public") {
          return false;
        }
        return this.activeCallIds.length > 0;
      };
      ChatRoom.prototype.havePendingCall = function () {
        return this.activeCallIds.length > 0;
      };
      ChatRoom.prototype.getActiveCallMessageId = function (ignoreActive) {
        var self = this;
        if (!ignoreActive && !self.havePendingCall() && !self.haveActiveCall()) {
          return false;
        }
        var msgs = self.messagesBuff.messages;
        for (var i = msgs.length - 1; i >= 0; i--) {
          var msg = msgs.getItem(i);
          if (msg.dialogType === "remoteCallEnded") {
            return false;
          }
          if (msg.dialogType === "remoteCallStarted") {
            return msg.messageId;
          }
        }
      };
      ChatRoom.prototype.stopRinging = function (callId) {
        if (this.ringingCalls.exists(callId)) {
          this.ringingCalls.remove(callId);
        }
        megaChat.plugins.callManager2.trigger("onRingingStopped", {
          callId: callId,
          chatRoom: this
        });
      };
      ChatRoom.prototype.callParticipantsUpdated = function () {
        var self = this;
        var msgId = self.getActiveCallMessageId();
        if (!msgId) {
          msgId = self.getActiveCallMessageId(true);
        }
        const callParts = self.getCallParticipants() || [];
        self.uniqueCallParts = {};
        for (let i = 0; i < callParts.length; i++) {
          self.uniqueCallParts[callParts[i]] = true;
        }
        var msg = self.messagesBuff.getMessageById(msgId);
        msg && msg.wrappedChatDialogMessage && msg.wrappedChatDialogMessage.trackDataChange();
        self.trackDataChange();
      };
      ChatRoom.prototype.onPublicChatRoomInitialized = function () {
        var self = this;
        if (self.type !== "public" || !localStorage.autoJoinOnLoginChat) {
          return;
        }
        var autoLoginChatInfo = tryCatch(JSON.parse.bind(JSON))(localStorage.autoJoinOnLoginChat) || false;
        if (autoLoginChatInfo[0] === self.publicChatHandle) {
          localStorage.removeItem("autoJoinOnLoginChat");
          if (unixtime() - 7200 < autoLoginChatInfo[1]) {
            var doJoinEventually = function (state) {
              if (state === ChatRoom.STATE.READY) {
                self.joinViaPublicHandle();
                self.unbind("onStateChange." + self.publicChatHandle);
              }
            };
            self.rebind("onStateChange." + self.publicChatHandle, function (e, oldState, newState) {
              doJoinEventually(newState);
            });
            doJoinEventually(self.state);
          }
        }
      };
      ChatRoom.prototype.isUIMounted = function () {
        return this._uiIsMounted;
      };
      ChatRoom.prototype.attachSearch = function () {
        this.activeSearches++;
      };
      ChatRoom.prototype.detachSearch = function () {
        if (--this.activeSearches === 0) {
          this.messagesBuff.detachMessages();
        }
        this.activeSearches = Math.max(this.activeSearches, 0);
        this.trackDataChange();
      };
      ChatRoom.prototype.scrollToMessageId = function (msgId, index, retryActive) {
        var self = this;
        if (!self.isCurrentlyActive && !retryActive) {
          tSleep(1.5).then(() => {
            self.scrollToMessageId(msgId, index, true);
          });
          return;
        }
        assert(self.isCurrentlyActive, "chatRoom is not visible");
        self.isScrollingToMessageId = true;
        if (!self.$rConversationPanel) {
          self.one("onHistoryPanelComponentDidMount.scrollToMsgId" + msgId, function () {
            self.scrollToMessageId(msgId, index);
          });
          return;
        }
        var ps = self.$rConversationPanel.messagesListScrollable;
        assert(ps);
        var msgObj = self.messagesBuff.getMessageById(msgId);
        if (msgObj) {
          var elem = $("." + msgId + ".message.body")[0];
          self.scrolledToBottom = false;
          ps.scrollToElement(elem, true);
          self.$rConversationPanel.lastScrollPosition = undefined;
          self.isScrollingToMessageId = false;
        } else if (self.messagesBuff.isRetrievingHistory) {
          self.one("onHistoryDecrypted.scrollToMsgId" + msgId, function () {
            self.one("onComponentDidUpdate.scrollToMsgId" + msgId, function () {
              self.scrollToMessageId(msgId, index);
            });
          });
        } else if (self.messagesBuff.haveMoreHistory()) {
          self.messagesBuff.retrieveChatHistory(!index || index <= 0 ? undefined : index);
          ps.doProgramaticScroll(0, true);
          self.one("onHistoryDecrypted.scrollToMsgId" + msgId, function () {
            self.one("onComponentDidUpdate.scrollToMsgId" + msgId, function () {
              self.scrollToMessageId(msgId);
            });
          });
        } else {
          self.isScrollingToMessageId = false;
        }
      };
      ChatRoom.prototype.setMcoFlags = function (flags) {
        const req = {
          a: "mco",
          cid: this.chatId,
          ...flags
        };
        asyncApiReq(req).dump("roomSetCallFlags");
      };
      ChatRoom.prototype.toggleOpenInvite = function () {
        if (this.type === "private" || !this.iAmOperator()) {
          return;
        }
        this.setMcoFlags({
          [MCO_FLAGS.OPEN_INVITE]: Math.abs(this.options[MCO_FLAGS.OPEN_INVITE] - 1)
        });
      };
      ChatRoom.prototype.toggleWaitingRoom = function () {
        if (this.type === "private" || !this.iAmOperator()) {
          return;
        }
        this.setMcoFlags({
          [MCO_FLAGS.WAITING_ROOM]: Math.abs(this.options[MCO_FLAGS.WAITING_ROOM] - 1)
        });
      };
      ChatRoom.prototype.exportToFile = function () {
        if (this.messagesBuff.messages.length === 0 || this.exportIo) {
          return;
        }
        loadingDialog.show("chat_export");
        eventlog(99874);
        this._exportChat()
          .then(() => {
            eventlog(99875, JSON.stringify([1]));
          })
          .catch((ex) => {
            if (d) {
              console.error("Chat export: ", ex);
            }
            const report = [
              String((ex && ex.message) || ex)
                .replace(/\s+/g, "")
                .substring(0, 64)
            ];
            report.unshift(report[0] === "Aborted" ? 1 : 0);
            if (!report[0]) {
              msgDialog("error", "", l.export_chat_failed, "", undefined, undefined, true);
            }
            eventlog(99875, JSON.stringify(report));
          })
          .finally(() => {
            loadingDialog.hide("chat_export");
            this.isScrollingToMessageId = false;
            onIdle(() => this.messagesBuff.detachMessages());
          });
      };
      ChatRoom.prototype._exportChat = async function () {
        this.isScrollingToMessageId = true;
        while (this.messagesBuff.haveMoreHistory()) {
          await this.messagesBuff.retrieveChatHistory(100);
        }
        await Promise.allSettled([
          this.messagesBuff.isDecrypting || Promise.resolve(),
          this.messagesBuff.$sharedFilesLoading || Promise.resolve(),
          this.messagesBuff.$isDecryptingSharedFiles || Promise.resolve()
        ]);
        do {
          await this.messagesBuff.retrieveSharedFilesHistory(100);
        } while (this.messagesBuff.haveMoreSharedFiles);
        let withMedia = !!M.v.length;
        if (withMedia) {
          withMedia = await asyncMsgDialog(
            `*confirmation:!^${l.export_chat_media_dlg_conf}!${l.export_chat_media_dlg_rej}`,
            "",
            l.export_chat_media_dlg_title,
            l.export_chat_media_dlg_text
          );
          if (withMedia === null) {
            throw new Error("Aborted");
          }
        }
        let { attachNodes, stringNodes } = this.messagesBuff.getExportContent(withMedia);
        stringNodes = stringNodes.join("\n");
        const basename = M.getSafeName(this.getRoomTitle());
        const zname = l.export_chat_zip_file.replace("%s", basename);
        const bufferName = l.export_chat_text_file.replace("%s", basename);
        if (attachNodes.length) {
          const p = [];
          const n = [];
          let s = 0;
          for (const node of attachNodes) {
            s += node.s;
            if (node.ph) {
              p.push(node.ph);
            } else {
              n.push(node.h);
            }
          }
          const res = await asyncApiReq({
            a: "qbq",
            s,
            n,
            p
          });
          if (res === 1 || res === 2) {
            const fallback = await asyncMsgDialog("confirmation", "", l.export_chat_media_obq_title, l.export_chat_media_obq_text);
            if (fallback) {
              return M.saveAs(stringNodes, bufferName);
            }
          } else if (res === 0) {
            await M.require("clientzip_js");
            const data = new TextEncoder().encode(stringNodes);
            const dl = {
              size: data.byteLength + s,
              n: bufferName,
              t: unixtime(),
              id: this.chatId,
              p: "",
              io: Object.create(null),
              writer: Object.create(null),
              offset: 0,
              zname
            };
            const io = await prepareExportIo(dl);
            const t = new Date((this.lastActivity || this.ctime) * 1000);
            let failedCount = 0;
            const src = prepareExportStreams(attachNodes, (size) => {
              failedCount++;
              dl.done += size;
            });
            src.unshift({
              name: bufferName,
              lastModified: t,
              input: data.buffer
            });
            dl.done = 0;
            const reader = clientZip.downloadZip(src).body.getReader();
            dl.nextChunk = async () => {
              const read = await reader.read().catch(dump);
              if (!read) {
                reader.cancel().catch((ex) => {
                  if (ex === EOVERQUOTA) {
                    dlmanager.showOverQuotaDialog();
                  } else {
                    msgDialog("error", "", l.export_chat_failed, "", undefined, undefined, true);
                  }
                });
                io.abort();
                delete this.exportIo;
                return;
              }
              if (read.done) {
                loadingDialog.hideProgress();
                io.download(zname);
                delete this.exportIo;
                if (failedCount) {
                  msgDialog("error", "", l.export_chat_failed, l.export_chat_partial_fail, undefined, undefined, true);
                }
              } else {
                dl.done += read.value.byteLength;
                loadingDialog.showProgress((dl.done / dl.size) * 100);
                io.write(read.value, dl.offset, dl.nextChunk);
                dl.offset += read.value.length;
              }
            };
            io.begin = dl.nextChunk;
            io.setCredentials(false, dl.size, zname);
            this.exportIo = io;
          } else {
            throw new Error(`Unexpected qbq response ${res}`);
          }
        } else {
          return M.saveAs(stringNodes, bufferName);
        }
      };
      window.ChatRoom = ChatRoom;
      const chatRoom = {
        ChatRoom: ChatRoom
      };

      /***/
    },

    /***/ 503: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        LY: () => timing,
        M9: () => SoonFcWrap,
        _p: () => ContactAwareComponent,
        qC: () => compose,
        wl: () => MegaRenderMixin
      });

      var _applyDecoratedDescriptor2__ = __webpack_require__(229);
      var react_dom0__ = __webpack_require__(533);
      var react_dom0 = __webpack_require__.n(react_dom0__);
      var react1__ = __webpack_require__(363);
      var react1 = __webpack_require__.n(react1__);

      var _dec, _dec2, _dec3, _dec4, _dec5, _class;

      var INTERSECTION_OBSERVER_AVAILABLE = typeof IntersectionObserver !== "undefined";
      var RESIZE_OBSERVER_AVAILABLE = typeof ResizeObserver !== "undefined";
      function shallowEqual(objA, objB) {
        if (objA === objB) {
          return true;
        }
        for (var key in objA) {
          if (key === "children") {
            continue;
          }
          if (objA.hasOwnProperty(key)) {
            if (!objB.hasOwnProperty(key)) {
              return false;
            } else if (objA[key] !== objB[key]) {
              if (typeof objA[key] === "function" && typeof objB[key] === "function") {
                if (objA[key].toString() !== objB[key].toString()) {
                  return false;
                }
              } else {
                return false;
              }
            }
          }
        }
        for (key in objB) {
          if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
            return false;
          }
        }
        return true;
      }
      window.shallowEqual = shallowEqual;
      var MAX_ALLOWED_DEBOUNCED_UPDATES = 5;
      var DEBOUNCED_UPDATE_TIMEOUT = 60;
      var REENABLE_UPDATES_AFTER_TIMEOUT = 300;
      var MAX_TRACK_CHANGES_RECURSIVE_DEPTH = 1;
      let _propertyTrackChangesVars = Object.create(null);
      _propertyTrackChangesVars._listenersMap = Object.create(null);
      _propertyTrackChangesVars._dataChangedHistory = Object.create(null);
      if (window._propertyTrackChangesVars) {
        _propertyTrackChangesVars = window._propertyTrackChangesVars;
      } else {
        window._propertyTrackChangesVars = _propertyTrackChangesVars;
      }
      window.megaRenderMixinId = window.megaRenderMixinId ? window.megaRenderMixinId : 0;
      var FUNCTIONS = [
        "render",
        "shouldComponentUpdate",
        "doProgramaticScroll",
        "componentDidMount",
        "componentDidUpdate",
        "componentWillUnmount",
        "refreshUI",
        "eventuallyInit",
        "handleWindowResize",
        "focusTypeArea",
        "initScrolling",
        "updateScroll",
        "isActive",
        "onMessagesScrollReinitialise",
        "specShouldComponentUpdate",
        "attachAnimationEvents",
        "eventuallyReinitialise",
        "reinitialise",
        "reinitialised",
        "getContentHeight",
        "getScrollWidth",
        "isAtBottom",
        "onResize",
        "isComponentEventuallyVisible",
        "getCursorPosition",
        "getTextareaMaxHeight"
      ];
      var localStorageProfileRenderFns = localStorage.profileRenderFns;
      if (localStorageProfileRenderFns) {
        window.REACT_RENDER_CALLS = {};
      }
      let ID_CURRENT = 1;
      const DEBUG_THIS = d > 1 ? d : false;
      const scheduler = (func, name, debug) => {
        let dbug = debug !== false && DEBUG_THIS;
        let idnt = null;
        let task = null;
        let fire = () => {
          if (dbug) {
            console.warn("Dispatching scheduled task for %s.%s...", idnt, name);
          }
          if (task) {
            queueMicrotask(task);
            task = null;
          }
        };
        const _scheduler = function () {
          if (dbug) {
            if (!idnt) {
              idnt = (name[0] === "(" && this.getReactId && this.getReactId()) || this;
            }
            console.warn("Scheduling task from %s.%s...", idnt, name, [this], !!task);
          }
          if (!task) {
            queueMicrotask(fire);
          }
          let idx = arguments.length;
          const args = new Array(idx);
          while (idx--) {
            args[idx] = arguments[idx];
          }
          task = () => {
            func.apply(this, args);
          };
        };
        if (DEBUG_THIS) {
          Object.defineProperty(_scheduler, smbl(name), {
            value: func
          });
        }
        return _scheduler;
      };
      const timing = (min, max) => {
        return function (target, key, de) {
          if (DEBUG_THIS > 2) {
            de[key] = de.value;
            _timing(de, min, max);
            de.value = de[key];
          }
          return de;
        };
      };
      const logcall = () => {
        return function (target, key, descriptor) {
          if (DEBUG_THIS > 3) {
            const func = descriptor.value;
            descriptor.value = function () {
              console.group("[logcall] Entering into %s.%s...", this, key);
              var r = func.apply(this, arguments);
              console.info("[logcall] Leaving %s.%s...", this, key);
              console.groupEnd();
              return r;
            };
          }
          return descriptor;
        };
      };
      const schedule = (local, debug) => {
        return function (target, property, descriptor) {
          if (local) {
            const func = descriptor.value;
            descriptor = {
              configurable: true,
              get: function _unusedScheduler() {
                Object.defineProperty(this, property, {
                  value: scheduler(func, "(" + property + ")", debug)
                });
                return this[property];
              }
            };
          } else {
            descriptor.value = scheduler(descriptor.value, property, debug);
          }
          return descriptor;
        };
      };
      const compose = (...funcs) =>
        funcs.reduce(
          (a, b) =>
            (...args) =>
              a(b(...args)),
          (arg) => arg
        );
      const replaceAt = (i, o, n) => `${o.slice(0, i)}<strong>${n}</strong>${o.slice(i + n.length)}`;
      const SoonFcWrap = (milliseconds, local) => {
        return function (target, propertyKey, descriptor) {
          descriptor.value = SoonFc(descriptor.value, !local, milliseconds);
          return descriptor;
        };
      };
      const rAFWrap = () => {
        return function (target, propertyKey, descriptor) {
          let old = descriptor.value;
          descriptor.value = function () {
            return old.apply(this, arguments);
          };
          return descriptor;
        };
      };
      const trycatcher = () => (t, p, d) => (d.value = tryCatch(d.value)) && d;
      let MegaRenderMixin =
        ((_dec = logcall()),
        (_dec2 = SoonFcWrap(50, true)),
        (_dec3 = logcall()),
        (_dec4 = SoonFcWrap(80, true)),
        (_dec5 = SoonFcWrap(350, true)),
        ((_class = class MegaRenderMixin extends react1().Component {
          constructor(props) {
            super(props);
            lazy(this, "__internalReactID", function () {
              let key = "";
              let fib = DEBUG_THIS && this._reactInternalFiber;
              while (fib) {
                let tmp = fib.key;
                if (tmp && tmp[0] !== "." && key.indexOf(tmp) < 0) {
                  key += tmp + "/";
                }
                if ((tmp = fib.memoizedProps)) {
                  if (tmp.contact) {
                    tmp = tmp.contact.u + (tmp.chatRoom ? "@" + tmp.chatRoom.roomId : "");
                  } else if (tmp.chatRoom) {
                    tmp = tmp.chatRoom.roomId;
                  } else {
                    tmp = 0;
                  }
                  if (tmp && key.indexOf(tmp) < 0) {
                    key += tmp + "/";
                  }
                }
                fib = fib._debugOwner;
              }
              key = key ? "[" + key.substr(0, key.length - 1) + "]" : "";
              return "::" + this.constructor.name + "[" + ("000" + ID_CURRENT++).slice(-4) + "]" + key;
            });
            lazy(this, "__internalUniqueID", function () {
              return (this.__internalReactID + makeUUID().substr(-12)).replace(/[^a-zA-Z0-9]/g, "");
            });
            Object.defineProperty(this, "isMounted", {
              value: function MegaRenderMixin_isMounted() {
                return !!this.__isMounted;
              }
            });
            if (DEBUG_THIS > 2) {
              Object.defineProperty(this, "safeForceUpdate", {
                value: function MegaRenderMixin_safeForceUpdate_debug() {
                  console.group(
                    "%s.safeForceUpdate: mounted:%s, visible:%s",
                    this.getReactId(),
                    this.__isMounted,
                    this.isComponentEventuallyVisible()
                  );
                  if (this.__isMounted) {
                    this.forceUpdate(() => {
                      console.warn("%s.safeForceUpdate finished.", this.getReactId());
                      console.groupEnd();
                    });
                  }
                }
              });
              Object.keys(this).forEach((k) => {
                if (this[k] && this[k].apply) {
                  let orig = this[k];
                  this[k] = function () {
                    let s = performance.now();
                    let r = orig.apply(this, arguments);
                    s = performance.now() - s;
                    if (s > 30) {
                      console.error(k, this, "took", s, "ms", "returned", r);
                    }
                    return r;
                  };
                }
              });
            }
            if (DEBUG_THIS) {
              if (!megaChat.__components) {
                megaChat.__components = new WeakMap();
              }
              megaChat.__components.set(this, Object.getPrototypeOf(this));
            }
          }
          componentWillUnmount() {
            if (super.componentWillUnmount) {
              super.componentWillUnmount();
            }
            this.__isMounted = false;
            chatGlobalEventManager.removeEventListener("resize", "megaRenderMixing" + this.getUniqueId());
            chatGlobalEventManager.removeEventListener("hashchange", "hc" + this.getUniqueId());
            var node = this.findDOMNode();
            if (this.__intersectionObserverInstance) {
              if (node) {
                this.__intersectionObserverInstance.unobserve(node);
              }
              this.__intersectionObserverInstance.disconnect();
              this.__intersectionObserverInstance = undefined;
            }
            if (this.onResizeObserved) {
              if (!RESIZE_OBSERVER_AVAILABLE) {
                $(document.body).unbind("resize.resObs" + this.getUniqueId());
              } else {
                this.__resizeObserverInstance.unobserve(node);
                this.__resizeObserverInstance.disconnect();
                this.__resizeObserverInstance = undefined;
              }
            }
            var instanceId = this.getUniqueId();
            var listeners = _propertyTrackChangesVars._listenersMap[instanceId];
            if (listeners) {
              for (var k in listeners) {
                var v = listeners[k];
                v[0].removeChangeListener(v[1]);
              }
            }
            _propertyTrackChangesVars._listenersMap[instanceId] = null;
            _propertyTrackChangesVars._dataChangedHistory[instanceId] = null;
            if (this._dataStructListeners) {
              this._internalDetachRenderCallbacks();
            }
            if (this.detachRerenderCallbacks) {
              this.detachRerenderCallbacks();
            }
          }
          getReactId() {
            return this.__internalReactID;
          }
          getUniqueId() {
            return this.__internalUniqueID;
          }
          debouncedForceUpdate() {
            this.eventuallyUpdate();
          }
          componentDidMount() {
            if (super.componentDidMount) {
              super.componentDidMount();
            }
            this.__isMounted = true;
            this._wasRendered = true;
            if (this.props.requiresUpdateOnResize || this.requiresUpdateOnResize || !this.props.skipQueuedUpdatesOnResize) {
              chatGlobalEventManager.addEventListener("resize", "megaRenderMixing" + this.getUniqueId(), () => this.onResizeDoUpdate());
            }
            chatGlobalEventManager.addEventListener("hashchange", "hc" + this.getUniqueId(), () => this.onResizeDoUpdate());
            if (this.props) {
              this._recurseAddListenersIfNeeded("p", this.props);
            }
            if (this.state) {
              this._recurseAddListenersIfNeeded("s", this.state);
            }
            var node = this.findDOMNode();
            if (INTERSECTION_OBSERVER_AVAILABLE && !this.customIsEventuallyVisible) {
              if (node) {
                this.__intersectionVisibility = false;
                onIdle(() => {
                  this.__intersectionObserverInstance = new IntersectionObserver(
                    ([entry]) => {
                      if (entry.intersectionRatio < 0.2 && !entry.isIntersecting) {
                        this.__intersectionVisibility = false;
                      } else {
                        this.__intersectionVisibility = true;
                        if (this._requiresUpdateOnResize) {
                          this.debouncedForceUpdate();
                        }
                      }
                      if (this.onVisibilityChange) {
                        this.onVisibilityChange(this.__intersectionVisibility);
                      }
                    },
                    {
                      threshold: 0.1
                    }
                  );
                  this.__intersectionObserverInstance.observe(node);
                });
              }
            }
            if (this.onResizeObserved) {
              if (!RESIZE_OBSERVER_AVAILABLE) {
                $(document.body).rebind("resize.resObs" + this.getUniqueId(), () => {
                  this.onResizeObserved(node.offsetWidth, node.offsetHeight);
                });
              } else {
                this.__resizeObserverInstance = new ResizeObserver((entries) => {
                  this.onResizeObserved(entries[0].contentRect.width, entries[0].contentRect.height);
                });
                this.__resizeObserverInstance.observe(node);
              }
            }
            if (this.attachRerenderCallbacks) {
              this.attachRerenderCallbacks();
            }
          }
          findDOMNode() {
            if (!this.domNode) {
              this.domNode = react_dom0().findDOMNode(this);
            }
            return this.domNode;
          }
          isComponentVisible() {
            if (!this.__isMounted) {
              return false;
            }
            if (this.customIsEventuallyVisible) {
              let ciev = this.customIsEventuallyVisible;
              var result = typeof ciev === "function" ? ciev.call(this) : ciev;
              if (result !== -1) {
                return result;
              }
            }
            if (this.__intersectionVisibility === false) {
              return false;
            } else if (this.__intersectionVisibility === true) {
              return true;
            }
            const domNode = this.findDOMNode();
            if (!this.props.hideable && (!domNode || domNode.offsetParent === null)) {
              return false;
            }
            if (!$(domNode).is(":visible")) {
              return false;
            }
            return verge.inViewport(domNode);
          }
          isComponentEventuallyVisible() {
            if (!this.__isMounted) {
              return false;
            }
            if (this.customIsEventuallyVisible) {
              let ciev = this.customIsEventuallyVisible;
              return typeof ciev === "function" ? ciev.call(this) : !!ciev;
            }
            if (typeof this.props.isVisible !== "undefined") {
              return this.props.isVisible;
            }
            return this.__intersectionVisibility !== false;
          }
          eventuallyUpdate() {
            if (!window.megaChat || megaChat.isLoggingOut || this._updatesDisabled || !this._wasRendered || !this.__isMounted) {
              return;
            }
            if (!this.isComponentEventuallyVisible()) {
              this._requiresUpdateOnResize = true;
              return;
            }
            if (this._requiresUpdateOnResize) {
              this._requiresUpdateOnResize = false;
            }
            this.forceUpdate();
          }
          tempDisableUpdates(forHowLong) {
            var self = this;
            self._updatesDisabled = true;
            if (self._updatesReenableTimer) {
              clearTimeout(self._updatesReenableTimer);
            }
            var timeout = forHowLong
              ? forHowLong
              : self.REENABLE_UPDATES_AFTER_TIMEOUT
              ? self.REENABLE_UPDATES_AFTER_TIMEOUT
              : REENABLE_UPDATES_AFTER_TIMEOUT;
            self._updatesReenableTimer = setTimeout(function () {
              self.tempEnableUpdates();
            }, timeout);
          }
          tempEnableUpdates() {
            clearTimeout(this._updatesReenableTimer);
            this._updatesDisabled = false;
            this.eventuallyUpdate();
          }
          onResizeDoUpdate() {
            this.eventuallyUpdate();
          }
          _getUniqueIDForMap(map, payload) {
            return map + "." + payload;
          }
          _recurseAddListenersIfNeeded(idx, map, depth) {
            depth |= 0;
            if (map instanceof MegaDataMap) {
              var cacheKey = this._getUniqueIDForMap(map, idx);
              var instanceId = this.getUniqueId();
              if (!_propertyTrackChangesVars._listenersMap[instanceId]) {
                _propertyTrackChangesVars._listenersMap[instanceId] = Object.create(null);
              }
              if (!_propertyTrackChangesVars._listenersMap[instanceId][cacheKey]) {
                _propertyTrackChangesVars._listenersMap[instanceId][cacheKey] = [
                  map,
                  map.addChangeListener(() => this.onPropOrStateUpdated())
                ];
              }
            }
            if (depth++ < MAX_TRACK_CHANGES_RECURSIVE_DEPTH && !this.props.manualDataChangeTracking) {
              var mapKeys = map instanceof MegaDataMap ? map.keys() : Object.keys(map);
              for (var i = 0; i < mapKeys.length; i++) {
                var k = mapKeys[i];
                if (map[k]) {
                  this._recurseAddListenersIfNeeded(idx + "_" + k, map[k], depth);
                }
              }
            }
          }
          _checkDataStructForChanges(idx, v, rv, depth) {
            if (!v && v === rv) {
              return false;
            }
            if (!rv && v) {
              return true;
            }
            if (v === null) {
              return rv !== null;
            }
            if (v instanceof MegaDataMap) {
              var cacheKey = this._getUniqueIDForMap(v, idx);
              var dataChangeHistory = _propertyTrackChangesVars._dataChangedHistory;
              var instanceId = this.getUniqueId();
              if (!dataChangeHistory[instanceId]) {
                dataChangeHistory[instanceId] = Object.create(null);
              }
              if (dataChangeHistory[instanceId][cacheKey] !== v._dataChangeIndex) {
                if (window.RENDER_DEBUG) {
                  console.error("changed: ", this.getElementName(), cacheKey, v._dataChangeTrackedId, v._dataChangeIndex, v);
                }
                dataChangeHistory[instanceId][cacheKey] = v._dataChangeIndex;
                return true;
              }
              return false;
            }
            return (
              depth < MAX_TRACK_CHANGES_RECURSIVE_DEPTH &&
              v &&
              v.byteLength === undefined &&
              typeof v === "object" &&
              this._recursiveSearchForDataChanges(idx, v, rv, depth + 1) === true
            );
          }
          _recursiveSearchForDataChanges(idx, map, referenceMap, depth) {
            var self = this;
            depth = depth || 0;
            if (!this.isMounted() || this._pendingForceUpdate === true || this._updatesDisabled === true) {
              return;
            }
            if (!this._wasRendered) {
              if (window.RENDER_DEBUG) console.error("First time render", self.getElementName(), map, referenceMap);
              this._wasRendered = true;
              return true;
            }
            if (idx === "p_children") {
              if (map.map && referenceMap.map) {
                var oldKeys = map.map(function (child) {
                  return child ? child.key : child;
                });
                var newKeys = referenceMap.map(function (child) {
                  return child ? child.key : child;
                });
                if (!shallowEqual(oldKeys, newKeys)) {
                  return true;
                }
              } else if ((!map && referenceMap) || (map && !referenceMap)) {
                return true;
              } else if (map.$$typeof && referenceMap.$$typeof) {
                if (!shallowEqual(map.props, referenceMap.props) || !shallowEqual(map.state, referenceMap.state)) {
                  return true;
                }
              }
            } else if ((map && !referenceMap) || (!map && referenceMap) || (map && referenceMap && !shallowEqual(map, referenceMap))) {
              return true;
            }
            const mapKeys = map instanceof MegaDataMap ? map.keys() : Object.keys(map);
            for (let i = mapKeys.length; i--; ) {
              let k = mapKeys[i];
              if (this._checkDataStructForChanges(idx + "_" + k, map[k], referenceMap[k], depth)) {
                return true;
              }
            }
            return false;
          }
          shouldComponentUpdate(nextProps, nextState) {
            var shouldRerender = false;
            if (megaChat && megaChat.isLoggingOut) {
              return false;
            }
            if (!this.isMounted() || this._pendingForceUpdate === true || this._updatesDisabled === true) {
              if (window.RENDER_DEBUG) {
                console.error("shouldUpdate? No.", "F1", this.getElementName(), this.props, nextProps, this.state, nextState);
              }
              return false;
            }
            if (this.customIsEventuallyVisible) {
              let ciev = this.customIsEventuallyVisible;
              ciev = typeof ciev === "function" ? ciev.call(this) : !!ciev;
              if (!this._queueUpdateWhenVisible && !ciev) {
                this._queueUpdateWhenVisible = true;
                if (window.RENDER_DEBUG) {
                  console.error("shouldUpdate? No.", "F1.1", this.getElementName(), this.props, nextProps, this.state, nextState);
                }
              } else if (this._queueUpdateWhenVisible && ciev) {
                delete this._queueUpdateWhenVisible;
                return true;
              }
            }
            if (this.specShouldComponentUpdate) {
              var r = this.specShouldComponentUpdate(nextProps, nextState);
              if (r === false) {
                if (window.RENDER_DEBUG) {
                  console.error("shouldUpdate? No.", "F2", this.getElementName(), this.props, nextProps, this.state, nextState);
                }
                this._requiresUpdateOnResize = true;
                return false;
              } else if (r === true) {
                return true;
              }
            }
            if (!this.props.disableCheckingVisibility && !this.isComponentEventuallyVisible()) {
              if (window.RENDER_DEBUG) {
                console.error("shouldUpdate? No.", "FVis", this.getElementName(), this.props, nextProps, this.state, nextState);
              }
              this._requiresUpdateOnResize = true;
              return false;
            }
            if (this.props !== null) {
              shouldRerender = this._recursiveSearchForDataChanges("p", nextProps, this.props);
            }
            if (shouldRerender === false) {
              if (window.RENDER_DEBUG) {
                console.error("shouldUpdate? No.", "F3", this.getElementName(), this.props, nextProps, this.state, nextState);
              }
            }
            if (shouldRerender === false && this.state !== null) {
              shouldRerender = this._recursiveSearchForDataChanges("s", nextState, this.state);
            }
            if (window.RENDER_DEBUG) {
              if (shouldRerender) {
              }
              console.error(
                "shouldRerender?",
                shouldRerender,
                "rendered: ",
                this.getElementName(),
                "props:",
                this.props,
                "nextProps:",
                this.props,
                "state:",
                this.state
              );
            }
            if (shouldRerender === true) {
              if (this.props) {
                this._recurseAddListenersIfNeeded("p", this.props);
              }
              if (this.state) {
                this._recurseAddListenersIfNeeded("s", this.state);
              }
            } else {
              if (window.RENDER_DEBUG) {
                console.error("shouldUpdate? No.", "F4", this.getElementName(), this.props, nextProps, this.state, nextState);
              }
            }
            return shouldRerender;
          }
          onPropOrStateUpdated() {
            this.eventuallyUpdate();
          }
          getElementName() {
            return this._reactInternalFiber.elementType.name;
          }
          safeForceUpdate() {
            if (this.__isMounted) {
              this.forceUpdate();
            }
          }
          componentDidUpdate() {
            if (window.RENDER_DEBUG) {
              var self = this;
              var getElementName = function () {
                if (!self.constructor) {
                  return "unknown";
                }
                return self.constructor.name;
              };
              console.error("renderedX: ", getElementName(), "props:", this.props, "state:", this.state);
            }
            if (this.domNode && !this.domNode.isConnected) {
              delete this.domNode;
            }
          }
          componentWillReceiveProps(nextProps, nextContext) {
            if (localStorageProfileRenderFns) {
              var self = this;
              var componentName = self.constructor ? self.constructor.name : "unknown";
              if (!this._wrappedRender) {
                FUNCTIONS.forEach(function (fnName) {
                  var _origFn = self[fnName];
                  if (_origFn) {
                    self[fnName] = function () {
                      var start = performance.now();
                      var res = _origFn.apply(this, arguments);
                      REACT_RENDER_CALLS[componentName + "." + fnName] = REACT_RENDER_CALLS[componentName + "." + fnName] || 0;
                      REACT_RENDER_CALLS[componentName + "." + fnName] += performance.now() - start;
                      return res;
                    };
                  }
                });
                self._wrappedRender = true;
              }
              REACT_RENDER_CALLS.sorted = function () {
                var sorted = [];
                Object.keys(REACT_RENDER_CALLS)
                  .sort(function (a, b) {
                    if (REACT_RENDER_CALLS[a] < REACT_RENDER_CALLS[b]) {
                      return 1;
                    } else if (REACT_RENDER_CALLS[a] > REACT_RENDER_CALLS[b]) {
                      return -1;
                    } else {
                      return 0;
                    }
                  })
                  .forEach(function (k) {
                    if (typeof REACT_RENDER_CALLS[k] !== "function") {
                      sorted.push([k, REACT_RENDER_CALLS[k]]);
                    }
                  });
                return sorted;
              };
              REACT_RENDER_CALLS.clear = function () {
                Object.keys(REACT_RENDER_CALLS).forEach(function (k) {
                  if (typeof REACT_RENDER_CALLS[k] !== "function") {
                    delete REACT_RENDER_CALLS[k];
                  }
                });
              };
            }
          }
          _internalDetachRenderCallbacks() {
            const items = this._dataStructListeners || false;
            for (let i = items.length; i--; ) {
              let item = items[i];
              if (item[0] === "dsprops") {
                console.assert(item[2].removeChangeListener(item[1]), "listener not found..");
              }
            }
          }
          addDataStructListenerForProperties(obj, properties) {
            if (!(obj instanceof MegaDataMap)) {
              return;
            }
            if (!this._dataStructListeners) {
              this._dataStructListeners = [];
            }
            properties = array.to.object(properties);
            var id = obj.addChangeListener((obj, data, k) => properties[k] && this.onPropOrStateUpdated());
            this._dataStructListeners.push(["dsprops", id, obj]);
          }
        }),
        ((0, _applyDecoratedDescriptor2__.Z)(
          _class.prototype,
          "componentWillUnmount",
          [_dec],
          Object.getOwnPropertyDescriptor(_class.prototype, "componentWillUnmount"),
          _class.prototype
        ),
        (0, _applyDecoratedDescriptor2__.Z)(
          _class.prototype,
          "debouncedForceUpdate",
          [_dec2],
          Object.getOwnPropertyDescriptor(_class.prototype, "debouncedForceUpdate"),
          _class.prototype
        ),
        (0, _applyDecoratedDescriptor2__.Z)(
          _class.prototype,
          "componentDidMount",
          [_dec3],
          Object.getOwnPropertyDescriptor(_class.prototype, "componentDidMount"),
          _class.prototype
        ),
        (0, _applyDecoratedDescriptor2__.Z)(
          _class.prototype,
          "eventuallyUpdate",
          [_dec4],
          Object.getOwnPropertyDescriptor(_class.prototype, "eventuallyUpdate"),
          _class.prototype
        ),
        (0, _applyDecoratedDescriptor2__.Z)(
          _class.prototype,
          "onResizeDoUpdate",
          [_dec5],
          Object.getOwnPropertyDescriptor(_class.prototype, "onResizeDoUpdate"),
          _class.prototype
        )),
        _class));
      class ContactAwareComponent extends MegaRenderMixin {
        constructor(props) {
          super(props);
          this.loadContactInfo();
        }
        _validContact() {
          const { contact } = this.props;
          if (!contact) {
            return false;
          }
          return (contact.h || contact.u) in M.u;
        }
        _attachRerenderCbContacts(others) {
          if (!this._validContact()) {
            return;
          }
          this.addDataStructListenerForProperties(
            this.props.contact,
            ["name", "firstName", "lastName", "nickname", "m", "avatar"].concat(Array.isArray(others) ? others : [])
          );
        }
        attachRerenderCallbacks() {
          this._attachRerenderCbContacts();
        }
        loadContactInfo() {
          var _contact$avatar;
          if (!this._validContact()) {
            return;
          }
          const { contact, chatRoom } = this.props;
          const contactHandle = contact.h || contact.u;
          const syncName = !ContactAwareComponent.unavailableNames[contactHandle] && !contact.firstName && !contact.lastName;
          const syncMail = megaChat.FORCE_EMAIL_LOADING || ((contact.c === 1 || contact.c === 2) && !contact.m && !is_chatlink);
          const syncAvtr =
            ((is_chatlink &&
              (!contact.avatar || ((_contact$avatar = contact.avatar) == null ? void 0 : _contact$avatar.type) === "text")) ||
              !contact.avatar) &&
            !avatars[contactHandle] &&
            !ContactAwareComponent.unavailableAvatars[contactHandle];
          const loader = () => {
            if (!this.isComponentEventuallyVisible()) {
              this.__isLoadingContactInfo = null;
              this._requiresUpdateOnResize = true;
              return;
            }
            const promises = [];
            const chatHandle = is_chatlink.ph || (chatRoom && chatRoom.publicChatHandle);
            if (syncName) {
              promises.push(M.syncUsersFullname(contactHandle, chatHandle));
            }
            if (syncMail) {
              promises.push(M.syncContactEmail(contactHandle));
            }
            if (syncAvtr) {
              promises.push(
                useravatar.loadAvatar(contactHandle, chatHandle).catch(function () {
                  ContactAwareComponent.unavailableAvatars[contactHandle] = true;
                })
              );
            }
            return Promise.allSettled(promises).always(() => {
              this.eventuallyUpdate();
              this.__isLoadingContactInfo = false;
              if (!contact.firstName && !contact.lastName) {
                ContactAwareComponent.unavailableNames[contactHandle] = true;
              }
            });
          };
          if (syncName || syncMail || syncAvtr) {
            (this.__isLoadingContactInfo = tSleep(0.3)).then(loader).catch(dump);
          }
        }
        componentDidUpdate() {
          super.componentDidUpdate();
          if (this.__isLoadingContactInfo === null) {
            this.loadContactInfo();
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          if (this.__isLoadingContactInfo) {
            this.__isLoadingContactInfo.abort();
            this.__isLoadingContactInfo = false;
          }
        }
        isLoadingContactInfo() {
          return !!this.__isLoadingContactInfo;
        }
      }
      ContactAwareComponent.unavailableAvatars = Object.create(null);
      ContactAwareComponent.unavailableNames = Object.create(null);

      /***/
    },

    /***/ 142: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        Z: () => ChatToaster
      });
      var react0__ = __webpack_require__(363);
      var react0 = __webpack_require__.n(react0__);
      var _mixins1__ = __webpack_require__(503);
      var _meetings_call_jsx2__ = __webpack_require__(689);
      var _ui_buttons3__ = __webpack_require__(204);

      const NAMESPACE = "chat-toast";
      class ChatToaster extends _mixins1__.wl {
        constructor(props) {
          super(props);
          this.state = {
            toast: null,
            endTime: 0,
            fmToastId: null,
            persistentToast: null
          };
          this.toasts = [];
          this.persistentToasts = [];
        }
        customIsEventuallyVisible() {
          return M.chat;
        }
        enqueueToast(e) {
          if (this.props.showDualNotifications && e.data.options && e.data.options.persistent) {
            this.persistentToasts.push(e.data);
          } else {
            this.toasts.push(e.data);
          }
          this.pollToasts();
        }
        pollToasts() {
          const { toast: shownToast, persistentToast: shownPersistentToast } = this.state;
          const { isRootToaster, showDualNotifications, onShownToast } = this.props;
          const now = Date.now();
          if (this.toasts.length + this.persistentToasts.length) {
            if (this.isMounted() && ((!isRootToaster && _meetings_call_jsx2__.ZP.isExpanded()) || M.chat)) {
              if (this.toasts.length && !shownToast) {
                this.dispatchToast(this.toasts.shift(), now);
              }
              if (showDualNotifications && this.persistentToasts.length && !shownPersistentToast) {
                const persistentToast = this.persistentToasts.shift();
                this.setState(
                  {
                    persistentToast
                  },
                  () => this.pollToasts()
                );
                if (typeof onShownToast === "function") {
                  onShownToast(persistentToast);
                }
              }
            } else if (isRootToaster && this.toasts.length && !shownToast) {
              const toast = this.toasts.shift();
              this.dispatchToast(toast, now, {
                fmToastId: "tmp"
              });
              this.dispatchFMToast(toast);
            }
          }
        }
        dispatchFMToast(toast, redraw) {
          window.toaster.alerts.medium(...toast.renderFM()).then((fmToastId) => {
            if (!redraw) {
              toast.onShown(fmToastId);
            }
            this.setState({
              fmToastId
            });
            if (toast.updater && typeof toast.updater === "function") {
              toast.updater();
              toast.updateInterval = setInterval(() => {
                toast.updater();
                const value = toast.render();
                if (!value) {
                  window.toaster.alerts.hide(fmToastId);
                  return this.onClose(toast.options && toast.options.persistent);
                }
                if (value !== $("span", `#${fmToastId}`).text()) {
                  $("span", `#${fmToastId}`).text(value);
                }
              }, 250);
            }
          });
        }
        dispatchToast(toast, now, options = {}) {
          const { fmToastId, endTime, silent } = options;
          const { onShownToast, onHideToast } = this.props;
          this.setState(
            {
              toast,
              endTime: endTime || now + toast.getTTL(),
              fmToastId
            },
            () => {
              this.eventuallyUpdate();
              if (!silent) {
                toast.onShown();
              }
              this.timeout = setTimeout(
                () => {
                  delete this.timeout;
                  this.setState(
                    {
                      toast: null,
                      endTime: 0
                    },
                    () => this.pollToasts()
                  );
                  if (typeof toast.onEnd === "function") {
                    toast.onEnd();
                  }
                  if (typeof onHideToast === "function") {
                    onHideToast(toast);
                  }
                  if (toast.updateInterval) {
                    clearInterval(toast.updateInterval);
                    delete toast.updateInterval;
                  }
                },
                endTime ? endTime - now : toast.getTTL()
              );
            }
          );
          if (typeof onShownToast === "function") {
            onShownToast(toast);
          }
        }
        onClose(persistent) {
          const { showDualNotifications, onHideToast } = this.props;
          const { toast, persistentToast } = this.state;
          if (showDualNotifications && persistent) {
            if (typeof persistentToast.onEnd === "function") {
              persistentToast.onEnd();
            }
            this.setState(
              {
                persistentToast: null
              },
              () => this.pollToasts()
            );
            if (typeof onHideToast === "function") {
              onHideToast(persistentToast);
            }
            return;
          }
          if (toast.updateInterval) {
            clearInterval(toast.updateInterval);
            delete toast.updateInterval;
          }
          clearTimeout(this.timeout);
          delete this.timeout;
          if (typeof toast.onEnd === "function") {
            toast.onEnd();
          }
          if (typeof onHideToast === "function") {
            onHideToast(toast);
          }
          this.setState(
            {
              toast: null,
              endTime: 0
            },
            () => this.pollToasts()
          );
        }
        flush() {
          const { toast, persistentToast, fmToastId } = this.state;
          this.endToastIntervals();
          if (fmToastId && fmToastId !== "tmp") {
            window.toaster.alerts.hide(fmToastId);
          }
          this.toasts = [];
          this.persistentToasts = [];
          if (this.timeout) {
            clearTimeout(this.timeout);
            delete this.timeout;
          }
          if (toast) {
            this.onClose(toast.persistent);
          }
          if (persistentToast) {
            this.onClose(true);
          }
          this.setState({
            toast: null,
            endTime: 0,
            fmToastId: null,
            persistentToast: null
          });
        }
        endToastIntervals() {
          if (!this.props.isRootToaster) {
            return;
          }
          for (const toast of this.toasts) {
            if (toast.updateInterval) {
              clearInterval(toast.updateInterval);
            }
          }
          for (const toast of this.persistentToasts) {
            if (toast.updateInterval) {
              clearInterval(toast.updateInterval);
            }
          }
        }
        componentDidMount() {
          super.componentDidMount();
          megaChat.rebind(`onChatToast.toaster${this.getUniqueId()}`, (e) => this.enqueueToast(e));
          megaChat.rebind(`onChatToastFlush.toaster${this.getUniqueId()}`, () => this.flush());
          onIdle(() => this.pollToasts());
          if (this.props.isRootToaster) {
            this.bpcListener = mBroadcaster.addListener("beforepagechange", (tpage) => {
              const { toast, endTime, fmToastId } = this.state;
              const now = Date.now();
              if (toast && endTime - 500 > now) {
                const toChat = tpage.includes("chat") && tpage !== "securechat";
                if (toChat && !M.chat) {
                  clearTimeout(this.timeout);
                  window.toaster.alerts.hide(fmToastId);
                  if (toast.updateInterval) {
                    clearInterval(toast.updateInterval);
                    delete toast.updateInterval;
                  }
                  this.dispatchToast(toast, now, {
                    endTime,
                    silent: true
                  });
                } else if (!toChat && M.chat) {
                  clearTimeout(this.timeout);
                  this.dispatchToast(toast, now, {
                    fmToastId: "tmp",
                    endTime,
                    silent: true
                  });
                  this.dispatchFMToast(toast, true);
                }
              } else if (toast && typeof toast.onEnd === "function") {
                toast.onEnd();
              }
            });
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          megaChat.off(`onChatToast.toaster${this.getUniqueId()}`);
          megaChat.off(`onChatToastFlush.toaster${this.getUniqueId()}`);
          if (this.bpcListener) {
            mBroadcaster.removeListener(this.bpcListener);
          }
          if (this.timeout) {
            clearTimeout(this.timeout);
          }
          this.endToastIntervals();
        }
        render() {
          const { hidden, isRootToaster, showDualNotifications } = this.props;
          const { toast, fmToastId, persistentToast } = this.state;
          return (
            !hidden &&
            !fmToastId &&
            react0().createElement(
              "div",
              {
                className: `chat-toast-bar ${isRootToaster ? "toaster-root" : ""}`
              },
              showDualNotifications &&
                persistentToast &&
                react0().createElement(ChatToastMsg, {
                  toast: persistentToast,
                  isRootToaster: isRootToaster,
                  usePersistentStyle: true,
                  onClose: (p) => this.onClose(p)
                }),
              toast &&
                react0().createElement(ChatToastMsg, {
                  toast: toast,
                  isRootToaster: isRootToaster,
                  isDualToast: !!persistentToast,
                  onClose: (p) => this.onClose(p)
                })
            )
          );
        }
      }
      class ChatToastMsg extends _mixins1__.wl {
        constructor(...args) {
          super(...args);
          this.state = {
            value: ""
          };
        }
        componentDidMount() {
          super.componentDidMount();
          const { toast, onClose } = this.props;
          if (toast.updater && typeof toast.updater === "function") {
            toast.updater();
            this.updateInterval = setInterval(() => {
              toast.updater();
              const value = toast.render();
              if (!value) {
                return onClose(toast.options && toast.options.persistent);
              }
              if (value !== this.state.value) {
                this.setState({
                  value
                });
              }
            }, 250);
          }
          const value = toast.render();
          if (value) {
            this.setState({
              value
            });
          } else {
            onClose(toast.options && toast.options.persistent);
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          if (this.updateInterval) {
            clearInterval(this.updateInterval);
          }
        }
        render() {
          const { toast, isRootToaster, isDualToast, usePersistentStyle, onClose } = this.props;
          const { value } = this.state;
          if (usePersistentStyle && toast.options.persistent) {
            return react0().createElement(
              "div",
              {
                className: `${NAMESPACE} chat-persistent-toast`
              },
              value || toast.render()
            );
          }
          const closeButton =
            toast.close &&
            react0().createElement(_ui_buttons3__.z, {
              className: "chat-toast-close",
              icon: "sprite-fm-mono icon-close-component",
              onClick: onClose
            });
          const icon =
            toast.icon &&
            react0().createElement("i", {
              className: toast.icon
            });
          if (isRootToaster) {
            return react0().createElement(
              "div",
              {
                className: `${NAMESPACE} chat-toast-wrapper root-toast`
              },
              react0().createElement(
                "div",
                {
                  className: "toast-value-wrapper"
                },
                icon,
                react0().createElement(
                  "div",
                  {
                    className: "toast-value"
                  },
                  value || toast.render()
                )
              ),
              closeButton
            );
          }
          return react0().createElement(
            "div",
            {
              className: `${NAMESPACE} chat-toast-wrapper theme-light-forced ${isDualToast ? "dual-toast" : ""}`
            },
            react0().createElement(
              "div",
              {
                className: "toast-value"
              },
              value || toast.render()
            )
          );
        }
      }

      /***/
    },

    /***/ 813: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, {
        Z: () => ComposedTextArea
      });

      // EXTERNAL MODULE: external "React"
      var external_React_ = __webpack_require__(363);
      var external_React_default = __webpack_require__.n(external_React_);
      // EXTERNAL MODULE: ./js/chat/mixins.js
      var mixins = __webpack_require__(503); // CONCATENATED MODULE: ./js/chat/ui/whosTyping.jsx
      var React = __webpack_require__(363);

      class WhosTyping extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            currentlyTyping: {}
          };
        }
        componentWillMount() {
          var self = this;
          var chatRoom = self.props.chatRoom;
          chatRoom.bind("onParticipantTyping.whosTyping", function (e, user_handle, bCastCode) {
            if (!self.isMounted()) {
              return;
            }
            if (user_handle === u_handle) {
              return;
            }
            const u_h = user_handle;
            if (u_h === u_handle) {
              return;
            } else if (!M.u[u_h]) {
              return;
            }
            const currentlyTyping = {
              ...self.state.currentlyTyping
            };
            if (currentlyTyping[u_h]) {
              currentlyTyping[u_h].abort();
            }
            if (bCastCode === 1) {
              const timer = tSleep(5);
              timer.then(() => {
                self.stoppedTyping(u_h);
              });
              currentlyTyping[u_h] = timer;
              self.setState({
                currentlyTyping: currentlyTyping
              });
            } else {
              self.stoppedTyping(u_h);
            }
            self.forceUpdate();
          });
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          var self = this;
          var chatRoom = self.props.chatRoom;
          chatRoom.off("onParticipantTyping.whosTyping");
        }
        stoppedTyping(u_h) {
          if (this.isMounted()) {
            const { currentlyTyping } = this.state;
            if (currentlyTyping[u_h]) {
              const newState = {
                ...currentlyTyping
              };
              if (!newState[u_h].aborted) {
                newState[u_h].abort();
              }
              delete newState[u_h];
              this.setState({
                currentlyTyping: newState
              });
            }
          }
        }
        render() {
          var self = this;
          var typingElement = null;
          const users = Object.keys(self.state.currentlyTyping);
          if (users.length > 0) {
            const names = users.map((u_h) => M.getNameByHandle(u_h)).filter(String);
            var namesDisplay = "";
            var areMultipleUsersTyping = false;
            if (names.length > 1) {
              areMultipleUsersTyping = true;
              namesDisplay = [names.splice(0, names.length - 1).join(", "), names[0]];
            } else {
              areMultipleUsersTyping = false;
              namesDisplay = [names[0]];
            }
            var msg;
            if (areMultipleUsersTyping === true) {
              msg = l[8872].replace("%1", namesDisplay[0]).replace("%2", namesDisplay[1]);
            } else {
              msg = l[8629].replace("%1", namesDisplay[0]);
            }
            typingElement = React.createElement(
              "div",
              {
                className: "typing-block"
              },
              React.createElement(
                "div",
                {
                  className: "typing-text"
                },
                msg
              ),
              React.createElement(
                "div",
                {
                  className: "typing-bounce"
                },
                React.createElement("div", {
                  className: "typing-bounce1"
                }),
                React.createElement("div", {
                  className: "typing-bounce2"
                }),
                React.createElement("div", {
                  className: "typing-bounce3"
                })
              )
            );
          }
          return typingElement;
        }
      }

      // EXTERNAL MODULE: ./js/chat/ui/typingArea.jsx + 1 modules
      var typingArea = __webpack_require__(825);
      // EXTERNAL MODULE: ./js/ui/buttons.jsx
      var buttons = __webpack_require__(204);
      // EXTERNAL MODULE: ./js/ui/dropdowns.jsx
      var dropdowns = __webpack_require__(78); // CONCATENATED MODULE: ./js/chat/ui/composedTextArea.jsx
      class ComposedTextArea extends mixins.wl {
        render() {
          const { chatRoom: room, parent, containerRef } = this.props;
          return external_React_default().createElement(
            "div",
            {
              className: "chat-textarea-block"
            },
            external_React_default().createElement(WhosTyping, {
              chatRoom: room
            }),
            external_React_default().createElement(
              typingArea.j,
              {
                chatRoom: room,
                className: "main-typing-area",
                containerRef: containerRef,
                disabled: room.isReadOnly(),
                persist: true,
                onUpEditPressed: () => {
                  const time = unixtime();
                  const keys = room.messagesBuff.messages.keys();
                  for (var i = keys.length; i--; ) {
                    var message = room.messagesBuff.messages[keys[i]];
                    var contact = M.u[message.userId];
                    if (!contact) {
                      continue;
                    }
                    if (
                      contact.u === u_handle &&
                      time - message.delay < MESSAGE_NOT_EDITABLE_TIMEOUT &&
                      !message.requiresManualRetry &&
                      !message.deleted &&
                      (!message.type || message instanceof Message) &&
                      (!message.isManagement || !message.isManagement())
                    ) {
                      parent.historyPanel.editMessage(message.messageId);
                      return true;
                    }
                  }
                  return false;
                },
                onResized: () => {
                  parent.historyPanel.handleWindowResize();
                },
                onConfirm: (messageContents) => {
                  const { messagesListScrollable } = parent.historyPanel;
                  if (messageContents && messageContents.length > 0) {
                    if (!room.scrolledToBottom) {
                      room.scrolledToBottom = true;
                      parent.lastScrollPosition = 0;
                      room.rebind("onMessagesBuffAppend.pull", () => {
                        if (messagesListScrollable) {
                          messagesListScrollable.scrollToBottom(false);
                          delay(
                            "messagesListScrollable",
                            () => {
                              messagesListScrollable.enable();
                            },
                            1500
                          );
                        }
                      });
                      room.sendMessage(messageContents);
                      messagesListScrollable.disable();
                      messagesListScrollable.scrollToBottom(true);
                    } else {
                      room.sendMessage(messageContents);
                    }
                  }
                }
              },
              external_React_default().createElement(
                buttons.z,
                {
                  className: "popup-button left",
                  icon: "sprite-fm-mono icon-add",
                  disabled: room.isReadOnly()
                },
                external_React_default().createElement(
                  dropdowns.Dropdown,
                  {
                    className: "wide-dropdown attach-to-chat-popup light",
                    noArrow: "true",
                    positionMy: "left top",
                    positionAt: "left bottom",
                    vertOffset: 4
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "dropdown info-txt"
                    },
                    l[23753] ? l[23753] : "Send..."
                  ),
                  external_React_default().createElement(dropdowns.DropdownItem, {
                    className: "link-button",
                    icon: "sprite-fm-mono icon-cloud",
                    label: l[19794] ? l[19794] : "My Cloud Drive",
                    disabled: mega.paywall,
                    onClick: () => room.trigger("openAttachCloudDialog")
                  }),
                  external_React_default().createElement(dropdowns.DropdownItem, {
                    className: "link-button",
                    icon: "sprite-fm-mono icon-session-history",
                    label: l[19795] ? l[19795] : "My computer",
                    disabled: mega.paywall,
                    onClick: () => room.uploadFromComputer()
                  }),
                  !is_eplusplus &&
                    !is_chatlink &&
                    external_React_default().createElement(
                      external_React_default().Fragment,
                      null,
                      external_React_default().createElement("hr", null),
                      external_React_default().createElement(dropdowns.DropdownItem, {
                        className: "link-button",
                        icon: "sprite-fm-mono icon-send-contact",
                        label: l.share_contact_button,
                        onClick: () => room.trigger("openSendContactDialog")
                      })
                    )
                )
              )
            )
          );
        }
      }

      /***/
    },

    /***/ 13: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        Avatar: () => Avatar,
        ContactAwareName: () => ContactAwareName,
        ContactButton: () => ContactButton,
        ContactCard: () => ContactCard,
        ContactFingerprint: () => ContactFingerprint,
        ContactItem: () => ContactItem,
        ContactPickerDialog: () => ContactPickerDialog,
        ContactPickerWidget: () => ContactPickerWidget,
        ContactPresence: () => ContactPresence,
        ContactVerified: () => ContactVerified,
        LastActivity: () => LastActivity,
        MAX_FREQUENTS: () => MAX_FREQUENTS,
        MembersAmount: () => MembersAmount
      });
      var _extends8__ = __webpack_require__(462);
      var react0__ = __webpack_require__(363);
      var react0 = __webpack_require__.n(react0__);
      var _mixins1__ = __webpack_require__(503);
      var _ui_utils_jsx2__ = __webpack_require__(79);
      var _ui_perfectScrollbar_jsx3__ = __webpack_require__(285);
      var _ui_buttons_jsx4__ = __webpack_require__(204);
      var _ui_dropdowns_jsx5__ = __webpack_require__(78);
      var _contactsPanel_contactsPanel_jsx6__ = __webpack_require__(808);
      var _ui_modalDialogs7__ = __webpack_require__(182);

      const MAX_FREQUENTS = 3;
      const closeDropdowns = () => {
        document.dispatchEvent(new Event("closeDropdowns"));
      };
      class ContactButton extends _mixins1__._p {
        constructor(props) {
          super(props);
          this.dropdownItemGenerator = this.dropdownItemGenerator.bind(this);
        }
        customIsEventuallyVisible() {
          if (this.props.chatRoom) {
            return this.props.chatRoom.isCurrentlyActive;
          }
          return -1;
        }
        dropdownItemGenerator() {
          let { contact, dropdowns, chatRoom, dropdownRemoveButton } = this.props;
          dropdowns = dropdowns ? dropdowns : [];
          const moreDropdowns = [];
          moreDropdowns.push(
            react0().createElement(
              "div",
              {
                className: "dropdown-avatar rounded",
                key: "mainContactInfo",
                onClick: () => {
                  if (contact.c === 2) {
                    loadSubPage("fm/account");
                  }
                  if (contact.c === 1) {
                    loadSubPage("fm/chat/contacts/" + contact.u);
                  }
                }
              },
              react0().createElement(Avatar, {
                className: "avatar-wrapper context-avatar",
                chatRoom: chatRoom,
                contact: contact,
                hideVerifiedBadge: "true"
              }),
              react0().createElement(
                "div",
                {
                  className: "dropdown-user-name"
                },
                react0().createElement(
                  "div",
                  {
                    className: "name"
                  },
                  react0().createElement(ContactAwareName, {
                    overflow: true,
                    contact: contact
                  }),
                  react0().createElement(ContactPresence, {
                    className: "small",
                    contact: contact
                  })
                ),
                contact &&
                  (megaChat.FORCE_EMAIL_LOADING || contact.c === 1 || contact.c === 2) &&
                  react0().createElement(
                    "span",
                    {
                      className: "email"
                    },
                    contact.m
                  )
              )
            )
          );
          moreDropdowns.push(
            react0().createElement(ContactFingerprint, {
              key: "fingerprint",
              contact: contact
            })
          );
          if (dropdowns.length && contact.c !== 2) {
            moreDropdowns.push(dropdowns);
            moreDropdowns.push(
              react0().createElement("hr", {
                key: "top-separator"
              })
            );
          }
          if (contact.u === u_handle) {
            moreDropdowns.push(
              react0().createElement(_ui_dropdowns_jsx5__.DropdownItem, {
                key: "view0",
                icon: "sprite-fm-mono icon-user-filled",
                label: l[187],
                onClick: () => loadSubPage("fm/account")
              })
            );
          }
          if (contact.c === 1) {
            const startAudioCall = () => {
              megaChat.createAndShowPrivateRoom(contact.u).then((room) => {
                room.setActive();
                room.startAudioCall();
              });
            };
            if (megaChat.currentlyOpenedChat && megaChat.currentlyOpenedChat === contact.u) {
              moreDropdowns.push(
                react0().createElement(
                  "div",
                  {
                    key: "startAudioVideoCall",
                    "data-simpletipposition": "top",
                    className: "simpletip",
                    "data-simpletip": !megaChat.hasSupportForCalls ? l.call_not_suported : ""
                  },
                  react0().createElement(_ui_dropdowns_jsx5__.DropdownItem, {
                    disabled: !megaChat.hasSupportForCalls,
                    key: "startCall",
                    className: "sprite-fm-mono-before icon-arrow-right-before",
                    icon: "sprite-fm-mono icon-phone",
                    submenu: megaChat.hasSupportForCalls,
                    label: l[19125]
                  }),
                  react0().createElement(
                    "div",
                    {
                      className: "dropdown body submenu",
                      key: "dropdownGroup"
                    },
                    react0().createElement(
                      "div",
                      null,
                      react0().createElement(_ui_dropdowns_jsx5__.DropdownItem, {
                        key: "startAudio",
                        icon: "sprite-fm-mono icon-phone",
                        disabled: !megaChat.hasSupportForCalls,
                        label: l[1565],
                        onClick: startAudioCall
                      })
                    ),
                    react0().createElement(
                      "div",
                      null,
                      react0().createElement(_ui_dropdowns_jsx5__.DropdownItem, {
                        key: "startVideo",
                        icon: "sprite-fm-mono icon-video-call-filled",
                        disabled: !megaChat.hasSupportForCalls,
                        label: l[1566],
                        onClick: () => {
                          megaChat.createAndShowPrivateRoom(contact.u).then((room) => {
                            room.setActive();
                            room.startVideoCall();
                          });
                        }
                      })
                    )
                  )
                )
              );
            } else {
              moreDropdowns.push(
                react0().createElement(_ui_dropdowns_jsx5__.DropdownItem, {
                  key: "startChat",
                  icon: "sprite-fm-mono icon-chat",
                  label: l[5885],
                  onClick: () => {
                    loadSubPage("fm/chat/p/" + contact.u);
                  }
                })
              );
            }
            moreDropdowns.push(
              react0().createElement("hr", {
                key: "files-separator"
              })
            );
            moreDropdowns.push(
              react0().createElement(_ui_dropdowns_jsx5__.DropdownItem, {
                key: "send-files-item",
                icon: "sprite-fm-mono icon-send-files",
                label: l[6834],
                disabled: mega.paywall,
                onClick: () => {
                  megaChat.openChatAndSendFilesDialog(contact.u);
                }
              })
            );
            moreDropdowns.push(
              react0().createElement(_ui_dropdowns_jsx5__.DropdownItem, {
                key: "share-item",
                icon: "sprite-fm-mono icon-folder-outgoing-share",
                label: l[6775],
                onClick: () => {
                  openCopyShareDialog(contact.u);
                }
              })
            );
          } else if (!is_chatlink && !is_eplusplus && (!contact.c || (contact.c === 2 && contact.u !== u_handle))) {
            moreDropdowns.push(
              react0().createElement(_ui_dropdowns_jsx5__.DropdownItem, {
                key: "view2",
                icon: "sprite-fm-mono icon-add",
                label: l[101],
                onClick: () => {
                  const isAnonymousUser = !u_handle || u_type !== 3;
                  const ADD_CONTACT = "addContact";
                  if (is_chatlink && isAnonymousUser) {
                    megaChat.loginOrRegisterBeforeJoining(undefined, undefined, undefined, true);
                    if (localStorage.getItem(ADD_CONTACT) === null) {
                      localStorage.setItem(
                        ADD_CONTACT,
                        JSON.stringify({
                          u: contact.u,
                          unixTime: unixtime()
                        })
                      );
                    }
                  } else {
                    loadingDialog.show();
                    M.syncContactEmail(contact.u, true)
                      .then((email) => {
                        if (Object.values(M.opc || {}).some((cr) => cr.m === email)) {
                          closeDialog();
                          msgDialog("warningb", "", l[17545]);
                        } else {
                          M.inviteContact(M.u[u_handle].m, email);
                          const title = l[150];
                          const msg = l[5898].replace("[X]", email);
                          closeDialog();
                          msgDialog("info", title, msg.replace("[X]", email));
                        }
                      })
                      .catch(() => {
                        const { chatRoom } = this.props;
                        const { u: userHandle } = contact;
                        if (chatRoom.call) {
                          return mBroadcaster.sendMessage("meetings:ephemeralAdd", userHandle);
                        }
                        const name = M.getNameByHandle(userHandle);
                        return msgDialog(
                          "info",
                          "",
                          l.ephemeral_title ? l.ephemeral_title.replace("%1", name) : `${name} is using an ephemeral session.`,
                          l.ephemeral_info
                        );
                      })
                      .finally(() => loadingDialog.hide());
                  }
                }
              })
            );
          }
          if (u_attr && contact.u !== u_handle) {
            if (moreDropdowns.length > 0 && !(moreDropdowns.length === 2 && moreDropdowns[1] && moreDropdowns[1].key === "fingerprint")) {
              moreDropdowns.push(
                react0().createElement("hr", {
                  key: "nicknames-separator"
                })
              );
            }
            moreDropdowns.push(
              react0().createElement(_ui_dropdowns_jsx5__.DropdownItem, {
                key: "set-nickname",
                icon: "sprite-fm-mono icon-rename",
                label: contact.nickname === "" ? l.set_nickname_label : l.edit_nickname_label,
                onClick: () => {
                  nicknames.setNicknameDialog.init(contact.u);
                }
              })
            );
          }
          if (dropdownRemoveButton && dropdownRemoveButton.length) {
            moreDropdowns.push(
              react0().createElement("hr", {
                key: "remove-separator"
              })
            );
            moreDropdowns.push(dropdownRemoveButton);
          }
          return moreDropdowns;
        }
        render() {
          let {
            label = "",
            className = "",
            contact,
            dropdownIconClasses = [],
            verticalOffset,
            dropdownDisabled,
            noLoading,
            noContextMenu
          } = this.props;
          let dropdownPosition = "left top";
          let vertOffset = 0;
          let horizOffset = -30;
          if (!contact) {
            return null;
          }
          if (label) {
            className = `user-card-name ${className}${className.includes("message") ? "" : " selectable-txt"}`;
            dropdownIconClasses = "";
            dropdownPosition = "left bottom";
            vertOffset = 25;
            horizOffset = 0;
          }
          if (typeof verticalOffset !== "undefined") {
            vertOffset = verticalOffset;
          }
          if (!contact.name && !contact.m && !noLoading && this.isLoadingContactInfo()) {
            label = react0().createElement("em", {
              className: "contact-name-loading"
            });
            className = `contact-button-loading ${className}`;
          }
          return noContextMenu
            ? react0().createElement(
                "div",
                {
                  className: "user-card-name light selectable-txt"
                },
                label
              )
            : react0().createElement(
                _ui_buttons_jsx4__.z,
                {
                  className: className,
                  icon: dropdownIconClasses,
                  disabled: dropdownDisabled,
                  label: label
                },
                react0().createElement(_ui_dropdowns_jsx5__.Dropdown, {
                  className: "context contact-card-dropdown",
                  positionMy: dropdownPosition,
                  positionAt: dropdownPosition,
                  vertOffset: vertOffset,
                  horizOffset: horizOffset,
                  dropdownItemGenerator: this.dropdownItemGenerator,
                  noArrow: true
                })
              );
        }
      }
      ContactButton.defaultProps = {
        manualDataChangeTracking: true,
        skipQueuedUpdatesOnResize: true
      };
      class ContactVerified extends _mixins1__.wl {
        attachRerenderCallbacks() {
          this.addDataStructListenerForProperties(this.props.contact, ["fingerprint"]);
        }
        render() {
          if (is_chatlink) {
            return null;
          }
          var contact = this.props.contact;
          if (!contact) {
            return null;
          }
          if (u_authring && u_authring.Ed25519) {
            var verifyState = u_authring.Ed25519[contact.u] || {};
            if (verifyState.method >= authring.AUTHENTICATION_METHOD.FINGERPRINT_COMPARISON) {
              return react0().createElement("div", {
                className: `
                            user-card-verified
                            ${this.props.className || ""}
                        `
              });
            }
          } else if (!pubEd25519[contact.u]) {
            crypt.getPubEd25519(contact.u).then(() => {
              if (pubEd25519[contact.u]) {
                this.safeForceUpdate();
              }
            });
          }
          return null;
        }
      }
      ContactVerified.defaultProps = {
        manualDataChangeTracking: true,
        skipQueuedUpdatesOnResize: true
      };
      class ContactPresence extends _mixins1__.wl {
        attachRerenderCallbacks() {
          this.addDataStructListenerForProperties(this.props.contact, ["presence"]);
        }
        render() {
          var contact = this.props.contact;
          var className = this.props.className || "";
          if (!contact || !contact.c) {
            return null;
          }
          const pres = megaChat.userPresenceToCssClass(contact.presence);
          return react0().createElement("div", {
            className: `user-card-presence ${pres} ${className}`
          });
        }
      }
      ContactPresence.defaultProps = {
        manualDataChangeTracking: true,
        skipQueuedUpdatesOnResize: true
      };
      class LastActivity extends _mixins1__._p {
        attachRerenderCallbacks() {
          this._attachRerenderCbContacts(["ats", "lastGreen", "presence"]);
        }
        render() {
          const { contact, showLastGreen } = this.props;
          if (!contact) {
            return null;
          }
          const lastActivity = !contact.ats || contact.lastGreen > contact.ats ? contact.lastGreen : contact.ats;
          const SECONDS = new Date().getTime() / 1000 - lastActivity;
          const timeToLast = SECONDS > 3888000 ? l[20673] : time2last(lastActivity, true);
          const hasActivityStatus = showLastGreen && contact.presence <= 2 && lastActivity;
          return react0().createElement(
            "span",
            null,
            hasActivityStatus ? (l[19994] || "Last seen %s").replace("%s", timeToLast) : M.onlineStatusClass(contact.presence)[0]
          );
        }
      }
      class ContactAwareName extends _mixins1__._p {
        render() {
          const { contact, emoji, overflow } = this.props;
          if (!contact || !M.u[contact.u || contact.h]) {
            return null;
          }
          const name = M.getNameByHandle(contact.u || contact.h);
          if (emoji || overflow) {
            const EmojiComponent = overflow ? _ui_utils_jsx2__.a0 : _ui_utils_jsx2__.dy;
            return react0().createElement(EmojiComponent, this.props, name);
          }
          return react0().createElement("span", null, name);
        }
      }
      class MembersAmount extends _mixins1__._p {
        render() {
          const { chatRoom } = this.props;
          return react0().createElement("span", null, mega.icu.format(l[20233], Object.keys(chatRoom.members).length));
        }
      }
      class ContactFingerprint extends _mixins1__.wl {
        attachRerenderCallbacks() {
          this.addDataStructListenerForProperties(this.props.contact, ["fingerprint"]);
        }
        render() {
          var contact = this.props.contact;
          if (!contact || !contact.u || is_chatlink) {
            return null;
          }
          var infoBlocks = [];
          userFingerprint(contact.u, function (fingerprints) {
            fingerprints.forEach(function (v, k) {
              infoBlocks.push(
                react0().createElement(
                  "span",
                  {
                    key: "fingerprint-" + k
                  },
                  v
                )
              );
            });
          });
          var verifyButton = null;
          if (contact.c === 1 && u_authring && u_authring.Ed25519) {
            var verifyState = u_authring.Ed25519[contact.u] || {};
            if (typeof verifyState.method === "undefined" || verifyState.method < authring.AUTHENTICATION_METHOD.FINGERPRINT_COMPARISON) {
              verifyButton = react0().createElement(_ui_buttons_jsx4__.z, {
                className: "dropdown-verify active",
                label: l.verify_credentials,
                icon: "sprite-fm-mono icon-key",
                onClick: () => {
                  closeDropdowns();
                  fingerprintDialog(contact.u);
                }
              });
            }
          }
          var fingerprintCode = null;
          if (infoBlocks.length > 0) {
            fingerprintCode = react0().createElement(
              "div",
              {
                className: `dropdown-fingerprint ${this.props.className || ""}`
              },
              react0().createElement(
                "div",
                {
                  className: "contact-fingerprint-title"
                },
                react0().createElement("span", null, l[6872])
              ),
              react0().createElement(
                "div",
                {
                  className: "contact-fingerprint-txt selectable-txt"
                },
                infoBlocks
              ),
              verifyButton
            );
          }
          return fingerprintCode;
        }
      }
      ContactFingerprint.defaultProps = {
        manualDataChangeTracking: true,
        skipQueuedUpdatesOnResize: true
      };
      class Avatar extends _mixins1__._p {
        render() {
          var self = this;
          var contact = this.props.contact;
          if (!contact) {
            return null;
          }
          if (!contact.m && contact.email) {
            contact.m = contact.email;
          }
          var avatarMeta = useravatar.generateContactAvatarMeta(contact);
          var classes =
            (this.props.className ? this.props.className : " avatar-wrapper small-rounded-avatar") + " " + contact.u + " in-chat";
          classes += " chat-avatar";
          var displayedAvatar;
          var verifiedElement = null;
          if (!this.props.hideVerifiedBadge && !is_chatlink) {
            verifiedElement = react0().createElement(ContactVerified, {
              contact: this.props.contact,
              className: this.props.verifiedClassName
            });
          }
          var extraProps = {};
          if (this.props.simpletip) {
            classes += " simpletip";
            extraProps["data-simpletip"] = this.props.simpletip;
            if (this.props.simpletipWrapper) {
              extraProps["data-simpletipwrapper"] = this.props.simpletipWrapper;
            }
            if (this.props.simpletipOffset) {
              extraProps["data-simpletipoffset"] = this.props.simpletipOffset;
            }
            if (this.props.simpletipPosition) {
              extraProps["data-simpletipposition"] = this.props.simpletipPosition;
            }
            if (this.props.simpletipClass) {
              extraProps["data-simpletip-class"] = this.props.simpletipClass;
            }
          }
          if (avatarMeta.type === "image") {
            displayedAvatar = react0().createElement(
              "div",
              (0, _extends8__.Z)(
                {
                  className: classes,
                  style: this.props.style
                },
                extraProps,
                {
                  onClick: self.props.onClick
                    ? (e) => {
                        closeDropdowns();
                        self.props.onClick(e);
                      }
                    : self.onClick
                }
              ),
              verifiedElement,
              react0().createElement("img", {
                src: avatarMeta.avatar,
                style: this.props.imgStyles
              })
            );
          } else {
            classes += " color" + avatarMeta.avatar.colorIndex;
            var isLoading = self.isLoadingContactInfo();
            if (isLoading) {
              classes += " default-bg";
            }
            displayedAvatar = react0().createElement(
              "div",
              (0, _extends8__.Z)(
                {
                  className: classes,
                  style: this.props.style
                },
                extraProps,
                {
                  onClick: self.props.onClick
                    ? (e) => {
                        closeDropdowns();
                        self.props.onClick(e);
                      }
                    : self.onClick
                }
              ),
              verifiedElement,
              react0().createElement("span", null, isLoading ? "" : avatarMeta.avatar.letters)
            );
          }
          return displayedAvatar;
        }
      }
      Avatar.defaultProps = {
        manualDataChangeTracking: true,
        skipQueuedUpdatesOnResize: true
      };
      class ContactCard extends _mixins1__._p {
        attachRerenderCallbacks() {
          this._attachRerenderCbContacts(["presence"]);
        }
        specShouldComponentUpdate(nextProps, nextState) {
          var self = this;
          var foundKeys = Object.keys(self.props);
          if (foundKeys.indexOf("dropdowns") >= 0) {
            array.remove(foundKeys, "dropdowns", true);
          }
          let shouldUpdate;
          if (foundKeys.length) {
            let k = foundKeys[0];
            shouldUpdate = shallowEqual(nextProps[k], self.props[k]);
          }
          if (!shouldUpdate) {
            shouldUpdate = shallowEqual(nextState, self.state);
          }
          if (!shouldUpdate && self.state.props.dropdowns && nextProps.state.dropdowns) {
            if (self.state.props.dropdowns.map && nextProps.state.dropdowns.map) {
              var oldKeys = self.state.props.dropdowns.map((child) => child.key);
              var newKeys = nextProps.state.dropdowns.map((child) => child.key);
              if (!shallowEqual(oldKeys, newKeys)) {
                shouldUpdate = true;
              }
            }
          }
          return shouldUpdate;
        }
        render() {
          var self = this;
          var contact = this.props.contact;
          if (!contact) {
            return null;
          }
          var pres = megaChat.userPresenceToCssClass(contact.presence);
          var username = (this.props.namePrefix ? this.props.namePrefix : "") + (M.getNameByHandle(contact.u) || contact.m);
          if (contact.u === u_handle) {
            username += " (" + escapeHTML(l[8885]) + ")";
          }
          var escapedUsername = react0().createElement(_ui_utils_jsx2__.a0, null, username);
          var dropdowns = this.props.dropdowns ? this.props.dropdowns : [];
          var noContextMenu = this.props.noContextMenu ? this.props.noContextMenu : "";
          var noContextButton = this.props.noContextButton ? this.props.noContextButton : "";
          var dropdownRemoveButton = self.props.dropdownRemoveButton ? self.props.dropdownRemoveButton : [];
          var highlightSearchValue = self.props.highlightSearchValue ? self.props.highlightSearchValue : false;
          var emailTooltips = self.props.emailTooltips ? self.props.emailTooltips : false;
          var searchValue = self.props.searchValue ? self.props.searchValue : "";
          var usernameBlock;
          if (!noContextMenu) {
            usernameBlock = react0().createElement(ContactButton, {
              key: "lnk",
              dropdowns: dropdowns,
              noContextMenu: noContextMenu,
              contact: contact,
              className: "light",
              label: escapedUsername,
              chatRoom: this.props.chatRoom,
              dropdownRemoveButton: dropdownRemoveButton,
              verticalOffset: 0
            });
          } else {
            if (highlightSearchValue && searchValue.length > 0) {
              var matches = [];
              var regex = new RegExp(RegExpEscape(searchValue), "gi");
              var result;
              while ((result = regex.exec(username))) {
                matches.push({
                  idx: result.index,
                  str: result[0]
                });
              }
              if (matches.length > 0) {
                escapedUsername = react0().createElement(
                  _ui_utils_jsx2__.Cw,
                  null,
                  megaChat.highlight(megaChat.html(username), matches, true)
                );
              }
            }
            if (emailTooltips) {
              usernameBlock = react0().createElement(
                "div",
                {
                  className: "user-card-name light simpletip selectable-txt",
                  "data-simpletip": contact.m,
                  "data-simpletipposition": "top"
                },
                escapedUsername
              );
            } else {
              usernameBlock = react0().createElement(
                "div",
                {
                  className: "user-card-name light selectable-txt"
                },
                escapedUsername
              );
            }
          }
          var userCard = null;
          var className = this.props.className || "";
          if (className.indexOf("short") >= 0) {
            userCard = react0().createElement(
              "div",
              {
                className: "user-card-data"
              },
              usernameBlock,
              react0().createElement(
                "div",
                {
                  className: "user-card-status"
                },
                this.props.isInCall
                  ? react0().createElement(
                      "div",
                      {
                        className: "audio-call"
                      },
                      react0().createElement("i", {
                        className: "sprite-fm-mono icon-phone"
                      })
                    )
                  : null,
                react0().createElement(LastActivity, {
                  contact: contact,
                  showLastGreen: this.props.showLastGreen
                })
              )
            );
          } else {
            userCard = react0().createElement(
              "div",
              {
                className: "user-card-data"
              },
              usernameBlock,
              react0().createElement(ContactPresence, {
                contact: contact,
                className: this.props.presenceClassName
              }),
              this.props.isInCall
                ? react0().createElement(
                    "div",
                    {
                      className: "audio-call"
                    },
                    react0().createElement("i", {
                      className: "sprite-fm-mono icon-phone"
                    })
                  )
                : null,
              react0().createElement(
                "div",
                {
                  className: "user-card-email selectable-txt"
                },
                contact.m
              )
            );
          }
          var selectionTick = null;
          if (this.props.selectable) {
            selectionTick = react0().createElement(
              "div",
              {
                className: "user-card-tick-wrap"
              },
              react0().createElement("i", {
                className: "sprite-fm-mono icon-check"
              })
            );
          }
          return react0().createElement(
            "div",
            {
              className: "contacts-info body " + (pres === "offline" ? "offline" : "") + (className ? " " + className : ""),
              onClick: (e) => {
                if (self.props.onClick) {
                  self.props.onClick(contact, e);
                }
              },
              onDoubleClick: (e) => {
                if (self.props.onDoubleClick) {
                  self.props.onDoubleClick(contact, e);
                }
              },
              style: self.props.style
            },
            react0().createElement(Avatar, {
              contact: contact,
              className: "avatar-wrapper small-rounded-avatar",
              chatRoom: this.props.chatRoom
            }),
            is_chatlink || noContextButton
              ? null
              : react0().createElement(ContactButton, {
                  key: "button",
                  dropdowns: dropdowns,
                  dropdownIconClasses: self.props.dropdownIconClasses ? self.props.dropdownIconClasses : "",
                  disabled: self.props.dropdownDisabled,
                  noContextMenu: noContextMenu,
                  contact: contact,
                  className: self.props.dropdownButtonClasses,
                  dropdownRemoveButton: dropdownRemoveButton,
                  noLoading: self.props.noLoading,
                  chatRoom: self.props.chatRoom,
                  verticalOffset: 0
                }),
            selectionTick,
            userCard
          );
        }
      }
      ContactCard.defaultProps = {
        dropdownButtonClasses: "tiny-button",
        dropdownIconClasses: "tiny-icon icons-sprite grey-dots",
        presenceClassName: "",
        manualDataChangeTracking: true,
        skipQueuedUpdatesOnResize: true
      };
      class ContactItem extends _mixins1__._p {
        render() {
          var self = this;
          var contact = this.props.contact;
          if (!contact) {
            return null;
          }
          var username = this.props.namePrefix ? this.props.namePrefix : "" + M.getNameByHandle(contact.u);
          return react0().createElement(
            "div",
            {
              className: "selected-contact-card short"
            },
            react0().createElement(
              "div",
              {
                className: "remove-contact-bttn",
                onClick: (e) => {
                  if (self.props.onClick) {
                    self.props.onClick(contact, e);
                  }
                }
              },
              react0().createElement("i", {
                className: "tiny-icon small-cross"
              })
            ),
            react0().createElement(Avatar, {
              contact: contact,
              className: "avatar-wrapper small-rounded-avatar",
              hideVerifiedBadge: true,
              chatRoom: this.props.chatRoom
            }),
            react0().createElement(
              "div",
              {
                className: "user-card-data simpletip",
                "data-simpletip": username,
                "data-simpletipposition": "top"
              },
              react0().createElement(ContactButton, {
                noContextMenu: this.props.noContextMenu,
                contact: contact,
                className: "light",
                label: react0().createElement(_ui_utils_jsx2__.dy, null, username),
                chatRoom: this.props.chatRoom
              })
            )
          );
        }
      }
      ContactItem.defaultProps = {
        manualDataChangeTracking: true,
        skipQueuedUpdatesOnResize: true
      };
      class ContactPickerWidget extends _mixins1__.wl {
        constructor(...args) {
          super(...args);
          this.contactLinkListener = null;
          this.containerRef = react0().createRef();
          this.state = {
            searchValue: "",
            selected: this.props.selected || [],
            publicLink: (M.account && M.account.contactLink) || undefined
          };
          this.onSearchChange = (ev) => {
            this.setState({
              searchValue: ev.target.value
            });
          };
          this.renderParticipantsList = () => {
            const { contacts, emailTooltips, onSelect } = this.props;
            const { selected } = this.state;
            const $$list = contacts.map((handle) => {
              const added = selected.includes(handle);
              return react0().createElement(ContactCard, {
                key: handle,
                className: `
                            contacts-search short
                            ${added ? "selected" : ""}
                        `,
                contact: M.u[handle],
                selectable: true,
                emailTooltips: emailTooltips,
                noContextButton: true,
                noContextMenu: true,
                onClick: () => {
                  this.setState(
                    {
                      selected: added ? selected.filter((h) => h !== handle) : [...selected, handle]
                    },
                    () => onSelect(this.state.selected)
                  );
                }
              });
            });
            return react0().createElement(
              _ui_perfectScrollbar_jsx3__.F,
              {
                className: "contacts-search-scroll",
                selected: selected,
                contacts: contacts
              },
              react0().createElement(
                "div",
                {
                  className: "contacts-search-subsection"
                },
                react0().createElement(
                  "div",
                  {
                    className: "contacts-list-header"
                  },
                  megaChat.activeCall ? l.call_participants : l[16217]
                ),
                react0().createElement(
                  "div",
                  {
                    className: "contacts-search-list"
                  },
                  $$list
                )
              )
            );
          };
        }
        componentDidMount() {
          super.componentDidMount();
          setContactLink(this.containerRef && this.containerRef.current);
          this.contactLinkListener = mBroadcaster.addListener("contact:setContactLink", (publicLink) =>
            this.state.publicLink
              ? null
              : this.setState({
                  publicLink
                })
          );
        }
        componentDidUpdate() {
          var self = this;
          if (self.scrollToLastSelected && self.psSelected) {
            self.scrollToLastSelected = false;
            self.psSelected.scrollToPercentX(100, false);
          }
          if (self.searchContactsScroll) {
            self.searchContactsScroll.reinitialise();
          }
        }
        componentWillMount() {
          if (super.componentWillMount) {
            super.componentWillMount();
          }
          var self = this;
          if (self.props.multiple) {
            $(document.body).rebind("keypress.contactPicker" + self.getUniqueId(), function (e) {
              var keyCode = e.which || e.keyCode;
              if (keyCode === 13) {
                if (self.state.selected) {
                  e.preventDefault();
                  e.stopPropagation();
                  closeDropdowns();
                  if (self.props.onSelectDone) {
                    self.props.onSelectDone(self.state.selected);
                  }
                }
              }
            });
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          var self = this;
          delete self._foundFrequents;
          if (self.props.multiple) {
            $(document.body).off("keypress.contactPicker" + self.getUniqueId());
          }
          if (this.contactLinkListener) {
            mBroadcaster.removeListener(this.contactLinkListener);
          }
        }
        _eventuallyAddContact(v, contacts, selectableContacts, forced) {
          var self = this;
          if (!forced && (v.c !== 1 || v.u === u_handle)) {
            return false;
          }
          if (self.props.exclude && self.props.exclude.indexOf(v.u) > -1) {
            return false;
          }
          var isDisabled = false;
          if (!self.wasMissingKeysForContacts) {
            self.wasMissingKeysForContacts = {};
          }
          if (!self.wasMissingKeysForContacts[v.u] && (!pubCu25519[v.u] || !pubEd25519[v.u])) {
            self.wasMissingKeysForContacts[v.u] = true;
            ChatdIntegration._ensureKeysAreLoaded(undefined, [v.u]).always(function () {
              if (self.isMounted()) {
                self.safeForceUpdate();
              }
            });
            isDisabled = true;
            return true;
          } else if (self.wasMissingKeysForContacts[v.u] && (!pubCu25519[v.u] || !pubEd25519[v.u])) {
            return false;
          }
          if (self.state.searchValue && self.state.searchValue.length > 0) {
            const norm = (s) => ChatSearch._normalize_str(String(s || "").toLowerCase());
            const sv = norm(this.state.searchValue);
            const skip =
              !norm(v.name).includes(sv) &&
              !norm(v.nickname).includes(sv) &&
              !norm(v.fullname).includes(sv) &&
              !norm(M.getNameByHandle(v.u)).includes(sv) &&
              (this.props.notSearchInEmails || !norm(v.m).includes(sv));
            if (skip) {
              return false;
            }
          }
          var selectedClass = "";
          if (self.state.selected && self.state.selected.indexOf(v.u) !== -1) {
            selectedClass = "selected";
          }
          contacts.push(
            react0().createElement(ContactCard, {
              disabled: isDisabled,
              contact: v,
              chatRoom: false,
              className: "contacts-search short " + selectedClass + (isDisabled ? " disabled" : ""),
              noContextButton: "true",
              selectable: selectableContacts,
              onClick: self.props.readOnly
                ? () => {}
                : (contact) => {
                    if (isDisabled) {
                      return false;
                    }
                    var contactHash = contact.u;
                    if (
                      (contactHash === self.lastClicked && new Date() - self.clickTime < 500 && !self.props.disableDoubleClick) ||
                      !self.props.multiple
                    ) {
                      if (self.props.onSelected) {
                        self.props.onSelected([contactHash]);
                      }
                      self.props.onSelectDone([contactHash]);
                      closeDropdowns();
                      return;
                    } else {
                      var selected = clone(self.state.selected || []);
                      if (selected.indexOf(contactHash) === -1) {
                        selected.push(contactHash);
                        self.scrollToLastSelected = true;
                        if (self.props.onSelected) {
                          self.props.onSelected(selected);
                        }
                      } else {
                        if (selected.indexOf(contactHash) >= 0) {
                          array.remove(selected, contactHash);
                        }
                        if (self.props.onSelected) {
                          self.props.onSelected(selected);
                        }
                      }
                      self.setState({
                        selected: selected
                      });
                      if (self.props.selectCleanSearchRes) {
                        self.setState({
                          searchValue: ""
                        });
                      }
                      if (self.props.autoFocusSearchField) {
                        var _self$contactSearchFi;
                        (_self$contactSearchFi = self.contactSearchField) == null || _self$contactSearchFi.focus();
                      }
                    }
                    self.clickTime = new Date();
                    self.lastClicked = contactHash;
                  },
              noContextMenu: true,
              searchValue: self.state.searchValue,
              highlightSearchValue: self.props.highlightSearchValue,
              emailTooltips: self.props.emailTooltips,
              key: v.u
            })
          );
          if (typeof this.props.onEventuallyUpdated === "function") {
            this.props.onEventuallyUpdated();
          }
          return true;
        }
        render() {
          var self = this;
          var contacts = [];
          var frequentContacts = [];
          var extraClasses = "";
          var contactsSelected = [];
          var multipleContacts = null;
          var selectableContacts = false;
          var selectFooter = null;
          var selectedContacts = false;
          var isSearching = !!self.state.searchValue;
          var onAddContact = (e) => {
            e.preventDefault();
            e.stopPropagation();
            contactAddDialog();
            if (this.props.onClose) {
              this.props.onClose();
            }
          };
          if (self.props.readOnly) {
            var sel = self.state.selected || [];
            for (var i = 0; i < sel.length; i++) {
              var v = sel[i];
              contactsSelected.push(
                react0().createElement(ContactItem, {
                  contact: M.u[v],
                  key: v,
                  chatRoom: self.props.chatRoom
                })
              );
            }
          } else if (self.props.multiple) {
            selectableContacts = true;
            var onSelectDoneCb = (e) => {
              e.preventDefault();
              e.stopPropagation();
              closeDropdowns();
              if (self.props.onSelectDone) {
                self.props.onSelectDone(self.state.selected);
              }
            };
            var onContactSelectDoneCb = (contact) => {
              var contactHash = contact.u;
              if (contactHash === self.lastClicked && new Date() - self.clickTime < 500) {
                if (self.props.onSelected) {
                  self.props.onSelected([contactHash]);
                }
                self.props.onSelectDone([contactHash]);
                return;
              } else {
                var selected = clone(self.state.selected || []);
                if (selected.indexOf(contactHash) === -1) {
                  selected.push(contactHash);
                  self.scrollToLastSelected = true;
                  if (self.props.onSelected) {
                    self.props.onSelected(selected);
                  }
                } else {
                  if (selected.indexOf(contactHash) >= 0) {
                    array.remove(selected, contactHash);
                  }
                  if (self.props.onSelected) {
                    self.props.onSelected(selected);
                  }
                }
                self.setState({
                  selected: selected
                });
                if (self.props.selectCleanSearchRes) {
                  self.setState({
                    searchValue: ""
                  });
                }
                if (self.props.autoFocusSearchField) {
                  var _self$contactSearchFi2;
                  (_self$contactSearchFi2 = self.contactSearchField) == null || _self$contactSearchFi2.focus();
                }
              }
              self.clickTime = new Date();
              self.lastClicked = contactHash;
            };
            var selectedWidthSize = self.props.selectedWidthSize || 54;
            var selectedWidth = self.state.selected.length * selectedWidthSize;
            if (!self.state.selected || self.state.selected.length === 0) {
              selectedContacts = false;
              var emptySelectionMsg = self.props.emptySelectionMsg || l[8889];
              multipleContacts = react0().createElement(
                "div",
                {
                  className: "horizontal-contacts-list"
                },
                react0().createElement(
                  "div",
                  {
                    className: "contacts-list-empty-txt"
                  },
                  self.props.nothingSelectedButtonLabel ? self.props.nothingSelectedButtonLabel : emptySelectionMsg
                )
              );
            } else {
              selectedContacts = true;
              onContactSelectDoneCb = onContactSelectDoneCb.bind(self);
              var sel2 = self.state.selected || [];
              for (var i2 = 0; i2 < sel2.length; i2++) {
                var v2 = sel2[i2];
                contactsSelected.push(
                  react0().createElement(ContactItem, {
                    key: v2,
                    chatRoom: self.props.chatRoom || false,
                    contact: M.u[v2],
                    noContextMenu: true,
                    onClick: onContactSelectDoneCb
                  })
                );
              }
              multipleContacts = react0().createElement(
                "div",
                {
                  className: "horizontal-contacts-list"
                },
                react0().createElement(
                  _ui_perfectScrollbar_jsx3__.F,
                  {
                    className: "perfectScrollbarContainer selected-contact-block horizontal-only",
                    selected: this.state.selected,
                    ref: function (psSelected) {
                      self.psSelected = psSelected;
                    }
                  },
                  react0().createElement(
                    "div",
                    {
                      className: "select-contact-centre",
                      style: {
                        width: selectedWidth
                      }
                    },
                    contactsSelected
                  )
                )
              );
            }
            if (self.props.selectFooter) {
              selectFooter = react0().createElement(
                "footer",
                null,
                react0().createElement(
                  "button",
                  {
                    className: "mega-button",
                    onClick: onAddContact.bind(self)
                  },
                  react0().createElement("span", null, l[71])
                ),
                react0().createElement("div", {
                  className: "footer-spacing"
                }),
                react0().createElement(
                  "button",
                  {
                    className: `mega-button ${selectedContacts ? "" : "disabled"}`,
                    onClick: function (e) {
                      if (self.state.selected.length > 0) {
                        onSelectDoneCb(e);
                      }
                    }
                  },
                  react0().createElement(
                    "span",
                    null,
                    this.props.multipleSelectedButtonLabel ? this.props.multipleSelectedButtonLabel : l[8890]
                  )
                )
              );
            }
          }
          var alreadyAdded = {};
          var hideFrequents = !self.props.readOnly && !self.state.searchValue && frequentContacts.length > 0;
          var frequentsLoading = false;
          if (this.props.readOnly || this.props.disableFrequents) {
            hideFrequents = true;
            this._foundFrequents = [];
          } else if (!self._foundFrequents) {
            frequentsLoading = true;
            this._foundFrequents = [];
            megaChat
              .getFrequentContacts()
              .then((res) => {
                this._foundFrequents = res.slice(Math.max(res.length - 30, 0), res.length).reverse();
              })
              .catch(dump)
              .finally(() => {
                if (this.isMounted()) {
                  this.safeForceUpdate();
                }
              });
          }
          for (let i = this._foundFrequents.length, total = 0; total < MAX_FREQUENTS && i--; ) {
            const v = this._foundFrequents[i];
            if (v.userId in M.u && this._eventuallyAddContact(M.u[v.userId], frequentContacts, selectableContacts)) {
              alreadyAdded[v.userId] = 1;
              total++;
            }
          }
          self.props.contacts.forEach(function (v) {
            alreadyAdded[v.h] || self._eventuallyAddContact(v, contacts, selectableContacts);
          });
          var sortFn = M.getSortByNameFn2(1);
          contacts.sort(function (a, b) {
            return sortFn(a.props.contact, b.props.contact);
          });
          if (Object.keys(alreadyAdded).length === 0) {
            hideFrequents = true;
          }
          var innerDivStyles = {};
          if (this.props.showMeAsSelected) {
            self._eventuallyAddContact(M.u[u_handle], contacts, selectableContacts, true);
          }
          var noOtherContacts = false;
          if (contacts.length === 0) {
            noOtherContacts = true;
            var noContactsMsg = "";
            if (M.u.length < 2) {
              noContactsMsg = l[8877];
            } else {
              noContactsMsg = l[8878];
            }
            if (hideFrequents) {
              contacts = react0().createElement("em", null, noContactsMsg);
            }
          }
          var haveContacts = isSearching || frequentContacts.length !== 0 || !noOtherContacts;
          var contactsList;
          if (haveContacts) {
            if (frequentContacts.length === 0 && noOtherContacts) {
              if (self.props.newEmptySearchResult) {
                contactsList = react0().createElement(
                  "div",
                  {
                    className: "chat-contactspicker-no-contacts flex flex-column flex-center searching mt-2"
                  },
                  react0().createElement("div", {
                    className: "section-icon sprite-fm-mono icon-contacts"
                  }),
                  react0().createElement(
                    "div",
                    {
                      className: "fm-empty-cloud-txt small"
                    },
                    l[8674]
                  )
                );
              } else {
                contactsList = react0().createElement(
                  "div",
                  {
                    className: "chat-contactspicker-no-contacts flex flex-column mt-2"
                  },
                  react0().createElement(
                    "div",
                    {
                      className: "contacts-list-header"
                    },
                    l[165]
                  ),
                  react0().createElement(
                    "div",
                    {
                      className: "flex flex-1 flex-column flex-center"
                    },
                    react0().createElement("div", {
                      className: "section-icon sprite-fm-mono icon-contacts"
                    }),
                    react0().createElement(
                      "div",
                      {
                        className: "fm-empty-cloud-txt small"
                      },
                      l[784]
                    ),
                    react0().createElement(
                      "div",
                      {
                        className: "fm-empty-description small"
                      },
                      l[19115]
                    )
                  )
                );
              }
            } else {
              contactsList = react0().createElement(
                _ui_perfectScrollbar_jsx3__.F,
                {
                  ref: (ref) => {
                    self.searchContactsScroll = ref;
                  },
                  className: "contacts-search-scroll",
                  selected: this.state.selected,
                  changedHashProp: this.props.changedHashProp,
                  contacts: contacts,
                  frequentContacts: frequentContacts,
                  searchValue: this.state.searchValue
                },
                react0().createElement(
                  react0().Fragment,
                  null,
                  react0().createElement(
                    "div",
                    {
                      className: "contacts-search-subsection",
                      style: {
                        display: hideFrequents ? "none" : ""
                      }
                    },
                    react0().createElement(
                      "div",
                      {
                        className: "contacts-list-header"
                      },
                      l[20141]
                    ),
                    frequentsLoading
                      ? react0().createElement(
                          "div",
                          {
                            className: "loading-spinner"
                          },
                          "..."
                        )
                      : react0().createElement(
                          "div",
                          {
                            className: "contacts-search-list",
                            style: innerDivStyles
                          },
                          frequentContacts
                        )
                  ),
                  contacts.length > 0
                    ? react0().createElement(
                        "div",
                        {
                          className: "contacts-search-subsection"
                        },
                        react0().createElement(
                          "div",
                          {
                            className: "contacts-list-header"
                          },
                          frequentContacts.length === 0 ? (this.props.readOnly ? l[16217] : l[165]) : l[165]
                        ),
                        react0().createElement(
                          "div",
                          {
                            className: "contacts-search-list",
                            style: innerDivStyles
                          },
                          contacts
                        )
                      )
                    : undefined
                )
              );
            }
          } else if (self.props.newNoContact) {
            multipleContacts = "";
            contactsList = react0().createElement(
              "div",
              {
                className: "chat-contactspicker-no-contacts flex flex-column flex-center mt-2"
              },
              react0().createElement("div", {
                className: "section-icon sprite-fm-mono icon-contacts"
              }),
              react0().createElement(
                "div",
                {
                  className: "fm-empty-cloud-txt small"
                },
                l[784]
              ),
              react0().createElement(
                "div",
                {
                  className: "fm-empty-description small"
                },
                l[19115]
              )
            );
            extraClasses += " no-contacts";
          } else {
            contactsList = react0().createElement(
              "div",
              {
                className: "chat-contactspicker-no-contacts flex flex-column flex-center mt-16"
              },
              react0().createElement("div", {
                className: "section-icon sprite-fm-mono icon-contacts"
              }),
              react0().createElement(
                "div",
                {
                  className: "fm-empty-cloud-txt small"
                },
                l[784]
              ),
              react0().createElement(
                "div",
                {
                  className: "fm-empty-description small"
                },
                l[19115]
              ),
              react0().createElement(
                "button",
                {
                  className: "mega-button positive large fm-empty-button",
                  onClick: function () {
                    contactAddDialog();
                    if (self.props.onClose) {
                      self.props.onClose();
                    }
                  }
                },
                react0().createElement("span", null, l[101])
              ),
              react0().createElement(
                "div",
                {
                  className: `
                        ${this.state.publicLink ? "" : "loading"}
                        empty-share-public
                    `
                },
                react0().createElement("i", {
                  className: "sprite-fm-mono icon-link-circle"
                }),
                react0().createElement(_ui_utils_jsx2__.Cw, null, l[19111])
              )
            );
            extraClasses += " no-contacts";
          }
          const totalContactsNum = contacts.length + frequentContacts.length;
          const searchPlaceholderMsg = mega.icu.format(l.search_contact_placeholder, totalContactsNum);
          return react0().createElement(
            "div",
            {
              ref: this.containerRef,
              className: `
                    ${this.props.className || ""}
                    ${extraClasses}
                `
            },
            this.props.topButtons &&
              react0().createElement(
                "div",
                {
                  className: "contacts-search-buttons"
                },
                this.props.topButtons.map((button) => {
                  const { key, icon, className, title, onClick } = button;
                  return react0().createElement(
                    "div",
                    {
                      key: key,
                      className: "button-wrapper",
                      onClick: (e) => {
                        closeDropdowns();
                        onClick(e);
                      }
                    },
                    react0().createElement(_ui_buttons_jsx4__.z, {
                      className: `
                                            ${className || ""}
                                            ${key === "newChatLink" ? "branded-blue" : ""}
                                            mega-button
                                            round
                                            positive
                                        `,
                      icon: icon
                    }),
                    react0().createElement(
                      "span",
                      {
                        className: "button-title"
                      },
                      title
                    )
                  );
                })
              ),
            multipleContacts,
            !this.props.readOnly &&
              haveContacts &&
              !this.props.hideSearch &&
              react0().createElement(
                react0().Fragment,
                null,
                react0().createElement(
                  "div",
                  {
                    className: `
                                contacts-search-header
                                ${this.props.headerClasses}
                            `
                  },
                  react0().createElement("i", {
                    className: "sprite-fm-mono icon-preview-reveal"
                  }),
                  react0().createElement("input", {
                    autoFocus: true,
                    type: "search",
                    placeholder: searchPlaceholderMsg,
                    ref: (nodeRef) => {
                      this.contactSearchField = nodeRef;
                    },
                    onChange: this.onSearchChange,
                    value: this.state.searchValue
                  }),
                  react0().createElement(
                    "div",
                    {
                      className: `
                                    search-result-clear
                                    ${this.state.searchValue && this.state.searchValue.length > 0 ? "" : "hidden"}
                                `,
                      onClick: () => {
                        this.setState(
                          {
                            searchValue: ""
                          },
                          () => {
                            var _this$contactSearchFi;
                            return (_this$contactSearchFi = this.contactSearchField) == null ? void 0 : _this$contactSearchFi.focus();
                          }
                        );
                      }
                    },
                    react0().createElement("i", {
                      className: "sprite-fm-mono icon-close-component"
                    })
                  )
                ),
                react0().createElement("div", {
                  className: "contacts-search-header-separator"
                })
              ),
            this.props.participantsList ? this.renderParticipantsList() : contactsList,
            selectFooter,
            _contactsPanel_contactsPanel_jsx6__["default"].hasContacts() &&
              this.props.showAddContact &&
              react0().createElement(
                "div",
                {
                  className: "contacts-search-bottom"
                },
                react0().createElement(_ui_buttons_jsx4__.z, {
                  className: "mega-button action positive",
                  icon: "sprite-fm-mono icon-add-circle",
                  label: l[71],
                  onClick: () => {
                    contactAddDialog();
                    closeDropdowns();
                  }
                })
              )
          );
        }
      }
      ContactPickerWidget.defaultProps = {
        multipleSelectedButtonLabel: false,
        singleSelectedButtonLabel: false,
        nothingSelectedButtonLabel: false,
        allowEmpty: false,
        disableFrequents: false,
        notSearchInEmails: false,
        autoFocusSearchField: true,
        selectCleanSearchRes: true,
        disableDoubleClick: false,
        newEmptySearchResult: false,
        newNoContact: false,
        emailTooltips: false
      };
      class ContactPickerDialog extends _mixins1__.wl {
        render() {
          const {
            active,
            allowEmpty,
            className,
            exclude,
            megaChat,
            multiple,
            multipleSelectedButtonLabel,
            name,
            nothingSelectedButtonLabel,
            selectFooter,
            singleSelectedButtonLabel,
            onClose,
            onSelectDone
          } = this.props;
          return react0().createElement(
            _ui_modalDialogs7__.Z.ModalDialog,
            {
              name: name,
              className: `${className} contact-picker-dialog contacts-search`,
              onClose: onClose
            },
            react0().createElement(ContactPickerWidget, {
              active: active,
              allowEmpty: allowEmpty,
              className: "popup contacts-search small-footer",
              contacts: M.u,
              exclude: exclude,
              megaChat: megaChat,
              multiple: multiple,
              multipleSelectedButtonLabel: multipleSelectedButtonLabel,
              nothingSelectedButtonLabel: nothingSelectedButtonLabel,
              selectFooter: selectFooter,
              singleSelectedButtonLabel: singleSelectedButtonLabel,
              onClose: onClose,
              onSelectDone: onSelectDone
            })
          );
        }
      }

      /***/
    },

    /***/ 808: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, {
        default: () => ContactsPanel
      });

      // EXTERNAL MODULE: external "React"
      var external_React_ = __webpack_require__(363);
      var external_React_default = __webpack_require__.n(external_React_);
      // EXTERNAL MODULE: ./js/chat/mixins.js
      var mixins = __webpack_require__(503);
      // EXTERNAL MODULE: ./js/ui/buttons.jsx
      var buttons = __webpack_require__(204); // CONCATENATED MODULE: ./js/chat/ui/contactsPanel/navigation.jsx
      class Navigation extends mixins.wl {
        render() {
          const { view } = this.props;
          const { receivedRequestsCount } = this.props;
          const { VIEW, LABEL } = ContactsPanel;
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            external_React_default().createElement(
              "div",
              {
                className: "contacts-navigation"
              },
              external_React_default().createElement(
                "ul",
                null,
                Object.keys(VIEW).map((key) => {
                  let activeClass = view === VIEW[key] ? "active" : "";
                  if (view === VIEW.PROFILE && VIEW[key] === VIEW.CONTACTS) {
                    activeClass = "active";
                  }
                  if (VIEW[key] !== VIEW.PROFILE) {
                    return external_React_default().createElement(
                      "li",
                      {
                        key: key,
                        onClick: () => {
                          let page = key.toLowerCase().split("_")[0];
                          page = page === "contacts" ? "" : page;
                          loadSubPage(`fm/chat/contacts/${page}`);
                        }
                      },
                      external_React_default().createElement(
                        buttons.z,
                        {
                          className: `
                                                mega-button
                                                action
                                                ${activeClass}
                                            `,
                          receivedRequestsCount: receivedRequestsCount
                        },
                        external_React_default().createElement("span", null, LABEL[key]),
                        receivedRequestsCount > 0 &&
                          VIEW[key] === VIEW.RECEIVED_REQUESTS &&
                          external_React_default().createElement(
                            "div",
                            {
                              className: "notifications-count"
                            },
                            receivedRequestsCount > 9 ? "9+" : receivedRequestsCount
                          )
                      )
                    );
                  }
                  return null;
                })
              )
            )
          );
        }
      }
      // EXTERNAL MODULE: ./js/ui/utils.jsx
      var utils = __webpack_require__(79); // CONCATENATED MODULE: ./js/chat/ui/contactsPanel/nil.jsx
      class Nil extends mixins.wl {
        componentDidMount() {
          super.componentDidMount();
          setContactLink();
        }
        render() {
          const { title } = this.props;
          return external_React_default().createElement(
            "div",
            {
              className: "fm-empty-section fm-empty-contacts"
            },
            external_React_default().createElement(
              "div",
              {
                className: "fm-empty-pad"
              },
              external_React_default().createElement("i", {
                className: "section-icon sprite-fm-mono icon-contacts"
              }),
              external_React_default().createElement(
                "div",
                {
                  className: "fm-empty-cloud-txt"
                },
                title
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "fm-empty-description"
                },
                l[19115]
              ),
              external_React_default().createElement(
                buttons.z,
                {
                  className: "mega-button positive large fm-empty-button",
                  onClick: () => contactAddDialog()
                },
                external_React_default().createElement("span", null, l[71])
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "empty-share-public"
                },
                external_React_default().createElement("i", {
                  className: "sprite-fm-mono icon-link-circle"
                }),
                external_React_default().createElement(utils.Cw, null, l[19111])
              )
            )
          );
        }
      }
      // EXTERNAL MODULE: ./js/ui/jsx/fm/fmView.jsx + 10 modules
      var fmView = __webpack_require__(309);
      // EXTERNAL MODULE: ./js/chat/ui/contacts.jsx
      var contacts = __webpack_require__(13);
      // EXTERNAL MODULE: ./js/ui/jsx/fm/nodes/genericNodePropsComponent.jsx + 1 modules
      var genericNodePropsComponent = __webpack_require__(297); // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnContactName.jsx
      class ColumnContactName extends genericNodePropsComponent.L {
        constructor(...args) {
          super(...args);
          this.Mail = (0, utils.pQ)(() =>
            external_React_default().createElement(
              "span",
              {
                className: "contact-item-email"
              },
              this.props.nodeAdapter.props.node.m
            )
          );
        }
        render() {
          const { nodeAdapter } = this.props;
          const { node } = nodeAdapter.props;
          return external_React_default().createElement(
            "td",
            null,
            external_React_default().createElement(contacts.Avatar, {
              contact: node,
              className: "avatar-wrapper box-avatar"
            }),
            external_React_default().createElement(
              "div",
              {
                className: "contact-item"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "contact-item-user"
                },
                external_React_default().createElement(utils.a0, null, nodeAdapter.nodeProps.title)
              ),
              external_React_default().createElement(this.Mail, null)
            ),
            external_React_default().createElement("div", {
              className: "clear"
            })
          );
        }
      }
      ColumnContactName.sortable = true;
      ColumnContactName.id = "name";
      ColumnContactName.label = l[86];
      ColumnContactName.megatype = "name"; // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnContactStatus.jsx
      class ColumnContactStatus extends genericNodePropsComponent.L {
        render() {
          let { nodeAdapter } = this.props;
          let onlineStatus = nodeAdapter.nodeProps.onlineStatus;
          return external_React_default().createElement(
            "td",
            {
              megatype: ColumnContactStatus.megatype,
              className: ColumnContactStatus.megatype
            },
            external_React_default().createElement(
              "div",
              {
                className: "contact-item"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "contact-item-status"
                },
                external_React_default().createElement("div", {
                  className: "user-card-presence " + onlineStatus[1]
                }),
                onlineStatus[0]
              )
            )
          );
        }
      }
      ColumnContactStatus.sortable = true;
      ColumnContactStatus.id = "status";
      ColumnContactStatus.label = l[89];
      ColumnContactStatus.megatype = "status"; // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnContactLastInteraction.jsx
      class ColumnContactLastInteraction extends genericNodePropsComponent.L {
        constructor(...args) {
          super(...args);
          this.getLastInteractionIcon = (handle) => {
            const { interactions } = this.props;
            const interaction = interactions[handle];
            const { type, time } = interaction || {
              type: undefined,
              time: undefined
            };
            return external_React_default().createElement("i", {
              className: `
                    sprite-fm-mono
                    ${parseInt(type, 10) === 0 ? "icon-cloud" : ""}
                    ${parseInt(type, 10) === 1 ? "icon-chat" : ""}
                    ${!time ? "icon-minimise" : ""}
                `
            });
          };
          this.getLastInteractionTime = (handle) => {
            const { interactions } = this.props;
            const interaction = interactions[handle];
            return interaction ? time2last(interaction.time) : l[1051];
          };
        }
        render() {
          let { nodeAdapter } = this.props;
          let { node } = nodeAdapter.props;
          return external_React_default().createElement(
            "td",
            {
              megatype: ColumnContactLastInteraction.megatype,
              className: ColumnContactLastInteraction.megatype
            },
            external_React_default().createElement(
              "div",
              {
                className: "contact-item"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "contact-item-time"
                },
                this.getLastInteractionIcon(node.h),
                this.getLastInteractionTime(node.h)
              )
            )
          );
        }
      }
      ColumnContactLastInteraction.sortable = true;
      ColumnContactLastInteraction.id = "interaction";
      ColumnContactLastInteraction.label = l[5904];
      ColumnContactLastInteraction.megatype = "interaction"; // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnContactVerifiedStatus.jsx
      class ColumnContactVerifiedStatus extends genericNodePropsComponent.L {
        constructor(...args) {
          super(...args);
          this.getFingerPrintDialogLink = (handle) => {
            const onVerifyContactClicked = (handle) => {
              ContactsPanel.verifyCredentials(this.props.contacts[handle]);
            };
            return external_React_default().createElement(
              "div",
              {
                className: "verify-contact-link-container"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "verify-contact-link",
                  onClick: () => onVerifyContactClicked(handle)
                },
                l.verify_credentials
              )
            );
          };
        }
        render() {
          const { nodeAdapter } = this.props;
          const { node } = nodeAdapter.props;
          return external_React_default().createElement(
            "td",
            {
              megatype: ColumnContactVerifiedStatus.megatype,
              className: ColumnContactVerifiedStatus.megatype
            },
            external_React_default().createElement(
              "div",
              {
                className: "contact-item"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "contact-item-verification"
                },
                ContactsPanel.isVerified(this.props.contacts[node.h])
                  ? ColumnContactVerifiedStatus.verifiedLabel
                  : this.getFingerPrintDialogLink(node.h)
              )
            )
          );
        }
      }
      ColumnContactVerifiedStatus.sortable = true;
      ColumnContactVerifiedStatus.id = "verification";
      ColumnContactVerifiedStatus.megatype = "verification";
      ColumnContactVerifiedStatus.label = external_React_default().createElement(
        external_React_default().Fragment,
        null,
        l.contact_ver_verification,
        external_React_default().createElement("i", {
          className: "simpletip sprite-fm-mono contacts-verification-icon icon-info",
          "data-simpletip": l.contact_ver_tooltip_content,
          "data-simpletip-class": "contacts-verification-icon-simpletip"
        })
      );
      ColumnContactVerifiedStatus.verifiedLabel = external_React_default().createElement(
        "div",
        {
          className: "verified-contact-label-container"
        },
        external_React_default().createElement("i", {
          className: "small-icon icons-sprite tiny-green-tick"
        }),
        l[6776]
      );
      // EXTERNAL MODULE: ./js/ui/dropdowns.jsx
      var dropdowns = __webpack_require__(78);
      // EXTERNAL MODULE: ./js/chat/ui/meetings/call.jsx + 23 modules
      var call = __webpack_require__(689); // CONCATENATED MODULE: ./js/chat/ui/contactsPanel/contextMenu.jsx
      class ContextMenu extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.EVENT_CLOSE = new Event("closeDropdowns");
          this.close = (callback) => {
            if (callback && typeof callback === "function" && !M.isInvalidUserStatus()) {
              callback();
            }
            document.dispatchEvent(this.EVENT_CLOSE);
          };
          this.handleSetNickname = (handle) => this.close(() => nicknames.setNicknameDialog.init(handle));
          this.handleAddContact = (handle) => {
            M.syncContactEmail(handle, true)
              .then((email) => {
                const OPC = Object.values(M.opc);
                const ALREADY_SENT = OPC && OPC.length && OPC.some((opc) => opc.m === email);
                this.close(() => {
                  if (ALREADY_SENT) {
                    return msgDialog("warningb", "", l[17545]);
                  }
                  msgDialog("info", l[150], l[5898]);
                  M.inviteContact(M.u[u_handle].m, email);
                });
              })
              .catch(nop);
          };
        }
        render() {
          const { contact, selected, withProfile } = this.props;
          if (ContactsPanel.hasRelationship(contact)) {
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              withProfile &&
                external_React_default().createElement(
                  "div",
                  {
                    className: "dropdown-avatar rounded",
                    onClick: (e) => {
                      e.stopPropagation();
                      loadSubPage(`fm/chat/contacts/${contact.h}`);
                    }
                  },
                  external_React_default().createElement(contacts.Avatar, {
                    contact: contact,
                    className: "avatar-wrapper context-avatar"
                  }),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "dropdown-profile"
                    },
                    external_React_default().createElement(
                      "span",
                      null,
                      external_React_default().createElement(utils.dy, null, M.getNameByHandle(contact.u))
                    ),
                    external_React_default().createElement(contacts.ContactPresence, {
                      contact: contact
                    })
                  )
                ),
              external_React_default().createElement(dropdowns.DropdownItem, {
                icon: "sprite-fm-mono icon-chat",
                label: l[8632],
                onClick: () =>
                  this.close(() => {
                    if (selected && selected.length) {
                      return megaChat.createAndShowGroupRoomFor(selected, "", {
                        keyRotation: true,
                        createChatLink: false
                      });
                    }
                    return loadSubPage(`fm/chat/p/${contact.u}`);
                  })
              }),
              external_React_default().createElement(dropdowns.DropdownItem, {
                icon: "sprite-fm-mono icon-send-files",
                label: l[6834],
                onClick: () => this.close(() => megaChat.openChatAndSendFilesDialog(contact.u))
              }),
              external_React_default().createElement(dropdowns.DropdownItem, {
                icon: "sprite-fm-mono icon-folder-outgoing-share",
                label: l[5631],
                onClick: () => this.close(() => openCopyShareDialog(contact.u))
              }),
              external_React_default().createElement(
                "div",
                {
                  "data-simpletipposition": "top",
                  className: "simpletip",
                  "data-simpletip": !megaChat.hasSupportForCalls ? l.call_not_suported : ""
                },
                external_React_default().createElement(dropdowns.DropdownItem, {
                  submenu: megaChat.hasSupportForCalls,
                  disabled: !navigator.onLine || !megaChat.hasSupportForCalls,
                  icon: "sprite-fm-mono icon-phone",
                  className: "sprite-fm-mono-before icon-arrow-right-before",
                  label: l[19125]
                }),
                external_React_default().createElement(
                  "div",
                  {
                    className: "dropdown body submenu"
                  },
                  external_React_default().createElement(dropdowns.DropdownItem, {
                    icon: "sprite-fm-mono icon-phone",
                    disabled: !navigator.onLine || !megaChat.hasSupportForCalls,
                    label: l[5896],
                    onClick: () =>
                      (0, call.xt)()
                        .then(() =>
                          this.close(() =>
                            megaChat.createAndShowPrivateRoom(contact.u).then((room) => {
                              room.setActive();
                              room.startAudioCall();
                            })
                          )
                        )
                        .catch(() => d && console.warn("Already in a call."))
                  }),
                  external_React_default().createElement(dropdowns.DropdownItem, {
                    icon: "sprite-fm-mono icon-video-call-filled",
                    disabled: !navigator.onLine || !megaChat.hasSupportForCalls,
                    label: l[5897],
                    onClick: () =>
                      (0, call.xt)()
                        .then(() =>
                          this.close(() =>
                            megaChat.createAndShowPrivateRoom(contact.u).then((room) => {
                              room.setActive();
                              room.startVideoCall();
                            })
                          )
                        )
                        .catch(() => d && console.warn("Already in a call."))
                  })
                )
              ),
              external_React_default().createElement("hr", null),
              withProfile &&
                external_React_default().createElement(dropdowns.DropdownItem, {
                  icon: "sprite-fm-mono icon-my-account",
                  label: l[5868],
                  onClick: () => loadSubPage(`fm/chat/contacts/${contact.u}`)
                }),
              external_React_default().createElement(dropdowns.DropdownItem, {
                icon: "sprite-fm-mono icon-rename",
                label: contact.nickname === "" ? l.set_nickname_label : l.edit_nickname_label,
                onClick: () => this.handleSetNickname(contact.u)
              }),
              external_React_default().createElement("hr", null),
              external_React_default().createElement(dropdowns.DropdownItem, {
                submenu: true,
                icon: "sprite-fm-mono icon-key",
                className: "sprite-fm-mono-before icon-arrow-right-before",
                label: l[6872]
              }),
              external_React_default().createElement(
                "div",
                {
                  className: "dropdown body white-context-menu submenu"
                },
                ContactsPanel.isVerified(contact)
                  ? external_React_default().createElement(dropdowns.DropdownItem, {
                      label: l[742],
                      onClick: () => this.close(() => ContactsPanel.resetCredentials(contact))
                    })
                  : external_React_default().createElement(dropdowns.DropdownItem, {
                      label: l[1960],
                      onClick: () => this.close(() => ContactsPanel.verifyCredentials(contact))
                    })
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "dropdown-credentials"
                },
                ContactsPanel.getUserFingerprint(contact.u)
              ),
              external_React_default().createElement("hr", null),
              external_React_default().createElement(dropdowns.DropdownItem, {
                icon: "sprite-fm-mono icon-disable",
                label: l[1001],
                disabled: !!contact.b,
                className: "",
                onClick: () => this.close(() => fmremove(contact.u))
              })
            );
          }
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            external_React_default().createElement(dropdowns.DropdownItem, {
              icon: "sprite-fm-mono icon-disabled-filled",
              label: l[71],
              onClick: () => this.handleAddContact(contact.u)
            }),
            external_React_default().createElement(dropdowns.DropdownItem, {
              icon: "sprite-fm-mono icon-rename",
              label: contact.nickname === "" ? l.set_nickname_label : l.edit_nickname_label,
              onClick: () => this.handleSetNickname(contact.u)
            })
          );
        }
      } // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnContactButtons.jsx
      class ColumnContactButtons extends genericNodePropsComponent.L {
        render() {
          const { nodeAdapter } = this.props;
          const { node, selected } = nodeAdapter.props;
          const handle = node.h;
          return external_React_default().createElement(
            "td",
            {
              megatype: ColumnContactButtons.megatype,
              className: ColumnContactButtons.megatype
            },
            external_React_default().createElement(
              "div",
              {
                className: "contact-item"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "contact-item-controls"
                },
                external_React_default().createElement(buttons.z, {
                  className: "mega-button action simpletip",
                  icon: "sprite-fm-mono icon-phone",
                  attrs: {
                    "data-simpletip": !megaChat.hasSupportForCalls ? l.unsupported_browser_audio : l[5896]
                  },
                  disabled: !navigator.onLine || !megaChat.hasSupportForCalls,
                  onClick: () =>
                    (0, call.xt)()
                      .then(() =>
                        megaChat.createAndShowPrivateRoom(handle).then((room) => {
                          room.setActive();
                          room.startAudioCall();
                        })
                      )
                      .catch(() => d && console.warn("Already in a call."))
                }),
                external_React_default().createElement(buttons.z, {
                  className: "mega-button action simpletip",
                  icon: "sprite-fm-mono icon-chat",
                  attrs: {
                    "data-simpletip": l[8632]
                  },
                  onClick: () => loadSubPage("fm/chat/p/" + handle)
                }),
                external_React_default().createElement(buttons.z, {
                  className: "mega-button action simpletip",
                  icon: "sprite-fm-mono icon-send-files",
                  attrs: {
                    "data-simpletip": l[6834]
                  },
                  onClick: () => megaChat.openChatAndSendFilesDialog(handle)
                }),
                external_React_default().createElement(
                  buttons.z,
                  {
                    ref: (node) => {
                      this.props.onContextMenuRef(handle, node);
                    },
                    className: "mega-button action contact-more",
                    icon: "sprite-fm-mono icon-options"
                  },
                  external_React_default().createElement(
                    dropdowns.Dropdown,
                    {
                      className: "context",
                      noArrow: true,
                      positionMy: "left bottom",
                      positionAt: "right bottom",
                      positionLeft: this.props.contextMenuPosition || null,
                      horizOffset: 4,
                      onActiveChange: (opened) => {
                        this.props.onActiveChange(opened);
                      }
                    },
                    external_React_default().createElement(ContextMenu, {
                      contact: node,
                      selected: selected,
                      withProfile: true
                    })
                  )
                )
              )
            )
          );
        }
      }
      ColumnContactButtons.sortable = false;
      ColumnContactButtons.id = "grid-url-header-nw";
      ColumnContactButtons.label = "";
      ColumnContactButtons.megatype = "grid-url-header-nw"; // CONCATENATED MODULE: ./js/chat/ui/contactsPanel/contactList.jsx
      class ContactList extends mixins.wl {
        constructor(props) {
          super(props);
          this.contextMenuRefs = [];
          this.state = {
            selected: [],
            searchValue: null,
            interactions: {},
            contextMenuPosition: null
          };
          this.onSelected = this.onSelected.bind(this);
          this.onHighlighted = this.onHighlighted.bind(this);
          this.onExpand = this.onExpand.bind(this);
          this.onAttachClicked = this.onAttachClicked.bind(this);
        }
        getLastInteractions() {
          const { contacts } = this.props;
          const promises = [];
          const push = (handle) => {
            promises.push(Promise.resolve(getLastInteractionWith(handle, true, true)).then((ts) => [ts, handle]));
          };
          for (const handle in contacts) {
            if (contacts[handle].c === 1) {
              push(handle);
            }
          }
          Promise.allSettled(promises)
            .then((res) => {
              if (this.isMounted()) {
                const interactions = {};
                for (let i = res.length; i--; ) {
                  if (res[i].status !== "fulfilled") {
                    if (d && res[i].reason !== false) {
                      console.warn("getLastInteractions", res[i].reason);
                    }
                  } else {
                    const [ts, u] = res[i].value;
                    const [type, time] = ts.split(":");
                    interactions[u] = {
                      u,
                      type,
                      time
                    };
                  }
                }
                this.setState({
                  interactions: interactions
                });
              }
            })
            .catch((ex) => {
              console.error("Failed to handle last interactions!", ex);
            });
        }
        handleContextMenu(ev, handle) {
          ev.persist();
          if (this.state.selected.length > 1) {
            return null;
          }
          const $$REF = this.contextMenuRefs[handle];
          if ($$REF && $$REF.isMounted()) {
            const refNodePosition = $$REF.domNode && $$REF.domNode.getBoundingClientRect().x;
            this.setState(
              {
                contextMenuPosition: ev.clientX > refNodePosition ? null : ev.clientX
              },
              () => $$REF.onClick(ev)
            );
          }
        }
        componentDidMount() {
          super.componentDidMount();
          this.getLastInteractions();
        }
        onSelected(handle) {
          this.setState({
            selected: handle
          });
        }
        onHighlighted(handle) {
          this.setState({
            highlighted: handle
          });
        }
        onExpand(handle) {
          loadSubPage("/fm/chat/contacts/" + handle);
        }
        onAttachClicked() {
          if (this.state.selected[0]) {
            this.onExpand(this.state.selected[0]);
          }
        }
        render() {
          const { contacts } = this.props;
          if (contacts && contacts.length > 1) {
            return external_React_default().createElement(
              "div",
              {
                className: "contacts-list"
              },
              external_React_default().createElement(fmView.Z, {
                dataSource: this.props.contacts,
                customFilterFn: (r) => {
                  return r.c === 1;
                },
                currentlyViewedEntry: "contacts",
                onSelected: this.onSelected,
                onHighlighted: this.onHighlighted,
                searchValue: this.state.searchValue,
                onExpand: this.onExpand,
                onAttachClicked: this.onAttachClicked,
                viewMode: 0,
                currentdirid: "contacts",
                megaListItemHeight: 59,
                headerContainerClassName: "contacts-table contacts-table-head",
                containerClassName: "contacts-table contacts-table-results",
                onContextMenu: (ev, handle) => this.handleContextMenu(ev, handle),
                listAdapterColumns: [
                  ColumnContactName,
                  ColumnContactStatus,
                  [
                    ColumnContactLastInteraction,
                    {
                      interactions: this.state.interactions
                    }
                  ],
                  [
                    ColumnContactVerifiedStatus,
                    {
                      contacts: this.props.contacts
                    }
                  ],
                  [
                    ColumnContactButtons,
                    {
                      onContextMenuRef: (handle, node) => {
                        this.contextMenuRefs[handle] = node;
                      },
                      onActiveChange: (opened) => {
                        if (!opened) {
                          this.setState({
                            contextMenuPosition: null
                          });
                        }
                      },
                      contextMenuPosition: this.state.contextMenuPosition
                    }
                  ]
                ],
                initialSortBy: ["status", "asc"],
                fmConfigSortEnabled: true,
                fmConfigSortId: "contacts",
                NilComponent: external_React_default().createElement(Nil, {
                  title: l[5737]
                })
              })
            );
          }
          return external_React_default().createElement(Nil, {
            title: l[5737]
          });
        }
      } // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnContactRequestsEmail.jsx
      class ColumnContactRequestsEmail extends mixins.wl {
        render() {
          const { nodeAdapter, currView } = this.props;
          let { node } = nodeAdapter.props;
          return external_React_default().createElement(
            "td",
            null,
            currView && currView === "opc"
              ? external_React_default().createElement(
                  "span",
                  null,
                  external_React_default().createElement("i", {
                    className: "sprite-fm-uni icon-send-requests"
                  })
                )
              : external_React_default().createElement(utils.Cw, null, useravatar.contact(node.m, "box-avatar")),
            external_React_default().createElement(
              "div",
              {
                className: "contact-item"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "contact-item-user"
                },
                node.m
              )
            ),
            external_React_default().createElement("div", {
              className: "clear"
            })
          );
        }
      }
      ColumnContactRequestsEmail.sortable = true;
      ColumnContactRequestsEmail.id = "email";
      ColumnContactRequestsEmail.label = l[95];
      ColumnContactRequestsEmail.megatype = "email"; // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnContactRequestsTs.jsx
      class ColumnContactRequestsTs extends mixins.wl {
        render() {
          let { nodeAdapter } = this.props;
          let { node } = nodeAdapter.props;
          let timestamp = node.rts || node.ts;
          if (timestamp) {
            timestamp = time2last(timestamp);
          } else {
            timestamp = node.dts ? l[6112] : "";
          }
          return external_React_default().createElement(
            "td",
            null,
            external_React_default().createElement(
              "div",
              {
                className: "contact-item"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "contact-item-time"
                },
                timestamp
              )
            ),
            external_React_default().createElement("div", {
              className: "clear"
            })
          );
        }
      }
      ColumnContactRequestsTs.sortable = true;
      ColumnContactRequestsTs.id = "ts";
      ColumnContactRequestsTs.label = l[19506];
      ColumnContactRequestsTs.megatype = "ts"; // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnContactRequestsRcvdBtns.jsx
      class ColumnContactRequestsRcvdBtns extends mixins.wl {
        render() {
          let { nodeAdapter } = this.props;
          let { node } = nodeAdapter.props;
          return external_React_default().createElement(
            "td",
            {
              megatype: ColumnContactRequestsRcvdBtns.megatype,
              className: ColumnContactRequestsRcvdBtns.megatype
            },
            external_React_default().createElement(
              "div",
              {
                className: "contact-item-controls"
              },
              external_React_default().createElement(buttons.z, {
                className: "mega-button action contact-reject",
                icon: "sprite-fm-mono icon-close-component",
                label: l[20981],
                onClick: () => this.props.onReject(node.p)
              }),
              external_React_default().createElement(buttons.z, {
                className: "mega-button action contact-block",
                icon: "sprite-fm-mono icon-disable",
                label: l[20980],
                onClick: () => this.props.onBlock(node.p)
              }),
              external_React_default().createElement(buttons.z, {
                className: "mega-button action contact-accept",
                icon: "sprite-fm-mono icon-check",
                label: l[5856],
                onClick: () => this.props.onAccept(node.p)
              })
            )
          );
        }
      }
      ColumnContactRequestsRcvdBtns.sortable = true;
      ColumnContactRequestsRcvdBtns.id = "grid-url-header-nw";
      ColumnContactRequestsRcvdBtns.label = "";
      ColumnContactRequestsRcvdBtns.megatype = "grid-url-header-nw contact-controls-container"; // CONCATENATED MODULE: ./js/chat/ui/contactsPanel/receivedRequests.jsx
      class ReceivedRequests extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.drawReceivedRequests = () => {
            const { received } = this.props;
            return external_React_default().createElement(fmView.Z, {
              sortFoldersFirst: false,
              dataSource: received,
              customFilterFn: (r) => {
                return !r.dts;
              },
              currentlyViewedEntry: "ipc",
              onSelected: nop,
              onHighlighted: nop,
              onExpand: nop,
              onAttachClicked: nop,
              viewMode: 0,
              currentdirid: "ipc",
              megaListItemHeight: 59,
              headerContainerClassName: "contacts-table requests-table contacts-table-head",
              containerClassName: "contacts-table requests-table contacts-table-results",
              listAdapterColumns: [
                [
                  ColumnContactRequestsEmail,
                  {
                    currView: "ipc"
                  }
                ],
                [
                  ColumnContactRequestsTs,
                  {
                    label: l[19505]
                  }
                ],
                [
                  ColumnContactRequestsRcvdBtns,
                  {
                    onReject: (handle) => {
                      M.denyPendingContactRequest(handle);
                    },
                    onBlock: (handle) => {
                      M.ignorePendingContactRequest(handle);
                    },
                    onAccept: (handle) => {
                      M.acceptPendingContactRequest(handle);
                    }
                  }
                ]
              ],
              keyProp: "p",
              nodeAdapterProps: {
                className: (node) => {
                  return `
                        ${node.dts || (node.s && node.s === 3) ? "deleted" : ""}
                        ${node.s && node.s === 1 ? "ignored" : ""}
                    `;
                }
              },
              NilComponent: () => {
                return external_React_default().createElement(Nil, {
                  title: l[6196]
                });
              },
              initialSortBy: ["email", "asc"],
              fmConfigSortEnabled: true,
              fmConfigSortId: "ipc"
            });
          };
        }
        render() {
          return external_React_default().createElement(
            "div",
            {
              className: "contacts-list"
            },
            this.drawReceivedRequests()
          );
        }
      } // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnContactRequestsSentBtns.jsx
      class ColumnContactRequestsSentBtns extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.reinviteAllowed = (rts) => {
            const UTC_DATE_NOW = Math.floor(Date.now() / 1000);
            return UTC_DATE_NOW > rts + 1209600;
          };
        }
        render() {
          let { nodeAdapter } = this.props;
          let { node } = nodeAdapter.props;
          return external_React_default().createElement(
            "td",
            {
              megatype: ColumnContactRequestsSentBtns.megatype,
              className: ColumnContactRequestsSentBtns.megatype
            },
            external_React_default().createElement(
              "div",
              {
                className: "contact-item-controls contact-request-sent"
              },
              !node.dts &&
                this.reinviteAllowed(node.rts) &&
                external_React_default().createElement(buttons.z, {
                  className: "mega-button action",
                  icon: "sprite-fm-mono icon-rewind",
                  label: l[5861],
                  onClick: () => this.props.onReinvite(node.m)
                }),
              !node.dts &&
                external_React_default().createElement(buttons.z, {
                  className: "mega-button action contact-reject",
                  icon: "sprite-fm-mono icon-close-component",
                  label: l[82],
                  onClick: () => this.props.onReject(node.m)
                })
            )
          );
        }
      }
      ColumnContactRequestsSentBtns.sortable = true;
      ColumnContactRequestsSentBtns.id = "grid-url-header-nw";
      ColumnContactRequestsSentBtns.label = "";
      ColumnContactRequestsSentBtns.megatype = "grid-url-header-nw contact-controls-container"; // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnContactRequestsRts.jsx
      class ColumnContactRequestsRts extends ColumnContactRequestsTs {}
      ColumnContactRequestsRts.sortable = true;
      ColumnContactRequestsRts.id = "rts";
      ColumnContactRequestsRts.label = l[19506];
      ColumnContactRequestsRts.megatype = "rts"; // CONCATENATED MODULE: ./js/chat/ui/contactsPanel/sentRequests.jsx
      class SentRequests extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.handleReinvite = (mail) => {
            this.setState(
              {
                reinvited: true
              },
              () => {
                M.reinvitePendingContactRequest(mail)
                  .then(() => {
                    contactsInfoDialog(l[19126], mail, l[19127]);
                  })
                  .catch(tell);
              }
            );
          };
          this.drawSentRequests = () => {
            const { sent } = this.props;
            return external_React_default().createElement(fmView.Z, {
              sortFoldersFirst: false,
              dataSource: sent,
              currentlyViewedEntry: "opc",
              onSelected: nop,
              onHighlighted: nop,
              onExpand: nop,
              onAttachClicked: nop,
              viewMode: 0,
              currentdirid: "opc",
              megaListItemHeight: 59,
              headerContainerClassName: "contacts-table requests-table contacts-table-head",
              containerClassName: "contacts-table requests-table contacts-table-results",
              listAdapterColumns: [
                [
                  ColumnContactRequestsEmail,
                  {
                    currView: "opc"
                  }
                ],
                ColumnContactRequestsRts,
                [
                  ColumnContactRequestsSentBtns,
                  {
                    onReject: (email) => {
                      M.cancelPendingContactRequest(email).catch((ex) => {
                        if (ex === EARGS) {
                          msgDialog("info", "", "This pending contact is already deleted.");
                        } else {
                          tell(ex);
                        }
                      });
                    },
                    onReinvite: (email) => {
                      this.handleReinvite(email);
                    }
                  }
                ]
              ],
              NilComponent: () => {
                return external_React_default().createElement(Nil, {
                  title: l[6196]
                });
              },
              listAdapterOpts: {
                className: (node) => node.dts && " disabled"
              },
              keyProp: "p",
              initialSortBy: ["email", "asc"],
              fmConfigSortEnabled: true,
              fmConfigSortMap: {
                rts: "rTimeStamp"
              },
              fmConfigSortId: "opc"
            });
          };
        }
        render() {
          return external_React_default().createElement(
            "div",
            {
              className: "contacts-list"
            },
            this.drawSentRequests()
          );
        }
      }
      // EXTERNAL MODULE: ./js/ui/jsx/fm/nodes/columns/columnFavIcon.jsx
      var columnFavIcon = __webpack_require__(310); // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnSharedFolderName.jsx
      class ColumnSharedFolderName extends genericNodePropsComponent.L {
        render() {
          let { nodeAdapter } = this.props;
          let { node } = nodeAdapter.props;
          return external_React_default().createElement(
            "td",
            {
              megatype: ColumnSharedFolderName.megatype,
              className: ColumnSharedFolderName.megatype
            },
            external_React_default().createElement("div", {
              className: "shared-folder-icon sprite-fm-uni-after icon-warning-after"
            }),
            external_React_default().createElement(
              "div",
              {
                className: "shared-folder-info-block"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "shared-folder-name"
                },
                missingkeys[node.h] ? l[8686] : nodeAdapter.nodeProps.title
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "shared-folder-info"
                },
                fm_contains(node.tf, node.td)
              )
            )
          );
        }
      }
      ColumnSharedFolderName.sortable = true;
      ColumnSharedFolderName.id = "name";
      ColumnSharedFolderName.label = l[86];
      ColumnSharedFolderName.megatype = "name"; // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnSharedFolderAccess.jsx
      class ColumnSharedFolderAccess extends genericNodePropsComponent.L {
        render() {
          const { nodeAdapter } = this.props;
          return external_React_default().createElement(
            "td",
            {
              megatype: ColumnSharedFolderAccess.megatype,
              className: ColumnSharedFolderAccess.megatype
            },
            external_React_default().createElement(
              "div",
              {
                className: "shared-folder-access"
              },
              external_React_default().createElement("i", {
                className: `
                            sprite-fm-mono
                            ${nodeAdapter.nodeProps.incomingShareData.accessIcon}
                        `
              }),
              external_React_default().createElement("span", null, nodeAdapter.nodeProps.incomingShareData.accessLabel)
            )
          );
        }
      }
      ColumnSharedFolderAccess.sortable = true;
      ColumnSharedFolderAccess.id = "access";
      ColumnSharedFolderAccess.label = l[5906];
      ColumnSharedFolderAccess.megatype = "access"; // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnSharedFolderButtons.jsx
      class ColumnSharedFolderButtons extends genericNodePropsComponent.L {
        render() {
          let { nodeAdapter } = this.props;
          let { node } = nodeAdapter.props;
          let handle = node.h;
          return external_React_default().createElement(
            "td",
            {
              megatype: ColumnSharedFolderButtons.megatype,
              className: ColumnSharedFolderButtons.megatype
            },
            external_React_default().createElement(
              "div",
              {
                className: "contact-item"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "contact-item-controls"
                },
                external_React_default().createElement(buttons.z, {
                  className: "mega-button action contact-more",
                  icon: "sprite-fm-mono icon-options",
                  onClick: (button, e) => {
                    e.persist();
                    $.selected = [handle];
                    $.gridLastSelected = handle;
                    e.preventDefault();
                    e.stopPropagation();
                    e.delegateTarget = $(e.target).parents("td")[0];
                    e.currentTarget = $(e.target).parents("tr");
                    if (!$(e.target).hasClass("active")) {
                      M.contextMenuUI(e, 1);
                      $(this).addClass("active");
                    } else {
                      $.hideContextMenu();
                      $(e.target).removeClass("active");
                    }
                  }
                })
              )
            )
          );
        }
      }
      ColumnSharedFolderButtons.sortable = true;
      ColumnSharedFolderButtons.id = "grid-url-header-nw";
      ColumnSharedFolderButtons.label = "";
      ColumnSharedFolderButtons.megatype = "grid-url-header-nw";
      // EXTERNAL MODULE: ./js/chat/ui/link.jsx
      var ui_link = __webpack_require__(941); // CONCATENATED MODULE: ./js/chat/ui/contactsPanel/contactProfile.jsx
      class ContactProfile extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.state = {
            selected: [],
            loading: true
          };
          this.onAttachClicked = () => {
            const { selected } = this.state;
            if (selected[0]) {
              this.onExpand(selected[0]);
            }
          };
          this.onExpand = (handle) => loadSubPage(`fm/${handle}`);
          this.Breadcrumb = () => {
            const { handle } = this.props;
            return external_React_default().createElement(
              "div",
              {
                className: "profile-breadcrumb"
              },
              external_React_default().createElement(
                "ul",
                null,
                external_React_default().createElement(
                  "li",
                  null,
                  external_React_default().createElement(
                    ui_link.Z,
                    {
                      to: "/fm/chat/contacts"
                    },
                    ContactsPanel.LABEL.CONTACTS
                  ),
                  external_React_default().createElement("i", {
                    className: "sprite-fm-mono icon-arrow-right"
                  })
                ),
                external_React_default().createElement(
                  "li",
                  null,
                  external_React_default().createElement(utils.dy, null, M.getNameByHandle(handle))
                )
              )
            );
          };
          this.Credentials = () => {
            const { handle } = this.props;
            const contact = M.u[handle];
            if (handle && contact && contact.c === 1) {
              const IS_VERIFIED = ContactsPanel.isVerified(contact);
              return external_React_default().createElement(
                "div",
                {
                  className: "profile-credentials"
                },
                external_React_default().createElement(
                  "span",
                  {
                    className: "credentials-head"
                  },
                  l[6872]
                ),
                external_React_default().createElement(
                  "div",
                  {
                    className: "credentials-fingerprints"
                  },
                  ContactsPanel.getUserFingerprint(handle)
                ),
                external_React_default().createElement(
                  "button",
                  {
                    className: `
                            mega-button
                            small
                            ${IS_VERIFIED ? "" : "positive"}
                        `,
                    onClick: () => ContactsPanel[IS_VERIFIED ? "resetCredentials" : "verifyCredentials"](contact)
                  },
                  IS_VERIFIED ? l[742] : l.verify_credentials
                )
              );
            }
            return null;
          };
          this.handleContextMenu = (e, handle) => {
            e.persist();
            e.preventDefault();
            e.stopPropagation();
            e.delegateTarget = e.target.tagName === "TR" ? e.target : $(e.target).parents("tr")[0];
            e.currentTarget = $(e.delegateTarget);
            $.selected = [handle];
            M.contextMenuUI(e, 1);
          };
        }
        componentWillMount() {
          if (super.componentWillMount) {
            super.componentWillMount();
          }
          const { handle } = this.props;
          if (handle) {
            const contact = M.u[handle];
            if (contact) {
              this._listener = contact.addChangeListener(() => {
                if (contact && contact.c === 1) {
                  this.safeForceUpdate();
                } else {
                  loadSubPage("/fm/chat/contacts");
                  return 0xdead;
                }
              });
            }
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          if (this._listener) {
            const { handle } = this.props;
            const contact = M.u[handle];
            contact.removeChangeListener(this._listener);
          }
        }
        componentDidMount() {
          super.componentDidMount();
          dbfetch.geta(Object.keys(M.c.shares || {}), new MegaPromise()).finally(() => {
            if (this.isMounted()) {
              this.setState({
                loading: false
              });
            }
          });
        }
        getSharedFoldersView() {
          return this.state.loading
            ? null
            : external_React_default().createElement(fmView.Z, {
                currentlyViewedEntry: this.props.handle,
                onSelected: (handle) =>
                  this.setState({
                    selected: handle
                  }),
                onHighlighted: nop,
                searchValue: this.state.searchValue,
                onExpand: this.onExpand,
                onAttachClicked: this.onAttachClicked,
                viewMode: 0,
                currentdirid: "shares",
                megaListItemHeight: 65,
                headerContainerClassName: "grid-table-header",
                containerClassName: "grid-table shared-with-me",
                onContextMenu: (ev, handle) => this.handleContextMenu(ev, handle),
                listAdapterColumns: [
                  columnFavIcon.l,
                  [
                    ColumnSharedFolderName,
                    {
                      label: `${l.shared_folders_from.replace("%NAME", M.getNameByHandle(this.props.handle))}`
                    }
                  ],
                  ColumnSharedFolderAccess,
                  ColumnSharedFolderButtons
                ]
              });
        }
        render() {
          const { handle } = this.props;
          if (handle) {
            const contact = M.u[handle];
            if (!contact || contact.c !== 1) {
              return external_React_default().createElement(Nil, {
                title: l.contact_not_found
              });
            }
            const HAS_RELATIONSHIP = ContactsPanel.hasRelationship(contact);
            return external_React_default().createElement(
              "div",
              {
                className: "contacts-profile"
              },
              external_React_default().createElement(this.Breadcrumb, null),
              external_React_default().createElement(
                "div",
                {
                  className: "profile-content"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "profile-head"
                  },
                  HAS_RELATIONSHIP && external_React_default().createElement(this.Credentials, null),
                  external_React_default().createElement(contacts.Avatar, {
                    contact: contact,
                    className: "profile-photo avatar-wrapper contacts-medium-avatar"
                  }),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "profile-info"
                    },
                    external_React_default().createElement(
                      "h2",
                      null,
                      external_React_default().createElement(utils.dy, null, M.getNameByHandle(handle)),
                      external_React_default().createElement(contacts.ContactPresence, {
                        contact: contact
                      })
                    ),
                    external_React_default().createElement("span", null, contact.m)
                  ),
                  HAS_RELATIONSHIP &&
                    external_React_default().createElement(
                      "div",
                      {
                        className: "profile-controls"
                      },
                      external_React_default().createElement(buttons.z, {
                        className: "mega-button round simpletip",
                        icon: "sprite-fm-mono icon-chat-filled",
                        attrs: {
                          "data-simpletip": l[8632]
                        },
                        onClick: () => loadSubPage(`fm/chat/p/${handle}`)
                      }),
                      external_React_default().createElement(buttons.z, {
                        className: "mega-button round simpletip",
                        icon: "sprite-fm-mono icon-send-files",
                        attrs: {
                          "data-simpletip": l[6834]
                        },
                        onClick: () => {
                          if (M.isInvalidUserStatus()) {
                            return;
                          }
                          megaChat.openChatAndSendFilesDialog(handle);
                        }
                      }),
                      external_React_default().createElement(
                        buttons.z,
                        {
                          className: "mega-button round",
                          icon: "sprite-fm-mono icon-options"
                        },
                        external_React_default().createElement(
                          dropdowns.Dropdown,
                          {
                            className: "context",
                            noArrow: true,
                            positionMy: "left bottom",
                            positionAt: "right bottom",
                            horizOffset: 4
                          },
                          external_React_default().createElement(ContextMenu, {
                            contact: contact
                          })
                        )
                      )
                    )
                ),
                external_React_default().createElement(
                  "div",
                  {
                    className: "profile-shared-folders"
                  },
                  this.getSharedFoldersView()
                )
              )
            );
          }
          return null;
        }
      } // CONCATENATED MODULE: ./js/chat/ui/contactsPanel/contactsPanel.jsx
      class ContactsPanel extends mixins.wl {
        get view() {
          switch (megaChat.routingSubSection) {
            case null:
              return ContactsPanel.VIEW.CONTACTS;
            case "contact":
              return ContactsPanel.VIEW.PROFILE;
            case "received":
              return ContactsPanel.VIEW.RECEIVED_REQUESTS;
            case "sent":
              return ContactsPanel.VIEW.SENT_REQUESTS;
            default:
              console.error("Shouldn't happen.");
              return false;
          }
        }
        constructor(props) {
          super(props);
          this.requestReceivedListener = null;
          this.state = {
            receivedRequestsCount: 0
          };
          this.handleToggle = ({ keyCode }) => {
            if (keyCode === 27) {
              const HAS_DIALOG_OPENED =
                $.dialog ||
                [".contact-nickname-dialog", ".fingerprint-dialog", ".context"].some((selector) => {
                  const dialog = document.querySelector(selector);
                  return dialog && dialog.offsetHeight > 0;
                });
              return HAS_DIALOG_OPENED ? keyCode : loadSubPage("fm/chat");
            }
          };
          this.handleAcceptAllRequests = () => {
            const { received } = this.props;
            const receivedKeys = Object.keys(received || {});
            if (receivedKeys.length) {
              for (let i = receivedKeys.length; i--; ) {
                M.acceptPendingContactRequest(receivedKeys[i]);
              }
            }
          };
          this.renderView = () => {
            const { contacts, received, sent } = this.props;
            const { view } = this;
            switch (view) {
              case ContactsPanel.VIEW.CONTACTS:
                return external_React_default().createElement(ContactList, {
                  contacts: contacts
                });
              case ContactsPanel.VIEW.PROFILE:
                return external_React_default().createElement(ContactProfile, {
                  handle: view === ContactsPanel.VIEW.PROFILE && megaChat.routingParams
                });
              case ContactsPanel.VIEW.RECEIVED_REQUESTS:
                return external_React_default().createElement(ReceivedRequests, {
                  received: received
                });
              case ContactsPanel.VIEW.SENT_REQUESTS:
                return external_React_default().createElement(SentRequests, {
                  sent: sent
                });
            }
          };
          this.state.receivedRequestsCount = Object.keys(M.ipc).length;
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          document.documentElement.removeEventListener(ContactsPanel.EVENTS.KEYDOWN, this.handleToggle);
          if (this.requestReceivedListener) {
            mBroadcaster.removeListener(this.requestReceivedListener);
          }
        }
        componentDidMount() {
          super.componentDidMount();
          document.documentElement.addEventListener(ContactsPanel.EVENTS.KEYDOWN, this.handleToggle);
          this.requestReceivedListener = mBroadcaster.addListener("fmViewUpdate:ipc", () =>
            this.setState({
              receivedRequestsCount: Object.keys(M.ipc).length
            })
          );
        }
        render() {
          const { view, state } = this;
          const { receivedRequestsCount } = state;
          return external_React_default().createElement(
            "div",
            {
              className: "contacts-panel"
            },
            external_React_default().createElement(Navigation, {
              view: view,
              contacts: this.props.contacts,
              receivedRequestsCount: receivedRequestsCount
            }),
            view !== ContactsPanel.VIEW.PROFILE &&
              external_React_default().createElement(
                "div",
                {
                  className: "contacts-actions"
                },
                view === ContactsPanel.VIEW.RECEIVED_REQUESTS &&
                  receivedRequestsCount > 1 &&
                  external_React_default().createElement(
                    "button",
                    {
                      className: "mega-button action",
                      onClick: this.handleAcceptAllRequests
                    },
                    external_React_default().createElement("i", {
                      className: "sprite-fm-mono icon-check"
                    }),
                    external_React_default().createElement("span", null, l[19062])
                  )
              ),
            external_React_default().createElement(
              "div",
              {
                className: "contacts-content"
              },
              this.renderView()
            )
          );
        }
      }
      ContactsPanel.EVENTS = {
        KEYDOWN: "keydown"
      };
      ContactsPanel.VIEW = {
        CONTACTS: 0x00,
        RECEIVED_REQUESTS: 0x01,
        SENT_REQUESTS: 0x02,
        PROFILE: 0x03
      };
      ContactsPanel.LABEL = {
        CONTACTS: l[165],
        RECEIVED_REQUESTS: l[5863],
        SENT_REQUESTS: l[5862]
      };
      ContactsPanel.hasContacts = () => M.u.some((contact) => contact.c === 1);
      ContactsPanel.hasRelationship = (contact) => contact && contact.c === 1;
      ContactsPanel.isVerified = (contact) => {
        if (contact && contact.u) {
          const { u: handle } = contact;
          const verificationState = u_authring.Ed25519[handle] || {};
          return verificationState.method >= authring.AUTHENTICATION_METHOD.FINGERPRINT_COMPARISON;
        }
        return null;
      };
      ContactsPanel.verifyCredentials = (contact) => {
        if (contact.c === 1 && u_authring && u_authring.Ed25519) {
          const verifyState = u_authring.Ed25519[contact.u] || {};
          if (typeof verifyState.method === "undefined" || verifyState.method < authring.AUTHENTICATION_METHOD.FINGERPRINT_COMPARISON) {
            fingerprintDialog(contact.u);
          }
        }
      };
      ContactsPanel.resetCredentials = (contact) => {
        if (M.isInvalidUserStatus()) {
          return;
        }
        authring
          .resetFingerprintsForUser(contact.u)
          .then(() => contact.trackDataChange())
          .catch(dump);
      };
      ContactsPanel.getUserFingerprint = (handle) => {
        const $$FINGERPRINT = [];
        userFingerprint(handle, (fingerprints) => {
          for (let i = 0; i < fingerprints.length; i++) {
            $$FINGERPRINT.push(
              external_React_default().createElement(
                "span",
                {
                  key: i
                },
                fingerprints[i]
              )
            );
          }
        });
        return $$FINGERPRINT;
      };

      /***/
    },

    /***/ 21: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, {
        GY: () => ConversationPanels,
        L2: () => EmptyConvPanel,
        R7: () => allContactsInChat,
        hU: () => excludedParticipants
      });

      // UNUSED EXPORTS: ConversationPanel, ConversationRightArea, JoinCallNotification

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js
      var applyDecoratedDescriptor = __webpack_require__(229);
      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
      var esm_extends = __webpack_require__(462);
      // EXTERNAL MODULE: external "React"
      var external_React_ = __webpack_require__(363);
      var external_React_default = __webpack_require__.n(external_React_);
      // EXTERNAL MODULE: ./js/ui/utils.jsx
      var utils = __webpack_require__(79);
      // EXTERNAL MODULE: ./js/chat/mixins.js
      var mixins = __webpack_require__(503);
      // EXTERNAL MODULE: ./js/ui/buttons.jsx
      var buttons = __webpack_require__(204);
      // EXTERNAL MODULE: ./js/ui/modalDialogs.jsx + 1 modules
      var modalDialogs = __webpack_require__(182); // CONCATENATED MODULE: ./js/ui/jsx/fm/viewModeSelector.jsx
      class ViewModeSelector extends mixins.wl {
        render() {
          let viewMode = this.props.viewMode;
          return external_React_default().createElement(
            "div",
            {
              className: "chat-fm-view-mode-selector"
            },
            external_React_default().createElement("i", {
              className: "sprite-fm-mono icon-view-medium-list" + (viewMode ? "" : " active"),
              title: l[5553],
              onClick: () => {
                if (this.props.onChange) {
                  this.props.onChange(ViewModeSelector.VIEW_MODE.LIST);
                }
              }
            }),
            external_React_default().createElement("i", {
              className: "sprite-fm-mono icon-view-grid" + (viewMode ? " active" : ""),
              title: l[5552],
              onClick: () => {
                if (this.props.onChange) {
                  this.props.onChange(ViewModeSelector.VIEW_MODE.GRID);
                }
              }
            })
          );
        }
      }
      ViewModeSelector.VIEW_MODE = {
        GRID: 1,
        LIST: undefined
      }; // CONCATENATED MODULE: ./js/ui/jsx/fm/breadcrumbs.jsx
      class Breadcrumbs extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            breadcrumbDropdownVisible: false
          };
          this.onGlobalClickHandler = this.onGlobalClickHandler.bind(this);
          this.onBreadcrumbNodeClick = this.onBreadcrumbNodeClick.bind(this);
        }
        getBreadcrumbNodeText(nodeId, prevNodeId) {
          const backupsId = M.BackupsId || "backups";
          switch (nodeId) {
            case M.RootID:
              return l[164];
            case M.RubbishID:
              return l[167];
            case backupsId:
              return l.restricted_folder_button;
            case "shares":
              return prevNodeId && M.d[prevNodeId] ? M.d[prevNodeId].m : l[5589];
            default:
              return M.d[nodeId] && M.d[nodeId].name;
          }
        }
        getBreadcrumbDropdownContents(items) {
          let contents = [];
          for (let item of items) {
            let icon;
            if (!item.name) {
              continue;
            }
            if (item.type === "cloud-drive") {
              icon = external_React_default().createElement("i", {
                className: "sprite-fm-mono icon-cloud icon24"
              });
            } else if (item.type === "backups") {
              icon = external_React_default().createElement("i", {
                className: "sprite-fm-mono icon-database-filled icon24"
              });
            } else if (item.type === "folder") {
              icon = external_React_default().createElement("i", {
                className: "sprite-fm-mono icon-folder-filled icon24"
              });
            }
            contents.push(
              external_React_default().createElement(
                "a",
                {
                  className: "crumb-drop-link",
                  key: "drop_link_" + item.nodeId,
                  onClick: (e) => this.onBreadcrumbNodeClick(e, item.nodeId)
                },
                icon,
                external_React_default().createElement("span", null, item.name)
              )
            );
          }
          return contents;
        }
        onBreadcrumbNodeClick(e, nodeId) {
          e.preventDefault();
          e.stopPropagation();
          if (this._clickToHideListener) {
            this.removeGlobalClickHandler();
            this.setState({
              breadcrumbDropdownVisible: false
            });
          }
          this.props.onNodeClick(nodeId);
        }
        customIsEventuallyVisible() {
          return true;
        }
        onGlobalClickHandler(e) {
          let node = this.findDOMNode();
          if (node.contains(e.target) || node === e.target) {
            return;
          }
          if (this._clickToHideListener) {
            this.removeGlobalClickHandler();
          }
          this.setState({
            breadcrumbDropdownVisible: false
          });
        }
        removeGlobalClickHandler() {
          this._clickToHideListener = false;
          document.body.removeEventListener("click", this.onGlobalClickHandler);
        }
        componentDidUpdate() {
          super.componentDidUpdate();
          if (this.state.breadcrumbDropdownVisible) {
            if (!this._clickToHideListener) {
              this._clickToHideListener = true;
              document.body.addEventListener("click", this.onGlobalClickHandler);
            }
          } else if (this._clickToHideListener) {
            this.removeGlobalClickHandler();
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          this.removeGlobalClickHandler();
        }
        render() {
          let { className, highlighted, currentlyViewedEntry, isSearch, path } = this.props;
          const breadcrumb = [];
          const extraPathItems = [];
          let breadcrumbDropdownContents = [];
          const entryId = isSearch ? highlighted[0] : currentlyViewedEntry;
          if (entryId !== undefined) {
            (path || M.getPath(entryId)).forEach((nodeId, k, path) => {
              var breadcrumbClasses = "";
              if (nodeId === M.RootID) {
                breadcrumbClasses += " cloud-drive";
              } else {
                breadcrumbClasses += " folder";
              }
              if (nodeId.length === 11 && M.u[nodeId]) {
                return;
              }
              if (nodeId === "shares") {
                breadcrumbClasses += " shared-with-me";
              }
              const prevNodeId = path[k - 1];
              const nodeName = this.getBreadcrumbNodeText(nodeId, prevNodeId);
              if (!nodeName) {
                return;
              }
              ((nodeId, k) => {
                if (k < 4) {
                  breadcrumb.unshift(
                    external_React_default().createElement(
                      "a",
                      {
                        className: "fm-breadcrumbs contains-directories " + breadcrumbClasses,
                        key: nodeId,
                        onClick: (e) => this.onBreadcrumbNodeClick(e, nodeId)
                      },
                      external_React_default().createElement(
                        "span",
                        {
                          className: `right-arrow-bg simpletip`,
                          "data-simpletip": nodeName
                        },
                        external_React_default().createElement(
                          "span",
                          {
                            className: "selectable-txt"
                          },
                          nodeName
                        )
                      ),
                      k !== 0 &&
                        external_React_default().createElement("i", {
                          className: "next-arrow sprite-fm-mono icon-arrow-right icon16"
                        })
                    )
                  );
                } else {
                  let folderType = nodeId === M.RootID ? "cloud-drive" : "folder";
                  if (M.BackupsId && nodeId === M.BackupsId) {
                    folderType = "backups";
                  }
                  extraPathItems.push({
                    name: nodeName,
                    type: folderType,
                    nodeId
                  });
                }
              })(nodeId, k);
            });
            if (extraPathItems.length > 0) {
              breadcrumbDropdownContents = this.getBreadcrumbDropdownContents(extraPathItems);
            }
          }
          return external_React_default().createElement(
            "div",
            {
              className: `fm-breadcrumbs-wrapper ${className || ""}`
            },
            external_React_default().createElement(
              "div",
              {
                className: "fm-breadcrumbs-block"
              },
              breadcrumbDropdownContents.length
                ? external_React_default().createElement(
                    external_React_default().Fragment,
                    null,
                    external_React_default().createElement(
                      "div",
                      {
                        className: "crumb-overflow-link"
                      },
                      external_React_default().createElement(
                        "a",
                        {
                          className: "breadcrumb-dropdown-link dropdown",
                          onClick: () => {
                            this.setState({
                              breadcrumbDropdownVisible: !this.state.breadcrumbDropdownVisible
                            });
                          }
                        },
                        external_React_default().createElement("i", {
                          className: "menu-icon sprite-fm-mono icon-options icon24"
                        })
                      ),
                      external_React_default().createElement("i", {
                        className: "sprite-fm-mono icon-arrow-right icon16"
                      })
                    ),
                    breadcrumb
                  )
                : breadcrumb
            ),
            breadcrumbDropdownContents.length
              ? external_React_default().createElement(
                  "div",
                  {
                    className: this.state.breadcrumbDropdownVisible ? "breadcrumb-dropdown active" : "breadcrumb-dropdown"
                  },
                  breadcrumbDropdownContents
                )
              : ""
          );
        }
      }
      // EXTERNAL MODULE: ./js/ui/jsx/fm/fmView.jsx + 10 modules
      var fmView = __webpack_require__(309); // CONCATENATED MODULE: ./js/ui/cloudBrowserModalDialog.jsx
      const MIN_SEARCH_LENGTH = 2;
      class CloudBrowserDialog extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            isActiveSearch: false,
            selected: [],
            highlighted: [],
            currentlyViewedEntry: M.RootID,
            selectedTab: "clouddrive",
            searchValue: "",
            searchText: ""
          };
          this.onAttachClicked = this.onAttachClicked.bind(this);
          this.onClearSearchIconClick = this.onClearSearchIconClick.bind(this);
          this.onPopupDidMount = this.onPopupDidMount.bind(this);
          this.onSearchChange = this.onSearchChange.bind(this);
          this.onSearchIconClick = this.onSearchIconClick.bind(this);
          this.onSelected = this.onSelected.bind(this);
          this.onHighlighted = this.onHighlighted.bind(this);
          this.handleTabChange = this.handleTabChange.bind(this);
          this.onViewModeSwitch = this.onViewModeSwitch.bind(this);
          this.onBreadcrumbNodeClick = this.onBreadcrumbNodeClick.bind(this);
          this.onExpand = this.onExpand.bind(this);
        }
        onViewModeSwitch(newMode) {
          let currentViewMode = mega.config.get("cbvm") | 0;
          if (newMode === currentViewMode) {
            return;
          }
          mega.config.set("cbvm", newMode);
          this.forceUpdate();
        }
        getHeaderButtonsClass() {
          const classes = ["fm-header-buttons"];
          if (this.state.isActiveSearch) {
            classes.push("active-search");
          }
          return classes.join(" ");
        }
        getSearchIconClass() {
          const classes = ["sprite-fm-mono", "icon-preview-reveal"];
          if (this.state.isActiveSearch && this.state.searchText.length > 0) {
            classes.push("disabled");
          }
          return classes.join(" ");
        }
        onSearchIconClick() {
          const isActiveSearch = !this.state.isActiveSearch;
          if (isActiveSearch) {
            this.searchInput.focus();
            this.setState({
              isActiveSearch: isActiveSearch
            });
          }
        }
        onClearSearchIconClick() {
          this.setState({
            isActiveSearch: false,
            searchValue: "",
            searchText: "",
            currentlyViewedEntry: this.state.selectedTab === "shares" ? "shares" : M.RootID
          });
        }
        handleTabChange(selectedTab) {
          this.setState({
            selectedTab,
            currentlyViewedEntry: selectedTab === "shares" ? "shares" : M.RootID,
            searchValue: "",
            searchText: "",
            isLoading: false
          });
        }
        onSearchBlur() {
          if (this.state.searchText === "") {
            this.setState({
              isActiveSearch: false
            });
          }
        }
        onSearchChange(e) {
          var searchValue = e.target.value;
          const newState = {
            searchText: searchValue,
            nodeLoading: searchValue.length >= MIN_SEARCH_LENGTH
          };
          if (searchValue && searchValue.length >= MIN_SEARCH_LENGTH) {
            this.setState(newState);
            delay("cbd:search-proc", this.searchProc.bind(this), 500);
            return;
          }
          if (this.state.currentlyViewedEntry === "search" && (!searchValue || searchValue.length < MIN_SEARCH_LENGTH)) {
            newState.currentlyViewedEntry = this.state.selectedTab === "shares" ? "shares" : M.RootID;
            newState.searchValue = undefined;
          }
          this.setState(newState);
          this.clearSelectionAndHighlight();
        }
        searchProc() {
          const { searchText } = this.state;
          const newState = {
            nodeLoading: true
          };
          if (searchText && searchText.length >= MIN_SEARCH_LENGTH) {
            this.setState(newState);
            M.fmSearchNodes(searchText).then(() => {
              newState.nodeLoading = false;
              newState.searchValue = searchText;
              newState.currentlyViewedEntry = "search";
              this.setState(newState);
              this.clearSelectionAndHighlight();
            });
          }
        }
        onSelected(nodes) {
          this.setState({
            selected: nodes
          });
          this.props.onSelected(nodes);
        }
        onHighlighted(nodes) {
          this.setState({
            highlighted: nodes
          });
          if (this.props.onHighlighted) {
            this.props.onHighlighted(nodes);
          }
        }
        clearSelectionAndHighlight() {
          this.onSelected([]);
          this.onHighlighted([]);
        }
        onPopupDidMount(elem) {
          this.domNode = elem;
        }
        onAttachClicked() {
          this.props.onAttachClicked();
        }
        onBreadcrumbNodeClick(nodeId) {
          if (nodeId === "shares") {
            return this.handleTabChange("shares");
          }
          if (M.d[nodeId] && M.d[nodeId].t) {
            const nodeRoot = M.getNodeRoot(nodeId);
            this.setState({
              selectedTab: nodeRoot === "shares" || nodeRoot === "contacts" ? "shares" : "clouddrive",
              currentlyViewedEntry: nodeId,
              selected: [],
              searchValue: "",
              searchText: ""
            });
          }
        }
        onExpand(nodeId) {
          this.setState({
            currentlyViewedEntry: nodeId,
            searchValue: "",
            searchText: "",
            selected: [],
            highlighted: []
          });
        }
        render() {
          var self = this;
          const viewMode = mega.config.get("cbvm") | 0;
          const classes = `add-from-cloud ${self.props.className} dialog-template-tool `;
          let folderIsHighlighted = false;
          let share = false;
          let isSearch = this.state.currentlyViewedEntry === "search";
          const entryId = isSearch ? self.state.highlighted[0] : self.state.currentlyViewedEntry;
          let isIncomingShare = M.getNodeRoot(entryId) === "shares";
          this.state.highlighted.forEach((nodeId) => {
            if (M.d[nodeId] && M.d[nodeId].t === 1) {
              folderIsHighlighted = true;
            }
            share = M.getNodeShare(nodeId);
          });
          let buttons = [
            {
              label: this.props.cancelLabel,
              key: "cancel",
              onClick: (e) => {
                this.props.onClose(this);
                e.preventDefault();
                e.stopPropagation();
              }
            }
          ];
          if (folderIsHighlighted) {
            const { highlighted } = this.state;
            const className = `${share && share.down ? "disabled" : ""}`;
            const highlightedNode = highlighted && highlighted.length && highlighted[0];
            const allowAttachFolders = this.props.allowAttachFolders && !isIncomingShare;
            buttons.push(
              {
                label: this.props.openLabel,
                key: "select",
                className: `positive ${className} ${highlighted.length > 1 ? "disabled" : ""}`,
                onClick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  if (highlighted.length > 1) {
                    return;
                  }
                  this.setState({
                    currentlyViewedEntry: highlightedNode
                  });
                  this.clearSelectionAndHighlight();
                  this.setState({
                    selected: [],
                    searchValue: "",
                    searchText: "",
                    highlighted: []
                  });
                }
              },
              allowAttachFolders
                ? {
                    label: l[8023],
                    key: "attach",
                    className: "positive " + className,
                    onClick: () => {
                      this.props.onClose();
                      onIdle(() => {
                        const createPublicLink = (h) => {
                          M.createPublicLink(h).then(({ link }) => this.props.room.sendMessage(link));
                        };
                        const frs = [];
                        const files = [];
                        for (let i = 0; i < highlighted.length; i++) {
                          const node = M.getNodeByHandle(highlighted[i]);
                          if (node && M.isFileNode(node)) {
                            if (!M.getNodeShare(node).down) {
                              files.push(node);
                            }
                          } else if (mega.fileRequestCommon.storage.isDropExist(highlighted[i]).length) {
                            frs.push(highlighted[i]);
                          } else {
                            createPublicLink(highlighted[i]);
                          }
                        }
                        if (files.length) {
                          this.props.onSelected(files);
                          this.props.onAttachClicked();
                        }
                        if (frs.length) {
                          const fldName =
                            frs.length > 1 ? l[17626] : l[17403].replace("%1", escapeHTML(M.getNameByHandle(frs[0])) || l[1049]);
                          msgDialog("confirmation", l[1003], fldName, l[18229], (e) => {
                            if (e) {
                              mega.fileRequest
                                .removeList(frs)
                                .then(() => {
                                  for (let i = 0; i < frs.length; i++) {
                                    createPublicLink(frs[i]);
                                  }
                                })
                                .catch(dump);
                            }
                          });
                        }
                      });
                    }
                  }
                : null
            );
          }
          if (!folderIsHighlighted || this.props.folderSelectable) {
            buttons.push({
              label: this.props.selectLabel,
              key: "select",
              className: "positive " + (this.state.selected.length === 0 || (share && share.down) ? "disabled" : ""),
              onClick: (e) => {
                if (this.state.selected.length > 0) {
                  this.props.onSelected(this.state.selected.filter((node) => !M.getNodeShare(node).down));
                  this.props.onAttachClicked();
                }
                e.preventDefault();
                e.stopPropagation();
              }
            });
          }
          var clearSearchBtn = null;
          if (self.state.searchText.length >= MIN_SEARCH_LENGTH) {
            clearSearchBtn = external_React_default().createElement("i", {
              className: "sprite-fm-mono icon-close-component",
              onClick: () => {
                self.onClearSearchIconClick();
              }
            });
          }
          let breadcrumbPath = M.getPath(entryId);
          return external_React_default().createElement(
            modalDialogs.Z.ModalDialog,
            {
              title: self.props.title || l[8011],
              className: classes + (isSearch && this.state.selected.length > 0 ? "has-breadcrumbs-bottom" : ""),
              onClose: () => {
                self.props.onClose(self);
              },
              dialogName: "add-from-cloud-dialog dialog-template-tool",
              popupDidMount: self.onPopupDidMount,
              buttons: buttons
            },
            external_React_default().createElement(
              "section",
              {
                className: "content"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "content-block"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "fm-dialog-tabs"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: `
                                    fm-dialog-tab cloud
                                    ${self.state.selectedTab === "clouddrive" ? "active" : ""}
                                `,
                      onClick: () => self.handleTabChange("clouddrive")
                    },
                    l[164]
                  ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: `
                                    fm-dialog-tab incoming
                                    ${self.state.selectedTab === "shares" ? "active" : ""}
                                `,
                      onClick: () => self.handleTabChange("shares")
                    },
                    l[5542]
                  ),
                  external_React_default().createElement("div", {
                    className: "clear"
                  })
                ),
                external_React_default().createElement(
                  "div",
                  {
                    className: "fm-picker-header"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: self.getHeaderButtonsClass()
                    },
                    external_React_default().createElement(ViewModeSelector, {
                      viewMode: viewMode,
                      onChange: this.onViewModeSwitch
                    }),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "fm-files-search"
                      },
                      external_React_default().createElement("i", {
                        className: self.getSearchIconClass(),
                        onClick: () => {
                          self.onSearchIconClick();
                        }
                      }),
                      external_React_default().createElement("input", {
                        ref: (input) => {
                          this.searchInput = input;
                        },
                        type: "search",
                        placeholder: l[102],
                        value: self.state.searchText,
                        onChange: self.onSearchChange,
                        onBlur: () => {
                          self.onSearchBlur();
                        }
                      }),
                      clearSearchBtn
                    ),
                    external_React_default().createElement("div", {
                      className: "clear"
                    })
                  ),
                  !isSearch &&
                    external_React_default().createElement(Breadcrumbs, {
                      className: "add-from-cloud",
                      nodeId: entryId,
                      path: breadcrumbPath,
                      onNodeClick: this.onBreadcrumbNodeClick,
                      isSearch: isSearch,
                      highlighted: this.state.highlighted,
                      currentlyViewedEntry: this.state.currentlyViewedEntry
                    })
                ),
                external_React_default().createElement(fmView.Z, {
                  nodeLoading: this.state.nodeLoading,
                  sortFoldersFirst: true,
                  currentlyViewedEntry: this.state.currentlyViewedEntry,
                  folderSelectNotAllowed: this.props.folderSelectNotAllowed,
                  folderSelectable: this.props.folderSelectable,
                  onSelected: this.onSelected,
                  onHighlighted: this.onHighlighted,
                  onAttachClicked: this.onAttachClicked,
                  initialSelected: this.state.selected,
                  initialHighlighted: this.state.highlighted,
                  searchValue: this.state.searchValue,
                  minSearchLength: MIN_SEARCH_LENGTH,
                  onExpand: this.onExpand,
                  viewMode: viewMode,
                  initialSortBy: ["name", "asc"],
                  fmConfigSortEnabled: true,
                  fmConfigSortId: "cbd"
                }),
                isSearch &&
                  breadcrumbPath.length > 0 &&
                  external_React_default().createElement(
                    "div",
                    {
                      className: `
                            fm-breadcrumbs-wrapper add-from-cloud breadcrumbs-bottom
                        `
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: "fm-breadcrumbs-block"
                      },
                      external_React_default().createElement(Breadcrumbs, {
                        nodeId: entryId,
                        path: breadcrumbPath,
                        onNodeClick: this.onBreadcrumbNodeClick,
                        isSearch: isSearch,
                        highlighted: this.state.highlighted,
                        currentlyViewedEntry: this.state.currentlyViewedEntry
                      }),
                      external_React_default().createElement("div", {
                        className: "clear"
                      })
                    )
                  )
              )
            )
          );
        }
      }
      CloudBrowserDialog.defaultProps = {
        selectLabel: l[8023],
        openLabel: l[1710],
        cancelLabel: l[82],
        hideable: true,
        className: ""
      };
      window.CloudBrowserModalDialogUI = {
        CloudBrowserDialog
      };
      const cloudBrowserModalDialog = {
        CloudBrowserDialog
      };
      // EXTERNAL MODULE: ./js/chat/chatRoom.jsx + 1 modules
      var chat_chatRoom = __webpack_require__(804); // CONCATENATED MODULE: ./js/ui/historyRetentionDialog.jsx
      const LIMIT = {
        CHARS: 2,
        HOURS: 24,
        DAYS: 31,
        WEEKS: 4,
        MONTHS: 12
      };
      class HistoryRetentionDialog extends external_React_.Component {
        constructor(props) {
          super(props);
          this.inputRef = external_React_default().createRef();
          this.state = {
            selectedTimeFormat: chat_chatRoom.RETENTION_FORMAT.HOURS,
            timeRange: undefined
          };
          this.handleRadioChange = (e) => {
            const selectedTimeFormat = e.target.value;
            this.setState((prevState) => ({
              selectedTimeFormat,
              timeRange: this.filterTimeRange(prevState.timeRange, selectedTimeFormat)
            }));
          };
          this.handleOnTimeChange = (e) => {
            const timeValue = e.target.value;
            this.setState((prevState) => ({
              timeRange: this.filterTimeRange(timeValue, prevState.selectedTimeFormat)
            }));
          };
          const { chatRoom } = props;
          this.state.timeRange = chatRoom.getRetentionTimeFormatted();
          if (this.state.timeRange === 0) {
            this.state.timeRange = "";
          }
          this.state.selectedTimeFormat = chatRoom.getRetentionFormat();
          this.state.selectedTimeFormat =
            this.state.selectedTimeFormat === chat_chatRoom.RETENTION_FORMAT.DISABLED
              ? chat_chatRoom.RETENTION_FORMAT.HOURS
              : this.state.selectedTimeFormat;
        }
        hasInput() {
          return this.state.timeRange && parseInt(this.state.timeRange, 10) >= 1;
        }
        getDefaultValue(selectedTimeFormat) {
          switch (selectedTimeFormat) {
            case chat_chatRoom.RETENTION_FORMAT.HOURS:
              return LIMIT.HOURS;
            case chat_chatRoom.RETENTION_FORMAT.DAYS:
              return LIMIT.DAYS;
            case chat_chatRoom.RETENTION_FORMAT.WEEKS:
              return LIMIT.WEEKS;
            case chat_chatRoom.RETENTION_FORMAT.MONTHS:
              return LIMIT.MONTHS;
          }
        }
        getParsedLabel(label, timeRange) {
          timeRange = timeRange ? parseInt(timeRange, 10) : this.getDefaultValue(label);
          switch (label) {
            case chat_chatRoom.RETENTION_FORMAT.HOURS:
              return mega.icu.format(l.plural_hour, timeRange);
            case chat_chatRoom.RETENTION_FORMAT.DAYS:
              return mega.icu.format(l.plural_day, timeRange);
            case chat_chatRoom.RETENTION_FORMAT.WEEKS:
              return mega.icu.format(l.plural_week, timeRange);
            case chat_chatRoom.RETENTION_FORMAT.MONTHS:
              return mega.icu.format(l.plural_month, timeRange);
          }
        }
        filterTimeRange(timeRange, selectedTimeFormat) {
          if (timeRange.length > LIMIT.CHARS) {
            return timeRange.substring(0, LIMIT.CHARS);
          }
          timeRange = parseInt(timeRange, 10);
          if (timeRange === 0 || isNaN(timeRange)) {
            return "";
          }
          switch (selectedTimeFormat) {
            case chat_chatRoom.RETENTION_FORMAT.HOURS:
              return timeRange > LIMIT.HOURS ? LIMIT.HOURS : timeRange;
            case chat_chatRoom.RETENTION_FORMAT.DAYS:
              return timeRange > LIMIT.DAYS ? LIMIT.DAYS : timeRange;
            case chat_chatRoom.RETENTION_FORMAT.WEEKS:
              return timeRange > LIMIT.WEEKS ? LIMIT.WEEKS : timeRange;
            case chat_chatRoom.RETENTION_FORMAT.MONTHS:
              return timeRange > LIMIT.MONTHS ? LIMIT.MONTHS : timeRange;
          }
          return timeRange;
        }
        handleOnSubmit(e) {
          if (!this.hasInput()) {
            return;
          }
          e.preventDefault();
          e.stopPropagation();
          const { chatRoom, onClose } = this.props;
          const { selectedTimeFormat, timeRange } = this.state;
          let time = 0;
          switch (selectedTimeFormat) {
            case chat_chatRoom.RETENTION_FORMAT.HOURS:
              time = hoursToSeconds(Number(timeRange));
              break;
            case chat_chatRoom.RETENTION_FORMAT.DAYS:
              time = daysToSeconds(Number(timeRange));
              break;
            case chat_chatRoom.RETENTION_FORMAT.WEEKS:
              time = daysToSeconds(Number(timeRange) * 7);
              break;
            case chat_chatRoom.RETENTION_FORMAT.MONTHS:
              time = daysToSeconds(Number(timeRange) * 30);
              break;
          }
          chatRoom.setRetention(time);
          onClose();
        }
        renderCustomRadioButton() {
          return [
            chat_chatRoom.RETENTION_FORMAT.HOURS,
            chat_chatRoom.RETENTION_FORMAT.DAYS,
            chat_chatRoom.RETENTION_FORMAT.WEEKS,
            chat_chatRoom.RETENTION_FORMAT.MONTHS
          ].map((label) => {
            return external_React_default().createElement(CustomRadioButton, {
              checked: this.state.selectedTimeFormat === label,
              label: this.getParsedLabel(label, this.state.timeRange),
              name: "time-selector",
              value: label,
              onChange: this.handleRadioChange,
              key: label
            });
          });
        }
        componentDidMount() {
          $(document.body).rebind("keydown.historyRetentionDialog", (e) => {
            const key = e.keyCode || e.which;
            if (key === 13) {
              this.handleOnSubmit(e);
            }
          });
        }
        componentWillUnmount() {
          $(document.body).off("keydown.historyRetentionDialog");
        }
        render() {
          const { chatRoom, onClose } = this.props;
          const { selectedTimeFormat, timeRange } = this.state;
          return external_React_default().createElement(
            modalDialogs.Z.ModalDialog,
            (0, esm_extends.Z)({}, this.state, {
              chatRoom: chatRoom,
              onClose: onClose,
              dialogName: "msg-retention-dialog",
              dialogType: "tool",
              onClick: () => this.inputRef.current.focus()
            }),
            external_React_default().createElement(
              "header",
              null,
              external_React_default().createElement(
                "h2",
                {
                  id: "msg-retention-dialog-title"
                },
                l[23434]
              )
            ),
            external_React_default().createElement(
              "section",
              {
                className: "content"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "content-block"
                },
                external_React_default().createElement("p", null, l[23435])
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "content-block form"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "form-section"
                  },
                  external_React_default().createElement(
                    "span",
                    {
                      className: "form-section-placeholder"
                    },
                    this.getParsedLabel(selectedTimeFormat, timeRange)
                  ),
                  external_React_default().createElement("input", {
                    type: "number",
                    min: "0",
                    step: "1",
                    className: "form-section-time",
                    placeholder: this.getDefaultValue(selectedTimeFormat),
                    ref: this.inputRef,
                    autoFocus: true,
                    value: timeRange,
                    onChange: this.handleOnTimeChange,
                    onKeyDown: (e) => (e.key === "-" || e.key === "+" || e.key === "e") && e.preventDefault()
                  })
                ),
                external_React_default().createElement(
                  "div",
                  {
                    className: "form-section"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "form-section-radio"
                    },
                    this.renderCustomRadioButton()
                  )
                )
              )
            ),
            external_React_default().createElement(
              "footer",
              null,
              external_React_default().createElement(
                "div",
                {
                  className: "footer-container"
                },
                external_React_default().createElement(
                  "button",
                  {
                    className: "mega-button",
                    onClick: onClose
                  },
                  external_React_default().createElement("span", null, l[82])
                ),
                external_React_default().createElement(
                  "button",
                  {
                    className: `
                                mega-button positive
                                ${this.hasInput() ? "" : "disabled"}
                            `,
                    onClick: (e) => this.handleOnSubmit(e)
                  },
                  external_React_default().createElement("span", null, l[726])
                )
              )
            )
          );
        }
      }
      function CustomRadioButton({ checked = false, label, name, value, onChange }) {
        return external_React_default().createElement(
          "label",
          {
            key: value,
            className: "radio-txt"
          },
          label,
          external_React_default().createElement(
            "div",
            {
              className: "custom-radio small green-active " + (checked ? "radioOn" : "radioOff")
            },
            external_React_default().createElement("input", {
              type: "radio",
              name: name,
              value: value,
              checked: checked,
              onChange: onChange
            })
          )
        );
      }
      // EXTERNAL MODULE: ./js/ui/dropdowns.jsx
      var dropdowns = __webpack_require__(78);
      // EXTERNAL MODULE: ./js/chat/ui/contacts.jsx
      var ui_contacts = __webpack_require__(13);
      // EXTERNAL MODULE: ./js/ui/perfectScrollbar.jsx
      var perfectScrollbar = __webpack_require__(285); // CONCATENATED MODULE: ./js/ui/accordion.jsx
      var React = __webpack_require__(363);

      class AccordionPanel extends mixins.wl {
        render() {
          var self = this;
          var contentClass = self.props.className ? self.props.className : "";
          return React.createElement(
            "div",
            {
              className: `chat-dropdown container ${this.props.accordionClass || ""}`
            },
            React.createElement(
              "div",
              {
                className: "chat-dropdown header " + (this.props.expanded ? "expanded" : ""),
                onClick: function (e) {
                  self.props.onToggle(e);
                }
              },
              React.createElement("span", null, this.props.title),
              React.createElement("i", {
                className: "sprite-fm-mono icon-arrow-down"
              })
            ),
            this.props.expanded
              ? React.createElement(
                  "div",
                  {
                    className: "chat-dropdown content have-animation " + contentClass
                  },
                  this.props.children
                )
              : null
          );
        }
      }
      class Accordion extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            expandedPanel: this.props.expandedPanel
          };
        }
        onToggle(e, key) {
          var obj = {};
          obj[key] = !(this.state.expandedPanel || {})[key];
          this.setState({
            expandedPanel: obj
          });
          this.props.onToggle && this.props.onToggle(key);
        }
        render() {
          var self = this;
          var classes = "accordion-panels " + (self.props.className ? self.props.className : "");
          var accordionPanels = [];
          var x = 0;
          React.Children.forEach(self.props.children, (child) => {
            if (!child) {
              return;
            }
            if (child.type.name === "AccordionPanel" || (child.type.name && child.type.name.indexOf("AccordionPanel") > -1)) {
              accordionPanels.push(
                React.cloneElement(child, {
                  key: child.key,
                  expanded: !!self.state.expandedPanel[child.key],
                  accordion: self,
                  onToggle: function (e) {
                    self.onToggle(e, child.key);
                  }
                })
              );
            } else {
              accordionPanels.push(
                React.cloneElement(child, {
                  key: x++,
                  accordion: self
                })
              );
            }
          });
          return React.createElement(
            "div",
            {
              className: classes
            },
            accordionPanels
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/participantsList.jsx

      var DropdownsUI = __webpack_require__(78);
      var ContactsUI = __webpack_require__(13);
      var PerfectScrollbar = __webpack_require__(285).F;
      class ParticipantsList extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            scrollPositionY: 0,
            scrollHeight: 144
          };
          this.doResizesOnComponentUpdate = SoonFc(10, function () {
            var self = this;
            if (!self.isMounted()) {
              return;
            }
            var fitHeight = self.contactsListScroll.getContentHeight();
            if (!fitHeight) {
              return null;
            }
            var $node = $(self.findDOMNode());
            var $parentContainer = $node.closest(".chat-right-pad");
            var maxHeight = $parentContainer.outerHeight(true) - $(".chat-right-head", $parentContainer).outerHeight(true) - 72;
            if (fitHeight < $(".buttons-block", $parentContainer).outerHeight(true)) {
              fitHeight = Math.max(fitHeight, 53);
            } else if (maxHeight < fitHeight) {
              fitHeight = Math.max(maxHeight, 53);
            }
            fitHeight = Math.min(self.calculateListHeight($parentContainer), fitHeight);
            var $contactsList = $(".chat-contacts-list", $parentContainer);
            if ($contactsList.height() !== fitHeight) {
              $(".chat-contacts-list", $parentContainer).height(fitHeight);
              if (self.contactsListScroll) {
                self.contactsListScroll.reinitialise();
              }
            }
            if (self.state.scrollHeight !== fitHeight) {
              self.setState({
                scrollHeight: fitHeight
              });
            }
            self.onUserScroll();
          });
        }
        onUserScroll() {
          if (!this.contactsListScroll) {
            return;
          }
          var scrollPosY = this.contactsListScroll.getScrollPositionY();
          if (this.state.scrollPositionY !== scrollPosY) {
            this.setState({
              scrollPositionY: scrollPosY
            });
          }
        }
        calculateListHeight($parentContainer) {
          var room = this.props.chatRoom;
          return (
            ($parentContainer ? $parentContainer : $(".conversationsApp")).outerHeight() -
            144 -
            10 -
            (room.type === "public" && room.observers > 0 ? 48 : 0) -
            (room.isReadOnly() ? 12 : 0)
          );
        }
        componentDidUpdate() {
          var self = this;
          if (!self.isMounted()) {
            return;
          }
          if (!self.contactsListScroll) {
            return null;
          }
          self.doResizesOnComponentUpdate();
        }
        render() {
          var self = this;
          var room = this.props.chatRoom;
          if (!room) {
            return null;
          }
          var contacts = room.stateIsLeftOrLeaving() ? [] : room.getParticipantsExceptMe();
          var contactListStyles = {};
          contactListStyles.height = Math.min(this.calculateListHeight(), contacts.length * this.props.contactCardHeight);
          return external_React_default().createElement(
            "div",
            {
              className: "chat-contacts-list",
              style: contactListStyles
            },
            external_React_default().createElement(
              PerfectScrollbar,
              {
                chatRoom: room,
                members: room.members,
                ref: function (ref) {
                  self.contactsListScroll = ref;
                },
                disableCheckingVisibility: true,
                onUserScroll: SoonFc(self.onUserScroll.bind(self), 76),
                requiresUpdateOnResize: true,
                onAnimationEnd: function () {
                  self.safeForceUpdate();
                },
                isVisible: self.props.chatRoom.isCurrentlyActive,
                options: {
                  suppressScrollX: true
                }
              },
              external_React_default().createElement(ParticipantsListInner, {
                chatRoom: room,
                members: room.members,
                scrollPositionY: self.state.scrollPositionY,
                scrollHeight: self.state.scrollHeight,
                disableCheckingVisibility: true
              })
            )
          );
        }
      }
      ParticipantsList.defaultProps = {
        requiresUpdateOnResize: true,
        contactCardHeight: 36
      };
      class ParticipantsListInner extends mixins.wl {
        render() {
          var room = this.props.chatRoom;
          var contactCardHeight = this.props.contactCardHeight;
          var scrollPositionY = this.props.scrollPositionY;
          var scrollHeight = this.props.scrollHeight;
          const { OPERATOR, FULL, READONLY } = ChatRoom.MembersSet.PRIVILEGE_STATE;
          if (!room) {
            return null;
          }
          if (!room.isCurrentlyActive && room._leaving !== true) {
            return false;
          }
          var contacts = room.getParticipantsExceptMe();
          var contactsList = [];
          const firstVisibleUserNum = Math.floor(scrollPositionY / contactCardHeight);
          const visibleUsers = Math.ceil(scrollHeight / contactCardHeight);
          var contactListInnerStyles = {
            height: contacts.length * contactCardHeight
          };
          if ((room.type === "group" || room.type === "public") && !room.stateIsLeftOrLeaving() && room.members.hasOwnProperty(u_handle)) {
            contacts.unshift(u_handle);
            contactListInnerStyles.height += contactCardHeight;
          }
          var onRemoveClicked = (contactHash) => {
            room.trigger("onRemoveUserRequest", [contactHash]);
          };
          var onSetPrivClicked = (contactHash, priv) => {
            if (room.members[contactHash] !== priv) {
              room.trigger("alterUserPrivilege", [contactHash, priv]);
            }
          };
          for (var i = 0; i < contacts.length; i++) {
            const contactHash = contacts[i];
            if (!(contactHash in M.u)) {
              continue;
            }
            var contact = M.u[contactHash];
            if (i < firstVisibleUserNum || i > firstVisibleUserNum + visibleUsers) {
              continue;
            }
            var dropdowns = [];
            var dropdownIconClasses = "small-icon tiny-icon icons-sprite grey-dots";
            var dropdownRemoveButton = [];
            if (room.type === "public" || (room.type === "group" && room.members)) {
              if (room.iAmOperator() && contactHash !== u_handle) {
                dropdownRemoveButton.push(
                  external_React_default().createElement(DropdownsUI.DropdownItem, {
                    className: "red",
                    key: "remove",
                    icon: "sprite-fm-mono icon-disabled-filled",
                    label: l[8867],
                    onClick: onRemoveClicked.bind(this, contactHash)
                  })
                );
              }
              if (room.iAmOperator()) {
                dropdowns.push(
                  external_React_default().createElement(
                    "div",
                    {
                      key: "setPermLabel",
                      className: "dropdown-items-info"
                    },
                    l[8868]
                  )
                );
                dropdowns.push(
                  external_React_default().createElement(DropdownsUI.DropdownItem, {
                    key: "privOperator",
                    icon: "sprite-fm-mono icon-admin-outline",
                    label: l[8875],
                    className: `
                                tick-item
                                ${room.members[contactHash] === OPERATOR ? "active" : ""}
                            `,
                    disabled: contactHash === u_handle,
                    onClick: () => onSetPrivClicked(contactHash, OPERATOR)
                  })
                );
                dropdowns.push(
                  external_React_default().createElement(DropdownsUI.DropdownItem, {
                    key: "privFullAcc",
                    icon: "sprite-fm-mono icon-chat",
                    className: `
                                tick-item
                                ${room.members[contactHash] === FULL ? "active" : ""}
                            `,
                    disabled: contactHash === u_handle,
                    label: l[8874],
                    onClick: () => onSetPrivClicked(contactHash, FULL)
                  })
                );
                dropdowns.push(
                  external_React_default().createElement(DropdownsUI.DropdownItem, {
                    key: "privReadOnly",
                    icon: "sprite-fm-mono icon-read-only",
                    className: `
                                tick-item
                                ${room.members[contactHash] === READONLY ? "active" : ""}
                            `,
                    disabled: contactHash === u_handle,
                    label: l[8873],
                    onClick: () => onSetPrivClicked(contactHash, READONLY)
                  })
                );
              }
              const baseClassName = "sprite-fm-mono";
              switch (room.members[contactHash]) {
                case OPERATOR:
                  dropdownIconClasses = `${baseClassName} icon-admin`;
                  break;
                case FULL:
                  dropdownIconClasses = `${baseClassName} icon-chat-filled`;
                  break;
                case READONLY:
                  dropdownIconClasses = `${baseClassName} icon-read-only`;
                  break;
                default:
                  break;
              }
              contactsList.push(
                external_React_default().createElement(ContactsUI.ContactCard, {
                  key: contact.u,
                  contact: contact,
                  chatRoom: room,
                  className: "right-chat-contact-card",
                  dropdownPositionMy: "left top",
                  dropdownPositionAt: "left top",
                  dropdowns: dropdowns,
                  dropdownDisabled: contactHash === u_handle || is_chatlink || is_eplusplus,
                  dropdownButtonClasses: "contacts-icon",
                  dropdownRemoveButton: dropdownRemoveButton,
                  dropdownIconClasses: dropdownIconClasses,
                  noLoading: true,
                  isInCall: room.uniqueCallParts && room.uniqueCallParts[contactHash],
                  style: {
                    width: 234,
                    position: "absolute",
                    top: i * contactCardHeight
                  }
                })
              );
            }
          }
          return external_React_default().createElement(
            "div",
            {
              className: "chat-contacts-list-inner default-bg",
              style: contactListInnerStyles
            },
            contactsList
          );
        }
      }
      ParticipantsListInner.defaultProps = {
        requiresUpdateOnResize: true,
        contactCardHeight: 32,
        scrollPositionY: 0,
        scrollHeight: 128,
        chatRoom: undefined
      };

      // EXTERNAL MODULE: ./js/chat/ui/messages/generic.jsx + 14 modules
      var generic = __webpack_require__(931); // CONCATENATED MODULE: ./js/chat/ui/sharedFilesAccordionPanel.jsx
      var _dec, _class;
      var sharedFilesAccordionPanel_React = __webpack_require__(363);

      class SharedFileItem extends mixins._p {
        render() {
          var self = this;
          var message = this.props.message;
          var contact = Message.getContactForMessage(message);
          var name = M.getNameByHandle(contact.u);
          var timestamp = time2date(message.delay);
          var node = this.props.node;
          var icon = this.props.icon;
          return sharedFilesAccordionPanel_React.createElement(
            "div",
            {
              className: "chat-shared-block " + (self.props.isLoading ? "is-loading" : ""),
              key: message.messageId + "_" + node.h,
              onClick: () => (this.props.isPreviewable ? M.viewMediaFile(node) : M.addDownload([node])),
              onDoubleClick: () => M.addDownload([node])
            },
            sharedFilesAccordionPanel_React.createElement(
              "div",
              {
                className: `icon-or-thumb ${thumbnails.has(node.fa) ? "thumb" : ""}`
              },
              sharedFilesAccordionPanel_React.createElement("div", {
                className: "medium-file-icon " + icon
              }),
              sharedFilesAccordionPanel_React.createElement(
                "div",
                {
                  className: "img-wrapper",
                  id: this.props.imgId
                },
                sharedFilesAccordionPanel_React.createElement("img", {
                  alt: "",
                  src: thumbnails.get(node.fa) || ""
                })
              )
            ),
            sharedFilesAccordionPanel_React.createElement(
              "div",
              {
                className: "chat-shared-info"
              },
              sharedFilesAccordionPanel_React.createElement(
                "span",
                {
                  className: "txt"
                },
                node.name
              ),
              sharedFilesAccordionPanel_React.createElement(
                "span",
                {
                  className: "txt small"
                },
                sharedFilesAccordionPanel_React.createElement(utils.dy, null, name)
              ),
              sharedFilesAccordionPanel_React.createElement(
                "span",
                {
                  className: "txt small grey"
                },
                timestamp
              )
            )
          );
        }
      }
      let SharedFilesAccordionPanel =
        ((_dec = utils.ZP.SoonFcWrap(350)),
        ((_class = class SharedFilesAccordionPanel extends mixins.wl {
          eventuallyRenderThumbnails() {
            if (this.allShownNodes) {
              var pending = [];
              const nodes = new Map(this.allShownNodes);
              const render = (n) => {
                if (thumbnails.has(n.fa)) {
                  const src = thumbnails.get(n.fa);
                  const batch = [...nodes.get(n.fa)];
                  for (var i = batch.length; i--; ) {
                    const n = batch[i];
                    let img = document.getElementById(`sharedFiles!${n.ch}`);
                    if (img && (img = img.querySelector("img"))) {
                      img.src = src;
                      if ((img = Object(img.parentNode).parentNode)) {
                        img.classList.add("thumb");
                      }
                    }
                  }
                  return true;
                }
              };
              for (const [, [n]] of nodes) {
                if (!render(n)) {
                  pending.push(n);
                }
              }
              this.allShownNodes.clear();
              if (pending.length) {
                fm_thumbnails("standalone", pending, render);
              }
            }
          }
          componentWillMount() {
            this.allShownNodes = new MapSet();
          }
          componentWillUnmount() {
            super.componentWillUnmount();
            delete this.allShownNodes;
          }
          componentDidUpdate() {
            this.eventuallyRenderThumbnails();
          }
          render() {
            var self = this;
            var room = self.props.chatRoom;
            var mb = room.messagesBuff;
            var contents = null;
            var currentPage = mb.sharedFilesPage;
            var startPos = currentPage * 12;
            var endPos = startPos + 12;
            var totalPages = mb.haveMoreSharedFiles ? "..." : Math.ceil(mb.sharedFiles.length / 12);
            totalPages = mb.sharedFiles.length && !totalPages ? 1 : totalPages;
            var haveMore = mb.haveMoreSharedFiles || currentPage + 1 < totalPages;
            var files = [];
            if (!mb.haveMoreSharedFiles && currentPage === totalPages) {
              currentPage = mb.sharedFilesPage = Math.max(totalPages - 1, 0);
            }
            if (this.props.expanded) {
              var prev = null;
              var next = null;
              if (currentPage > 0) {
                prev = sharedFilesAccordionPanel_React.createElement("div", {
                  className: "chat-share-nav button prev",
                  onClick: function () {
                    mb.sharedFilesPage--;
                    self.safeForceUpdate();
                  }
                });
              }
              if (haveMore) {
                next = sharedFilesAccordionPanel_React.createElement("div", {
                  className: "chat-share-nav button next",
                  onClick: function () {
                    if (self.isLoadingMore) {
                      return;
                    }
                    if (mb.sharedFiles.length < endPos + 12) {
                      self.isLoadingMore = true;
                      mb.retrieveSharedFilesHistory(12)
                        .catch(dump)
                        .finally(() => {
                          self.isLoadingMore = false;
                          mb.sharedFilesPage++;
                          if (!mb.haveMoreSharedFiles && mb.sharedFilesPage > totalPages) {
                            mb.sharedFilesPage = totalPages - 1;
                          }
                          Soon(function () {
                            self.safeForceUpdate();
                          });
                        });
                    } else {
                      mb.sharedFilesPage++;
                    }
                    Soon(function () {
                      self.safeForceUpdate();
                    });
                  }
                });
              }
              if (!mb.sharedFilesLoadedOnce) {
                mb.retrieveSharedFilesHistory(12)
                  .then(() => this.safeForceUpdate())
                  .catch(dump);
              }
              var sharedNodesContainer = null;
              if (mb.isRetrievingSharedFiles && !self.isLoadingMore) {
                sharedNodesContainer = sharedFilesAccordionPanel_React.createElement(
                  "div",
                  {
                    className: "chat-dropdown empty-txt loading-initial"
                  },
                  sharedFilesAccordionPanel_React.createElement(
                    "div",
                    {
                      className: "loading-spinner light small"
                    },
                    sharedFilesAccordionPanel_React.createElement("div", {
                      className: "main-loader"
                    })
                  )
                );
              } else if (!mb.haveMoreSharedFiles && !mb.sharedFiles.length) {
                sharedNodesContainer = sharedFilesAccordionPanel_React.createElement(
                  "div",
                  {
                    className: "chat-dropdown empty-txt"
                  },
                  l[19985]
                );
              } else {
                var keys = clone(mb.sharedFiles.keys()).reverse();
                for (var i = startPos; i < endPos; i++) {
                  var message = mb.sharedFiles[keys[i]];
                  if (!message) {
                    continue;
                  }
                  var nodes = message.getAttachmentMeta();
                  nodes.forEach(function (node) {
                    var imgId = "sharedFiles!" + node.ch;
                    const { icon, showThumbnail, isPreviewable } = M.getMediaProperties(node);
                    files.push(
                      sharedFilesAccordionPanel_React.createElement(SharedFileItem, {
                        message: message,
                        key: `${node.h}_${message.messageId}`,
                        isLoading: self.isLoadingMore,
                        node: node,
                        icon: icon,
                        imgId: imgId,
                        showThumbnail: showThumbnail,
                        isPreviewable: isPreviewable,
                        chatRoom: room,
                        contact: Message.getContactForMessage(message)
                      })
                    );
                    if (showThumbnail) {
                      self.allShownNodes.set(node.fa, node);
                    }
                  });
                }
                sharedNodesContainer = sharedFilesAccordionPanel_React.createElement("div", null, files);
              }
              contents = sharedFilesAccordionPanel_React.createElement(
                "div",
                {
                  className: "chat-dropdown content have-animation"
                },
                sharedNodesContainer,
                self.isLoadingMore
                  ? sharedFilesAccordionPanel_React.createElement(
                      "div",
                      {
                        className: "loading-spinner light small"
                      },
                      sharedFilesAccordionPanel_React.createElement("div", {
                        className: "main-loader"
                      })
                    )
                  : null,
                files.length > 0
                  ? sharedFilesAccordionPanel_React.createElement(
                      "div",
                      {
                        className: "chat-share-nav body"
                      },
                      prev,
                      next,
                      sharedFilesAccordionPanel_React.createElement(
                        "div",
                        {
                          className: "chat-share-nav pages"
                        },
                        (l[19988] ? l[19988] : "Page %1").replace("%1", currentPage + 1)
                      )
                    )
                  : null
              );
            }
            return sharedFilesAccordionPanel_React.createElement(
              "div",
              {
                className: "chat-dropdown container"
              },
              sharedFilesAccordionPanel_React.createElement(
                "div",
                {
                  className: "chat-dropdown header " + (this.props.expanded ? "expanded" : ""),
                  onClick: function (e) {
                    self.props.onToggle(e);
                  }
                },
                sharedFilesAccordionPanel_React.createElement("span", null, this.props.title),
                sharedFilesAccordionPanel_React.createElement("i", {
                  className: "sprite-fm-mono icon-arrow-down"
                })
              ),
              sharedFilesAccordionPanel_React.createElement(
                "div",
                {
                  className: "chat-shared-files-container" + (self.isLoadingMore ? "is-loading" : "")
                },
                contents
              )
            );
          }
        }),
        (0, applyDecoratedDescriptor.Z)(
          _class.prototype,
          "eventuallyRenderThumbnails",
          [_dec],
          Object.getOwnPropertyDescriptor(_class.prototype, "eventuallyRenderThumbnails"),
          _class.prototype
        ),
        _class)); // CONCATENATED MODULE: ./js/chat/ui/incomingSharesAccordionPanel.jsx

      var incomingSharesAccordionPanel_React = __webpack_require__(363);

      class SharedFolderItem extends mixins.wl {
        render() {
          var self = this;
          var node = this.props.node;
          return incomingSharesAccordionPanel_React.createElement(
            "div",
            {
              className: "chat-shared-block incoming " + (self.props.isLoading ? "is-loading" : ""),
              key: node.h,
              onClick: function () {
                M.openFolder(node.h);
              },
              onDoubleClick: function () {
                M.openFolder(node.h);
              }
            },
            incomingSharesAccordionPanel_React.createElement("div", {
              className: "medium-file-icon inbound-share"
            }),
            incomingSharesAccordionPanel_React.createElement(
              "div",
              {
                className: "chat-shared-info"
              },
              incomingSharesAccordionPanel_React.createElement(
                "span",
                {
                  className: "txt"
                },
                node.name
              ),
              incomingSharesAccordionPanel_React.createElement(
                "span",
                {
                  className: "txt small"
                },
                fm_contains(node.tf, node.td)
              )
            )
          );
        }
      }
      class IncSharesAccordionPanel extends mixins.wl {
        componentWillMount() {
          this.hadLoaded = false;
        }
        getContactHandle() {
          var self = this;
          var room = self.props.chatRoom;
          var contactHandle = room.getParticipantsExceptMe()[0];
          if (!contactHandle || room.type !== "private") {
            return {};
          }
          return contactHandle;
        }
        render() {
          var self = this;
          var room = self.props.chatRoom;
          var contactHandle = self.getContactHandle();
          var contents = null;
          if (this.props.expanded) {
            if (!this.hadLoaded) {
              this.hadLoaded = true;
              self.isLoadingMore = true;
              dbfetch.geta(Object.keys(M.c.shares || {}), new MegaPromise()).always(function () {
                self.isLoadingMore = false;
                Soon(function () {
                  if (self.isComponentEventuallyVisible()) {
                    self.safeForceUpdate();
                  }
                }, 5000);
              });
            }
            var incomingSharesContainer = null;
            var sharedFolders = (M.c[contactHandle] && Object.keys(M.c[contactHandle])) || [];
            if (!self.isLoadingMore && (!sharedFolders || sharedFolders.length === 0)) {
              incomingSharesContainer = incomingSharesAccordionPanel_React.createElement(
                "div",
                {
                  className: "chat-dropdown empty-txt"
                },
                l[19986]
              );
            } else {
              var haveMore = sharedFolders.length > 10;
              var defSortFn = M.getSortByNameFn();
              sharedFolders.sort(function (a, b) {
                var nodeA = M.d[a];
                var nodeB = M.d[b];
                return defSortFn(nodeA, nodeB, -1);
              });
              var renderNodes = [];
              for (var i = 0; i < Math.min(sharedFolders.length, 10); i++) {
                var nodeHandle = sharedFolders[i];
                var node = M.d[nodeHandle];
                if (!node) {
                  continue;
                }
                renderNodes.push(
                  incomingSharesAccordionPanel_React.createElement(SharedFolderItem, {
                    key: node.h,
                    isLoading: self.isLoadingMore,
                    node: node,
                    chatRoom: room
                  })
                );
              }
              incomingSharesContainer = incomingSharesAccordionPanel_React.createElement(
                "div",
                null,
                renderNodes,
                haveMore
                  ? incomingSharesAccordionPanel_React.createElement(
                      "div",
                      {
                        className: "chat-share-nav body"
                      },
                      incomingSharesAccordionPanel_React.createElement(
                        "div",
                        {
                          className: "chat-share-nav show-all",
                          onClick: function () {
                            M.openFolder(contactHandle);
                          }
                        },
                        incomingSharesAccordionPanel_React.createElement(
                          "span",
                          {
                            className: "transfer-filetype-icon inbound-share"
                          },
                          incomingSharesAccordionPanel_React.createElement("span", {
                            className: "transfer-filetype-icon inbound-share"
                          })
                        ),
                        incomingSharesAccordionPanel_React.createElement(
                          "span",
                          {
                            className: "txt"
                          },
                          l[19797] ? l[19797] : "Show All"
                        )
                      )
                    )
                  : null
              );
            }
            contents = incomingSharesAccordionPanel_React.createElement(
              "div",
              {
                className: "chat-dropdown content have-animation"
              },
              incomingSharesContainer,
              self.isLoadingMore
                ? incomingSharesAccordionPanel_React.createElement(
                    "div",
                    {
                      className: "chat-dropdown empty-txt"
                    },
                    incomingSharesAccordionPanel_React.createElement(
                      "div",
                      {
                        className: "loading-spinner light small"
                      },
                      incomingSharesAccordionPanel_React.createElement("div", {
                        className: "main-loader"
                      })
                    )
                  )
                : null
            );
          }
          return incomingSharesAccordionPanel_React.createElement(
            "div",
            {
              className: "chat-dropdown container"
            },
            incomingSharesAccordionPanel_React.createElement(
              "div",
              {
                className: "chat-dropdown header " + (this.props.expanded ? "expanded" : ""),
                onClick: function (e) {
                  self.props.onToggle(e);
                }
              },
              incomingSharesAccordionPanel_React.createElement("span", null, this.props.title),
              incomingSharesAccordionPanel_React.createElement("i", {
                className: "sprite-fm-mono icon-arrow-down"
              })
            ),
            incomingSharesAccordionPanel_React.createElement(
              "div",
              {
                className: "chat-shared-files-container" + (self.isLoadingMore ? "is-loading" : "")
              },
              contents
            )
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/chatlinkDialog.jsx

      class ChatlinkDialog extends mixins.wl {
        constructor(props) {
          super(props);
          this.onPopupDidMount = ($node) => {
            this.$popupNode = $node;
          };
          this.onClose = () => {
            if (this.props.onClose) {
              this.props.onClose();
            }
          };
          this.onTopicFieldChanged = (e) => {
            this.setState({
              newTopic: e.target.value
            });
          };
          this.onTopicFieldKeyPress = (e) => {
            if (e.which === 13) {
              this.props.chatRoom.setRoomTitle(this.state.newTopic);
            }
          };
          this.state = {
            link: l[5533],
            newTopic: ""
          };
        }
        componentWillMount() {
          this.retrieveChatLink();
        }
        retrieveChatLink() {
          const { chatRoom } = this.props;
          if (!chatRoom.topic) {
            delete this.loading;
            return;
          }
          this.loading = chatRoom.updatePublicHandle(false, true).always(() => {
            this.loading = false;
            if (this.isMounted()) {
              if (chatRoom.publicLink) {
                this.setState({
                  link: `${getBaseUrl()}/${chatRoom.publicLink}`
                });
              } else {
                this.setState({
                  link: l[20660]
                });
              }
            }
          });
        }
        componentDidUpdate() {
          const { chatRoom } = this.props;
          if (!this.loading && chatRoom.topic) {
            this.retrieveChatLink();
          }
          this.toastTxt = l[7654];
          if (!this.$popupNode) {
            return;
          }
          const $node = this.$popupNode;
          const $copyButton = $(".copy-to-clipboard", $node);
          $copyButton.rebind("click", () => {
            copyToClipboard(this.state.link, this.toastTxt);
            return false;
          });
          $("span", $copyButton).text(l[1990]);
        }
        render() {
          const { chatRoom } = this.props;
          const { newTopic, link } = this.state;
          const closeButton = external_React_default().createElement(
            "button",
            {
              key: "close",
              className: "mega-button negative links-button",
              onClick: this.onClose
            },
            external_React_default().createElement("span", null, l[148])
          );
          return external_React_default().createElement(
            modalDialogs.Z.ModalDialog,
            (0, esm_extends.Z)({}, this.state, {
              title: chatRoom.iAmOperator() && !chatRoom.topic ? (chatRoom.isMeeting ? l.rename_meeting : l[9080]) : "",
              className: `
                    chat-rename-dialog
                    export-chat-links-dialog
                    group-chat-link
                    ${chatRoom.topic ? "" : "requires-topic"}
                `,
              onClose: this.onClose,
              dialogName: "chat-link-dialog",
              dialogType: chatRoom.iAmOperator() && !chatRoom.topic ? "main" : "graphic",
              chatRoom: chatRoom,
              popupDidMount: this.onPopupDidMount
            }),
            chatRoom.iAmOperator() && !chatRoom.topic
              ? external_React_default().createElement(
                  "section",
                  {
                    className: "content"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "content-block"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: "export-chat-ink-warning"
                      },
                      l[20617]
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "rename-input-bl",
                        style: {
                          margin: "10px auto 20px auto"
                        }
                      },
                      external_React_default().createElement("input", {
                        type: "text",
                        name: "newTopic",
                        value: newTopic,
                        style: {
                          paddingLeft: 8
                        },
                        onChange: this.onTopicFieldChanged,
                        onKeyPress: this.onTopicFieldKeyPress,
                        placeholder: l[20616],
                        maxLength: ChatRoom.TOPIC_MAX_LENGTH
                      })
                    )
                  )
                )
              : external_React_default().createElement(
                  external_React_default().Fragment,
                  null,
                  external_React_default().createElement(
                    "header",
                    null,
                    external_React_default().createElement("i", {
                      className: "sprite-fm-uni icon-chat-group"
                    }),
                    external_React_default().createElement(
                      "h2",
                      {
                        id: "chat-link-dialog-title"
                      },
                      external_React_default().createElement(utils.dy, null, chatRoom.getRoomTitle())
                    )
                  ),
                  external_React_default().createElement(
                    "section",
                    {
                      className: "content"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: "content-block"
                      },
                      external_React_default().createElement(
                        "div",
                        {
                          className: "chat-link-input"
                        },
                        external_React_default().createElement("i", {
                          className: "sprite-fm-mono icon-link-small"
                        }),
                        external_React_default().createElement("input", {
                          type: "text",
                          readOnly: true,
                          value: this.loading ? l[5533] : !chatRoom.topic ? l[20660] : link
                        })
                      ),
                      external_React_default().createElement(
                        "div",
                        {
                          className: "info"
                        },
                        chatRoom.publicLink ? l[20644] : null
                      )
                    )
                  )
                ),
            external_React_default().createElement(
              "footer",
              null,
              external_React_default().createElement(
                "div",
                {
                  className: "footer-container"
                },
                chatRoom.iAmOperator() &&
                  chatRoom.publicLink &&
                  external_React_default().createElement(
                    "button",
                    {
                      key: "deleteLink",
                      className: `
                                    mega-button
                                    links-button
                                    ${this.loading ? "disabled" : ""}
                                `,
                      onClick: () => {
                        chatRoom.updatePublicHandle(1);
                        this.onClose();
                      }
                    },
                    external_React_default().createElement("span", null, l[20487])
                  ),
                chatRoom.topic
                  ? chatRoom.publicLink
                    ? external_React_default().createElement(
                        "button",
                        {
                          className: `
                                        mega-button
                                        positive
                                        copy-to-clipboard
                                        ${this.loading ? "disabled" : ""}
                                    `
                        },
                        external_React_default().createElement("span", null, l[63])
                      )
                    : closeButton
                  : chatRoom.iAmOperator()
                  ? external_React_default().createElement(
                      "button",
                      {
                        key: "setTopic",
                        className: `
                                        mega-button
                                        positive
                                        links-button
                                        ${newTopic && $.trim(newTopic) ? "" : "disabled"}
                                    `,
                        onClick: () => chatRoom.iAmOperator() && chatRoom.setRoomTitle(newTopic)
                      },
                      external_React_default().createElement("span", null, l[20615])
                    )
                  : closeButton
              )
            )
          );
        }
      }
      ChatlinkDialog.defaultProps = {
        requiresUpdateOnResize: true,
        disableCheckingVisibility: true
      }; // CONCATENATED MODULE: ./js/chat/ui/pushSettingsDialog.jsx
      var pushSettingsDialog_class;

      class PushSettingsDialog extends mixins.wl {
        constructor(props) {
          super(props);
          this.renderOptions = () => {
            return Object.keys(PushSettingsDialog.options).map((key) => {
              key = parseInt(key, 10) || Infinity;
              return external_React_default().createElement(
                "label",
                {
                  key: key,
                  className: "radio-txt"
                },
                PushSettingsDialog.options[key],
                external_React_default().createElement(
                  "div",
                  {
                    className: "custom-radio small green-active " + (this.state.pushSettingsValue === key ? "radioOn" : "radioOff")
                  },
                  external_React_default().createElement("input", {
                    type: "radio",
                    name: "time-selector",
                    value: key,
                    checked: this.state.pushSettingsValue === key,
                    onChange: () =>
                      this.setState({
                        pushSettingsValue: key
                      })
                  })
                )
              );
            });
          };
          this.state = {
            pushSettingsValue: this.props.pushSettingsValue || Infinity
          };
        }
        render() {
          return external_React_default().createElement(
            modalDialogs.Z.ModalDialog,
            (0, esm_extends.Z)({}, this.state, {
              name: "push-settings",
              title: l.dnd_mute_title,
              subtitle: this.props.room.isMeeting ? l.meeting_dnd_subtitle : l[22015],
              className: "push-settings-dialog",
              dialogName: "push-settings-chat-dialog",
              dialogType: "tool",
              onClose: this.props.onClose
            }),
            external_React_default().createElement(
              "section",
              {
                className: "content"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "content-block"
                },
                external_React_default().createElement("div", null, this.renderOptions())
              )
            ),
            external_React_default().createElement(
              "footer",
              null,
              external_React_default().createElement(
                "div",
                {
                  className: "footer-container"
                },
                external_React_default().createElement(
                  "button",
                  {
                    className: "mega-button",
                    onClick: this.props.onClose
                  },
                  external_React_default().createElement("span", null, l[82])
                ),
                external_React_default().createElement(
                  "button",
                  {
                    className: "mega-button positive",
                    onClick: () => this.props.onConfirm(this.state.pushSettingsValue)
                  },
                  external_React_default().createElement("span", null, l[726])
                )
              )
            )
          );
        }
      }
      pushSettingsDialog_class = PushSettingsDialog;
      PushSettingsDialog.options = {
        30: l[22012],
        60: l[19048],
        360: l[22013],
        1440: l[22014],
        Infinity: l[22011]
      };
      PushSettingsDialog.default = pushSettingsDialog_class.options[pushSettingsDialog_class.options.length - 1];
      // EXTERNAL MODULE: ./js/chat/ui/meetings/call.jsx + 23 modules
      var call = __webpack_require__(689);
      // EXTERNAL MODULE: ./js/chat/ui/historyPanel.jsx + 7 modules
      var historyPanel = __webpack_require__(192);
      // EXTERNAL MODULE: ./js/chat/ui/composedTextArea.jsx + 1 modules
      var composedTextArea = __webpack_require__(813); // CONCATENATED MODULE: ./js/chat/ui/meetings/workflow/loading.jsx
      class Loading extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.PERMISSIONS = {
            VIDEO: "camera",
            AUDIO: "microphone"
          };
          this.state = {
            pendingPermissions: false
          };
          this.queryPermissions = (name) => {
            navigator.permissions
              .query({
                name
              })
              .then((status) => {
                const { name, state } = status;
                status.onchange = () => name === "audio_capture" && this.queryPermissions(this.PERMISSIONS.VIDEO);
                if (state === "prompt") {
                  return (
                    this.isMounted() &&
                    this.setState({
                      pendingPermissions: name
                    })
                  );
                }
              })
              .catch((ex) => console.warn(`Failed to get permissions state: ${ex}`));
          };
          this.renderLoading = () => {
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              external_React_default().createElement(
                "span",
                null,
                external_React_default().createElement("i", {
                  className: "sprite-fm-mono icon-video-call-filled"
                })
              ),
              external_React_default().createElement("h3", null, this.props.title || l[5533]),
              external_React_default().createElement(
                "div",
                {
                  className: "loading-container"
                },
                external_React_default().createElement("div", {
                  className: "loading-indication"
                })
              )
            );
          };
          this.renderDebug = () => {
            const { chatRoom } = this.props;
            if (chatRoom && chatRoom.call) {
              return external_React_default().createElement(
                "div",
                {
                  className: `${Loading.NAMESPACE}-debug`
                },
                external_React_default().createElement("div", null, "callId: ", chatRoom.call.callId),
                external_React_default().createElement("div", null, "roomId: ", chatRoom.roomId),
                external_React_default().createElement("div", null, "isMeeting: ", chatRoom.isMeeting ? "true" : "false")
              );
            }
          };
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          megaChat.unbind(`onLocalMediaQueryError.${Loading.NAMESPACE}`);
        }
        componentDidMount() {
          var _notify, _alarm;
          super.componentDidMount();
          document.dispatchEvent(new Event("closeDropdowns"));
          if ($.dialog) {
            closeDialog == null || closeDialog();
          }
          (_notify = notify) == null || _notify.closePopup();
          (_alarm = alarm) == null || _alarm.hideAllWarningPopups();
          document
            .querySelectorAll(".js-dropdown-account")
            .forEach(({ classList }) => classList.contains("show") && classList.remove("show"));
          const { chatRoom } = this.props;
          const { audio, video } = chatRoom.meetingsLoading;
          const isVideoCall = audio && video;
          if (audio && !video) {
            this.queryPermissions(this.PERMISSIONS.AUDIO);
          }
          if (isVideoCall) {
            Object.values(this.PERMISSIONS).forEach((name) => this.queryPermissions(name));
          }
          megaChat.rebind(`onLocalMediaQueryError.${Loading.NAMESPACE}`, (ev, { type, err }) => {
            if (isVideoCall && type === "mic" && String(err).includes("dismissed")) {
              this.queryPermissions(this.PERMISSIONS.VIDEO);
            }
          });
        }
        render() {
          const { pendingPermissions } = this.state;
          return external_React_default().createElement(
            "div",
            {
              className: Loading.NAMESPACE
            },
            external_React_default().createElement(
              "div",
              {
                className: `${Loading.NAMESPACE}-content`
              },
              pendingPermissions
                ? external_React_default().createElement(
                    "h2",
                    null,
                    pendingPermissions === "audio_capture" ? l.permissions_allow_mic : l.permissions_allow_camera
                  )
                : this.renderLoading()
            ),
            d ? this.renderDebug() : ""
          );
        }
      }
      Loading.NAMESPACE = "meetings-loading";
      // EXTERNAL MODULE: ./js/chat/ui/meetings/button.jsx
      var meetings_button = __webpack_require__(193);
      // EXTERNAL MODULE: ./js/chat/ui/meetings/workflow/preview.jsx
      var preview = __webpack_require__(889);
      // EXTERNAL MODULE: ./js/chat/ui/link.jsx
      var ui_link = __webpack_require__(941); // CONCATENATED MODULE: ./js/chat/ui/meetings/workflow/join.jsx
      class Join extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            preview: false,
            view: Join.VIEW.INITIAL,
            firstName: "",
            lastName: "",
            previewAudio: true,
            previewVideo: false,
            ephemeralDialog: false
          };
          this.handleKeyDown = ({ key }) => {
            var _this$props$onClose, _this$props;
            return key && key === "Escape"
              ? (_this$props$onClose = (_this$props = this.props).onClose) == null
                ? void 0
                : _this$props$onClose.call(_this$props)
              : true;
          };
          this.showPanels = () => {
            return [document.querySelector(".nw-fm-left-icons-panel"), document.querySelector(".chat-app-container")].map(
              (el) => el && el.classList.remove("hidden")
            );
          };
          this.hidePanels = () => {
            return [document.querySelector(".nw-fm-left-icons-panel"), document.querySelector(".chat-app-container")].map(
              (el) => el && el.classList.add("hidden")
            );
          };
          this.showConfirmationDialog = () => {
            megaChat.destroy();
            return mega.ui.sendSignupLinkDialog(JSON.parse(localStorage.awaitingConfirmationAccount), () => {
              delete localStorage.awaitingConfirmationAccount;
              u_logout(true).then(() => location.reload());
            });
          };
          this.Ephemeral = () => {
            const onCancel = () =>
              this.setState({
                ephemeralDialog: false
              });
            const msgFragments = l.ephemeral_data_lost.split(/\[A]|\[\/A]/);
            return external_React_default().createElement(
              modalDialogs.Z.ModalDialog,
              {
                name: "end-ephemeral",
                dialogType: "message",
                icon: "sprite-fm-uni icon-warning",
                title: l.ephemeral_data_lost_title,
                noCloseOnClickOutside: true,
                buttons: [
                  {
                    key: "cancel",
                    label: l[82],
                    onClick: onCancel
                  },
                  {
                    key: "continue",
                    label: l[507],
                    className: "positive",
                    onClick: () => {
                      u_logout(true).then(() => location.reload());
                      sessionStorage.guestForced = true;
                    }
                  }
                ],
                onClose: onCancel
              },
              external_React_default().createElement(
                "p",
                null,
                msgFragments[0],
                external_React_default().createElement(
                  ui_link.Z,
                  {
                    to: "/register",
                    onClick: () => loadSubPage("register")
                  },
                  msgFragments[1]
                ),
                msgFragments[2]
              )
            );
          };
          this.Head = () => {
            var _this$props$chatRoom;
            return external_React_default().createElement(
              "div",
              {
                className: `${Join.NAMESPACE}-head`
              },
              external_React_default().createElement(
                "div",
                {
                  className: `${Join.NAMESPACE}-logo`
                },
                external_React_default().createElement("i", {
                  className: `
                            sprite-fm-illustration-wide
                            ${document.body.classList.contains("theme-dark") ? "mega-logo-dark" : "img-mega-logo-light"}
                        `
                })
              ),
              external_React_default().createElement(
                "h1",
                null,
                external_React_default().createElement(
                  utils.dy,
                  null,
                  l.you_have_invitation.replace(
                    "%1",
                    (_this$props$chatRoom = this.props.chatRoom) == null ? void 0 : _this$props$chatRoom.topic
                  )
                )
              ),
              isEphemeral() &&
                external_React_default().createElement(
                  "div",
                  {
                    className: "ephemeral-info"
                  },
                  external_React_default().createElement("i", {
                    className: "sprite-fm-uni icon-warning"
                  }),
                  external_React_default().createElement("p", null, l.ephemeral_data_store_lost)
                )
            );
          };
          this.Intro = () => {
            const $$CONTAINER = ({ children }) =>
              external_React_default().createElement(
                external_React_default().Fragment,
                null,
                external_React_default().createElement(
                  "div",
                  {
                    className: `${Join.NAMESPACE}-content`
                  },
                  children
                ),
                this.Chat()
              );
            if (isEphemeral()) {
              return external_React_default().createElement(
                $$CONTAINER,
                null,
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    className: "mega-button positive",
                    onClick: () =>
                      this.setState({
                        ephemeralDialog: true
                      })
                  },
                  l.join_as_guest
                ),
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    className: "mega-button",
                    onClick: () => loadSubPage("register")
                  },
                  l[5582]
                ),
                external_React_default().createElement(
                  "span",
                  null,
                  l[5585],
                  external_React_default().createElement(
                    "a",
                    {
                      href: "#",
                      onClick: () =>
                        mega.ui
                          .showLoginRequiredDialog({
                            minUserType: 3,
                            skipInitialDialog: 1
                          })
                          .done(() =>
                            this.setState({
                              view: Join.VIEW.ACCOUNT
                            })
                          )
                    },
                    l[171]
                  )
                )
              );
            }
            return external_React_default().createElement(
              $$CONTAINER,
              null,
              external_React_default().createElement(
                meetings_button.Z,
                {
                  className: "mega-button positive",
                  onClick: () =>
                    this.setState({
                      view: Join.VIEW.GUEST
                    })
                },
                l.join_as_guest
              ),
              external_React_default().createElement(
                meetings_button.Z,
                {
                  className: "mega-button",
                  onClick: () => {
                    var _this$props$chatRoom2;
                    megaChat.loginOrRegisterBeforeJoining(
                      (_this$props$chatRoom2 = this.props.chatRoom) == null ? void 0 : _this$props$chatRoom2.publicChatHandle,
                      false,
                      true,
                      undefined,
                      () =>
                        this.setState({
                          view: Join.VIEW.ACCOUNT
                        })
                    );
                  }
                },
                l[171]
              ),
              external_React_default().createElement(
                "p",
                null,
                external_React_default().createElement(
                  utils.Cw,
                  {
                    onClick: (e) => {
                      e.preventDefault();
                      megaChat.loginOrRegisterBeforeJoining(this.props.chatRoom.publicChatHandle, true, undefined, undefined, () =>
                        this.setState({
                          view: Join.VIEW.ACCOUNT
                        })
                      );
                    }
                  },
                  l[20635]
                )
              )
            );
          };
          this.Chat = () => {
            const { chatRoom } = this.props;
            const { preview } = this.state;
            return external_React_default().createElement(
              "div",
              {
                className: `
                    ${Join.NAMESPACE}-chat
                    ${preview ? "expanded" : ""}
                `
              },
              external_React_default().createElement(
                "div",
                {
                  className: "chat-content"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "chat-content-head",
                    onClick: () =>
                      this.setState({
                        preview: !preview
                      })
                  },
                  external_React_default().createElement(utils.dy, null, chatRoom.topic),
                  external_React_default().createElement(meetings_button.Z, {
                    icon: "icon-minimise"
                  })
                ),
                preview &&
                  external_React_default().createElement(
                    "div",
                    {
                      className: "chat-body"
                    },
                    external_React_default().createElement(historyPanel.Z, {
                      chatRoom: chatRoom,
                      onMount: (cmp) => cmp.messagesListScrollable.scrollToBottom()
                    })
                  )
              )
            );
          };
          this.Card = ({ children }) => {
            const { previewAudio, previewVideo } = this.state;
            return external_React_default().createElement(
              "div",
              {
                className: "card"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "card-body"
                },
                children,
                external_React_default().createElement(
                  "div",
                  null,
                  external_React_default().createElement(
                    ui_link.Z,
                    {
                      to: "https://mega.io/chatandmeetings",
                      target: "_blank"
                    },
                    l.how_meetings_work
                  )
                )
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "card-preview"
                },
                external_React_default().createElement(preview.Z, {
                  audio: previewAudio,
                  video: previewVideo,
                  context: Join.NAMESPACE,
                  onToggle: (audio, video) =>
                    this.setState({
                      previewAudio: audio,
                      previewVideo: video
                    })
                })
              )
            );
          };
          this.Field = ({ name, children }) => {
            var _this$state$name;
            return external_React_default().createElement(
              "div",
              {
                className: `
                    mega-input
                    title-ontop
                    ${(_this$state$name = this.state[name]) != null && _this$state$name.length ? "valued" : ""}
                `
              },
              external_React_default().createElement(
                "div",
                {
                  className: "mega-input-title"
                },
                children,
                external_React_default().createElement(
                  "span",
                  {
                    className: "required-red"
                  },
                  "*"
                )
              ),
              external_React_default().createElement("input", {
                type: "text",
                name: name,
                className: "titleTop required megaInputs",
                placeholder: children,
                value: this.state[name] || "",
                maxLength: 40,
                onChange: (ev) =>
                  this.setState({
                    [name]: ev.target.value
                  })
              })
            );
          };
          this.Guest = () =>
            external_React_default().createElement(
              this.Card,
              null,
              external_React_default().createElement("h2", null, l.enter_name_join_meeting),
              external_React_default().createElement(
                "div",
                {
                  className: "card-fields"
                },
                external_React_default().createElement(
                  this.Field,
                  {
                    name: "firstName"
                  },
                  l[1096]
                ),
                external_React_default().createElement(
                  this.Field,
                  {
                    name: "lastName"
                  },
                  l[1097]
                )
              ),
              external_React_default().createElement(
                meetings_button.Z,
                {
                  className: `
                    mega-button
                    positive
                    large
                    ${this.state.firstName.length && this.state.lastName.length ? "" : "disabled"}
                    ${this.state.joining && " loading disabled"}
                `,
                  onClick: () => {
                    if (this.state.joining) {
                      return;
                    }
                    let { firstName, lastName, previewAudio, previewVideo } = this.state;
                    firstName = firstName && firstName.trim();
                    lastName = lastName && lastName.trim();
                    if (firstName && lastName && firstName.length > 0 && lastName.length > 0) {
                      this.setState({
                        joining: true
                      });
                      this.props.onJoinGuestClick(firstName, lastName, previewAudio, previewVideo);
                    }
                  }
                },
                l.join_chat_button
              )
            );
          this.Account = () =>
            external_React_default().createElement(
              this.Card,
              null,
              external_React_default().createElement("h4", null, l.join_meeting),
              external_React_default().createElement(
                meetings_button.Z,
                {
                  className: `mega-button positive large ${this.state.joining && " loading disabled"}`,
                  onClick: () => {
                    if (!this.state.joining) {
                      this.setState({
                        joining: true
                      });
                      this.props.onJoinClick(this.state.previewAudio, this.state.previewVideo);
                    }
                  }
                },
                l.join_chat_button
              )
            );
          this.Unsupported = () =>
            external_React_default().createElement(
              "div",
              {
                className: "meetings-unsupported-container"
              },
              external_React_default().createElement("i", {
                className: "sprite-fm-uni icon-error"
              }),
              external_React_default().createElement(
                "div",
                {
                  className: "unsupported-info"
                },
                external_React_default().createElement("h3", null, l.heading_unsupported_browser),
                external_React_default().createElement("h3", null, l.join_meeting_methods),
                external_React_default().createElement(
                  "ul",
                  null,
                  external_React_default().createElement("li", null, l.join_via_link),
                  external_React_default().createElement(
                    "li",
                    null,
                    external_React_default().createElement(
                      utils.Cw,
                      null,
                      l.join_via_mobile
                        .replace("[A]", '<a href="https://mega.io/mobile" target="_blank" class="clickurl">')
                        .replace("[/A]", "</a>")
                    )
                  )
                )
              )
            );
          this.View = (view) => {
            switch (view) {
              default:
                return this.Intro();
              case Join.VIEW.GUEST:
                return this.Guest();
              case Join.VIEW.ACCOUNT:
                return this.Account();
              case Join.VIEW.UNSUPPORTED:
                return this.Unsupported();
            }
          };
          this.state.view = sessionStorage.guestForced ? Join.VIEW.GUEST : props.initialView || this.state.view;
          if (localStorage.awaitingConfirmationAccount) {
            this.showConfirmationDialog();
          }
        }
        componentDidMount() {
          super.componentDidMount();
          document.addEventListener("keydown", this.handleKeyDown);
          this.hidePanels();
          megaChat._joinDialogIsShown = true;
          alarm.hideAllWarningPopups();
          sessionStorage.removeItem("guestForced");
          if (!megaChat.hasSupportForCalls) {
            this.setState({
              view: Join.VIEW.UNSUPPORTED
            });
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          document.removeEventListener("keydown", this.handleKeyDown);
          this.showPanels();
          megaChat._joinDialogIsShown = false;
          if (this.props.onClose) {
            this.props.onClose();
          }
        }
        render() {
          const { view, ephemeralDialog } = this.state;
          return external_React_default().createElement(
            utils.ZP.RenderTo,
            {
              element: document.body
            },
            external_React_default().createElement(
              "div",
              {
                className: Join.NAMESPACE
              },
              this.Head(),
              this.View(view),
              ephemeralDialog && external_React_default().createElement(this.Ephemeral, null)
            )
          );
        }
      }
      Join.NAMESPACE = "join-meeting";
      Join.VIEW = {
        INITIAL: 0,
        GUEST: 1,
        ACCOUNT: 2,
        UNSUPPORTED: 4
      }; // CONCATENATED MODULE: ./js/chat/ui/meetings/workflow/alert.jsx
      const NAMESPACE = "meetings-alert";
      class Alert extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.alertRef = external_React_default().createRef();
        }
        componentWillUnmount() {
          var _this$props$onTransit, _this$props;
          super.componentWillUnmount();
          (_this$props$onTransit = (_this$props = this.props).onTransition) == null || _this$props$onTransit.call(_this$props);
        }
        componentDidUpdate() {
          var _this$props$onTransit2, _this$props2;
          super.componentDidUpdate();
          (_this$props$onTransit2 = (_this$props2 = this.props).onTransition) == null ||
            _this$props$onTransit2.call(_this$props2, this.alertRef);
        }
        componentDidMount() {
          var _this$props$onTransit3, _this$props3;
          super.componentDidMount();
          (_this$props$onTransit3 = (_this$props3 = this.props).onTransition) == null ||
            _this$props$onTransit3.call(_this$props3, this.alertRef);
        }
        render() {
          const { type, className, content, children, onClose } = this.props;
          if (content || children) {
            return external_React_default().createElement(
              "div",
              {
                ref: this.alertRef,
                className: `
                        ${NAMESPACE}
                        ${type ? `${NAMESPACE}-${type}` : ""}
                        ${className || ""}
                    `
              },
              external_React_default().createElement(
                "div",
                {
                  className: `${NAMESPACE}-content`
                },
                content || children
              ),
              onClose &&
                external_React_default().createElement(
                  "span",
                  {
                    className: `${NAMESPACE}-close`,
                    onClick: onClose
                  },
                  external_React_default().createElement("i", {
                    className: "sprite-fm-mono icon-close-component"
                  })
                )
            );
          }
          return null;
        }
      }
      Alert.TYPE = {
        LIGHT: "light",
        NEUTRAL: "neutral",
        MEDIUM: "medium",
        HIGH: "high"
      };
      // EXTERNAL MODULE: ./js/chat/ui/meetings/schedule/helpers.jsx
      var helpers = __webpack_require__(435);
      // EXTERNAL MODULE: ./js/chat/ui/meetings/hostsObserver.jsx
      var hostsObserver = __webpack_require__(419); // CONCATENATED MODULE: ./js/chat/ui/meetings/waitingRoom/waitingRoom.jsx
      const waitingRoom_NAMESPACE = "waiting-room";
      const VIEW = {
        INTRO: 0,
        ACCOUNT: 1,
        GUEST: 2,
        AWAIT: 3,
        UNSUPPORTED: 4,
        REDIRECT: 5
      };
      class WaitingRoom extends mixins.wl {
        constructor(props) {
          super(props);
          this.redirectInterval = undefined;
          this.state = {
            view: VIEW.ACCOUNT,
            call: false,
            audio: false,
            video: false,
            firstName: "",
            lastName: "",
            countdown: 4,
            loading: false
          };
          this.renderLeaveDialog = () =>
            msgDialog(
              `confirmation:!^${l.wr_leave}!${l.wr_do_not_leave}`,
              null,
              l.wr_leave_confirmation,
              "",
              (cb) => cb && this.doLeave(),
              1
            );
          this.renderDeniedDialog = () => msgDialog("error", "", l.wr_denied, l.wr_denied_details, this.doLeave);
          this.renderTimeoutDialog = () => msgDialog("error", "", l.wr_timeout, l.wr_timeout_details, this.doLeave);
          this.renderWaitingRoomInfo = () => {
            const { chatRoom } = this.props;
            const { nextOccurrenceStart, nextOccurrenceEnd } = chatRoom.scheduledMeeting || {};
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              external_React_default().createElement(utils.Cw, {
                tag: "h2",
                content: megaChat.html(chatRoom.topic)
              }),
              external_React_default().createElement(
                "div",
                {
                  className: `${waitingRoom_NAMESPACE}-schedule`
                },
                external_React_default().createElement("span", null, time2date(nextOccurrenceStart / 1000, 20)),
                external_React_default().createElement(
                  "span",
                  null,
                  toLocaleTime(nextOccurrenceStart),
                  " - ",
                  toLocaleTime(nextOccurrenceEnd)
                )
              )
            );
          };
          this.doLeave = () =>
            this.setState(
              {
                view: VIEW.REDIRECT
              },
              () => {
                tSleep(this.state.countdown).then(() => this.props.onWaitingRoomLeave());
                this.redirectInterval = setInterval(
                  () =>
                    this.setState(({ countdown }) => ({
                      countdown: countdown > 0 ? countdown - 1 : 0
                    })),
                  1e3
                );
                sessionStorage.removeItem("previewMedia");
              }
            );
          this.setInitialView = () => {
            if (u_type || is_eplusplus) {
              var _this$props$chatRoom;
              return (_this$props$chatRoom = this.props.chatRoom) != null && _this$props$chatRoom.iAmInRoom() ? VIEW.AWAIT : VIEW.ACCOUNT;
            }
            return VIEW.INTRO;
          };
          this.requestJoin = () => {
            var _this$props$chatRoom2;
            const { audio, video } = this.state;
            (_this$props$chatRoom2 = this.props.chatRoom) == null || _this$props$chatRoom2.joinCall(audio, video);
          };
          this.Field = ({ name, children }) => {
            var _this$state$name;
            return external_React_default().createElement(
              "div",
              {
                className: `
                    mega-input
                    title-ontop
                    ${(_this$state$name = this.state[name]) != null && _this$state$name.length ? "valued" : ""}
                `
              },
              external_React_default().createElement(
                "div",
                {
                  className: "mega-input-title"
                },
                children,
                external_React_default().createElement(
                  "span",
                  {
                    className: "required-red"
                  },
                  "*"
                )
              ),
              external_React_default().createElement("input", {
                type: "text",
                name: name,
                className: "titleTop required megaInputs",
                placeholder: children,
                value: this.state[name] || "",
                maxLength: 40,
                onChange: (ev) =>
                  this.setState({
                    [name]: ev.target.value
                  })
              })
            );
          };
          this.Card = ({ className, children }) => {
            const { audio, video } = this.state;
            return external_React_default().createElement(
              "div",
              {
                className: `
                    card
                    ${className || ""}
                 `
              },
              external_React_default().createElement(
                "div",
                {
                  className: "card-body"
                },
                children
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "card-preview"
                },
                external_React_default().createElement(preview.Z, {
                  audio: audio,
                  video: video,
                  onToggle: (audio, video) => {
                    this.setState(
                      {
                        audio,
                        video
                      },
                      () => {
                        sessionStorage.previewMedia = JSON.stringify({
                          audio,
                          video
                        });
                      }
                    );
                  }
                })
              )
            );
          };
          this.Head = ({ title }) => {
            var _this$props$chatRoom3;
            const hasDarkMode = Object.values(document.body.classList).some((c) => c === "theme-dark" || c === "theme-dark-forced");
            return external_React_default().createElement(
              "div",
              {
                className: `${waitingRoom_NAMESPACE}-head`
              },
              external_React_default().createElement(
                "div",
                {
                  className: `${waitingRoom_NAMESPACE}-logo`
                },
                external_React_default().createElement("i", {
                  className: `
                        sprite-fm-illustration-wide
                        ${hasDarkMode ? "mega-logo-dark" : "img-mega-logo-light"}
                    `
                })
              ),
              external_React_default().createElement(
                "h1",
                {
                  className: (megaChat.initialChatId || is_chatlink) && this.state.view !== VIEW.INTRO ? "hidden" : ""
                },
                external_React_default().createElement(
                  utils.dy,
                  null,
                  title ||
                    l.you_have_invitation.replace(
                      "%1",
                      (_this$props$chatRoom3 = this.props.chatRoom) == null ? void 0 : _this$props$chatRoom3.topic
                    )
                )
              )
            );
          };
          this.Await = () => {
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              megaChat.initialChatId ? external_React_default().createElement(this.Head, null) : null,
              external_React_default().createElement(
                this.Card,
                {
                  className: megaChat.initialChatId ? "" : "fit-spacing"
                },
                this.renderWaitingRoomInfo(),
                external_React_default().createElement(
                  "div",
                  {
                    className: `${waitingRoom_NAMESPACE}-message`
                  },
                  this.state.call ? l.wr_wait_to_admit : l.wr_wait_to_start
                ),
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    icon: "sprite-fm-mono icon-log-out-thin-solid",
                    className: `${waitingRoom_NAMESPACE}-leave`,
                    onClick: () => this.renderLeaveDialog()
                  },
                  l.wr_leave
                )
              )
            );
          };
          this.Account = () => {
            const { loading, audio, video } = this.state;
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              external_React_default().createElement(this.Head, null),
              external_React_default().createElement(
                this.Card,
                null,
                this.renderWaitingRoomInfo(),
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    className: `
                           mega-button
                           positive
                           large
                           ${loading ? "disabled" : ""}
                        `,
                    onClick: () => {
                      return loading
                        ? null
                        : this.setState(
                            {
                              loading: true
                            },
                            () => {
                              const { chatRoom } = this.props;
                              const { chatId, publicChatHandle, publicChatKey } = chatRoom;
                              if (chatRoom.iAmInRoom()) {
                                return megaChat.routing
                                  .reinitAndOpenExistingChat(chatId, publicChatHandle)
                                  .then(() => {
                                    megaChat.getChatById(chatId).joinCall(audio, video);
                                  })
                                  .catch((ex) => console.error(`Failed to open existing room and join call: ${ex}`));
                              }
                              megaChat.routing
                                .reinitAndJoinPublicChat(chatId, publicChatHandle, publicChatKey)
                                .then(() => {
                                  delete megaChat.initialPubChatHandle;
                                })
                                .catch((ex) => console.error(`Failed to join room: ${ex}`));
                            }
                          );
                    }
                  },
                  l.wr_ask_to_join
                ),
                external_React_default().createElement(
                  "div",
                  null,
                  external_React_default().createElement(
                    ui_link.Z,
                    {
                      to: "https://mega.io/chatandmeetings",
                      target: "_blank"
                    },
                    l.how_meetings_work
                  )
                )
              )
            );
          };
          this.Redirect = () =>
            external_React_default().createElement(
              external_React_default().Fragment,
              null,
              external_React_default().createElement(this.Head, {
                title: l.wr_left_heading
              }),
              external_React_default().createElement("h5", null, l.wr_left_countdown.replace("%1", this.state.countdown))
            );
          this.Guest = () => {
            const { chatRoom } = this.props;
            const { loading, firstName, lastName } = this.state;
            const isDisabled = !firstName.length || !lastName.length;
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              external_React_default().createElement(this.Head, null),
              external_React_default().createElement(
                this.Card,
                null,
                this.renderWaitingRoomInfo(),
                external_React_default().createElement(
                  "div",
                  {
                    className: "card-fields"
                  },
                  external_React_default().createElement(
                    this.Field,
                    {
                      name: "firstName"
                    },
                    l[1096]
                  ),
                  external_React_default().createElement(
                    this.Field,
                    {
                      name: "lastName"
                    },
                    l[1097]
                  )
                ),
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    className: `
                            mega-button
                            positive
                            large
                            ${isDisabled || loading ? "disabled" : ""}
                        `,
                    onClick: () => {
                      if (isDisabled || loading) {
                        return false;
                      }
                      return this.setState(
                        {
                          loading: true
                        },
                        () => {
                          u_eplusplus(this.state.firstName, this.state.lastName)
                            .then(() => {
                              return megaChat.routing.reinitAndJoinPublicChat(
                                chatRoom.chatId,
                                chatRoom.publicChatHandle,
                                chatRoom.publicChatKey
                              );
                            })
                            .catch((ex) => d && console.error(`E++ account failure: ${ex}`));
                        }
                      );
                    }
                  },
                  l.wr_ask_to_join
                ),
                external_React_default().createElement(
                  "div",
                  null,
                  external_React_default().createElement(
                    ui_link.Z,
                    {
                      to: "https://mega.io/chatandmeetings",
                      target: "_blank"
                    },
                    l.how_meetings_work
                  )
                )
              )
            );
          };
          this.Intro = () => {
            const { chatRoom } = this.props;
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              external_React_default().createElement(this.Head, null),
              external_React_default().createElement(
                "div",
                {
                  className: "join-meeting-content"
                },
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    className: "mega-button positive",
                    onClick: () => {
                      megaChat.loginOrRegisterBeforeJoining(chatRoom.publicChatHandle, false, true, undefined, () =>
                        this.setState({
                          view: VIEW.ACCOUNT
                        })
                      );
                    }
                  },
                  l[171]
                ),
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    className: "mega-button",
                    onClick: () =>
                      this.setState({
                        view: VIEW.GUEST
                      })
                  },
                  l.join_as_guest
                ),
                external_React_default().createElement(
                  "p",
                  null,
                  external_React_default().createElement(
                    utils.Cw,
                    {
                      onClick: (e) => {
                        e.preventDefault();
                        megaChat.loginOrRegisterBeforeJoining(chatRoom.publicChatHandle, true, undefined, undefined, () =>
                          this.setState({
                            view: VIEW.ACCOUNT
                          })
                        );
                      }
                    },
                    l[20635]
                  )
                )
              )
            );
          };
          this.Unsupported = () => {
            var _this$props$chatRoom4;
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              external_React_default().createElement(this.Head, null),
              external_React_default().createElement(
                "h1",
                null,
                l.you_have_invitation.replace(
                  "%1",
                  (_this$props$chatRoom4 = this.props.chatRoom) == null ? void 0 : _this$props$chatRoom4.topic
                )
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "meetings-unsupported-container"
                },
                external_React_default().createElement("i", {
                  className: "sprite-fm-uni icon-error"
                }),
                external_React_default().createElement(
                  "div",
                  {
                    className: "unsupported-info"
                  },
                  external_React_default().createElement("h3", null, l.heading_unsupported_browser),
                  external_React_default().createElement("h3", null, l.join_meeting_methods),
                  external_React_default().createElement(
                    "ul",
                    null,
                    external_React_default().createElement("li", null, l.join_via_link),
                    external_React_default().createElement(
                      "li",
                      null,
                      external_React_default().createElement(
                        utils.Cw,
                        null,
                        l.join_via_mobile
                          .replace("[A]", '<a href="https://mega.io/mobile" target="_blank" class="clickurl">')
                          .replace("[/A]", "</a>")
                      )
                    )
                  )
                )
              )
            );
          };
          this.renderView = (view) => {
            switch (view) {
              default:
                return this.Await();
              case VIEW.INTRO:
                return this.Intro();
              case VIEW.GUEST:
                return this.Guest();
              case VIEW.ACCOUNT:
                return this.Account();
              case VIEW.REDIRECT:
                return this.Redirect();
              case VIEW.UNSUPPORTED:
                return this.Unsupported();
            }
          };
          this.state.call = this.props.havePendingCall;
          this.state.view = megaChat.hasSupportForCalls ? this.setInitialView() : VIEW.UNSUPPORTED;
          if (sessionStorage.previewMedia) {
            const { audio, video } = JSON.parse(sessionStorage.previewMedia);
            this.state.audio = audio;
            this.state.video = video;
            sessionStorage.removeItem("previewMedia");
          }
        }
        componentWillReceiveProps(nextProps) {
          if (this.props.havePendingCall !== nextProps.havePendingCall) {
            this.setState(
              {
                call: nextProps.havePendingCall
              },
              () => this.state.view === VIEW.AWAIT && nextProps.havePendingCall && this.requestJoin()
            );
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          clearInterval(this.redirectInterval);
          this.props.chatRoom.unbind(`onCallLeft.${waitingRoom_NAMESPACE}`);
        }
        componentDidMount() {
          super.componentDidMount();
          const { chatRoom } = this.props;
          const { call, view } = this.state;
          if (call && view === VIEW.AWAIT) {
            this.requestJoin();
          }
          chatRoom.rebind(`onCallLeft.${waitingRoom_NAMESPACE}`, (ev, { termCode }) => {
            if (termCode === SfuClient.TermCode.kKickedFromWaitingRoom) {
              return this.renderDeniedDialog();
            }
            if (termCode === SfuClient.TermCode.kWaitingRoomAllowTimeout) {
              return this.renderTimeoutDialog();
            }
          });
          chatRoom.rebind(`onModeratorAdd.${waitingRoom_NAMESPACE}`, (ev, user) => {
            if (user === u_handle) {
              chatRoom.meetingsLoading = false;
              this.requestJoin();
            }
          });
        }
        render() {
          const { view } = this.state;
          return external_React_default().createElement(
            utils.ZP.RenderTo,
            {
              element: document.body
            },
            external_React_default().createElement(
              "div",
              {
                className: `
                        ${waitingRoom_NAMESPACE}
                        join-meeting
                        ${view === VIEW.AWAIT ? `${waitingRoom_NAMESPACE}--await` : ""}
                        ${view === VIEW.AWAIT && !megaChat.initialChatId ? "theme-dark-forced" : ""}
                        ${view === VIEW.REDIRECT ? `${waitingRoom_NAMESPACE}--redirect` : ""}
                        ${megaChat.initialChatId || is_chatlink ? `${waitingRoom_NAMESPACE}--chatlink-landing` : ""}
                    `
              },
              this.renderView(view)
            )
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/conversationpanel.jsx
      var conversationpanel_dec, _dec2, _class4;

      const ENABLE_GROUP_CALLING_FLAG = true;
      const MAX_USERS_CHAT_PRIVATE = 100;
      class EndCallButton extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.IS_MODERATOR = call.ZP.isModerator(this.props.chatRoom, u_handle);
          this.EVENTS = ["onCallPeerJoined.endCallButton", "onCallPeerLeft.endCallButton"];
          this.LeaveButton = (0, hostsObserver.N)(({ hasHost, chatRoom, confirmLeave, onLeave }) => {
            return external_React_default().createElement(dropdowns.DropdownItem, {
              className: "link-button",
              icon: "sprite-fm-mono icon-leave-call",
              label: l.leave,
              persistent: true,
              onClick: () =>
                hasHost(chatRoom.getCallParticipants())
                  ? onLeave()
                  : confirmLeave({
                      title: l.assign_host_leave_call,
                      body: l.assign_host_leave_call_details,
                      cta: l.assign_host_button
                    })
            });
          });
        }
        shouldComponentUpdate() {
          return true;
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          this.EVENTS.map((ev) => this.props.chatRoom.unbind(ev));
        }
        componentDidMount() {
          super.componentDidMount();
          this.EVENTS.map((ev) => this.props.chatRoom.rebind(ev, () => this.safeForceUpdate()));
        }
        renderButton({ label, onClick, children = null, disabled }) {
          return external_React_default().createElement(
            buttons.z,
            {
              className: `
                    link-button
                    light
                    red
                    dropdown-element
                    ${disabled ? "disabled" : ""}
                `,
              icon: "small-icon colorized horizontal-red-handset",
              label: label,
              onClick: disabled ? null : onClick
            },
            children
          );
        }
        render() {
          const { chatRoom } = this.props;
          const { type, call } = chatRoom;
          if (call) {
            const peers = call.peers && call.peers.length;
            if (type === "private") {
              return this.renderButton({
                label: l[5884],
                onClick: () => call.hangUp()
              });
            }
            if (this.IS_MODERATOR) {
              return this.renderButton({
                label: l[5884],
                onClick: peers ? null : () => call.hangUp(),
                children:
                  peers &&
                  external_React_default().createElement(
                    dropdowns.Dropdown,
                    {
                      className: "wide-dropdown light end-call-selector",
                      noArrow: "true",
                      vertOffset: 4,
                      horizOffset: 0
                    },
                    external_React_default().createElement(this.LeaveButton, {
                      chatRoom: chatRoom,
                      participants: chatRoom.getCallParticipants(),
                      onLeave: () => call.hangUp()
                    }),
                    external_React_default().createElement(dropdowns.DropdownItem, {
                      className: "link-button",
                      icon: "sprite-fm-mono icon-contacts",
                      label: l.end_for_all,
                      onClick: () => chatRoom.endCallForAll()
                    })
                  )
              });
            }
            return this.renderButton({
              label: peers ? l[5883] : l[5884],
              onClick: () => call.hangUp()
            });
          }
          if (chatRoom.havePendingGroupCall()) {
            return this.IS_MODERATOR
              ? this.renderButton({
                  label: l.end_call_for_all,
                  onClick: () =>
                    msgDialog("confirmation", null, l.end_call_for_all_title, l.end_call_for_all_text, (cb) =>
                      cb ? chatRoom.endCallForAll() : 0xdead
                    ),
                  disabled: !chatRoom.iAmInRoom()
                })
              : null;
          }
          return null;
        }
      }
      class StartMeetingNotification extends mixins.wl {
        customIsEventuallyVisible() {
          return this.props.chatRoom.isCurrentlyActive;
        }
        render() {
          const { chatRoom, offset, onWaitingRoomJoin, onStartCall } = this.props;
          if (chatRoom.call || !megaChat.hasSupportForCalls) {
            return null;
          }
          return external_React_default().createElement(
            "div",
            {
              className: "in-call-notif neutral start",
              style: {
                marginTop: offset
              },
              onClick: () => {
                if (chatRoom.options.w && !chatRoom.iAmOperator()) {
                  return onWaitingRoomJoin();
                }
                return onStartCall(call.wD.AUDIO);
              }
            },
            external_React_default().createElement(
              "button",
              {
                className: "mega-button positive small"
              },
              l.schedule_start_aot
            )
          );
        }
      }
      class JoinCallNotification extends mixins.wl {
        customIsEventuallyVisible() {
          return this.props.chatRoom.isCurrentlyActive;
        }
        render() {
          const { chatRoom, offset } = this.props;
          if (chatRoom.call) {
            return null;
          }
          if (!megaChat.hasSupportForCalls) {
            return external_React_default().createElement(Alert, {
              type: Alert.TYPE.MEDIUM,
              content: l.active_call_not_supported
            });
          }
          return external_React_default().createElement(
            "div",
            {
              className: "in-call-notif neutral join",
              style: {
                marginTop: offset
              }
            },
            external_React_default().createElement("i", {
              className: "sprite-fm-mono icon-phone"
            }),
            external_React_default().createElement(
              utils.Cw,
              {
                onClick: () => {
                  return (0, call.xt)(true, chatRoom)
                    .then(() => chatRoom.joinCall())
                    .catch((ex) => d && console.warn("Already in a call.", ex));
                }
              },
              (l[20460] || "There is an active group call. [A]Join[/A]")
                .replace("[A]", '<button class="mega-button positive joinActiveCall small">')
                .replace("[/A]", "</button>")
            )
          );
        }
      }
      const allContactsInChat = (participants) => {
        var currentContacts = M.u.keys();
        for (var i = 0; i < currentContacts.length; i++) {
          var k = currentContacts[i];
          if (M.u[k].c === 1 && !participants.includes(k)) {
            return false;
          }
        }
        return true;
      };
      const excludedParticipants = (room) => {
        const excParticipants =
          room.type === "group" || room.type === "public"
            ? room.members && Object.keys(room.members).length > 0
              ? Object.keys(room.members)
              : room.getParticipants()
            : room.getParticipants();
        if (excParticipants.includes(u_handle)) {
          array.remove(excParticipants, u_handle, false);
        }
        return excParticipants;
      };
      class Occurrences extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.loadingMore = false;
          this.state = {
            editDialog: false,
            occurrenceId: undefined
          };
        }
        loadOccurrences() {
          if (!this.loadingMore) {
            const { scheduledMeeting, occurrences } = this.props;
            const occurrenceItems = Object.values(occurrences || {});
            const lastOccurrence = occurrenceItems[occurrenceItems.length - 1];
            if (lastOccurrence) {
              this.loadingMore = true;
              scheduledMeeting
                .getOccurrences({
                  from: lastOccurrence.start
                })
                .catch(dump)
                .finally(() => {
                  this.loadingMore = false;
                });
            }
          }
        }
        renderCancelConfirmation(occurrence) {
          const { scheduledMeeting, chatRoom } = this.props;
          const nextOccurrences = Object.values(scheduledMeeting.occurrences).filter((o) => o.isUpcoming);
          if (nextOccurrences.length > 1) {
            return msgDialog(
              `confirmation:!^${l.cancel_meeting_occurrence_button}!${l.schedule_cancel_abort}`,
              "cancel-occurrence",
              l.schedule_cancel_occur_dlg_title,
              l.schedule_cancel_occur_dlg_text,
              (cb) => cb && occurrence.cancel(),
              1
            );
          }
          return chatRoom.hasUserMessages()
            ? msgDialog(
                `confirmation:!^${l.cancel_meeting_button}!${l.schedule_cancel_abort}`,
                "cancel-occurrence",
                l.schedule_cancel_all_dialog_title,
                l.schedule_cancel_all_dialog_move,
                (cb) => cb && megaChat.plugins.meetingsManager.cancelMeeting(scheduledMeeting, scheduledMeeting.chatId),
                1
              )
            : msgDialog(
                `confirmation:!^${l.cancel_meeting_button}!${l.schedule_cancel_abort}`,
                "cancel-occurrence",
                l.schedule_cancel_all_dialog_title,
                l.schedule_cancel_all_dialog_archive,
                (cb) => cb && megaChat.plugins.meetingsManager.cancelMeeting(scheduledMeeting, scheduledMeeting.chatId),
                1
              );
        }
        renderLoading() {
          return external_React_default().createElement(
            "div",
            {
              className: "loading-sketch"
            },
            Array.from(
              {
                length: 10
              },
              (el, i) => {
                return external_React_default().createElement(
                  "div",
                  {
                    key: i,
                    className: "chat-occurrence"
                  },
                  external_React_default().createElement("div", {
                    className: "chat-occurrence-date"
                  }),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "chat-occurrence-content"
                    },
                    external_React_default().createElement("div", {
                      className: "chat-occurrence-title"
                    }),
                    external_React_default().createElement("div", {
                      className: "chat-occurrence-time"
                    })
                  )
                );
              }
            )
          );
        }
        renderOccurrences() {
          const { chatRoom, occurrences, occurrencesLoading, scheduledMeeting } = this.props;
          if (occurrencesLoading) {
            return this.renderLoading();
          }
          if (occurrences && occurrences.length > 0) {
            const sortedOccurrences = Object.values(occurrences).sort((a, b) => a.start - b.start);
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              sortedOccurrences.map((occurrence) =>
                occurrence.isUpcoming
                  ? external_React_default().createElement(
                      "div",
                      {
                        key: occurrence.uid,
                        className: `
                                    chat-occurrence
                                    ${occurrence.uid}
                                `
                      },
                      external_React_default().createElement(
                        "div",
                        {
                          className: "chat-occurrence-date"
                        },
                        (0, helpers.zk)(occurrence.start) &&
                          external_React_default().createElement("span", null, l.today_occurrence_label, " -"),
                        (0, helpers.Pm)(occurrence.start) &&
                          external_React_default().createElement("span", null, l.tomorrow_occurrence_label, " -"),
                        external_React_default().createElement("span", null, time2date(occurrence.start / 1000, 19))
                      ),
                      external_React_default().createElement(
                        "div",
                        {
                          className: "chat-occurrence-content"
                        },
                        external_React_default().createElement(
                          "div",
                          {
                            className: "chat-occurrence-title"
                          },
                          scheduledMeeting.title
                        ),
                        external_React_default().createElement(
                          "div",
                          {
                            className: "chat-occurrence-time"
                          },
                          toLocaleTime(occurrence.start),
                          " - \xA0",
                          toLocaleTime(occurrence.end)
                        ),
                        chatRoom.iAmOperator() &&
                          external_React_default().createElement(
                            "div",
                            {
                              className: "chat-occurrence-controls"
                            },
                            external_React_default().createElement(
                              "div",
                              {
                                className: "chat-occurrence-control simpletip",
                                "data-simpletip": l[1342],
                                "data-simpletipposition": "top",
                                "data-simpletipoffset": "5"
                              },
                              external_React_default().createElement(buttons.z, {
                                icon: "sprite-fm-mono icon-rename",
                                onClick: () => {
                                  megaChat.trigger(megaChat.plugins.meetingsManager.EVENTS.EDIT, occurrence);
                                }
                              })
                            ),
                            external_React_default().createElement(
                              "div",
                              {
                                className: "chat-occurrence-control simpletip",
                                "data-simpletip": l[82],
                                "data-simpletipposition": "top",
                                "data-simpletipoffset": "5"
                              },
                              external_React_default().createElement(buttons.z, {
                                icon: "sprite-fm-mono icon-bin",
                                onClick: () => this.renderCancelConfirmation(occurrence)
                              })
                            )
                          )
                      )
                    )
                  : null
              )
            );
          }
          return external_React_default().createElement("span", null, l.no_occurrences_remain);
        }
        render() {
          const { chatRoom, scheduledMeeting } = this.props;
          const { editDialog, occurrenceId } = this.state;
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            external_React_default().createElement(
              "div",
              {
                className: "chat-occurrences-list"
              },
              external_React_default().createElement(
                perfectScrollbar.F,
                {
                  chatRoom: chatRoom,
                  ref: (ref) => {
                    this.contactsListScroll = ref;
                  },
                  disableCheckingVisibility: true,
                  onUserScroll: (ps) => ps.isCloseToBottom(30) && this.loadOccurrences(),
                  isVisible: this.isCurrentlyActive,
                  options: {
                    suppressScrollX: true
                  }
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "chat-occurrences-list-inner"
                  },
                  this.renderOccurrences()
                )
              )
            )
          );
        }
      }
      class ConversationRightArea extends mixins.wl {
        constructor(props) {
          super(props);
          this.LeaveButton = (0, hostsObserver.N)(({ chatRoom, hasHost, confirmLeave, onLeave }) => {
            const isDisabled = chatRoom.call || chatRoom.isReadOnly() || is_chatlink;
            const participants = chatRoom.getParticipantsExceptMe();
            return external_React_default().createElement(
              "div",
              {
                className: `
                        link-button
                        light
                        ${isDisabled ? "disabled" : ""}
                    `,
                onClick: isDisabled
                  ? null
                  : () =>
                      hasHost(participants) || !participants.length
                        ? onLeave()
                        : confirmLeave({
                            title: chatRoom.isMeeting ? l.assign_host_to_leave : l.assign_host_to_leave_group,
                            body: chatRoom.isMeeting ? l.assign_host_to_details : l.assign_host_to_details_group,
                            cta: l.assign_host_button
                          })
              },
              external_React_default().createElement("i", {
                className: "sprite-fm-mono icon-disabled-filled"
              }),
              external_React_default().createElement("span", null, chatRoom.isMeeting ? l.meeting_leave : l[8633])
            );
          });
          this.OptionsButton = ({ icon, label, secondLabel, toggled, disabled, onClick }) => {
            const { chatRoom } = this.props;
            const isDisabled = !chatRoom.iAmOperator() || disabled;
            return external_React_default().createElement(buttons.z, {
              className: `
                    link-button
                    light
                    room-settings-button
                `,
              disabled: isDisabled,
              icon: `
                    sprite-fm-mono
                    ${icon}
                `,
              label: label,
              secondLabel: secondLabel,
              secondLabelClass: "label--green",
              toggle: {
                enabled: toggled,
                onClick: isDisabled ? null : onClick
              },
              onClick: isDisabled ? null : onClick
            });
          };
          this.handleCancelMeeting = () => {
            const { chatRoom } = this.props;
            const { scheduledMeeting, chatId } = chatRoom || {};
            if (scheduledMeeting) {
              const { isRecurring, title } = scheduledMeeting;
              const doConfirm = (res) => res && megaChat.plugins.meetingsManager.cancelMeeting(scheduledMeeting, chatId);
              if (isRecurring) {
                return chatRoom.hasUserMessages()
                  ? msgDialog(
                      `confirmation:!^${l.cancel_meeting_button}!${l.schedule_cancel_abort}`,
                      null,
                      l.schedule_cancel_dialog_title.replace("%s", title),
                      l.schedule_cancel_dialog_move_recurring,
                      doConfirm,
                      1
                    )
                  : msgDialog(
                      `confirmation:!^${l.schedule_cancel_dialog_confirm}!${l.schedule_cancel_abort}`,
                      null,
                      l.schedule_cancel_dialog_title.replace("%s", title),
                      l.schedule_cancel_dialog_archive_recurring,
                      doConfirm,
                      1
                    );
              }
              return chatRoom.hasUserMessages()
                ? msgDialog(
                    `confirmation:!^${l.cancel_meeting_button}!${l.schedule_cancel_abort}`,
                    null,
                    l.schedule_cancel_dialog_title.replace("%s", title),
                    l.schedule_cancel_dialog_move_single,
                    doConfirm,
                    1
                  )
                : msgDialog(
                    `confirmation:!^${l.schedule_cancel_dialog_confirm}!${l.schedule_cancel_abort}`,
                    null,
                    l.schedule_cancel_dialog_title.replace("%s", title),
                    l.schedule_cancel_dialog_archive_single,
                    doConfirm,
                    1
                  );
            }
          };
          this.state = {
            contactPickerDialog: false
          };
        }
        customIsEventuallyVisible() {
          return this.props.chatRoom.isCurrentlyActive;
        }
        setRetention(chatRoom, retentionTime) {
          chatRoom.setRetention(retentionTime);
          $(document).trigger("closeDropdowns");
        }
        renderOptionsBanner() {
          const { chatRoom } = this.props;
          return !!chatRoom.options[MCO_FLAGS.WAITING_ROOM] && !!chatRoom.options[MCO_FLAGS.OPEN_INVITE]
            ? external_React_default().createElement(
                "div",
                {
                  className: "room-settings-banner"
                },
                external_React_default().createElement("i", {
                  className: "sprite-fm-mono icon-info"
                }),
                external_React_default().createElement(
                  utils.Cw,
                  null,
                  l.waiting_room_invite
                    .replace(
                      "[A]",
                      `<a
                                href="${l.mega_help_host}/wp-admin/post.php?post=3005&action=edit"
                                target="_blank"
                                class="ulickurl">`
                    )
                    .replace("[/A]", "</a>")
                )
              )
            : null;
        }
        renderPushSettingsButton() {
          const { pushSettingsValue, chatRoom, onPushSettingsToggled, onPushSettingsClicked } = this.props;
          const icon = pushSettingsValue || pushSettingsValue === 0 ? "icon-notification-off-filled" : "icon-notification-filled";
          return external_React_default().createElement(
            "div",
            {
              className: "push-settings"
            },
            external_React_default().createElement("div", {
              className: "chat-button-separator"
            }),
            external_React_default().createElement(buttons.z, {
              className: `
                        link-button
                        light
                        push-settings-button
                        ${chatRoom.isReadOnly() ? "disabled" : ""}
                    `,
              icon: `
                        sprite-fm-mono
                        ${icon}
                    `,
              label: chatRoom.isMeeting ? l.meeting_notifications : l[16709],
              secondLabel: (() => {
                if (pushSettingsValue !== null && pushSettingsValue !== undefined) {
                  return pushSettingsValue === 0
                    ? PushSettingsDialog.options[Infinity]
                    : l[23539].replace("%s", toLocaleTime(pushSettingsValue));
                }
              })(),
              secondLabelClass: "label--green",
              toggle: chatRoom.isReadOnly()
                ? null
                : {
                    enabled: !pushSettingsValue && pushSettingsValue !== 0,
                    onClick: () => (!pushSettingsValue && pushSettingsValue !== 0 ? onPushSettingsClicked() : onPushSettingsToggled())
                  },
              onClick: () => (chatRoom.isReadOnly() ? null : onPushSettingsClicked())
            }),
            external_React_default().createElement("div", {
              className: "chat-button-separator"
            })
          );
        }
        componentDidMount() {
          super.componentDidMount();
          megaChat.rebind(`${megaChat.plugins.meetingsManager.EVENTS.OCCURRENCES_UPDATE}.${this.getUniqueId()}`, () => {
            if (this.isMounted()) {
              this.safeForceUpdate();
            }
          });
        }
        render() {
          const self = this;
          const { chatRoom: room, onStartCall, occurrencesLoading, onShowScheduledDescription } = self.props;
          if (!room || !room.roomId) {
            return null;
          }
          if (!room.isCurrentlyActive && !self._wasAppendedEvenOnce) {
            return null;
          }
          self._wasAppendedEvenOnce = true;
          var startCallDisabled = isStartCallDisabled(room) || room.iAmWaitingRoomPeer();
          var startAudioCallButton;
          var startVideoCallButton;
          var isInCall = !!room.call;
          if (isInCall) {
            startAudioCallButton = startVideoCallButton = null;
          }
          if (room.type === "group" || room.type === "public") {
            if (room.getCallParticipants().length > 0 && !isInCall) {
              startAudioCallButton = startVideoCallButton = null;
            }
          }
          if (startAudioCallButton !== null) {
            startAudioCallButton = external_React_default().createElement(
              "div",
              {
                "data-simpletip": l.unsupported_browser_audio,
                "data-simpletipposition": "top",
                "data-simpletipoffset": "7",
                className: `
                        link-button light
                        ${megaChat.hasSupportForCalls ? "" : "simpletip"}
                        ${startCallDisabled ? "disabled" : ""}
                    `,
                onClick: () => onStartCall(call.wD.AUDIO)
              },
              external_React_default().createElement("i", {
                className: "sprite-fm-mono icon-phone"
              }),
              external_React_default().createElement("span", null, l[5896])
            );
          }
          if (startVideoCallButton !== null) {
            startVideoCallButton = external_React_default().createElement(
              "div",
              {
                "data-simpletip": l.unsupported_browser_video,
                "data-simpletipposition": "top",
                "data-simpletipoffset": "7",
                className: `
                        link-button light
                        ${megaChat.hasSupportForCalls ? "" : "simpletip"}
                        ${startCallDisabled ? "disabled" : ""}
                    `,
                onClick: () => onStartCall(call.wD.VIDEO)
              },
              external_React_default().createElement("i", {
                className: "sprite-fm-mono icon-video-call-filled"
              }),
              external_React_default().createElement("span", null, l[5897])
            );
          }
          var AVseperator = external_React_default().createElement("div", {
            className: "chat-button-separator"
          });
          var isReadOnlyElement = null;
          if (room.isReadOnly()) {
            isReadOnlyElement = external_React_default().createElement(
              "center",
              {
                className: "center",
                style: {
                  margin: "6px"
                }
              },
              l.read_only_chat
            );
          }
          const exParticipants = excludedParticipants(room);
          var dontShowTruncateButton = false;
          if (
            !room.iAmOperator() ||
            room.isReadOnly() ||
            room.messagesBuff.messages.length === 0 ||
            (room.messagesBuff.messages.length === 1 && room.messagesBuff.messages.getItem(0).dialogType === "truncated")
          ) {
            dontShowTruncateButton = true;
          }
          const renameButtonClass = `
            link-button
            light
            ${(0, call.nJ)() || room.isReadOnly() || !room.iAmOperator() ? "disabled" : ""}
        `;
          const getChatLinkClass = `
            link-button
            light
            ${(0, call.nJ)() || room.isReadOnly() ? "disabled" : ""}
        `;
          let participantsList = null;
          if (room.type === "group" || room.type === "public") {
            participantsList = external_React_default().createElement(
              "div",
              null,
              isReadOnlyElement,
              external_React_default().createElement(ParticipantsList, {
                ref: function (r) {
                  self.participantsListRef = r;
                },
                chatRoom: room,
                members: room.members,
                isCurrentlyActive: room.isCurrentlyActive
              })
            );
          }
          const addParticipantBtn = external_React_default().createElement(buttons.z, {
            className: "link-button light",
            icon: "sprite-fm-mono icon-add-small",
            label: l[8007],
            disabled:
              (0, call.nJ)() ||
              room.isReadOnly() ||
              !(room.iAmOperator() || (room.type !== "private" && room.options[MCO_FLAGS.OPEN_INVITE])),
            onClick: () =>
              M.u.length > 1
                ? !allContactsInChat(exParticipants)
                  ? this.setState({
                      contactPickerDialog: true
                    })
                  : msgDialog(
                      `confirmationa:!^${l[8726]}!${l[82]}`,
                      null,
                      `${l.all_contacts_added}`,
                      `${l.all_contacts_added_to_chat}`,
                      (res) => {
                        if (res) {
                          contactAddDialog(null, false);
                        }
                      },
                      1
                    )
                : msgDialog(
                    `confirmationa:!^${l[8726]}!${l[82]}`,
                    null,
                    `${l.no_contacts}`,
                    `${l.no_contacts_text}`,
                    (resp) => {
                      if (resp) {
                        contactAddDialog(null, false);
                      }
                    },
                    1
                  )
          });
          const waitingRoomButton = {
            icon: "icon-clock-user-thin-solid",
            label: l.waiting_room,
            secondLabel: l.waiting_room_info,
            toggled: room.options[MCO_FLAGS.WAITING_ROOM],
            disabled: room.havePendingCall(),
            onClick: () => room.toggleWaitingRoom()
          };
          const openInviteButton = {
            icon: "icon-user-filled",
            label: room.isMeeting ? l.meeting_open_invite_label : l.chat_open_invite_label,
            secondLabel: l.open_invite_desc,
            toggled: room.options[MCO_FLAGS.OPEN_INVITE],
            onClick: () => room.toggleOpenInvite()
          };
          let retentionTime = room.retentionTime ? secondsToDays(room.retentionTime) : 0;
          const ICON_ACTIVE = external_React_default().createElement("i", {
            className: "sprite-fm-mono icon-check"
          });
          const retentionHistoryBtn = external_React_default().createElement(
            buttons.z,
            {
              className: "link-button light history-retention-btn",
              icon: "sprite-fm-mono icon-recents-filled",
              label: l[23436],
              disabled: !room.iAmOperator() || room.isReadOnly() || (0, call.nJ)(),
              secondLabel: room.getRetentionLabel(),
              secondLabelClass: "label--red",
              chatRoom: room
            },
            room.iAmOperator()
              ? external_React_default().createElement(
                  dropdowns.Dropdown,
                  {
                    className: "retention-history-menu light",
                    noArrow: "false",
                    vertOffset: -53,
                    horizOffset: -205
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "retention-history-menu__list"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: "dropdown-item link-button retention-history-menu__list__elem",
                        onClick: () => this.setRetention(room, 0)
                      },
                      external_React_default().createElement("span", null, l[7070]),
                      retentionTime === 0 && ICON_ACTIVE
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "dropdown-item link-button retention-history-menu__list__elem",
                        onClick: () => this.setRetention(room, daysToSeconds(1))
                      },
                      external_React_default().createElement("span", null, l[23437]),
                      retentionTime === 1 && ICON_ACTIVE
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "dropdown-item link-button retention-history-menu__list__elem",
                        onClick: () => this.setRetention(room, daysToSeconds(7))
                      },
                      external_React_default().createElement("span", null, l[23438]),
                      retentionTime === 7 && ICON_ACTIVE
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "dropdown-item link-button retention-history-menu__list__elem",
                        onClick: () => this.setRetention(room, daysToSeconds(30))
                      },
                      external_React_default().createElement("span", null, l[23439]),
                      retentionTime === 30 && ICON_ACTIVE
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "dropdown-item link-button retention-history-menu__list__elem",
                        onClick: () => {
                          $(document).trigger("closeDropdowns");
                          self.props.onHistoryRetentionConfig();
                        }
                      },
                      external_React_default().createElement("span", null, l[23440]),
                      [0, 1, 7, 30].indexOf(retentionTime) === -1 && ICON_ACTIVE
                    )
                  )
                )
              : null
          );
          const MEMBERS_LIMITED = Object.keys(room.members).length > MAX_USERS_CHAT_PRIVATE;
          const { scheduledMeeting, isMeeting } = room;
          const { isRecurring, isUpcoming, occurrences } = scheduledMeeting || {};
          let archiveText = room.isMeeting ? l.archive_meeting_btn : l.archive_chat_btn;
          if (room.isArchived()) {
            archiveText = room.isMeeting ? l.unarchive_meeting_btn : l[19065];
          }
          return external_React_default().createElement(
            "div",
            {
              className: "chat-right-area"
            },
            external_React_default().createElement(
              perfectScrollbar.F,
              {
                className: "chat-right-area conversation-details-scroll",
                options: {
                  suppressScrollX: true
                },
                ref: (ref) => {
                  this.rightScroll = ref;
                },
                triggerGlobalResize: true,
                isVisible: room.isCurrentlyActive,
                chatRoom: room
              },
              external_React_default().createElement(
                "div",
                {
                  className: `
                            chat-right-pad
                            ${room.haveActiveCall() ? "in-call" : ""}
                        `
                },
                external_React_default().createElement(
                  Accordion,
                  (0, esm_extends.Z)({}, this.state, {
                    chatRoom: room,
                    onToggle: SoonFc(20, () => {
                      if (this.rightScroll) {
                        this.rightScroll.reinitialise();
                      }
                      if (this.participantsListRef) {
                        this.participantsListRef.safeForceUpdate();
                      }
                    }),
                    expandedPanel: {
                      participants: (room.type === "group" || room.type === "public") && !isMeeting,
                      options: room.type === "private" || (isMeeting && !isRecurring),
                      occurrences: isMeeting && scheduledMeeting && isRecurring
                    }
                  }),
                  participantsList
                    ? external_React_default().createElement(
                        AccordionPanel,
                        {
                          className: "small-pad",
                          title: room.isMeeting ? l.meeting_participants : l.chat_participants,
                          chatRoom: room,
                          key: "participants"
                        },
                        participantsList
                      )
                    : null,
                  room.type === "public" && room.observers > 0 && !room.options.w
                    ? external_React_default().createElement(
                        "div",
                        {
                          className: "accordion-text observers"
                        },
                        l[20466],
                        external_React_default().createElement(
                          "span",
                          {
                            className: "observers-count"
                          },
                          external_React_default().createElement("i", {
                            className: "sprite-fm-mono icon-eye-reveal"
                          }),
                          room.observers
                        )
                      )
                    : external_React_default().createElement("div", null),
                  isRecurring &&
                    isUpcoming &&
                    scheduledMeeting.occurrences.some((o) => !o.canceled) &&
                    external_React_default().createElement(
                      AccordionPanel,
                      {
                        key: "occurrences",
                        className: "chat-occurrences-panel",
                        accordionClass: "chatroom-occurrences-panel",
                        title: l.occurrences_heading,
                        chatRoom: room,
                        scheduledMeeting: scheduledMeeting,
                        occurrences: occurrences
                      },
                      external_React_default().createElement(Occurrences, {
                        chatRoom: room,
                        scheduledMeeting: scheduledMeeting,
                        occurrences: occurrences,
                        occurrencesLoading: occurrencesLoading
                      })
                    ),
                  external_React_default().createElement(
                    AccordionPanel,
                    {
                      key: "options",
                      className: "have-animation buttons",
                      accordionClass: "chatroom-options-panel",
                      title: l[7537],
                      chatRoom: room,
                      sfuClient: window.sfuClient
                    },
                    external_React_default().createElement(
                      external_React_default().Fragment,
                      null,
                      addParticipantBtn,
                      startAudioCallButton,
                      startVideoCallButton,
                      external_React_default().createElement(EndCallButton, {
                        call: room.havePendingGroupCall() || room.haveActiveCall(),
                        chatRoom: room
                      }),
                      scheduledMeeting &&
                        external_React_default().createElement(
                          "div",
                          {
                            className: `
                                            link-button light schedule-view-desc
                                            ${room.isReadOnly() || !scheduledMeeting.description ? "disabled" : ""}
                                        `,
                            onClick: () => {
                              if (!room.isReadOnly() && scheduledMeeting.description) {
                                onShowScheduledDescription();
                              }
                            }
                          },
                          external_React_default().createElement("i", {
                            className: "sprite-fm-mono icon-description"
                          }),
                          external_React_default().createElement("span", null, l.schedule_view_desc)
                        ),
                      (room.type === "group" || room.type === "public") && !scheduledMeeting
                        ? external_React_default().createElement(
                            "div",
                            {
                              className: renameButtonClass,
                              onClick: (e) => {
                                if ($(e.target).closest(".disabled").length > 0) {
                                  return false;
                                }
                                if (this.props.onRenameClicked) {
                                  this.props.onRenameClicked();
                                }
                              }
                            },
                            external_React_default().createElement("i", {
                              className: "sprite-fm-mono icon-rename"
                            }),
                            external_React_default().createElement("span", null, room.isMeeting ? l.rename_meeting : l[9080])
                          )
                        : null,
                      scheduledMeeting
                        ? external_React_default().createElement(
                            "div",
                            {
                              className: `
                                                link-button
                                                light
                                                ${room.iAmOperator() ? "" : "disabled"}
                                            `,
                              onClick: () => {
                                const { plugins } = megaChat;
                                return room.iAmOperator() ? megaChat.trigger(plugins.meetingsManager.EVENTS.EDIT, room) : null;
                              }
                            },
                            external_React_default().createElement("i", {
                              className: "sprite-fm-mono icon-rename"
                            }),
                            scheduledMeeting.isRecurring
                              ? external_React_default().createElement("span", null, l.edit_meeting_series_button)
                              : external_React_default().createElement("span", null, l.edit_meeting_button)
                          )
                        : null,
                      room.type === "public"
                        ? external_React_default().createElement(
                            "div",
                            {
                              className: getChatLinkClass,
                              onClick: (e) => {
                                if ($(e.target).closest(".disabled").length > 0) {
                                  return false;
                                }
                                this.props.onGetManageChatLinkClicked();
                              }
                            },
                            external_React_default().createElement("i", {
                              className: "sprite-fm-mono icon-link-filled"
                            }),
                            external_React_default().createElement(
                              "span",
                              null,
                              scheduledMeeting ? l.share_meeting_button : room.isMeeting ? l.meeting_get_link : l[20481]
                            )
                          )
                        : null,
                      scheduledMeeting
                        ? external_React_default().createElement(
                            "div",
                            {
                              className: `
                                                link-button
                                                light
                                                ${room.iAmOperator() && !scheduledMeeting.canceled ? "" : "disabled"}
                                            `,
                              onClick: () => {
                                if (room.iAmOperator() && !scheduledMeeting.canceled) {
                                  this.handleCancelMeeting();
                                }
                              }
                            },
                            external_React_default().createElement("i", {
                              className: "sprite-fm-mono icon-bin-filled"
                            }),
                            scheduledMeeting.isRecurring
                              ? external_React_default().createElement("span", null, l.cancel_meeting_series_button)
                              : external_React_default().createElement("span", null, l.cancel_meeting_button)
                          )
                        : null,
                      !room.membersSetFromApi.members.hasOwnProperty(u_handle) &&
                        room.type === "public" &&
                        !is_chatlink &&
                        room.publicChatHandle &&
                        room.publicChatKey
                        ? external_React_default().createElement(
                            "div",
                            {
                              className: "link-button light",
                              onClick: (e) => {
                                if ($(e.target).closest(".disabled").length > 0) {
                                  return false;
                                }
                                this.props.onJoinViaPublicLinkClicked();
                              }
                            },
                            external_React_default().createElement("i", {
                              className: "sprite-fm-mono icon-rename"
                            }),
                            external_React_default().createElement("span", null, l[20597])
                          )
                        : null,
                      scheduledMeeting
                        ? null
                        : external_React_default().createElement(
                            external_React_default().Fragment,
                            null,
                            AVseperator,
                            external_React_default().createElement(
                              buttons.z,
                              {
                                className: "link-button light dropdown-element",
                                icon: "sprite-fm-mono icon-upload-filled",
                                label: l[23753],
                                disabled: room.isReadOnly()
                              },
                              external_React_default().createElement(
                                dropdowns.Dropdown,
                                {
                                  className: "wide-dropdown send-files-selector light",
                                  noArrow: "true",
                                  vertOffset: 4,
                                  onClick: () => false
                                },
                                external_React_default().createElement(
                                  "div",
                                  {
                                    className: "dropdown info-txt"
                                  },
                                  l[23753] || "Send..."
                                ),
                                external_React_default().createElement(dropdowns.DropdownItem, {
                                  className: "link-button",
                                  icon: "sprite-fm-mono icon-cloud-drive",
                                  label: l[19794] || "My Cloud Drive",
                                  disabled: mega.paywall,
                                  onClick: () => {
                                    this.props.onAttachFromCloudClicked();
                                  }
                                }),
                                external_React_default().createElement(dropdowns.DropdownItem, {
                                  className: "link-button",
                                  icon: "sprite-fm-mono icon-session-history",
                                  label: l[19795] || "My computer",
                                  disabled: mega.paywall,
                                  onClick: () => {
                                    this.props.onAttachFromComputerClicked();
                                  }
                                })
                              )
                            )
                          ),
                      this.renderPushSettingsButton(),
                      room.type === "private"
                        ? null
                        : external_React_default().createElement(
                            external_React_default().Fragment,
                            null,
                            room.scheduledMeeting && this.OptionsButton(waitingRoomButton),
                            this.OptionsButton(openInviteButton),
                            this.renderOptionsBanner(),
                            AVseperator
                          ),
                      mega.es2020 &&
                        external_React_default().createElement(
                          buttons.z,
                          {
                            className: "link-button light export-chat-button",
                            disabled: room.messagesBuff.messages.length === 0 || room.exportIo,
                            onClick: () => {
                              room.exportToFile();
                            }
                          },
                          external_React_default().createElement("i", {
                            className: "sprite-fm-mono icon-export-chat-filled"
                          }),
                          external_React_default().createElement("span", null, room.isMeeting ? l.export_meeting_rhp : l.export_chat_rhp)
                        ),
                      external_React_default().createElement(
                        buttons.z,
                        {
                          className: "link-button light clear-history-button",
                          disabled: dontShowTruncateButton || !room.members.hasOwnProperty(u_handle),
                          onClick: () => {
                            if (this.props.onTruncateClicked) {
                              this.props.onTruncateClicked();
                            }
                          }
                        },
                        external_React_default().createElement("i", {
                          className: "sprite-fm-mono icon-remove"
                        }),
                        external_React_default().createElement(
                          "span",
                          {
                            className: "accordion-clear-history-text"
                          },
                          room.isMeeting ? l.meeting_clear_hist : l[8871]
                        )
                      ),
                      retentionHistoryBtn,
                      room.iAmOperator() && room.type === "public" && !scheduledMeeting
                        ? external_React_default().createElement(
                            "div",
                            {
                              className: "chat-enable-key-rotation-paragraph"
                            },
                            AVseperator,
                            external_React_default().createElement(
                              "div",
                              {
                                className: `
                                                    link-button
                                                    light
                                                    ${MEMBERS_LIMITED ? "disabled" : ""}
                                                `,
                                onClick: (e) => {
                                  if (MEMBERS_LIMITED || $(e.target).closest(".disabled").length > 0) {
                                    return false;
                                  }
                                  this.props.onMakePrivateClicked();
                                }
                              },
                              external_React_default().createElement("i", {
                                className: "sprite-fm-mono icon-key"
                              }),
                              external_React_default().createElement("span", null, l[20623])
                            ),
                            external_React_default().createElement(
                              "p",
                              null,
                              external_React_default().createElement("span", null, l[20454])
                            )
                          )
                        : null,
                      AVseperator,
                      external_React_default().createElement(
                        "div",
                        {
                          className: `
                                                link-button
                                                light
                                                ${
                                                  (room.members.hasOwnProperty(u_handle) || room.state === ChatRoom.STATE.LEFT) &&
                                                  !is_chatlink
                                                    ? ""
                                                    : "disabled"
                                                }
                                            `,
                          onClick: (e) => {
                            if ($(e.target).closest(".disabled").length > 0) {
                              return false;
                            }
                            if (room.isArchived()) {
                              if (this.props.onUnarchiveClicked) {
                                this.props.onUnarchiveClicked();
                              }
                            } else if (this.props.onArchiveClicked) {
                              this.props.onArchiveClicked();
                            }
                          }
                        },
                        external_React_default().createElement("i", {
                          className: `
                                                sprite-fm-mono
                                                ${room.isArchived() ? "icon-unarchive" : "icon-archive"}
                                            `
                        }),
                        external_React_default().createElement("span", null, archiveText)
                      ),
                      room.type === "private"
                        ? null
                        : external_React_default().createElement(this.LeaveButton, {
                            chatRoom: room,
                            participants: room.getParticipantsExceptMe(),
                            onLeave: () => room.leave(true)
                          })
                    )
                  ),
                  external_React_default().createElement(SharedFilesAccordionPanel, {
                    key: "sharedFiles",
                    title: l[19796] || "Shared Files",
                    chatRoom: room,
                    sharedFiles: room.messagesBuff.sharedFiles
                  }),
                  room.type === "private"
                    ? external_React_default().createElement(IncSharesAccordionPanel, {
                        key: "incomingShares",
                        title: l[5542],
                        chatRoom: room
                      })
                    : null
                )
              )
            ),
            this.state.contactPickerDialog &&
              external_React_default().createElement(ui_contacts.ContactPickerDialog, {
                exclude: exParticipants,
                megaChat: room.megaChat,
                multiple: true,
                className: "popup add-participant-selector",
                singleSelectedButtonLabel: room.isMeeting ? l.meeting_add_participant : l[8869],
                multipleSelectedButtonLabel: room.isMeeting ? l.meeting_add_participant : l[8869],
                nothingSelectedButtonLabel: l[8870],
                onSelectDone: (selected) => {
                  this.props.onAddParticipantSelected(selected);
                  this.setState({
                    contactPickerDialog: false
                  });
                },
                onClose: () =>
                  this.setState({
                    contactPickerDialog: false
                  }),
                selectFooter: true
              })
          );
        }
      }
      ConversationRightArea.defaultProps = {
        requiresUpdateOnResize: true
      };
      let ConversationPanel =
        ((conversationpanel_dec = utils.ZP.SoonFcWrap(360)),
        (_dec2 = (0, mixins.LY)(0.7, 9)),
        ((_class4 = class ConversationPanel extends mixins.wl {
          constructor(props) {
            super(props);
            this.containerRef = external_React_default().createRef();
            this.$container = null;
            this.$messages = null;
            this.state = {
              startCallPopupIsActive: false,
              localVideoIsMinimized: false,
              isFullscreenModeEnabled: false,
              mouseOverDuringCall: false,
              attachCloudDialog: false,
              messagesToggledInCall: false,
              sendContactDialog: false,
              confirmDeleteDialog: false,
              pasteImageConfirmDialog: false,
              nonLoggedInJoinChatDialog: false,
              pushSettingsDialog: false,
              pushSettingsValue: null,
              messageToBeDeleted: null,
              callMinimized: false,
              editing: false,
              showHistoryRetentionDialog: false,
              setNonLoggedInJoinChatDlgTrue: null,
              hasInvalidKeys: null,
              invalidKeysBanner: null,
              descriptionDialog: false,
              occurrencesLoading: false,
              waitingRoom: false
            };
            const { chatRoom } = this.props;
            chatRoom.rebind(`openAttachCloudDialog.${this.getUniqueId()}`, () => this.openAttachCloudDialog());
            chatRoom.rebind(`openSendContactDialog.${this.getUniqueId()}`, () => this.openSendContactDialog());
            chatRoom.rebind(`openSchedDescDialog.${this.getUniqueId()}`, () => this.openSchedDescDialog());
            this.handleKeyDown = SoonFc(120, (ev) => this._handleKeyDown(ev));
            this.state.waitingRoom = chatRoom.options.w && (chatRoom.isAnonymous() || megaChat.initialChatId || is_eplusplus);
          }
          customIsEventuallyVisible() {
            return this.props.chatRoom.isCurrentlyActive;
          }
          openAttachCloudDialog() {
            this.setState({
              attachCloudDialog: true
            });
          }
          openSendContactDialog() {
            this.setState({
              sendContactDialog: true
            });
          }
          openSchedDescDialog() {
            this.setState({
              descriptionDialog: true
            });
          }
          onMouseMove() {
            if (this.isComponentEventuallyVisible()) {
              this.props.chatRoom.trigger("onChatIsFocused");
            }
          }
          _handleKeyDown() {
            if (this.__isMounted) {
              const chatRoom = this.props.chatRoom;
              if (chatRoom.isActive() && !chatRoom.isReadOnly()) {
                chatRoom.trigger("onChatIsFocused");
              }
            }
          }
          handleDeleteDialog(msg) {
            if (msg) {
              this.setState({
                editing: false,
                confirmDeleteDialog: true,
                messageToBeDeleted: msg
              });
            }
          }
          toggleExpandedFlag() {
            if (this.props.onToggleExpandedFlag) {
              this.props.onToggleExpandedFlag();
            }
            return document.body.classList[call.ZP.isExpanded() ? "remove" : "add"](call.F3);
          }
          startCall(type, scheduled) {
            const { chatRoom } = this.props;
            if (isStartCallDisabled(chatRoom) || chatRoom.iAmWaitingRoomPeer()) {
              return false;
            }
            return type === call.wD.AUDIO ? chatRoom.startAudioCall(scheduled) : chatRoom.startVideoCall(scheduled);
          }
          renderUpcomingInfo() {
            const { scheduledMeeting } = this.props.chatRoom;
            if (scheduledMeeting) {
              const { recurring, nextOccurrenceStart, nextOccurrenceEnd, isUpcoming } = scheduledMeeting;
              const until = `${
                (0, helpers.KC)(nextOccurrenceStart, nextOccurrenceEnd) ? "" : time2date(nextOccurrenceEnd / 1000, 4)
              } ${toLocaleTime(nextOccurrenceEnd)}`;
              return external_React_default().createElement(
                external_React_default().Fragment,
                null,
                isUpcoming && recurring && external_React_default().createElement("span", null, l.next_meeting),
                external_React_default().createElement(
                  "span",
                  null,
                  (l.schedule_formatted_date || "%1 from %2 to %3")
                    .replace("%1", time2date(nextOccurrenceStart / 1000, 4))
                    .replace("%2", toLocaleTime(nextOccurrenceStart))
                    .replace("%3", until)
                )
              );
            }
            return null;
          }
          componentDidMount() {
            super.componentDidMount();
            const { chatRoom } = this.props;
            this.$container = $(".conversation-panel", "#fmholder");
            this.$messages = $(".messages.scroll-area > .perfectScrollbarContainer", this.$container);
            window.addEventListener("keydown", this.handleKeyDown);
            chatRoom.rebind("call-ended.jspHistory call-declined.jspHistory", () => {
              this.callJustEnded = true;
            });
            chatRoom.rebind("onSendMessage.scrollToBottom", () => {
              chatRoom.scrolledToBottom = true;
              if (this.messagesListScrollable) {
                this.messagesListScrollable.scrollToBottom();
              }
            });
            chatRoom.rebind("openSendFilesDialog.cpanel", () => {
              this.setState({
                attachCloudDialog: true
              });
            });
            chatRoom.rebind("showGetChatLinkDialog.ui", () => {
              createTimeoutPromise(() => chatRoom.topic && chatRoom.state === ChatRoom.STATE.READY, 350, 15000).always(() => {
                return chatRoom.isCurrentlyActive
                  ? this.setState({
                      chatLinkDialog: true
                    })
                  : chatRoom.updatePublicHandle(false, true);
              });
            });
            if (chatRoom.type === "private") {
              const otherContactHash = chatRoom.getParticipantsExceptMe()[0];
              if (otherContactHash in M.u) {
                this._privateChangeListener = M.u[otherContactHash].addChangeListener(() => {
                  if (!this.isMounted()) {
                    return 0xdead;
                  }
                  this.safeForceUpdate();
                });
              }
            }
            if (is_chatlink && !chatRoom.isMeeting) {
              this.state.setNonLoggedInJoinChatDlgTrue = setTimeout(
                () => {
                  M.safeShowDialog("chat-links-preview-desktop", () => {
                    if (this.isMounted()) {
                      this.setState({
                        nonLoggedInJoinChatDialog: true
                      });
                    }
                  });
                },
                rand_range(5, 10) * 1000
              );
            }
            if (is_chatlink && chatRoom.isMeeting && u_type !== false && u_type < 3) {
              eventlog(99747, JSON.stringify([1, u_type | 0]), true);
            }
            chatRoom._uiIsMounted = true;
            chatRoom.$rConversationPanel = this;
            chatRoom.trigger("onComponentDidMount");
            ChatdIntegration._waitForProtocolHandler(chatRoom, () => {
              if (this.isMounted()) {
                const hasInvalidKeys = chatRoom.hasInvalidKeys();
                this.setState(
                  {
                    hasInvalidKeys,
                    invalidKeysBanner: hasInvalidKeys
                  },
                  () => this.safeForceUpdate()
                );
              }
            });
            this.eventuallyInit();
            megaChat.rebind(`${megaChat.plugins.meetingsManager.EVENTS.OCCURRENCES_UPDATE}.${this.getUniqueId()}`, () => {
              return (
                this.isMounted() &&
                this.setState({
                  occurrencesLoading: false
                })
              );
            });
            chatRoom.rebind(`wrOnJoinNotAllowed.${this.getUniqueId()}`, () => {
              return (
                this.isMounted() &&
                this.setState({
                  waitingRoom: true
                })
              );
            });
            chatRoom.rebind(`wrOnJoinAllowed.${this.getUniqueId()}`, () => {
              return (
                this.isMounted() &&
                this.setState({
                  waitingRoom: false
                })
              );
            });
            if (chatRoom.options.w) {
              chatRoom.rebind(`onMembersUpdated.${this.getUniqueId()}`, (ev, { userId, priv }) => {
                if (userId === u_handle && priv !== ChatRoom.MembersSet.PRIVILEGE_STATE.LEFT) {
                  chatRoom.unbind(`onMembersUpdated.${this.getUniqueId()}`);
                  if (is_chatlink) {
                    return megaChat.routing
                      .reinitAndOpenExistingChat(chatRoom.chatId, chatRoom.publicChatHandle)
                      .then(
                        (chatRoom) =>
                          chatRoom.havePendingCall() && priv === ChatRoom.MembersSet.PRIVILEGE_STATE.OPERATOR && chatRoom.joinCall()
                      )
                      .catch(dump);
                  }
                  return (
                    this.state.waitingRoom &&
                    this.setState({
                      waitingRoom: priv !== ChatRoom.MembersSet.PRIVILEGE_STATE.OPERATOR
                    })
                  );
                }
              });
            }
            this.pageChangeListener = mBroadcaster.addListener(
              "beforepagechange",
              () =>
                M.chat &&
                this.state.waitingRoom &&
                this.setState(
                  {
                    waitingRoom: false
                  },
                  () => this.safeForceUpdate()
                )
            );
          }
          eventuallyInit() {
            var self = this;
            if (self.initialised) {
              return;
            }
            var $container = $(self.findDOMNode());
            if ($container.length > 0) {
              self.initialised = true;
            } else {
              return;
            }
            var room = self.props.chatRoom;
            $(document).rebind("fullscreenchange.megaChat_" + room.roomId, function () {
              if (self.isComponentEventuallyVisible()) {
                self.setState({
                  isFullscreenModeEnabled: !!$(document).fullScreen()
                });
                self.forceUpdate();
              }
            });
          }
          componentWillUnmount() {
            super.componentWillUnmount();
            var self = this;
            var chatRoom = self.props.chatRoom;
            chatRoom._uiIsMounted = true;
            if (this._privateChangeListener) {
              var otherContactHash = self.props.chatRoom.getParticipantsExceptMe()[0];
              if (otherContactHash in M.u) {
                M.u[otherContactHash].removeChangeListener(this._privateChangeListener);
                delete this._privateChangeListener;
              }
            }
            mBroadcaster.removeListener(this.pageChangeListener);
            this.props.chatRoom.unbind("openAttachCloudDialog." + this.getUniqueId());
            this.props.chatRoom.unbind("openSendContactDialog." + this.getUniqueId());
            this.props.chatRoom.unbind(`openSchedDescDialog.${this.getUniqueId()}`);
            window.removeEventListener("keydown", self.handleKeyDown);
            $(document).off("fullscreenchange.megaChat_" + chatRoom.roomId);
            $(document).off("keydown.keyboardScroll_" + chatRoom.roomId);
            this.props.chatRoom.unbind(`wrOnJoinNotAllowed.${this.getUniqueId()}`);
            this.props.chatRoom.unbind(`wrOnJoinAllowed.${this.getUniqueId()}`);
            megaChat.unbind(`onIncomingCall.${this.getUniqueId()}`);
          }
          componentDidUpdate(prevProps, prevState) {
            var self = this;
            var room = this.props.chatRoom;
            self.eventuallyInit(false);
            room.megaChat.updateSectionUnreadCount();
            var domNode = self.findDOMNode();
            if (prevState.messagesToggledInCall !== self.state.messagesToggledInCall || self.callJustEnded) {
              if (self.callJustEnded) {
                self.callJustEnded = false;
              }
              self.$messages.trigger("forceResize", [true, 1]);
              Soon(function () {
                self.messagesListScrollable.scrollToBottom(true);
              });
            }
            if (prevProps.isActive === false && self.props.isActive === true) {
              var $typeArea = $(".messages-textarea:visible:first", domNode);
              if ($typeArea.length === 1) {
                $typeArea.trigger("focus");
                moveCursortoToEnd($typeArea[0]);
              }
            }
            if (!prevState.renameDialog && self.state.renameDialog === true) {
              Soon(function () {
                var $input = $(".chat-rename-dialog input");
                if ($input && $input[0] && !$($input[0]).is(":focus")) {
                  $input.trigger("focus");
                  $input[0].selectionStart = 0;
                  $input[0].selectionEnd = $input.val().length;
                }
              });
            }
            if (self.$messages && self.isComponentEventuallyVisible()) {
              $(window).rebind("pastedimage.chatRoom", function (e, blob, fileName) {
                if (self.$messages && self.isComponentEventuallyVisible()) {
                  self.setState({
                    pasteImageConfirmDialog: [blob, fileName, URL.createObjectURL(blob)]
                  });
                  e.preventDefault();
                }
              });
              self.props.chatRoom.trigger("onComponentDidUpdate");
            }
          }
          isActive() {
            return document.hasFocus() && this.$messages && this.$messages.is(":visible");
          }
          render() {
            var self = this;
            var room = this.props.chatRoom;
            if (!room || !room.roomId) {
              return null;
            }
            if (!room.isCurrentlyActive && !self._wasAppendedEvenOnce) {
              return null;
            }
            self._wasAppendedEvenOnce = true;
            var contacts = room.getParticipantsExceptMe();
            var contactHandle;
            var contact;
            var conversationPanelClasses = "conversation-panel " + (room.type === "public" ? "group-chat " : "") + room.type + "-chat";
            if (!room.isCurrentlyActive || megaChat._joinDialogIsShown) {
              conversationPanelClasses += " hidden";
            }
            var topicBlockClass = "chat-topic-block";
            if (room.type !== "public") {
              topicBlockClass += " privateChat";
            }
            var attachCloudDialog = null;
            if (self.state.attachCloudDialog === true) {
              var selected = [];
              attachCloudDialog = external_React_default().createElement(cloudBrowserModalDialog.CloudBrowserDialog, {
                allowAttachFolders: true,
                room: room,
                onClose: () => {
                  self.setState({
                    attachCloudDialog: false
                  });
                  selected = [];
                },
                onSelected: (nodes) => {
                  selected = nodes;
                },
                onAttachClicked: () => {
                  self.setState({
                    attachCloudDialog: false
                  });
                  self.props.chatRoom.scrolledToBottom = true;
                  room.attachNodes(selected).catch(dump);
                }
              });
            }
            var nonLoggedInJoinChatDialog = null;
            if (self.state.nonLoggedInJoinChatDialog === true) {
              var usersCount = Object.keys(room.members).length;
              let closeJoinDialog = () => {
                onIdle(() => {
                  if ($.dialog === "chat-links-preview-desktop") {
                    closeDialog();
                  }
                });
                self.setState({
                  nonLoggedInJoinChatDialog: false
                });
              };
              nonLoggedInJoinChatDialog = external_React_default().createElement(
                modalDialogs.Z.ModalDialog,
                {
                  title: l[20596],
                  className: "mega-dialog chat-links-preview-desktop dialog-template-graphic",
                  chatRoom: room,
                  onClose: closeJoinDialog
                },
                external_React_default().createElement(
                  "section",
                  {
                    className: "content"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "chatlink-contents"
                    },
                    external_React_default().createElement("div", {
                      className: "huge-icon group-chat"
                    }),
                    external_React_default().createElement(
                      "h3",
                      null,
                      external_React_default().createElement(utils.dy, null, room.getRoomTitle())
                    ),
                    external_React_default().createElement("h5", null, usersCount ? mega.icu.format(l[20233], usersCount) : ""),
                    external_React_default().createElement("p", null, l[20595])
                  )
                ),
                external_React_default().createElement(
                  "footer",
                  null,
                  external_React_default().createElement(
                    "div",
                    {
                      className: "bottom-buttons"
                    },
                    external_React_default().createElement(
                      "button",
                      {
                        className: "mega-button positive",
                        onClick: () => {
                          closeJoinDialog();
                          megaChat.loginOrRegisterBeforeJoining(room.publicChatHandle, false, false, false, () => {
                            megaChat.routing.reinitAndJoinPublicChat(room.chatId, room.publicChatHandle, room.publicChatKey).then(
                              () => {
                                delete megaChat.initialPubChatHandle;
                              },
                              (ex) => {
                                console.error("Failed to join room:", ex);
                              }
                            );
                          });
                        }
                      },
                      l[20597]
                    ),
                    external_React_default().createElement(
                      "button",
                      {
                        className: "mega-button",
                        onClick: closeJoinDialog
                      },
                      l[18682]
                    )
                  )
                )
              );
            }
            var chatLinkDialog;
            if (self.state.chatLinkDialog === true) {
              chatLinkDialog = external_React_default().createElement(ChatlinkDialog, {
                chatRoom: self.props.chatRoom,
                onClose: () => {
                  self.setState({
                    chatLinkDialog: false
                  });
                }
              });
            }
            let privateChatDialog;
            if (self.state.privateChatDialog === true) {
              const onClose = () =>
                this.setState({
                  privateChatDialog: false
                });
              privateChatDialog = external_React_default().createElement(
                modalDialogs.Z.ModalDialog,
                {
                  title: l[20594],
                  className: "mega-dialog create-private-chat",
                  chatRoom: room,
                  onClose: onClose,
                  dialogType: "action",
                  dialogName: "create-private-chat-dialog"
                },
                external_React_default().createElement(
                  "section",
                  {
                    className: "content"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "content-block"
                    },
                    external_React_default().createElement("i", {
                      className: "huge-icon lock"
                    }),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "dialog-body-text"
                      },
                      external_React_default().createElement("strong", null, l[20590]),
                      external_React_default().createElement("br", null),
                      external_React_default().createElement("span", null, l[20591])
                    )
                  )
                ),
                external_React_default().createElement(
                  "footer",
                  null,
                  external_React_default().createElement(
                    "div",
                    {
                      className: "footer-container"
                    },
                    external_React_default().createElement(
                      "button",
                      {
                        className: "mega-button positive large",
                        onClick: () => {
                          this.props.chatRoom.switchOffPublicMode();
                          onClose();
                        }
                      },
                      external_React_default().createElement("span", null, l[20593])
                    )
                  )
                )
              );
            }
            var sendContactDialog = null;
            if (self.state.sendContactDialog === true) {
              var excludedContacts = [];
              if (room.type == "private") {
                room.getParticipantsExceptMe().forEach(function (userHandle) {
                  if (userHandle in M.u) {
                    excludedContacts.push(M.u[userHandle].u);
                  }
                });
              }
              sendContactDialog = external_React_default().createElement(modalDialogs.Z.SelectContactDialog, {
                chatRoom: room,
                exclude: excludedContacts,
                onClose: () => {
                  self.setState({
                    sendContactDialog: false
                  });
                  selected = [];
                },
                onSelectClicked: (selected) => {
                  self.setState({
                    sendContactDialog: false
                  });
                  room.attachContacts(selected);
                }
              });
            }
            var confirmDeleteDialog = null;
            if (self.state.confirmDeleteDialog === true) {
              confirmDeleteDialog = external_React_default().createElement(
                modalDialogs.Z.ConfirmDialog,
                {
                  chatRoom: room,
                  dialogType: "main",
                  title: l[8004],
                  subtitle: l[8879],
                  name: "delete-message",
                  pref: "1",
                  onClose: () => {
                    self.setState({
                      confirmDeleteDialog: false
                    });
                  },
                  onConfirmClicked: () => {
                    var msg = self.state.messageToBeDeleted;
                    if (!msg) {
                      return;
                    }
                    var chatdint = room.megaChat.plugins.chatdIntegration;
                    if (
                      msg.getState() === Message.STATE.SENT ||
                      msg.getState() === Message.STATE.DELIVERED ||
                      msg.getState() === Message.STATE.NOT_SENT
                    ) {
                      const textContents = msg.textContents || "";
                      if (textContents[1] === Message.MANAGEMENT_MESSAGE_TYPES.VOICE_CLIP) {
                        const attachmentMetadata = msg.getAttachmentMeta() || [];
                        Promise.all(attachmentMetadata.map((v) => M.moveToRubbish(v.h))).catch(dump);
                      }
                      chatdint.deleteMessage(room, msg.internalId ? msg.internalId : msg.orderValue);
                      msg.deleted = true;
                      msg.textContents = "";
                    } else if (msg.getState() === Message.STATE.NOT_SENT_EXPIRED) {
                      chatdint.discardMessage(room, msg.internalId ? msg.internalId : msg.orderValue);
                    }
                    self.setState({
                      confirmDeleteDialog: false,
                      messageToBeDeleted: false
                    });
                    if (msg.getState && msg.getState() === Message.STATE.NOT_SENT && !msg.requiresManualRetry) {
                      msg.message = "";
                      msg.textContents = "";
                      msg.messageHtml = "";
                      msg.deleted = true;
                      msg.trigger("onChange", [msg, "deleted", false, true]);
                    }
                  }
                },
                external_React_default().createElement(
                  "section",
                  {
                    className: "content"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "content-block"
                    },
                    external_React_default().createElement(generic.Z, {
                      className: " dialog-wrapper",
                      message: self.state.messageToBeDeleted,
                      hideActionButtons: true,
                      initTextScrolling: true,
                      dialog: true,
                      chatRoom: self.props.chatRoom
                    })
                  )
                )
              );
            }
            if (self.state.pasteImageConfirmDialog) {
              confirmDeleteDialog = external_React_default().createElement(
                modalDialogs.Z.ConfirmDialog,
                {
                  chatRoom: room,
                  title: l[20905],
                  subtitle: l[20906],
                  icon: "sprite-fm-uni icon-question",
                  name: "paste-image-chat",
                  pref: "2",
                  onClose: () => {
                    self.setState({
                      pasteImageConfirmDialog: false
                    });
                  },
                  onConfirmClicked: () => {
                    var meta = self.state.pasteImageConfirmDialog;
                    if (!meta) {
                      return;
                    }
                    try {
                      Object.defineProperty(meta[0], "name", {
                        configurable: true,
                        writeable: true,
                        value: Date.now() + "." + M.getSafeName(meta[1] || meta[0].name)
                      });
                    } catch (e) {}
                    self.props.chatRoom.scrolledToBottom = true;
                    M.addUpload([meta[0]]);
                    self.setState({
                      pasteImageConfirmDialog: false
                    });
                    URL.revokeObjectURL(meta[2]);
                  }
                },
                external_React_default().createElement("img", {
                  src: self.state.pasteImageConfirmDialog[2],
                  style: {
                    maxWidth: "90%",
                    height: "auto",
                    maxHeight: $(document).outerHeight() * 0.3,
                    margin: "10px auto",
                    display: "block",
                    border: "1px solid #ccc",
                    borderRadius: "4px"
                  },
                  onLoad: function (e) {
                    $(e.target)
                      .parents(".paste-image-chat")
                      .position({
                        of: $(document.body)
                      });
                  }
                })
              );
            }
            let pushSettingsDialog = null;
            if (self.state.pushSettingsDialog === true) {
              const state = {
                pushSettingsDialog: false,
                pushSettingsValue: null
              };
              pushSettingsDialog = external_React_default().createElement(PushSettingsDialog, {
                room: room,
                pushSettingsValue: this.state.pushSettingsValue,
                onClose: () =>
                  this.setState({
                    ...state,
                    pushSettingsValue: this.state.pushSettingsValue
                  }),
                onConfirm: (pushSettingsValue) =>
                  self.setState(
                    {
                      ...state,
                      pushSettingsValue
                    },
                    () =>
                      pushNotificationSettings.setDnd(room.chatId, pushSettingsValue === Infinity ? 0 : unixtime() + pushSettingsValue * 60)
                  )
              });
            }
            if (self.state.truncateDialog === true) {
              confirmDeleteDialog = external_React_default().createElement(modalDialogs.Z.ConfirmDialog, {
                chatRoom: room,
                title: room.isMeeting ? l.meeting_clear_hist : l[8871],
                subtitle: room.isMeeting ? l.meeting_trunc_txt : l[8881],
                icon: "sprite-fm-uni icon-question",
                name: "truncate-conversation",
                pref: "3",
                dontShowAgainCheckbox: false,
                onClose: () => {
                  self.setState({
                    truncateDialog: false
                  });
                },
                onConfirmClicked: () => {
                  self.props.chatRoom.scrolledToBottom = true;
                  room.truncate();
                  self.setState({
                    truncateDialog: false
                  });
                }
              });
            }
            if (self.state.archiveDialog === true) {
              confirmDeleteDialog = external_React_default().createElement(modalDialogs.Z.ConfirmDialog, {
                chatRoom: room,
                title: room.isMeeting ? l.meeting_archive_dlg : l[19068],
                subtitle: room.isMeeting ? l.meeting_archive_dlg_text : l[19069],
                icon: "sprite-fm-uni icon-question",
                name: "archive-conversation",
                pref: "4",
                onClose: () => {
                  self.setState({
                    archiveDialog: false
                  });
                },
                onConfirmClicked: () => {
                  self.props.chatRoom.scrolledToBottom = true;
                  room.archive();
                  self.setState({
                    archiveDialog: false
                  });
                }
              });
            }
            if (self.state.unarchiveDialog === true) {
              confirmDeleteDialog = external_React_default().createElement(modalDialogs.Z.ConfirmDialog, {
                chatRoom: room,
                title: room.isMeeting ? l.meeting_unarchive_dlg : l[19063],
                subtitle: room.isMeeting ? l.meeting_unarchive_dlg_text : l[19064],
                icon: "sprite-fm-uni icon-question",
                name: "unarchive-conversation",
                pref: "5",
                onClose: () => {
                  self.setState({
                    unarchiveDialog: false
                  });
                },
                onConfirmClicked: () => {
                  self.props.chatRoom.scrolledToBottom = true;
                  room.unarchive();
                  self.setState({
                    unarchiveDialog: false
                  });
                }
              });
            }
            if (self.state.renameDialog === true) {
              var onEditSubmit = function (e) {
                if (self.props.chatRoom.setRoomTitle(self.state.renameDialogValue)) {
                  self.setState({
                    renameDialog: false,
                    renameDialogValue: undefined
                  });
                }
                e.preventDefault();
                e.stopPropagation();
              };
              var renameDialogValue =
                typeof self.state.renameDialogValue !== "undefined" ? self.state.renameDialogValue : self.props.chatRoom.getRoomTitle();
              confirmDeleteDialog = external_React_default().createElement(
                modalDialogs.Z.ModalDialog,
                {
                  chatRoom: room,
                  title: room.isMeeting ? l.rename_meeting : l[9080],
                  name: "rename-group",
                  className: "chat-rename-dialog dialog-template-main",
                  onClose: () => {
                    self.setState({
                      renameDialog: false,
                      renameDialogValue: undefined
                    });
                  },
                  buttons: [
                    {
                      label: l[1686],
                      key: "cancel",
                      onClick: function (e) {
                        self.setState({
                          renameDialog: false,
                          renameDialogValue: undefined
                        });
                        e.preventDefault();
                        e.stopPropagation();
                      }
                    },
                    {
                      label: l[61],
                      key: "rename",
                      className:
                        $.trim(self.state.renameDialogValue).length === 0 ||
                        self.state.renameDialogValue === self.props.chatRoom.getRoomTitle()
                          ? "positive disabled"
                          : "positive",
                      onClick: function (e) {
                        onEditSubmit(e);
                      }
                    }
                  ]
                },
                external_React_default().createElement(
                  "section",
                  {
                    className: "content"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "content-block"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: "dialog secondary-header"
                      },
                      external_React_default().createElement(
                        "div",
                        {
                          className: "rename-input-bl"
                        },
                        external_React_default().createElement("input", {
                          type: "text",
                          className: "chat-rename-group-dialog",
                          name: "newTopic",
                          value: renameDialogValue,
                          maxLength: ChatRoom.TOPIC_MAX_LENGTH,
                          onChange: (e) => {
                            self.setState({
                              renameDialogValue: e.target.value.substr(0, 30)
                            });
                          },
                          onKeyUp: (e) => {
                            if (e.which === 13) {
                              onEditSubmit(e);
                            }
                          }
                        })
                      )
                    )
                  )
                )
              );
            }
            let { descriptionDialog } = this.state;
            descriptionDialog = descriptionDialog
              ? external_React_default().createElement(
                  modalDialogs.Z.ModalDialog,
                  {
                    className: "scheduled-description-dialog",
                    meeting: room.scheduledMeeting,
                    onClose: () => {
                      this.setState({
                        descriptionDialog: false
                      });
                    }
                  },
                  external_React_default().createElement(
                    "header",
                    null,
                    external_React_default().createElement("h3", null, l.schedule_desc_dlg_title)
                  ),
                  external_React_default().createElement(
                    "section",
                    {
                      className: "content"
                    },
                    external_React_default().createElement(
                      perfectScrollbar.F,
                      {
                        className: "description-scroller"
                      },
                      external_React_default().createElement(
                        utils.Cw,
                        null,
                        megaChat.html(room.scheduledMeeting.description).replace(/\n/g, "<br>") || l.schedule_no_desc
                      )
                    )
                  )
                )
              : null;
            var topicInfo = null;
            const isUpcoming = room.scheduledMeeting && room.scheduledMeeting.isUpcoming;
            const isRecurring = room.scheduledMeeting && room.scheduledMeeting.isRecurring;
            if (room.type === "group" || room.type === "public") {
              topicInfo = external_React_default().createElement(
                "div",
                {
                  className: "chat-topic-info"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: `
                            chat-topic-icon
                            ${room.isMeeting ? "meeting-icon" : ""}
                        `
                  },
                  external_React_default().createElement("i", {
                    className: room.isMeeting ? "sprite-fm-mono icon-video-call-filled" : "sprite-fm-uni icon-chat-group"
                  })
                ),
                external_React_default().createElement(
                  "div",
                  {
                    className: "chat-topic-text"
                  },
                  external_React_default().createElement(
                    "span",
                    {
                      className: "txt"
                    },
                    external_React_default().createElement(utils.dy, null, room.getRoomTitle()),
                    isUpcoming &&
                      isRecurring &&
                      external_React_default().createElement("i", {
                        className: "sprite-fm-mono icon-repeat"
                      })
                  ),
                  external_React_default().createElement(
                    "span",
                    {
                      className: "txt small"
                    },
                    is_chatlink && isUpcoming && !isRecurring
                      ? this.renderUpcomingInfo()
                      : external_React_default().createElement(ui_contacts.MembersAmount, {
                          chatRoom: room
                        })
                  )
                )
              );
            } else {
              contactHandle = contacts[0];
              contact = M.u[contactHandle];
              topicInfo = external_React_default().createElement(ui_contacts.ContactCard, {
                className: "short",
                chatRoom: room,
                noContextButton: "true",
                contact: contact,
                showLastGreen: true,
                key: contact.u
              });
            }
            let historyRetentionDialog = null;
            if (self.state.showHistoryRetentionDialog === true) {
              historyRetentionDialog = external_React_default().createElement(HistoryRetentionDialog, {
                chatRoom: room,
                title: "",
                name: "rename-group",
                className: "",
                onClose: () => {
                  self.setState({
                    showHistoryRetentionDialog: false
                  });
                }
              });
            }
            if (this.state.waitingRoom) {
              return external_React_default().createElement(WaitingRoom, {
                chatRoom: room,
                havePendingCall: room.havePendingCall(),
                onWaitingRoomLeave: () => {
                  var _room$call;
                  (_room$call = room.call) == null || _room$call.destroy();
                  if (is_eplusplus) {
                    room.leave(true);
                    return onIdle(M.logout);
                  }
                  return this.setState(
                    {
                      waitingRoom: false
                    },
                    () => {
                      onIdle(() => {
                        if (megaChat.initialChatId) {
                          megaChat.initialChatId = undefined;
                          loadSubPage(getLandingPage());
                        }
                      });
                    }
                  );
                }
              });
            }
            const startCallDisabled = isStartCallDisabled(room) || room.iAmWaitingRoomPeer();
            return external_React_default().createElement(
              "div",
              {
                className: conversationPanelClasses,
                onMouseMove: () => self.onMouseMove(),
                "data-room-id": self.props.chatRoom.chatId
              },
              room.meetingsLoading &&
                external_React_default().createElement(Loading, {
                  chatRoom: room,
                  title: room.meetingsLoading.title
                }),
              room.call &&
                external_React_default().createElement(call.ZP, {
                  chatRoom: room,
                  peers: room.call.peers,
                  call: room.call,
                  minimized: this.state.callMinimized,
                  onCallMinimize: () => {
                    return this.state.callMinimized
                      ? null
                      : this.setState(
                          {
                            callMinimized: true
                          },
                          () => {
                            this.toggleExpandedFlag();
                            this.safeForceUpdate();
                          }
                        );
                  },
                  onCallExpand: () => {
                    return (
                      this.state.callMinimized &&
                      this.setState(
                        {
                          callMinimized: false
                        },
                        () => {
                          $.hideTopMenu();
                          if ($.dialog) {
                            closeDialog();
                          }
                          loadSubPage("fm/chat");
                          room.show();
                          this.toggleExpandedFlag();
                        }
                      )
                    );
                  },
                  didMount: () => {
                    this.toggleExpandedFlag();
                    if (room.isMeeting) {
                      room.updatePublicHandle().catch(dump);
                    }
                  },
                  willUnmount: (minimised) =>
                    this.setState(
                      {
                        callMinimized: false
                      },
                      () => (minimised ? null : this.toggleExpandedFlag())
                    ),
                  onCallEnd: () => this.safeForceUpdate(),
                  onDeleteMessage: (msg) => this.handleDeleteDialog(msg),
                  parent: this
                }),
              megaChat.initialPubChatHandle &&
                room.publicChatHandle === megaChat.initialPubChatHandle &&
                !room.call &&
                room.isMeeting &&
                !room.call &&
                room.activeCallIds.length > 0 &&
                external_React_default().createElement(Join, {
                  initialView: u_type || is_eplusplus ? Join.VIEW.ACCOUNT : Join.VIEW.INITIAL,
                  chatRoom: room,
                  onJoinGuestClick: (firstName, lastName, audioFlag, videoFlag) => {
                    room.meetingsLoading = l.joining;
                    u_eplusplus(firstName, lastName)
                      .then(() => {
                        return megaChat.routing.reinitAndJoinPublicChat(room.chatId, room.publicChatHandle, room.publicChatKey);
                      })
                      .then(() => {
                        delete megaChat.initialPubChatHandle;
                        return megaChat.getChatById(room.chatId).joinCall(audioFlag, videoFlag);
                      })
                      .catch((ex) => {
                        if (d) {
                          console.error("E++ account failure!", ex);
                        }
                        setTimeout(() => {
                          msgDialog("warninga", l[135], l.eplusplus_create_failed, escapeHTML(api_strerror(ex) || ex));
                        }, 1234);
                        eventlog(99745, JSON.stringify([1, String(ex).split("\n")[0]]));
                      });
                  },
                  onJoinClick: (audioFlag, videoFlag) => {
                    const chatId = room.chatId;
                    if (room.members[u_handle]) {
                      delete megaChat.initialPubChatHandle;
                      megaChat.routing
                        .reinitAndOpenExistingChat(chatId, room.publicChatHandle)
                        .then(() => {
                          return megaChat.getChatById(chatId).joinCall(audioFlag, videoFlag);
                        })
                        .catch((ex) => {
                          console.error("Failed to open existing room and join call:", ex);
                        });
                    } else {
                      megaChat.routing
                        .reinitAndJoinPublicChat(chatId, room.publicChatHandle, room.publicChatKey)
                        .then(() => {
                          delete megaChat.initialPubChatHandle;
                          return megaChat.getChatById(chatId).joinCall(audioFlag, videoFlag);
                        })
                        .catch((ex) => {
                          console.error("Failed to join room:", ex);
                        });
                    }
                  }
                }),
              external_React_default().createElement(
                "div",
                {
                  className: "chat-content-block " + (!room.megaChat.chatUIFlags["convPanelCollapse"] ? "with-pane" : "no-pane")
                },
                !room.megaChat.chatUIFlags["convPanelCollapse"]
                  ? external_React_default().createElement(ConversationRightArea, {
                      isVisible: this.props.chatRoom.isCurrentlyActive,
                      chatRoom: this.props.chatRoom,
                      roomFlags: this.props.chatRoom.flags,
                      members: this.props.chatRoom.membersSetFromApi,
                      messagesBuff: room.messagesBuff,
                      pushSettingsValue: pushNotificationSettings.getDnd(this.props.chatRoom.chatId),
                      occurrencesLoading: this.state.occurrencesLoading,
                      onStartCall: (mode) =>
                        (0, call.xt)()
                          .then(() => this.startCall(mode))
                          .catch(() => d && console.warn("Already in a call.")),
                      onAttachFromComputerClicked: function () {
                        self.props.chatRoom.uploadFromComputer();
                      },
                      onTruncateClicked: function () {
                        self.setState({
                          truncateDialog: true
                        });
                      },
                      onArchiveClicked: function () {
                        self.setState({
                          archiveDialog: true
                        });
                      },
                      onUnarchiveClicked: function () {
                        self.setState({
                          unarchiveDialog: true
                        });
                      },
                      onRenameClicked: function () {
                        self.setState({
                          renameDialog: true,
                          renameDialogValue: self.props.chatRoom.getRoomTitle()
                        });
                      },
                      onGetManageChatLinkClicked: function () {
                        self.setState({
                          chatLinkDialog: true
                        });
                      },
                      onMakePrivateClicked: function () {
                        self.setState({
                          privateChatDialog: true
                        });
                      },
                      onCloseClicked: function () {
                        room.destroy();
                      },
                      onJoinViaPublicLinkClicked: function () {
                        room.joinViaPublicHandle();
                      },
                      onSwitchOffPublicMode: function (topic) {
                        room.switchOffPublicMode(topic);
                      },
                      onAttachFromCloudClicked: function () {
                        self.setState({
                          attachCloudDialog: true
                        });
                      },
                      onPushSettingsClicked: function () {
                        self.setState({
                          pushSettingsDialog: true
                        });
                      },
                      onPushSettingsToggled: function () {
                        return room.dnd || room.dnd === 0
                          ? self.setState(
                              {
                                pushSettingsValue: null
                              },
                              () => pushNotificationSettings.disableDnd(room.chatId)
                            )
                          : pushNotificationSettings.setDnd(room.chatId, 0);
                      },
                      onHistoryRetentionConfig: function () {
                        self.setState({
                          showHistoryRetentionDialog: true
                        });
                      },
                      onAddParticipantSelected: (contactHashes) => {
                        room.scrolledToBottom = true;
                        if (room.type === "public") {
                          if (room.options.w && room.call) {
                            var _room$call$sfuClient;
                            (_room$call$sfuClient = room.call.sfuClient) == null || _room$call$sfuClient.wrAllowJoin(contactHashes);
                          }
                          return room.trigger("onAddUserRequest", [contactHashes]);
                        }
                        loadingDialog.show();
                        megaChat.trigger("onNewGroupChatRequest", [
                          [...room.getParticipantsExceptMe(), ...contactHashes],
                          {
                            keyRotation: false,
                            topic: ""
                          }
                        ]);
                      },
                      onShowScheduledDescription: () => {
                        if (room.scheduledMeeting) {
                          this.setState({
                            descriptionDialog: true
                          });
                        }
                      }
                    })
                  : null,
                privateChatDialog,
                chatLinkDialog,
                nonLoggedInJoinChatDialog,
                attachCloudDialog,
                sendContactDialog,
                confirmDeleteDialog,
                historyRetentionDialog,
                null,
                pushSettingsDialog,
                descriptionDialog,
                external_React_default().createElement(
                  "div",
                  {
                    className: "dropdown body dropdown-arrow down-arrow tooltip not-sent-notification hidden"
                  },
                  external_React_default().createElement("i", {
                    className: "dropdown-white-arrow"
                  }),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "dropdown notification-text"
                    },
                    external_React_default().createElement("i", {
                      className: "small-icon conversations"
                    }),
                    l[8882]
                  )
                ),
                external_React_default().createElement(
                  "div",
                  {
                    className: `
                            chat-topic-block
                            ${topicBlockClass}
                            ${room.haveActiveCall() ? "in-call" : ""}
                        `
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "chat-topic-buttons"
                    },
                    external_React_default().createElement(buttons.z, {
                      className: "right",
                      disableCheckingVisibility: true,
                      icon: "sprite-fm-mono icon-info-filled",
                      onClick: () => room.megaChat.toggleUIFlag("convPanelCollapse")
                    }),
                    external_React_default().createElement(
                      "div",
                      {
                        "data-simpletip": l.unsupported_browser_video,
                        "data-simpletipposition": "top",
                        "data-simpletipoffset": "5",
                        className: `
                                    ${!megaChat.hasSupportForCalls ? "simpletip" : ""}
                                    right
                                    ${startCallDisabled ? "disabled" : ""}
                                `
                      },
                      external_React_default().createElement(buttons.z, {
                        icon: "sprite-fm-mono icon-video-call-filled",
                        onClick: () =>
                          startCallDisabled
                            ? false
                            : (0, call.xt)()
                                .then(() => this.startCall(call.wD.VIDEO))
                                .catch(() => d && console.warn("Already in a call."))
                      })
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        "data-simpletip": l.unsupported_browser_audio,
                        "data-simpletipposition": "top",
                        "data-simpletipoffset": "5",
                        className: `
                                    ${!megaChat.hasSupportForCalls ? "simpletip" : ""}
                                    right
                                    ${startCallDisabled ? "disabled" : ""}
                                `
                      },
                      external_React_default().createElement(buttons.z, {
                        icon: "sprite-fm-mono icon-phone",
                        onClick: () =>
                          startCallDisabled
                            ? false
                            : (0, call.xt)()
                                .then(() => this.startCall(call.wD.AUDIO))
                                .catch(() => d && console.warn("Already in a call."))
                      })
                    )
                  ),
                  topicInfo
                ),
                external_React_default().createElement(
                  "div",
                  {
                    ref: this.containerRef,
                    className: `
                            messages-block
                            ${""}
                        `
                  },
                  this.state.hasInvalidKeys &&
                    this.state.invalidKeysBanner &&
                    external_React_default().createElement(Alert, {
                      type: Alert.TYPE.HIGH,
                      content: external_React_default().createElement(
                        external_React_default().Fragment,
                        null,
                        l.chat_key_failed_banner.split("[A]")[0],
                        external_React_default().createElement(
                          "a",
                          {
                            onClick: () => M.reload()
                          },
                          l.chat_key_failed_banner.substring(
                            l.chat_key_failed_banner.indexOf("[A]") + 3,
                            l.chat_key_failed_banner.indexOf("[/A]")
                          )
                        ),
                        l.chat_key_failed_banner.split("[/A]")[1]
                      ),
                      onClose: () =>
                        this.setState({
                          invalidKeysBanner: false
                        })
                    }),
                  external_React_default().createElement(
                    historyPanel.Z,
                    (0, esm_extends.Z)({}, this.props, {
                      onMessagesListScrollableMount: (mls) => {
                        this.messagesListScrollable = mls;
                      },
                      ref: (historyPanel) => {
                        this.historyPanel = historyPanel;
                      },
                      onDeleteClicked: (msg) => this.handleDeleteDialog(msg)
                    })
                  ),
                  !is_chatlink &&
                    room.state !== ChatRoom.STATE.LEFT &&
                    navigator.onLine &&
                    room.scheduledMeeting &&
                    !room.isArchived() &&
                    !isStartCallDisabled(room)
                    ? external_React_default().createElement(StartMeetingNotification, {
                        chatRoom: room,
                        offset: this.props.offset,
                        onWaitingRoomJoin: () =>
                          this.setState({
                            waitingRoom: true
                          }),
                        onStartCall: (mode) => {
                          return isStartCallDisabled(room)
                            ? null
                            : (0, call.xt)(true, room)
                                .then(() => this.startCall(mode, true))
                                .catch((ex) => d && console.warn(`Already in a call. ${ex}`));
                        }
                      })
                    : null,
                  !is_chatlink &&
                    room.state !== ChatRoom.STATE.LEFT &&
                    (room.havePendingGroupCall() || room.havePendingCall()) &&
                    navigator.onLine
                    ? external_React_default().createElement(JoinCallNotification, {
                        chatRoom: room,
                        offset: this.props.offset
                      })
                    : null,
                  room.isAnonymous()
                    ? external_React_default().createElement(
                        "div",
                        {
                          className: "join-chat-block"
                        },
                        external_React_default().createElement(
                          "div",
                          {
                            className: "mega-button large positive",
                            onClick: () => {
                              const join = () => {
                                megaChat.routing.reinitAndJoinPublicChat(room.chatId, room.publicChatHandle, room.publicChatKey).then(
                                  () => delete megaChat.initialPubChatHandle,
                                  (ex) => console.error("Failed to join room:", ex)
                                );
                              };
                              if (u_type === 0) {
                                return loadSubPage("register");
                              }
                              if (u_type === false) {
                                clearTimeout(self.state.setNonLoggedInJoinChatDlgTrue);
                                megaChat.loginOrRegisterBeforeJoining(room.publicChatHandle, false, false, false, join);
                                return;
                              }
                              clearTimeout(self.state.setNonLoggedInJoinChatDlgTrue);
                              join();
                            }
                          },
                          l[20597]
                        )
                      )
                    : external_React_default().createElement(composedTextArea.Z, {
                        chatRoom: room,
                        parent: this,
                        containerRef: this.containerRef
                      })
                )
              )
            );
          }
        }),
        ((0, applyDecoratedDescriptor.Z)(
          _class4.prototype,
          "onMouseMove",
          [conversationpanel_dec],
          Object.getOwnPropertyDescriptor(_class4.prototype, "onMouseMove"),
          _class4.prototype
        ),
        (0, applyDecoratedDescriptor.Z)(
          _class4.prototype,
          "render",
          [_dec2],
          Object.getOwnPropertyDescriptor(_class4.prototype, "render"),
          _class4.prototype
        )),
        _class4));
      class ConversationPanels extends mixins.wl {
        constructor(props) {
          super(props);
          this.alertsOffset = 4;
          this.notificationListener = "meetings:notificationPermissions";
          this.notificationGranted = undefined;
          this.notificationHelpURL = `${l.mega_help_host}/chats-meetings/meetings/enable-notification-browser-system-permission`;
          this.state = {
            supportAlert: undefined,
            notificationsPermissions: undefined,
            alertsOffset: this.alertsOffset
          };
          this.closeSupportAlert = () =>
            this.setState(
              {
                supportAlert: false
              },
              () => mega.config.set("nocallsup", 1)
            );
          this.onNotificationsGranted = () => {
            msgDialog(
              "info",
              "",
              l.notifications_permissions_granted_title,
              l.notifications_permissions_granted_info
                .replace("[A]", `<a href="${this.notificationHelpURL}" target="_blank" class="clickurl">`)
                .replace("[/A]", "</a>")
            );
            this.notificationGranted = new Notification(l.notification_granted_title, {
              body: l.notification_granted_body
            });
          };
          this.state.supportAlert = !megaChat.hasSupportForCalls;
          this.state.notificationsPermissions = window.Notification ? Notification.permission : "granted";
        }
        renderNotificationsPending() {
          return external_React_default().createElement(
            Alert,
            {
              type: Alert.TYPE.LIGHT,
              className: `
                    ${megaChat.chatUIFlags.convPanelCollapse ? "full-span" : ""}
                    ${this.props.isEmpty ? "empty-state" : ""}
                `,
              onTransition: (ref) =>
                this.setState({
                  alertsOffset: ref ? ref.current.offsetHeight : this.alertsOffset
                }),
              onClose: () => {
                this.setState(
                  {
                    notificationsPermissions: undefined
                  },
                  () => {
                    showToast("success", l.notifications_permissions_toast_title, l.notifications_permissions_toast_control, "", () =>
                      loadSubPage("fm/account/notifications")
                    );
                  }
                );
              }
            },
            l.notifications_permissions_pending,
            external_React_default().createElement(
              "div",
              {
                className: "meetings-alert-control"
              },
              external_React_default().createElement(
                "a",
                {
                  href: "#",
                  onClick: (ev) => {
                    ev.preventDefault();
                    Notification.requestPermission()
                      .then((status) => {
                        this.setState(
                          {
                            notificationsPermissions: status
                          },
                          () => onIdle(() => this.state.notificationsPermissions === "granted" && this.onNotificationsGranted())
                        );
                      })
                      .catch((ex) => d && console.warn(`Failed to retrieve permissions: ${ex}`));
                  }
                },
                l.notifications_permissions_enable
              )
            )
          );
        }
        renderNotificationsBlocked() {
          return external_React_default().createElement(
            Alert,
            {
              type: Alert.TYPE.MEDIUM,
              className: `
                    ${megaChat.chatUIFlags.convPanelCollapse ? "full-span" : ""}
                    ${this.props.isEmpty ? "empty-state" : ""}
                `,
              onTransition: (ref) =>
                this.setState({
                  alertsOffset: ref ? ref.current.offsetHeight : this.alertsOffset
                }),
              onClose: () =>
                this.setState({
                  notificationsPermissions: undefined
                })
            },
            external_React_default().createElement(utils.Cw, {
              content: l.notifications_permissions_denied_info
                .replace("[A]", `<a href="${this.notificationHelpURL}" target="_blank" class="clickurl">`)
                .replace("[/A]", "</a>")
            })
          );
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          mBroadcaster.removeListener(this.notificationListener);
        }
        componentDidMount() {
          var _this$props$onMount, _this$props;
          super.componentDidMount();
          (_this$props$onMount = (_this$props = this.props).onMount) == null || _this$props$onMount.call(_this$props);
          megaChat.chats.forEach((chatRoom) => {
            const { scheduledMeeting } = chatRoom;
            if (scheduledMeeting && scheduledMeeting.isUpcoming && scheduledMeeting.isRecurring) {
              scheduledMeeting.getOccurrences().catch(nop);
            }
          });
          mBroadcaster.addListener(
            this.notificationListener,
            (notificationsPermissions) =>
              this.isMounted() &&
              this.setState({
                notificationsPermissions
              })
          );
        }
        render() {
          const { routingSection, chatUIFlags, isEmpty, onToggleExpandedFlag } = this.props;
          const { notificationsPermissions, supportAlert, alertsOffset } = this.state;
          const now = Date.now();
          return external_React_default().createElement(
            "div",
            {
              className: "conversation-panels"
            },
            routingSection === "contacts" || notificationsPermissions === "granted"
              ? null
              : external_React_default().createElement(
                  external_React_default().Fragment,
                  null,
                  notificationsPermissions === "default" && this.renderNotificationsPending(),
                  notificationsPermissions === "denied" && this.renderNotificationsBlocked()
                ),
            routingSection === "contacts"
              ? null
              : supportAlert &&
                  !mega.config.get("nocallsup") &&
                  !notificationsPermissions &&
                  external_React_default().createElement(Alert, {
                    type: Alert.TYPE.MEDIUM,
                    className: `
                                ${megaChat.chatUIFlags.convPanelCollapse ? "full-span" : ""}
                                ${isEmpty ? "empty-state" : ""}
                            `,
                    content: call.ZP.getUnsupportedBrowserMessage(),
                    onClose: this.closeSupportAlert
                  }),
            megaChat.chats.map((chatRoom) => {
              if (chatRoom.isCurrentlyActive || now - chatRoom.lastShownInUI < 900000) {
                return external_React_default().createElement(ConversationPanel, {
                  key: `${chatRoom.roomId}_${chatRoom.instanceIndex}`,
                  chatRoom: chatRoom,
                  roomType: chatRoom.type,
                  isExpanded: chatRoom.megaChat.chatUIFlags.convPanelCollapse,
                  isActive: chatRoom.isCurrentlyActive,
                  messagesBuff: chatRoom.messagesBuff,
                  chatUIFlags: chatUIFlags,
                  offset: alertsOffset,
                  onToggleExpandedFlag: onToggleExpandedFlag
                });
              }
              return null;
            })
          );
        }
      }
      class EmptyConvPanel extends mixins.wl {
        renderActions() {
          const { isMeeting, onNewChat, onStartMeeting, onScheduleMeeting } = this.props;
          if (isMeeting) {
            return external_React_default().createElement(
              buttons.z,
              {
                className: "mega-button large positive",
                label: l.create_meeting
              },
              external_React_default().createElement(
                dropdowns.Dropdown,
                {
                  className: "light",
                  noArrow: "true",
                  vertOffset: 4
                },
                external_React_default().createElement(dropdowns.DropdownItem, {
                  className: "link-button",
                  icon: "sprite-fm-mono icon-video-plus",
                  label: l.new_meeting_start,
                  onClick: onStartMeeting
                }),
                external_React_default().createElement("hr", null),
                external_React_default().createElement(dropdowns.DropdownItem, {
                  className: "link-button",
                  icon: "sprite-fm-mono icon-calendar2",
                  label: l.schedule_meeting_start,
                  onClick: onScheduleMeeting
                })
              )
            );
          }
          return external_React_default().createElement(buttons.z, {
            className: "mega-button large positive",
            label: l.add_chat,
            onClick: onNewChat
          });
        }
        render() {
          return external_React_default().createElement(
            "div",
            {
              className: "conversations-empty"
            },
            external_React_default().createElement(
              "div",
              {
                className: "conversations-empty-content"
              },
              external_React_default().createElement("i", {
                className: "sprite-fm-mono icon-chat-filled"
              }),
              this.props.isMeeting
                ? external_React_default().createElement(
                    external_React_default().Fragment,
                    null,
                    external_React_default().createElement("h1", null, l.start_meeting),
                    external_React_default().createElement("p", null, l.onboard_megachat_dlg3_text)
                  )
                : external_React_default().createElement(
                    external_React_default().Fragment,
                    null,
                    external_React_default().createElement("h1", null, l.start_chat),
                    external_React_default().createElement("p", null, l.onboard_megachat_dlg2_text)
                  ),
              this.renderActions()
            )
          );
        }
      }
      function isStartCallDisabled(room) {
        if ((0, call.nJ)()) {
          return true;
        }
        if (!megaChat.hasSupportForCalls) {
          return true;
        }
        return (
          !room.isOnlineForCalls() ||
          room.isReadOnly() ||
          !room.chatId ||
          room.call ||
          ((room.type === "group" || room.type === "public") && false) ||
          room.getCallParticipants().length > 0
        );
      }

      /***/
    },

    /***/ 978: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, {
        FP: () => conversations_EVENTS,
        nk: () => VIEWS,
        ZP: () => conversations
      });

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
      var esm_extends = __webpack_require__(462);
      // EXTERNAL MODULE: external "React"
      var external_React_ = __webpack_require__(363);
      var external_React_default = __webpack_require__.n(external_React_);
      // EXTERNAL MODULE: ./js/chat/mixins.js
      var mixins = __webpack_require__(503);
      // EXTERNAL MODULE: ./js/chat/ui/conversationpanel.jsx + 14 modules
      var conversationpanel = __webpack_require__(21);
      // EXTERNAL MODULE: ./js/chat/ui/contactsPanel/contactsPanel.jsx + 20 modules
      var contactsPanel = __webpack_require__(808);
      // EXTERNAL MODULE: ./js/ui/modalDialogs.jsx + 1 modules
      var modalDialogs = __webpack_require__(182);
      // EXTERNAL MODULE: ./js/chat/ui/meetings/button.jsx
      var meetings_button = __webpack_require__(193);
      // EXTERNAL MODULE: ./js/chat/ui/meetings/workflow/preview.jsx
      var preview = __webpack_require__(889);
      // EXTERNAL MODULE: ./js/chat/ui/link.jsx
      var ui_link = __webpack_require__(941);
      // EXTERNAL MODULE: ./js/ui/utils.jsx
      var utils = __webpack_require__(79); // CONCATENATED MODULE: ./js/chat/ui/meetings/workflow/start.jsx
      var _class;

      class Start extends mixins.wl {
        constructor(props) {
          super(props);
          this.inputRef = external_React_default().createRef();
          this.defaultTopic = l.default_meeting_topic.replace("%NAME", M.getNameByHandle(u_handle));
          this.state = {
            audio: false,
            video: false,
            editing: false,
            previousTopic: undefined,
            topic: undefined,
            mounted: false
          };
          this.handleChange = (ev) =>
            this.setState({
              topic: ev.target.value
            });
          this.toggleEdit = () => {
            this.setState(
              (state) => {
                const topic = state.topic.trim() || this.defaultTopic;
                return {
                  editing: !state.editing,
                  topic,
                  previousTopic: topic
                };
              },
              () => onIdle(this.doFocus)
            );
          };
          this.doFocus = () => {
            if (this.state.editing) {
              const input = this.inputRef.current;
              input.focus();
              input.setSelectionRange(0, input.value.length);
            }
          };
          this.doReset = () =>
            this.setState((state) => ({
              editing: false,
              topic: state.previousTopic,
              previousTopic: undefined
            }));
          this.bindEvents = () =>
            $(document)
              .rebind(`mousedown.${Start.NAMESPACE}`, (ev) => {
                if (
                  this.state.editing &&
                  !ev.target.classList.contains(Start.CLASS_NAMES.EDIT) &&
                  !ev.target.classList.contains(Start.CLASS_NAMES.INPUT)
                ) {
                  this.toggleEdit();
                }
              })
              .rebind(`keyup.${Start.NAMESPACE}`, ({ keyCode }) => {
                if (this.state.editing) {
                  const [ENTER, ESCAPE] = [13, 27];
                  return keyCode === ENTER ? this.toggleEdit() : keyCode === ESCAPE ? this.doReset() : null;
                }
              });
          this.Input = () =>
            external_React_default().createElement("input", {
              type: "text",
              ref: this.inputRef,
              className: Start.CLASS_NAMES.INPUT,
              value: this.state.topic,
              maxLength: ChatRoom.TOPIC_MAX_LENGTH,
              onChange: this.handleChange
            });
          this.onStreamToggle = (audio, video) =>
            this.setState({
              audio,
              video
            });
          this.startMeeting = () => {
            const { onStart } = this.props;
            const { topic, audio, video } = this.state;
            if (onStart) {
              onStart(topic.trim() || this.defaultTopic, audio, video);
            }
          };
          this.state.topic = this.defaultTopic;
        }
        componentDidMount() {
          super.componentDidMount();
          this.bindEvents();
          M.safeShowDialog(Start.dialogName, () =>
            this.setState({
              mounted: true
            })
          );
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          $(document).unbind(`.${Start.NAMESPACE}`);
          if ($.dialog === Start.dialogName) {
            closeDialog();
          }
        }
        render() {
          const { NAMESPACE, CLASS_NAMES } = Start;
          const { editing, topic } = this.state;
          return external_React_default().createElement(
            modalDialogs.Z.ModalDialog,
            (0, esm_extends.Z)({}, this.state, {
              name: NAMESPACE,
              className: NAMESPACE,
              stopKeyPropagation: editing,
              noCloseOnClickOutside: true,
              onClose: () => this.props.onClose()
            }),
            external_React_default().createElement(
              "div",
              {
                className: `${NAMESPACE}-preview`
              },
              external_React_default().createElement(preview.Z, {
                context: NAMESPACE,
                onToggle: this.onStreamToggle
              })
            ),
            external_React_default().createElement(
              "div",
              {
                className: "fm-dialog-body"
              },
              external_React_default().createElement(
                "div",
                {
                  className: `${NAMESPACE}-title`
                },
                editing
                  ? external_React_default().createElement(this.Input, null)
                  : external_React_default().createElement(
                      "h2",
                      {
                        onClick: this.toggleEdit
                      },
                      external_React_default().createElement(utils.dy, null, topic)
                    ),
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    className: `
                                mega-button
                                action
                                small
                                ${CLASS_NAMES.EDIT}
                                ${editing ? "editing" : ""}
                            `,
                    icon: "icon-rename",
                    simpletip: {
                      label: l[1342],
                      position: "top"
                    },
                    onClick: this.toggleEdit
                  },
                  external_React_default().createElement("span", null, l[1342])
                )
              ),
              external_React_default().createElement(
                meetings_button.Z,
                {
                  className: "mega-button positive large start-meeting-button",
                  onClick: this.startMeeting
                },
                external_React_default().createElement("span", null, l[7315])
              ),
              external_React_default().createElement(
                ui_link.Z,
                {
                  to: "https://mega.io/chatandmeetings",
                  target: "_blank"
                },
                l.how_meetings_work
              )
            )
          );
        }
      }
      _class = Start;
      Start.NAMESPACE = "start-meeting";
      Start.dialogName = `${_class.NAMESPACE}-dialog`;
      Start.CLASS_NAMES = {
        EDIT: "call-title-edit",
        INPUT: "call-title-input"
      };
      Start.STREAMS = {
        AUDIO: 1,
        VIDEO: 2
      };
      // EXTERNAL MODULE: ./js/ui/perfectScrollbar.jsx
      var perfectScrollbar = __webpack_require__(285);
      // EXTERNAL MODULE: ./js/chat/ui/contacts.jsx
      var ui_contacts = __webpack_require__(13); // CONCATENATED MODULE: ./js/chat/ui/meetings/schedule/invite.jsx
      class Invite extends mixins.wl {
        constructor(props) {
          super(props);
          this.containerRef = external_React_default().createRef();
          this.wrapperRef = external_React_default().createRef();
          this.state = {
            value: "",
            expanded: false,
            loading: true,
            frequents: [],
            frequentsInitial: [],
            contacts: [],
            contactsInitial: [],
            selected: []
          };
          this.handleMousedown = ({ target }) =>
            this.containerRef && this.containerRef.current && this.containerRef.current.contains(target)
              ? null
              : this.setState({
                  expanded: false
                });
          this.getSortedContactsList = (frequents) => {
            const filteredContacts = [];
            M.u.forEach((contact) => {
              if (contact.c === 1 && !frequents.includes(contact.u) && !this.state.selected.includes(contact.u)) {
                filteredContacts.push(contact);
              }
            });
            const sortFn = M.getSortByNameFn2(1);
            filteredContacts.sort((a, b) => sortFn(a, b));
            return filteredContacts;
          };
          this.doMatch = (value, collection) => {
            value = value.toLowerCase();
            return collection.filter((contact) => {
              contact = typeof contact === "string" ? M.getUserByHandle(contact) : contact;
              const name = M.getNameByHandle(contact.u).toLowerCase();
              const email = contact.m && contact.m.toLowerCase();
              return name.includes(value) || email.includes(value);
            });
          };
          this.handleSearch = this.handleSearch.bind(this);
          this.state.selected = this.props.participants || [];
        }
        reinitializeWrapper() {
          const wrapperRef = this.wrapperRef && this.wrapperRef.current;
          if (wrapperRef) {
            wrapperRef.reinitialise();
            wrapperRef.scrollToY(0);
          }
        }
        buildContactsList() {
          megaChat.getFrequentContacts().then((frequentContacts) => {
            if (this.isMounted()) {
              const frequents = frequentContacts.slice(-ui_contacts.MAX_FREQUENTS).map((c) => c.userId);
              const contacts = this.getSortedContactsList(frequents);
              this.setState({
                frequents,
                frequentsInitial: frequents,
                contacts,
                contactsInitial: contacts,
                loading: false
              });
            }
          });
        }
        handleSearch(ev) {
          const { value } = ev.target;
          const searching = value.length >= 2;
          const frequents = searching ? this.doMatch(value, this.state.frequentsInitial) : this.state.frequentsInitial;
          const contacts = searching ? this.doMatch(value, this.state.contactsInitial) : this.state.contactsInitial;
          this.setState(
            {
              value,
              contacts,
              frequents
            },
            () => this.reinitializeWrapper()
          );
        }
        handleSelect(userHandle, expanded = false) {
          this.setState(
            (state) => ({
              value: "",
              expanded,
              selected: state.selected.includes(userHandle)
                ? state.selected.filter((c) => c !== userHandle)
                : [...state.selected, userHandle]
            }),
            () => {
              this.props.onSelect(this.state.selected);
              this.buildContactsList();
              this.reinitializeWrapper();
            }
          );
        }
        getFilteredContacts(contacts) {
          if (contacts && contacts.length) {
            return contacts.map((contact) => {
              contact = contact instanceof MegaDataMap ? contact : M.u[contact];
              return this.state.selected.includes(contact.u)
                ? null
                : external_React_default().createElement(
                    "div",
                    {
                      key: contact.u,
                      className: "invite-section-item",
                      onClick: () => {
                        this.handleSelect(contact.u);
                      }
                    },
                    external_React_default().createElement(ui_contacts.Avatar, {
                      contact: contact
                    }),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "invite-item-data"
                      },
                      external_React_default().createElement(
                        "div",
                        {
                          className: "invite-item-name"
                        },
                        external_React_default().createElement(ui_contacts.ContactAwareName, {
                          overflow: true,
                          simpletip: {
                            offset: 10
                          },
                          contact: contact
                        })
                      ),
                      external_React_default().createElement(
                        "div",
                        {
                          className: "invite-item-mail"
                        },
                        contact.m
                      )
                    )
                  );
            });
          }
          return null;
        }
        renderContent() {
          const { frequents, contacts, selected } = this.state;
          const hasMoreFrequents = frequents.length && frequents.some((h) => !selected.includes(h));
          const $$SECTION = (title, children) =>
            external_React_default().createElement(
              "div",
              {
                className: "invite-section"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "invite-section-title"
                },
                title
              ),
              children &&
                external_React_default().createElement(
                  "div",
                  {
                    className: "invite-section-list"
                  },
                  children
                )
            );
          if (hasMoreFrequents || contacts.length) {
            return external_React_default().createElement(
              perfectScrollbar.F,
              {
                ref: this.wrapperRef,
                className: "invite-scroll-wrapper",
                options: {
                  suppressScrollX: true
                }
              },
              hasMoreFrequents ? $$SECTION(l.recent_contact_label, this.getFilteredContacts(frequents)) : "",
              contacts.length ? $$SECTION(l.all_contact_label, this.getFilteredContacts(contacts)) : "",
              frequents.length === 0 && contacts.length === 0 && $$SECTION(l.invite_no_results_found, null)
            );
          }
          return $$SECTION(l.invite_no_contacts_to_add, null);
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          document.removeEventListener("mousedown", this.handleMousedown);
        }
        componentDidMount() {
          super.componentDidMount();
          document.addEventListener("mousedown", this.handleMousedown);
          this.buildContactsList();
        }
        render() {
          const { value, expanded, loading, selected } = this.state;
          return external_React_default().createElement(
            "div",
            {
              ref: this.containerRef,
              className: `
                    ${Invite.NAMESPACE}
                    ${this.props.className || ""}
                `
            },
            external_React_default().createElement(
              "div",
              {
                className: "multiple-input"
              },
              external_React_default().createElement(
                "ul",
                {
                  className: "token-input-list-mega",
                  onClick: (ev) =>
                    ev.target.classList.contains("token-input-list-mega") &&
                    this.setState({
                      expanded: true
                    })
                },
                selected.map((handle) => {
                  return external_React_default().createElement(
                    "li",
                    {
                      key: handle,
                      className: "token-input-token-mega"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: "contact-tag-item"
                      },
                      external_React_default().createElement(ui_contacts.Avatar, {
                        contact: M.u[handle],
                        className: "avatar-wrapper box-avatar"
                      }),
                      external_React_default().createElement(ui_contacts.ContactAwareName, {
                        contact: M.u[handle],
                        overflow: true
                      }),
                      external_React_default().createElement("i", {
                        className: "sprite-fm-mono icon-close-component",
                        onClick: () => {
                          this.handleSelect(handle);
                        }
                      })
                    )
                  );
                }),
                external_React_default().createElement(
                  "li",
                  {
                    className: "token-input-input-token-mega"
                  },
                  external_React_default().createElement("input", {
                    type: "text",
                    name: "participants",
                    className: `${Invite.NAMESPACE}-input`,
                    autoComplete: "off",
                    placeholder: selected.length ? "" : l.schedule_participant_input,
                    value: value,
                    onFocus: () =>
                      this.setState({
                        expanded: true
                      }),
                    onChange: this.handleSearch,
                    onKeyDown: ({ target, keyCode }) => {
                      const { selected } = this.state;
                      return (
                        keyCode === 8 && target.value === "" && selected.length && this.handleSelect(selected[selected.length - 1], true)
                      );
                    }
                  })
                )
              )
            ),
            loading
              ? null
              : external_React_default().createElement(
                  "div",
                  {
                    className: `mega-input-dropdown ${expanded ? "" : "hidden"}`
                  },
                  this.renderContent()
                )
          );
        }
      }
      Invite.NAMESPACE = "meetings-invite";
      // EXTERNAL MODULE: ./js/chat/ui/meetings/schedule/helpers.jsx
      var helpers = __webpack_require__(435); // CONCATENATED MODULE: ./js/chat/ui/meetings/schedule/datepicker.jsx
      class Datepicker extends mixins.wl {
        constructor(props) {
          super(props);
          this.OPTIONS = {
            classes: "meetings-datepicker-calendar",
            dateFormat: "@",
            minDate: null,
            startDate: null,
            selectedDates: [],
            prevHtml: '<i class="sprite-fm-mono icon-arrow-right"></i>',
            nextHtml: '<i class="sprite-fm-mono icon-arrow-right"></i>',
            altField: null,
            firstDay: 0,
            autoClose: true,
            toggleSelected: false,
            position: "bottom left",
            language: {
              daysMin: [l[8763], l[8764], l[8765], l[8766], l[8767], l[8768], l[8769]],
              months: [l[408], l[409], l[410], l[411], l[412], l[413], l[414], l[415], l[416], l[417], l[418], l[419]],
              monthsShort: [
                l[24035],
                l[24037],
                l[24036],
                l[24038],
                l[24047],
                l[24039],
                l[24040],
                l[24041],
                l[24042],
                l[24043],
                l[24044],
                l[24045]
              ]
            },
            onSelect: (dateText) => {
              const prevDate = new Date(+this.props.value);
              const nextDate = new Date(+dateText);
              nextDate.setHours(prevDate.getHours(), prevDate.getMinutes());
              return this.props.onSelect(nextDate.getTime());
            }
          };
          this.containerRef = external_React_default().createRef();
          this.inputRef = external_React_default().createRef();
          this.datepicker = null;
          this.formatValue = (value) => {
            if (typeof value === "number") {
              return time2date(value / 1000, 18);
            }
            return value;
          };
          this.OPTIONS.startDate = new Date(this.props.startDate);
          this.OPTIONS.selectedDates = this.props.selectedDates || [this.OPTIONS.startDate];
          this.OPTIONS.minDate = this.props.minDate ? new Date(this.props.minDate) : new Date();
          this.OPTIONS.position = this.props.position || this.OPTIONS.position;
          this.OPTIONS.altField = `input.${this.props.altField}`;
        }
        initialize() {
          const inputRef = this.inputRef && this.inputRef.current;
          if (inputRef) {
            var _this$props$onMount, _this$props;
            $(inputRef).datepicker(this.OPTIONS);
            this.datepicker = $(inputRef).data("datepicker");
            (_this$props$onMount = (_this$props = this.props).onMount) == null || _this$props$onMount.call(_this$props, this.datepicker);
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          if (this.containerRef && this.containerRef.current) {
            $(this.containerRef.current).unbind(`keyup.${Datepicker.NAMESPACE}`);
          }
        }
        componentDidMount() {
          super.componentDidMount();
          M.require("datepicker_js").done(() => this.initialize());
          if (this.containerRef && this.containerRef.current) {
            $(this.containerRef.current).rebind(`keyup.${Datepicker.NAMESPACE}`, ({ keyCode }) => {
              if (keyCode === 13) {
                this.datepicker.hide();
                return false;
              }
            });
          }
        }
        render() {
          const { NAMESPACE } = Datepicker;
          const { value, name, className, placeholder, onFocus, onChange, onBlur } = this.props;
          const formattedValue = this.formatValue(value);
          return external_React_default().createElement(
            "div",
            {
              ref: this.containerRef,
              className: NAMESPACE
            },
            external_React_default().createElement(
              "div",
              {
                className: "mega-input datepicker-input"
              },
              external_React_default().createElement("input", {
                ref: this.inputRef,
                type: "text",
                name: name,
                className: `
                            dialog-input
                            ${className || ""}
                        `,
                autoComplete: "off",
                placeholder: placeholder || "",
                value: formattedValue,
                onFocus: (ev) => (onFocus == null ? void 0 : onFocus(ev)),
                onChange: (ev) => (onChange == null ? void 0 : onChange(ev)),
                onBlur: (ev) => (onBlur == null ? void 0 : onBlur(ev))
              }),
              external_React_default().createElement("i", {
                className: "sprite-fm-mono icon-calendar1",
                onClick: () => this.datepicker && this.datepicker.show()
              })
            )
          );
        }
      }
      Datepicker.NAMESPACE = "meetings-datepicker"; // CONCATENATED MODULE: ./js/chat/ui/meetings/schedule/select.jsx
      class Select extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.containerRef = external_React_default().createRef();
          this.inputRef = external_React_default().createRef();
          this.menuRef = external_React_default().createRef();
          this.optionRefs = {};
          this.state = {
            expanded: false,
            manualTimeInput: "",
            timestamp: ""
          };
          this.handleMousedown = ({ target }) => {
            var _this$containerRef;
            return (_this$containerRef = this.containerRef) != null && _this$containerRef.current.contains(target)
              ? null
              : this.setState({
                  expanded: false
                });
          };
          this.handleToggle = ({ target }) => {
            const menuRef = this.menuRef && this.menuRef.current;
            if (target !== menuRef.domNode) {
              const { value } = this.props;
              this.setState(
                (state) => ({
                  expanded: !state.expanded
                }),
                () => {
                  if (value && this.optionRefs[value]) {
                    menuRef.scrollToElement(this.optionRefs[value]);
                  }
                }
              );
            }
          };
        }
        getFormattedDuration(duration) {
          duration = moment.duration(duration);
          const hours = duration.get("hours");
          const minutes = duration.get("minutes");
          if (!hours && !minutes) {
            return "";
          }
          if (!hours && minutes) {
            return "([[MINUTES]]\u00a0m)".replace("[[MINUTES]]", minutes);
          }
          return (minutes ? "([[HOURS]]\u00a0h [[MINUTES]]\u00a0m)" : "([[HOURS]]\u00a0h)")
            .replace("[[HOURS]]", hours)
            .replace("[[MINUTES]]", minutes);
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          document.removeEventListener("mousedown", this.handleMousedown);
          if (this.inputRef && this.inputRef.current) {
            $(this.inputRef.current).unbind(`keyup.${Select.NAMESPACE}`);
          }
        }
        componentDidMount() {
          var _this$inputRef;
          super.componentDidMount();
          document.addEventListener("mousedown", this.handleMousedown);
          const inputRef = (_this$inputRef = this.inputRef) == null ? void 0 : _this$inputRef.current;
          if (inputRef) {
            $(inputRef).rebind(`keyup.${Select.NAMESPACE}`, ({ keyCode }) => {
              if (keyCode === 13) {
                this.handleToggle();
                inputRef.blur();
                return false;
              }
            });
          }
        }
        render() {
          const { NAMESPACE } = Select;
          const { name, className, icon, typeable, options, value, format, onChange, onBlur, onSelect } = this.props;
          return external_React_default().createElement(
            "div",
            {
              ref: this.containerRef,
              className: `
                    ${NAMESPACE}
                    ${className || ""}
                `
            },
            external_React_default().createElement(
              "div",
              {
                className: `
                        mega-input
                        dropdown-input
                        ${typeable ? "typeable" : ""}
                    `,
                onClick: this.handleToggle
              },
              typeable ? null : value && external_React_default().createElement("span", null, format ? format(value) : value),
              external_React_default().createElement("input", {
                ref: this.inputRef,
                type: "text",
                className: `
                            ${NAMESPACE}-input
                            ${name}
                        `,
                value: (() => {
                  if (this.state.manualTimeInput) {
                    return this.state.manualTimeInput;
                  }
                  return format ? format(value) : value;
                })(),
                onFocus: ({ target }) => {
                  this.setState(
                    {
                      manualTimeInput: "",
                      timestamp: ""
                    },
                    () => target.select()
                  );
                },
                onChange: ({ target }) => {
                  const { value: manualTimeInput } = target;
                  const { value } = this.props;
                  const prevDate = moment(value);
                  const inputTime = (0, helpers.K6)(manualTimeInput);
                  prevDate.set({
                    hours: inputTime.get("hours"),
                    minutes: inputTime.get("minutes")
                  });
                  const timestamp = prevDate.valueOf();
                  onChange == null || onChange(timestamp);
                  if (this.optionRefs[value]) {
                    this.menuRef.current.scrollToElement(this.optionRefs[value]);
                  }
                  this.setState({
                    manualTimeInput,
                    timestamp
                  });
                },
                onBlur: () => {
                  onBlur(this.state.timestamp);
                  this.setState({
                    manualTimeInput: "",
                    timestamp: ""
                  });
                }
              }),
              icon &&
                external_React_default().createElement("i", {
                  className: "sprite-fm-mono icon-dropdown"
                }),
              options &&
                external_React_default().createElement(
                  "div",
                  {
                    className: `
                                mega-input-dropdown
                                ${this.state.expanded ? "" : "hidden"}
                            `
                  },
                  external_React_default().createElement(
                    perfectScrollbar.F,
                    {
                      ref: this.menuRef,
                      options: {
                        suppressScrollX: true
                      }
                    },
                    options.map((option) => {
                      return external_React_default().createElement(
                        "div",
                        {
                          ref: (ref) => {
                            this.optionRefs[option.value] = ref;
                          },
                          key: option.value,
                          className: `
                                                option
                                                ${option.value === value || option.label === value ? "active" : ""}
                                            `,
                          onClick: () => onSelect(option)
                        },
                        option.label,
                        "\xA0",
                        option.duration && this.getFormattedDuration(option.duration)
                      );
                    })
                  )
                )
            )
          );
        }
      }
      Select.NAMESPACE = "meetings-select"; // CONCATENATED MODULE: ./js/chat/ui/meetings/schedule/datetime.jsx
      class DateTime extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.state = {
            datepickerRef: undefined,
            manualDateInput: "",
            manualTimeInput: "",
            initialDate: ""
          };
          this.handleChange = (ev) => {
            const { onChange } = this.props;
            const { datepickerRef, initialDate } = this.state;
            if (!datepickerRef) {
              return;
            }
            const { value } = ev.target;
            const date = (0, helpers.p6)(value);
            const timestamp = date.valueOf();
            const dateObj = new Date(timestamp);
            dateObj.setHours(initialDate.getHours(), initialDate.getMinutes());
            datepickerRef.selectedDates = [dateObj];
            datepickerRef.currentDate = dateObj;
            datepickerRef.nav._render();
            datepickerRef.views.days._render();
            onChange == null || onChange(value);
            this.setState({
              manualDateInput: dateObj.getTime()
            });
          };
        }
        render() {
          const {
            name,
            startDate,
            altField,
            value,
            minDate,
            filteredTimeIntervals,
            label,
            isLoading,
            onMount,
            onSelectDate,
            onSelectTime,
            onBlur
          } = this.props;
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            label && external_React_default().createElement("span", null, label),
            external_React_default().createElement(Datepicker, {
              name: `${Datepicker.NAMESPACE}-${name}`,
              className: isLoading ? "disabled" : "",
              startDate: startDate,
              altField: `${Select.NAMESPACE}-${altField}`,
              value: value,
              minDate: minDate,
              onMount: (datepickerRef) =>
                this.setState(
                  {
                    datepickerRef
                  },
                  () => onMount(datepickerRef)
                ),
              onSelect: onSelectDate,
              onFocus: ({ target }) => {
                this.setState(
                  {
                    manualDateInput: undefined,
                    manualTimeInput: undefined,
                    initialDate: new Date(value)
                  },
                  () => target.select()
                );
              },
              onChange: this.handleChange,
              onBlur: () => onBlur(this.state.manualDateInput)
            }),
            external_React_default().createElement(Select, {
              name: `${Select.NAMESPACE}-${altField}`,
              className: isLoading ? "disabled" : "",
              typeable: true,
              options: filteredTimeIntervals,
              value: (() => (typeof value === "number" ? value : this.state.datepickerRef.currentDate.getTime()))(),
              format: toLocaleTime,
              onSelect: onSelectTime,
              onChange: () => false,
              onBlur: (timestamp) => {
                if (timestamp) {
                  onSelectTime({
                    value: timestamp
                  });
                }
              }
            })
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/meetings/schedule/recurring.jsx
      class Recurring extends mixins.wl {
        constructor(props) {
          var _Object$values$find;
          super(props);
          this.VIEWS = {
            DAILY: 0x00,
            WEEKLY: 0x01,
            MONTHLY: 0x02
          };
          this.FREQUENCIES = {
            DAILY: "d",
            WEEKLY: "w",
            MONTHLY: "m"
          };
          this.WEEK_DAYS = {
            MONDAY: {
              value: 1,
              label: l.schedule_day_control_mon,
              name: l.schedule_occur_mon
            },
            TUESDAY: {
              value: 2,
              label: l.schedule_day_control_tue,
              name: l.schedule_occur_tue
            },
            WEDNESDAY: {
              value: 3,
              label: l.schedule_day_control_wed,
              name: l.schedule_occur_wed
            },
            THURSDAY: {
              value: 4,
              label: l.schedule_day_control_thu,
              name: l.schedule_occur_thu
            },
            FRIDAY: {
              value: 5,
              label: l.schedule_day_control_fri,
              name: l.schedule_occur_fri
            },
            SATURDAY: {
              value: 6,
              label: l.schedule_day_control_sat,
              name: l.schedule_occur_sat
            },
            SUNDAY: {
              value: 7,
              label: l.schedule_day_control_sun,
              name: l.schedule_occur_sun
            }
          };
          this.OFFSETS = {
            FIRST: {
              value: 1,
              label: l.recurring_frequency_offset_first
            },
            SECOND: {
              value: 2,
              label: l.recurring_frequency_offset_second
            },
            THIRD: {
              value: 3,
              label: l.recurring_frequency_offset_third
            },
            FOURTH: {
              value: 4,
              label: l.recurring_frequency_offset_fourth
            },
            FIFTH: {
              value: 5,
              label: l.recurring_frequency_offset_fifth
            }
          };
          this.MONTH_RULES = {
            DAY: "day",
            OFFSET: "offset"
          };
          this.initialEnd = (0, helpers.zI)(this.props.startDateTime, 6);
          this.initialWeekDays = Object.values(this.WEEK_DAYS).map((d) => d.value);
          this.initialMonthDay = this.props.startDateTime ? new Date(this.props.startDateTime).getDate() : undefined;
          this.state = {
            view: this.VIEWS.DAILY,
            frequency: this.FREQUENCIES.DAILY,
            end: this.initialEnd,
            prevEnd: undefined,
            interval: 0,
            weekDays: this.initialWeekDays,
            monthRule: this.MONTH_RULES.DAY,
            monthDays: [this.initialMonthDay],
            offset: {
              value: this.OFFSETS.FIRST.value,
              weekDay: this.WEEK_DAYS.MONDAY.value
            },
            monthDaysWarning: this.initialMonthDay > 28
          };
          this.toggleView = (view, frequency, state) =>
            this.setState({
              view,
              frequency,
              ...state
            });
          const { chatRoom, startDateTime } = this.props;
          const weekDay = new Date(startDateTime).getDay();
          this.state.offset.weekDay =
            ((_Object$values$find = Object.values(this.WEEK_DAYS).find((d) => d.value === weekDay)) == null
              ? void 0
              : _Object$values$find.value) || this.WEEK_DAYS.SUNDAY.value;
          if (chatRoom && chatRoom.scheduledMeeting && chatRoom.scheduledMeeting.isRecurring) {
            const { frequency, interval, end, weekDays, monthDays, offset } = chatRoom.scheduledMeeting.recurring;
            this.state.view = frequency === "d" ? this.VIEWS.DAILY : frequency === "w" ? this.VIEWS.WEEKLY : this.VIEWS.MONTHLY;
            this.state.frequency = frequency;
            this.state.end = end;
            this.state.interval = interval;
            this.state.weekDays = weekDays && weekDays.length ? weekDays : this.initialWeekDays;
            this.state.monthRule = monthDays && monthDays.length ? this.MONTH_RULES.DAY : this.MONTH_RULES.OFFSET;
            this.state.monthDays = monthDays && monthDays.length ? [monthDays[0]] : [this.initialMonthDay];
            this.state.offset = offset && Object.keys(offset).length ? offset : this.state.offset;
          }
        }
        getFormattedState(state) {
          const { frequency, end, interval, weekDays, monthRule, monthDays, offset } = state;
          switch (true) {
            case frequency === this.FREQUENCIES.DAILY:
              return {
                frequency,
                end,
                weekDays
              };
            case frequency === this.FREQUENCIES.WEEKLY:
              return {
                frequency,
                end,
                ...(interval && {
                  interval
                }),
                weekDays
              };
            case frequency === this.FREQUENCIES.MONTHLY:
              return {
                frequency,
                end,
                ...(interval && {
                  interval
                }),
                ...(monthRule === this.MONTH_RULES.DAY
                  ? {
                      monthDays
                    }
                  : {
                      offset: [[offset.value, offset.weekDay]]
                    })
              };
          }
        }
        renderDayControls() {
          const { weekDays, view } = this.state;
          const handleWeeklySelection = (weekDay, remove) => {
            this.setState(
              (state) => {
                if (remove) {
                  return {
                    weekDays: state.weekDays.length === 1 ? state.weekDays : state.weekDays.filter((d) => d !== weekDay)
                  };
                }
                return {
                  weekDays: [...state.weekDays, weekDay]
                };
              },
              () => {
                const { weekDays } = this.state;
                if (weekDays.length === Object.keys(this.WEEK_DAYS).length) {
                  this.toggleView(this.VIEWS.DAILY, this.FREQUENCIES.DAILY);
                }
              }
            );
          };
          const handleDailySelection = (weekDay) => {
            this.toggleView(this.VIEWS.WEEKLY, this.FREQUENCIES.WEEKLY, {
              weekDays: weekDays.filter((d) => d !== weekDay)
            });
          };
          return external_React_default().createElement(
            "div",
            {
              className: "recurring-field-row"
            },
            Object.values(this.WEEK_DAYS).map(({ value, label }) => {
              const isCurrentlySelected = weekDays.includes(value);
              return external_React_default().createElement(
                meetings_button.Z,
                {
                  key: value,
                  className: `
                                mega-button
                                action
                                recurring-toggle-button
                                ${isCurrentlySelected ? "active" : ""}
                                ${weekDays.length === 1 && isCurrentlySelected ? "disabled" : ""}
                            `,
                  onClick: () => {
                    if (view === this.VIEWS.WEEKLY) {
                      return handleWeeklySelection(value, isCurrentlySelected);
                    }
                    return handleDailySelection(value);
                  }
                },
                label
              );
            })
          );
        }
        renderIntervalControls() {
          const { view, interval } = this.state;
          return external_React_default().createElement(
            "div",
            {
              className: "recurring-field-row"
            },
            external_React_default().createElement("span", null, l.recur_rate),
            external_React_default().createElement(
              "div",
              {
                className: "mega-input inline recurring-interval"
              },
              external_React_default().createElement(Select, {
                name: `${Recurring.NAMESPACE}-interval`,
                value: interval > 0 ? interval : 1,
                icon: true,
                options: [...Array(view === this.VIEWS.WEEKLY ? 52 : 12).keys()].map((value) => {
                  value += 1;
                  return {
                    value: value,
                    label: value
                  };
                }),
                onSelect: ({ value }) => {
                  this.setState({
                    interval: value === 1 ? 0 : value
                  });
                }
              })
            ),
            view === this.VIEWS.WEEKLY && external_React_default().createElement("span", null, mega.icu.format(l.plural_week, interval)),
            view === this.VIEWS.MONTHLY && external_React_default().createElement("span", null, mega.icu.format(l.plural_month, interval))
          );
        }
        renderEndControls() {
          const { end, prevEnd } = this.state;
          return external_React_default().createElement(
            "div",
            {
              className: "recurring-field-row"
            },
            external_React_default().createElement(
              "div",
              {
                className: "recurring-title-heading"
              },
              l.recurring_ends
            ),
            external_React_default().createElement(
              "div",
              {
                className: "recurring-radio-buttons"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "recurring-label-wrap"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: `
                                uiTheme
                                ${end ? "radioOff" : "radioOn"}
                            `
                  },
                  external_React_default().createElement("input", {
                    type: "radio",
                    name: `${Recurring.NAMESPACE}-radio-end`,
                    className: `
                                    uiTheme
                                    ${end ? "radioOff" : "radioOn"}
                                `,
                    onChange: () => {
                      this.setState((state) => ({
                        end: undefined,
                        prevEnd: state.end || state.prevEnd
                      }));
                    }
                  })
                ),
                external_React_default().createElement(
                  "div",
                  {
                    className: "radio-txt"
                  },
                  external_React_default().createElement(
                    "span",
                    {
                      className: "recurring-radio-label",
                      onClick: () => {
                        this.setState((state) => ({
                          end: undefined,
                          prevEnd: state.end || state.prevEnd
                        }));
                      }
                    },
                    l.recurring_never
                  )
                )
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "recurring-label-wrap"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: `
                                uiTheme
                                ${end ? "radioOn" : "radioOff"}
                            `
                  },
                  external_React_default().createElement("input", {
                    type: "radio",
                    name: `${Recurring.NAMESPACE}-radio-end`,
                    className: `
                                    uiTheme
                                    ${end ? "radioOn" : "radioOff"}
                                `,
                    onChange: () => {
                      this.setState({
                        end: prevEnd || this.initialEnd
                      });
                    }
                  })
                ),
                external_React_default().createElement(
                  "div",
                  {
                    className: "radio-txt"
                  },
                  external_React_default().createElement(
                    "span",
                    {
                      className: "recurring-radio-label",
                      onClick: () => {
                        return end
                          ? null
                          : this.setState({
                              end: prevEnd || this.initialEnd
                            });
                      }
                    },
                    l.recurring_on
                  ),
                  external_React_default().createElement(Datepicker, {
                    name: `${Recurring.NAMESPACE}-endDateTime`,
                    position: "top left",
                    startDate: end || this.initialEnd,
                    selectedDates: [new Date(end)],
                    value: end || prevEnd || "",
                    placeholder: time2date(end || prevEnd || this.initialEnd / 1000, 18),
                    onMount: this.props.onMount,
                    onSelect: (timestamp) => {
                      this.setState(
                        {
                          end: timestamp
                        },
                        () => {
                          this.safeForceUpdate();
                        }
                      );
                    }
                  })
                )
              )
            )
          );
        }
        renderDaily() {
          return external_React_default().createElement(
            "div",
            {
              className: `${Recurring.NAMESPACE}-daily`
            },
            this.renderDayControls(),
            this.renderEndControls()
          );
        }
        renderWeekly() {
          return external_React_default().createElement(
            "div",
            {
              className: `${Recurring.NAMESPACE}-weekly`
            },
            this.renderIntervalControls(),
            this.renderDayControls(),
            this.renderEndControls()
          );
        }
        renderMonthly() {
          const { monthRule, monthDays, monthDaysWarning, offset } = this.state;
          return external_React_default().createElement(
            "div",
            {
              className: `${Recurring.NAMESPACE}-monthly`
            },
            this.renderIntervalControls(),
            external_React_default().createElement(
              "div",
              {
                className: "recurring-field-row"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "recurring-radio-buttons",
                  onClick: (ev) => {
                    const { name, value } = ev.target;
                    if (name === `${Recurring.NAMESPACE}-radio-monthRule`) {
                      this.setState({
                        monthRule: value
                      });
                    }
                  }
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "recurring-label-wrap"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: `
                                    uiTheme
                                    ${monthRule === "day" ? "radioOn" : "radioOff"}
                                `
                    },
                    external_React_default().createElement("input", {
                      type: "radio",
                      name: `${Recurring.NAMESPACE}-radio-monthRule`,
                      value: "day",
                      className: `
                                        uiTheme
                                        ${monthRule === "day" ? "radioOn" : "radioOff"}
                                    `
                    })
                  ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "radio-txt"
                    },
                    external_React_default().createElement(
                      "span",
                      {
                        className: "recurring-radio-label",
                        onClick: () => {
                          this.setState({
                            monthRule: this.MONTH_RULES.DAY
                          });
                        }
                      },
                      l.recurring_frequency_day
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "mega-input inline recurring-day"
                      },
                      external_React_default().createElement(Select, {
                        name: `${Recurring.NAMESPACE}-monthDay`,
                        icon: true,
                        value: monthDays[0],
                        options: [...Array(31).keys()].map((value) => {
                          value += 1;
                          return {
                            value,
                            label: value
                          };
                        }),
                        onSelect: ({ value }) => {
                          this.setState({
                            monthRule: this.MONTH_RULES.DAY,
                            monthDays: [value],
                            monthDaysWarning: value > 28
                          });
                        }
                      })
                    )
                  )
                ),
                monthDaysWarning &&
                  external_React_default().createElement(
                    "div",
                    {
                      className: "recurring-label-wrap"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: "mega-banner body with-btn"
                      },
                      external_React_default().createElement(
                        "div",
                        {
                          className: "green-notification cell text-cell"
                        },
                        external_React_default().createElement(
                          "div",
                          {
                            className: "versioning-body-text"
                          },
                          l.recurring_monthdays_warning.replace("%n", monthDays[0])
                        )
                      )
                    )
                  ),
                external_React_default().createElement(
                  "div",
                  {
                    className: "recurring-label-wrap"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: `
                                    uiTheme
                                    ${monthRule === this.MONTH_RULES.OFFSET ? "radioOn" : "radioOff"}
                                `
                    },
                    external_React_default().createElement("input", {
                      type: "radio",
                      name: `${Recurring.NAMESPACE}-radio-monthRule`,
                      value: "offset",
                      className: `
                                        uiTheme
                                        ${monthRule === this.MONTH_RULES.OFFSET ? "radioOn" : "radioOff"}
                                    `
                    })
                  ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "radio-txt"
                    },
                    external_React_default().createElement(Select, {
                      name: "recurring-offset-value",
                      className: "inline",
                      icon: true,
                      value:
                        (offset && offset.value && Object.values(this.OFFSETS).find((o) => o.value === offset.value).label) ||
                        this.OFFSETS.FIRST.label,
                      options: Object.values(this.OFFSETS),
                      onSelect: (option) => {
                        this.setState((state) => ({
                          monthRule: this.MONTH_RULES.OFFSET,
                          offset: {
                            value: option.value,
                            weekDay: state.offset.weekDay || this.WEEK_DAYS.MONDAY.value
                          }
                        }));
                      }
                    }),
                    external_React_default().createElement(Select, {
                      name: "recurring-offset-day",
                      className: "inline",
                      icon: true,
                      value:
                        (offset && offset.weekDay && Object.values(this.WEEK_DAYS).find((o) => o.value === offset.weekDay).name) ||
                        this.WEEK_DAYS.MONDAY.name,
                      options: Object.values(this.WEEK_DAYS).map(({ value, name }) => ({
                        value,
                        label: name
                      })),
                      onSelect: (option) => {
                        this.setState((state) => ({
                          monthRule: this.MONTH_RULES.OFFSET,
                          offset: {
                            value: state.offset.value || this.OFFSETS.FIRST.value,
                            weekDay: option.value
                          }
                        }));
                      }
                    })
                  )
                )
              )
            ),
            this.renderEndControls()
          );
        }
        renderNavigation(view) {
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            external_React_default().createElement(
              meetings_button.Z,
              {
                className: `
                        mega-button
                        action
                        recurring-nav-button
                        ${view === this.VIEWS.DAILY ? "active" : ""}
                    `,
                onClick: () => this.toggleView(this.VIEWS.DAILY, this.FREQUENCIES.DAILY)
              },
              l.recurring_daily
            ),
            external_React_default().createElement(
              meetings_button.Z,
              {
                className: `
                        mega-button
                        action
                        recurring-nav-button
                        ${view === this.VIEWS.WEEKLY ? "active" : ""}
                    `,
                onClick: () => this.toggleView(this.VIEWS.WEEKLY, this.FREQUENCIES.WEEKLY)
              },
              l.recurring_weekly
            ),
            external_React_default().createElement(
              meetings_button.Z,
              {
                className: `
                        mega-button
                        action
                        recurring-nav-button
                        ${view === this.VIEWS.MONTHLY ? "active" : ""}
                    `,
                onClick: () => this.toggleView(this.VIEWS.MONTHLY, this.FREQUENCIES.MONTHLY)
              },
              l.recurring_monthly
            )
          );
        }
        renderContent(view) {
          switch (view) {
            case this.VIEWS.DAILY:
              return this.renderDaily();
            case this.VIEWS.WEEKLY:
              return this.renderWeekly();
            case this.VIEWS.MONTHLY:
              return this.renderMonthly();
          }
        }
        componentWillUpdate(nextProps, nextState) {
          if (this.state.view !== this.VIEWS.DAILY && nextState.view === this.VIEWS.DAILY) {
            nextState.weekDays = this.initialWeekDays;
          }
          if (
            (nextState.weekDays.length === Object.keys(this.WEEK_DAYS).length &&
              this.state.view !== this.VIEWS.WEEKLY &&
              nextState.view === this.VIEWS.WEEKLY) ||
            (!(0, helpers.KC)(nextProps.startDateTime, this.props.startDateTime) && this.state.view === this.VIEWS.WEEKLY)
          ) {
            const weekday = new Date(nextProps.startDateTime).getDay();
            nextState.weekDays = [weekday === 0 ? 7 : weekday];
          }
          if (!(0, helpers.KC)(nextProps.startDateTime, this.props.startDateTime) && this.state.view === this.VIEWS.MONTHLY) {
            var _Object$values$find2;
            const nextDate = new Date(nextProps.startDateTime);
            nextState.monthDays = [nextDate.getDate()];
            nextState.offset.weekDay =
              ((_Object$values$find2 = Object.values(this.WEEK_DAYS).find((d) => d.value === nextDate.getDay())) == null
                ? void 0
                : _Object$values$find2.value) || this.WEEK_DAYS.SUNDAY.value;
          }
          if (nextState.view === this.VIEWS.MONTHLY && this.state.interval > 12) {
            nextState.interval = 12;
          }
          this.props.onUpdate(this.getFormattedState(nextState));
        }
        componentDidMount() {
          super.componentDidMount();
          this.props.onUpdate(this.getFormattedState(this.state));
        }
        render() {
          const { NAMESPACE } = Recurring;
          const { view } = this.state;
          return external_React_default().createElement(
            Row,
            null,
            external_React_default().createElement(Column, null),
            external_React_default().createElement(
              Column,
              null,
              external_React_default().createElement(
                "div",
                {
                  className: NAMESPACE
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: `${NAMESPACE}-container`
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: `${NAMESPACE}-navigation`
                    },
                    this.renderNavigation(view)
                  ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: `${NAMESPACE}-content`
                    },
                    this.renderContent(view)
                  )
                )
              )
            )
          );
        }
      }
      Recurring.NAMESPACE = "meetings-recurring";
      class Edit extends mixins.wl {
        constructor(props) {
          super(props);
          this.occurrenceRef = null;
          this.datepickerRefs = [];
          this.interval = ChatRoom.SCHEDULED_MEETINGS_INTERVAL;
          this.incomingCallListener = "onIncomingCall.recurringEdit";
          this.state = {
            startDateTime: undefined,
            endDateTime: undefined,
            isDirty: false,
            closeDialog: false,
            overlayed: false
          };
          this.onStartDateSelect = (startDateTime) => {
            this.setState(
              {
                startDateTime,
                isDirty: true
              },
              () => {
                this.datepickerRefs.endDateTime.selectDate(new Date(startDateTime + this.interval));
              }
            );
          };
          this.onEndDateSelect = (endDateTime) => {
            this.setState(
              {
                endDateTime,
                isDirty: true
              },
              () => {
                const { startDateTime, endDateTime } = this.state;
                if (endDateTime < startDateTime) {
                  if (endDateTime < Date.now()) {
                    return this.setState({
                      endDateTime: startDateTime + this.interval
                    });
                  }
                  this.datepickerRefs.startDateTime.selectDate(new Date(endDateTime - this.interval));
                }
              }
            );
          };
          this.handleTimeSelect = ({ startDateTime, endDateTime }) => {
            startDateTime = startDateTime || this.state.startDateTime;
            endDateTime = endDateTime || this.state.endDateTime;
            this.setState((state) => {
              return {
                startDateTime: endDateTime <= state.startDateTime ? endDateTime - this.interval : startDateTime,
                endDateTime: startDateTime >= state.endDateTime ? startDateTime + this.interval : endDateTime,
                isDirty: true
              };
            });
          };
          const { scheduledMeeting, occurrenceId } = this.props;
          this.occurrenceRef = scheduledMeeting.occurrences[occurrenceId];
          if (this.occurrenceRef) {
            this.state.startDateTime = this.occurrenceRef.start;
            this.state.endDateTime = this.occurrenceRef.end;
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          if (this.incomingCallListener) {
            megaChat.off(this.incomingCallListener);
          }
          if ($.dialog === Schedule.dialogName) {
            closeDialog();
          }
        }
        componentDidMount() {
          super.componentDidMount();
          M.safeShowDialog(Schedule.dialogName, () => {
            if (!this.isMounted()) {
              throw Error(`Edit dialog: component not mounted.`);
            }
            megaChat.rebind(this.incomingCallListener, ({ data }) => {
              if (this.isMounted() && !is_chatlink && pushNotificationSettings.isAllowedForChatId(data[0].chatId)) {
                this.setState({
                  overlayed: true,
                  closeDialog: false
                });
                megaChat.plugins.callManager2.rebind("onRingingStopped.recurringEdit", () => {
                  megaChat.plugins.callManager2.off("onRingingStopped.recurringEdit");
                  this.setState({
                    overlayed: false
                  });
                  fm_showoverlay();
                });
              }
            });
            return $(`#${Schedule.NAMESPACE}`);
          });
        }
        componentDidUpdate(prevProps) {
          if (prevProps.callExpanded && !this.props.callExpanded) {
            if (!$.dialog) {
              M.safeShowDialog(Schedule.dialogName, `#${Schedule.NAMESPACE}`);
            }
            fm_showoverlay();
            this.setState({
              closeDialog: false
            });
          }
          if (!prevProps.callExpanded && this.props.callExpanded) {
            this.setState({
              closeDialog: false
            });
          }
        }
        render() {
          const { chatRoom, callExpanded, onClose } = this.props;
          const { startDateTime, endDateTime, isDirty, closeDialog, overlayed } = this.state;
          const dialogClasses = ["fluid"];
          if (closeDialog) {
            dialogClasses.push("with-confirmation-dialog");
          }
          if (callExpanded || overlayed) {
            dialogClasses.push("hidden");
          }
          return external_React_default().createElement(
            modalDialogs.Z.ModalDialog,
            (0, esm_extends.Z)({}, this.state, {
              id: Schedule.NAMESPACE,
              className: dialogClasses.join(" "),
              dialogName: Schedule.dialogName,
              dialogType: "main",
              onClose: () => {
                return isDirty
                  ? this.setState({
                      closeDialog: true
                    })
                  : onClose();
              }
            }),
            external_React_default().createElement(
              "header",
              null,
              external_React_default().createElement("h2", null, l.edit_meeting_title)
            ),
            external_React_default().createElement(
              "div",
              {
                className: "fm-dialog-body"
              },
              external_React_default().createElement(
                Row,
                null,
                external_React_default().createElement(
                  "div",
                  {
                    className: "mega-banner body recurring-edit-banner"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "cell"
                    },
                    (0, utils.hV)(l.scheduled_edit_occurrence_note, "[A]", ui_link.Z, {
                      onClick: () => {
                        onClose();
                        megaChat.trigger(megaChat.plugins.meetingsManager.EVENTS.EDIT, chatRoom);
                      }
                    })
                  )
                )
              ),
              external_React_default().createElement(
                Row,
                {
                  className: "start-aligned"
                },
                external_React_default().createElement(
                  Column,
                  null,
                  external_React_default().createElement("i", {
                    className: "sprite-fm-mono icon-recents-filled"
                  })
                ),
                external_React_default().createElement(
                  "div",
                  {
                    className: "schedule-date-container"
                  },
                  external_React_default().createElement(DateTime, {
                    name: "startDateTime",
                    altField: "startTime",
                    datepickerRef: this.datepickerRefs.startDateTime,
                    startDate: startDateTime,
                    value: startDateTime,
                    filteredTimeIntervals: (0, helpers.nl)(startDateTime),
                    label: l.schedule_start_date,
                    onMount: (datepicker) => {
                      this.datepickerRefs.startDateTime = datepicker;
                    },
                    onSelectDate: (startDateTime) => this.onStartDateSelect(startDateTime),
                    onSelectTime: ({ value: startDateTime }) =>
                      this.handleTimeSelect({
                        startDateTime
                      }),
                    onChange: (value) =>
                      this.setState({
                        startDateTime: value
                      }),
                    onBlur: (timestamp) => {
                      if (timestamp) {
                        timestamp = timestamp < Date.now() ? this.occurrenceRef.start : timestamp;
                        this.onStartDateSelect(timestamp);
                      }
                    }
                  }),
                  external_React_default().createElement(DateTime, {
                    name: "endDateTime",
                    altField: "endTime",
                    datepickerRef: this.datepickerRefs.endDateTime,
                    startDate: endDateTime,
                    value: endDateTime,
                    filteredTimeIntervals: (0, helpers.nl)(endDateTime, startDateTime),
                    label: l.schedule_end_date,
                    onMount: (datepicker) => {
                      this.datepickerRefs.endDateTime = datepicker;
                    },
                    onSelectDate: (endDateTime) => this.onEndDateSelect(endDateTime),
                    onSelectTime: ({ value: endDateTime }) =>
                      this.handleTimeSelect({
                        endDateTime
                      }),
                    onChange: (timestamp) =>
                      this.setState({
                        endDateTime: timestamp
                      }),
                    onBlur: (timestamp) => timestamp && this.onEndDateSelect(timestamp)
                  })
                )
              )
            ),
            external_React_default().createElement(
              "footer",
              null,
              external_React_default().createElement(
                "div",
                {
                  className: "footer-container"
                },
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    className: "mega-button positive",
                    onClick: () => {
                      const { startDateTime, endDateTime } = this.state;
                      if (startDateTime !== this.occurrenceRef.start || endDateTime !== this.occurrenceRef.end) {
                        this.occurrenceRef.update(startDateTime, endDateTime);
                      }
                      onClose();
                    }
                  },
                  external_React_default().createElement("span", null, l.update_meeting_button)
                )
              )
            ),
            !(overlayed || callExpanded) &&
              closeDialog &&
              external_React_default().createElement(CloseDialog, {
                onToggle: () =>
                  this.setState({
                    closeDialog: false
                  }),
                onClose: onClose
              })
          );
        }
      }
      // EXTERNAL MODULE: ./js/chat/chatRoom.jsx + 1 modules
      var chat_chatRoom = __webpack_require__(804); // CONCATENATED MODULE: ./js/chat/ui/meetings/schedule/schedule.jsx
      var schedule_class;

      class Schedule extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.wrapperRef = external_React_default().createRef();
          this.scheduledMeetingRef = null;
          this.localStreamRef = ".float-video";
          this.datepickerRefs = [];
          this.incomingCallListener = "onIncomingCall.scheduleDialog";
          this.ringingStoppedListener = "onRingingStopped.scheduleDialog";
          this.interval = ChatRoom.SCHEDULED_MEETINGS_INTERVAL;
          this.nearestHalfHour = (0, helpers.Ny)();
          this.state = {
            topic: "",
            startDateTime: this.nearestHalfHour,
            endDateTime: this.nearestHalfHour + this.interval,
            timezone: (0, helpers.Sv)(),
            recurring: false,
            participants: [],
            link: false,
            sendInvite: false,
            waitingRoom: false,
            openInvite: false,
            description: "",
            closeDialog: false,
            isEdit: false,
            isDirty: false,
            isLoading: false,
            topicInvalid: false,
            invalidTopicMsg: "",
            descriptionInvalid: false,
            overlayed: false
          };
          this.onTopicChange = (value) => {
            if (value.length > ChatRoom.TOPIC_MAX_LENGTH) {
              this.setState({
                invalidTopicMsg: l.err_schedule_title_long,
                topicInvalid: true
              });
              value = value.substring(0, ChatRoom.TOPIC_MAX_LENGTH);
            } else if (value.length === 0) {
              this.setState({
                invalidTopicMsg: l.schedule_title_missing,
                topicInvalid: true
              });
            } else if (this.state.invalidTopicMsg) {
              this.setState({
                invalidTopicMsg: "",
                topicInvalid: false
              });
            }
            this.handleChange("topic", value);
          };
          this.onTextareaChange = (value) => {
            if (value.length > 3000) {
              this.setState({
                descriptionInvalid: true
              });
              value = value.substring(0, 3000);
            } else if (this.state.descriptionInvalid) {
              this.setState({
                descriptionInvalid: false
              });
            }
            this.handleChange("description", value);
          };
          this.onStartDateSelect = () => {
            this.datepickerRefs.endDateTime.selectDate(new Date(this.state.startDateTime + this.interval));
          };
          this.onEndDateSelect = () => {
            const { startDateTime, endDateTime } = this.state;
            if (endDateTime < startDateTime) {
              if (endDateTime < Date.now()) {
                return this.setState({
                  endDateTime: startDateTime + this.interval
                });
              }
              this.datepickerRefs.startDateTime.selectDate(new Date(endDateTime - this.interval));
            }
          };
          this.handleToggle = (prop) => {
            return (
              Object.keys(this.state).includes(prop) &&
              this.setState((state) => ({
                [prop]: !state[prop],
                isDirty: true
              }))
            );
          };
          this.handleChange = (prop, value) => {
            return (
              Object.keys(this.state).includes(prop) &&
              this.setState({
                [prop]: value,
                isDirty: true
              })
            );
          };
          this.handleDateSelect = ({ startDateTime, endDateTime }, callback) => {
            this.setState(
              (state) => ({
                startDateTime: startDateTime || state.startDateTime,
                endDateTime: endDateTime || state.endDateTime,
                isDirty: true
              }),
              () => {
                const { recurring } = this.state;
                if (recurring && recurring.end) {
                  const recurringEnd = (0, helpers.zI)(this.state.startDateTime, 6);
                  this.datepickerRefs.recurringEnd.selectDate(new Date(recurringEnd));
                }
                if (callback) {
                  callback();
                }
              }
            );
          };
          this.handleTimeSelect = ({ startDateTime, endDateTime }) => {
            startDateTime = startDateTime || this.state.startDateTime;
            endDateTime = endDateTime || this.state.endDateTime;
            this.setState((state) => {
              return {
                startDateTime: endDateTime <= state.startDateTime ? endDateTime - this.interval : startDateTime,
                endDateTime: startDateTime >= state.endDateTime ? startDateTime + this.interval : endDateTime,
                isDirty: true
              };
            });
          };
          this.handleParticipantSelect = (participants) => {
            return (
              participants &&
              Array.isArray(participants) &&
              this.setState(
                {
                  participants,
                  isDirty: true
                },
                () => {
                  const wrapperRef = this.wrapperRef && this.wrapperRef.current;
                  if (wrapperRef) {
                    wrapperRef.reinitialise();
                  }
                }
              )
            );
          };
          this.handleSubmit = () => {
            if (this.state.topic) {
              return this.setState(
                {
                  isLoading: true
                },
                async () => {
                  const { chatRoom, onClose } = this.props;
                  const params = [this.state, chatRoom];
                  await megaChat.plugins.meetingsManager[chatRoom ? "updateMeeting" : "createMeeting"](...params);
                  this.setState(
                    {
                      isLoading: false
                    },
                    () => onClose()
                  );
                }
              );
            }
            return this.setState({
              topicInvalid: true,
              invalidTopicMsg: l.schedule_title_missing
            });
          };
        }
        syncPublicLink() {
          if (this.state.isEdit) {
            const { chatRoom } = this.props;
            chatRoom
              .updatePublicHandle()
              .then(
                () =>
                  this.isMounted() &&
                  this.setState({
                    link: !!chatRoom.publicLink
                  })
              )
              .catch(dump);
          }
        }
        getFilteredTimeIntervals(timestamp, offsetFrom) {
          const timeIntervals = (0, helpers.nl)(timestamp, offsetFrom);
          const { end } = this.scheduledMeetingRef || {};
          if (this.state.isEdit && end < Date.now()) {
            return timeIntervals;
          }
          return timeIntervals.filter((o) => {
            return offsetFrom ? o.value > this.nearestHalfHour : o.value > Date.now();
          });
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          if ($.dialog === Schedule.dialogName) {
            closeDialog();
          }
          [document, this.localStreamRef].map((el) => $(el).unbind(`.${Schedule.NAMESPACE}`));
          megaChat.off(this.incomingCallListener);
        }
        componentWillMount() {
          const { chatRoom } = this.props;
          if (chatRoom) {
            const { scheduledMeeting, publicLink, options } = chatRoom;
            this.state.topic = scheduledMeeting.title;
            this.state.startDateTime = scheduledMeeting.start;
            this.state.endDateTime = scheduledMeeting.end;
            this.state.timezone = scheduledMeeting.timezone || (0, helpers.Sv)();
            this.state.recurring = scheduledMeeting.recurring;
            this.state.participants = chatRoom.getParticipantsExceptMe();
            this.state.link = !!publicLink;
            this.state.description = scheduledMeeting.description || "";
            this.state.sendInvite = scheduledMeeting.flags;
            this.state.waitingRoom = options[chat_chatRoom.MCO_FLAGS.WAITING_ROOM];
            this.state.openInvite = options[chat_chatRoom.MCO_FLAGS.OPEN_INVITE];
            this.state.isEdit = true;
            this.scheduledMeetingRef = scheduledMeeting;
          }
        }
        componentDidMount() {
          super.componentDidMount();
          this.syncPublicLink();
          if ($.dialog === "onboardingDialog") {
            closeDialog();
          }
          M.safeShowDialog(Schedule.dialogName, () => {
            if (!this.isMounted()) {
              throw new Error(`${Schedule.dialogName} dialog: component ${Schedule.NAMESPACE} not mounted.`);
            }
            $(document).rebind(`keyup.${Schedule.NAMESPACE}`, ({ keyCode, target }) => {
              return this.state.closeDialog || target instanceof HTMLTextAreaElement ? null : keyCode === 13 && this.handleSubmit();
            });
            $(this.localStreamRef).rebind(`click.${Schedule.NAMESPACE}`, () => {
              if (this.state.isDirty) {
                this.handleToggle("closeDialog");
                return false;
              }
            });
            megaChat.rebind(this.incomingCallListener, (e, chatRoom) => {
              if (!is_chatlink && pushNotificationSettings.isAllowedForChatId(chatRoom.chatId)) {
                this.setState({
                  overlayed: true,
                  closeDialog: false
                });
                megaChat.plugins.callManager2.rebind(this.ringingStoppedListener, () => {
                  megaChat.plugins.callManager2.off(this.ringingStoppedListener);
                  this.setState({
                    overlayed: false
                  });
                  fm_showoverlay();
                });
              }
            });
            return $(`#${Schedule.NAMESPACE}`);
          });
        }
        componentDidUpdate(prevProps) {
          if (prevProps.callExpanded && !this.props.callExpanded) {
            if (!$.dialog) {
              M.safeShowDialog(Schedule.dialogName, `#${Schedule.NAMESPACE}`);
            }
            fm_showoverlay();
            this.setState({
              closeDialog: false
            });
          }
          if (!prevProps.callExpanded && this.props.callExpanded) {
            this.setState({
              closeDialog: false
            });
          }
        }
        render() {
          var _this$props$chatRoom;
          const {
            topic,
            startDateTime,
            endDateTime,
            recurring,
            participants,
            link,
            sendInvite,
            waitingRoom,
            openInvite,
            description,
            closeDialog,
            isEdit,
            isDirty,
            isLoading,
            topicInvalid,
            invalidTopicMsg,
            descriptionInvalid,
            overlayed
          } = this.state;
          return external_React_default().createElement(
            modalDialogs.Z.ModalDialog,
            (0, esm_extends.Z)({}, this.state, {
              id: Schedule.NAMESPACE,
              className: `
                    ${closeDialog ? "with-confirmation-dialog" : ""}
                    ${this.props.callExpanded || overlayed ? "hidden" : ""}
                `,
              dialogName: Schedule.dialogName,
              dialogType: "main",
              onClose: () => (isDirty ? this.handleToggle("closeDialog") : this.props.onClose())
            }),
            external_React_default().createElement(Header, {
              chatRoom: isEdit && this.props.chatRoom
            }),
            external_React_default().createElement(
              perfectScrollbar.F,
              {
                ref: this.wrapperRef,
                className: "fm-dialog-body",
                options: {
                  suppressScrollX: true
                }
              },
              external_React_default().createElement(Input, {
                name: "topic",
                placeholder: l.schedule_title_input,
                value: topic,
                invalid: topicInvalid,
                invalidMessage: invalidTopicMsg,
                autoFocus: true,
                isLoading: isLoading,
                onFocus: () =>
                  topicInvalid &&
                  this.setState({
                    topicInvalid: false
                  }),
                onChange: this.onTopicChange
              }),
              external_React_default().createElement(
                Row,
                {
                  className: "start-aligned"
                },
                external_React_default().createElement(
                  Column,
                  null,
                  external_React_default().createElement("i", {
                    className: "sprite-fm-mono icon-recents-filled"
                  })
                ),
                external_React_default().createElement(
                  "div",
                  {
                    className: "schedule-date-container"
                  },
                  external_React_default().createElement(DateTime, {
                    name: "startDateTime",
                    altField: "startTime",
                    datepickerRef: this.datepickerRefs.startDateTime,
                    startDate: startDateTime,
                    value: startDateTime,
                    filteredTimeIntervals: this.getFilteredTimeIntervals(startDateTime),
                    label: l.schedule_start_date,
                    isLoading: isLoading,
                    onMount: (datepicker) => {
                      this.datepickerRefs.startDateTime = datepicker;
                    },
                    onSelectDate: (startDateTime) => {
                      this.handleDateSelect(
                        {
                          startDateTime
                        },
                        this.onStartDateSelect
                      );
                    },
                    onSelectTime: ({ value: startDateTime }) => {
                      this.handleTimeSelect({
                        startDateTime: startDateTime < Date.now() ? this.nearestHalfHour : startDateTime
                      });
                    },
                    onChange: (value) => this.handleChange("startDateTime", value),
                    onBlur: (timestamp) => {
                      if (timestamp) {
                        const startDateTime = timestamp < Date.now() ? this.nearestHalfHour : timestamp;
                        this.handleDateSelect(
                          {
                            startDateTime
                          },
                          this.onStartDateSelect
                        );
                      }
                    }
                  }),
                  external_React_default().createElement(DateTime, {
                    name: "endDateTime",
                    altField: "endTime",
                    datepickerRef: this.datepickerRefs.endDateTime,
                    isLoading: isLoading,
                    startDate: endDateTime,
                    value: endDateTime,
                    filteredTimeIntervals: this.getFilteredTimeIntervals(endDateTime, startDateTime),
                    label: l.schedule_end_date,
                    onMount: (datepicker) => {
                      this.datepickerRefs.endDateTime = datepicker;
                    },
                    onSelectDate: (endDateTime) => {
                      this.handleDateSelect(
                        {
                          endDateTime
                        },
                        this.onEndDateSelect
                      );
                    },
                    onSelectTime: ({ value: endDateTime }) => {
                      this.handleTimeSelect({
                        endDateTime: endDateTime < Date.now() ? this.nearestHalfHour + this.interval : endDateTime
                      });
                    },
                    onChange: (value) => this.handleChange("endDateTime", value),
                    onBlur: (timestamp) => {
                      this.handleDateSelect(
                        {
                          endDateTime: timestamp
                        },
                        this.onEndDateSelect
                      );
                    }
                  })
                )
              ),
              external_React_default().createElement(Checkbox, {
                name: "recurring",
                checked: recurring,
                label: l.schedule_recurring_label,
                isLoading: isLoading,
                onToggle: this.handleToggle
              }),
              recurring &&
                external_React_default().createElement(Recurring, {
                  chatRoom: this.props.chatRoom,
                  startDateTime: startDateTime,
                  endDateTime: endDateTime,
                  onMount: (datepicker) => {
                    this.datepickerRefs.recurringEnd = datepicker;
                  },
                  onUpdate: (state) => {
                    this.setState({
                      recurring: state
                    });
                  }
                }),
              external_React_default().createElement(
                Row,
                null,
                external_React_default().createElement(
                  Column,
                  null,
                  external_React_default().createElement("i", {
                    className: "sprite-fm-mono icon-contacts"
                  })
                ),
                external_React_default().createElement(
                  Column,
                  null,
                  external_React_default().createElement(Invite, {
                    className: isLoading ? "disabled" : "",
                    participants: participants,
                    onSelect: this.handleParticipantSelect
                  })
                )
              ),
              external_React_default().createElement(Switch, {
                name: "link",
                toggled: link,
                label: l.schedule_link_label,
                isLoading: isLoading,
                onToggle: this.handleToggle
              }),
              external_React_default().createElement(Checkbox, {
                name: "sendInvite",
                checked: sendInvite,
                label: l.schedule_invite_label,
                isLoading: isLoading,
                onToggle: this.handleToggle
              }),
              external_React_default().createElement(Checkbox, {
                name: "waitingRoom",
                className: (_this$props$chatRoom = this.props.chatRoom) != null && _this$props$chatRoom.havePendingCall() ? "disabled" : "",
                checked: waitingRoom,
                label: l.waiting_room,
                subLabel: l.waiting_room_info,
                isLoading: isLoading,
                onToggle: (waitingRoom) => {
                  var _this$props$chatRoom2;
                  return (_this$props$chatRoom2 = this.props.chatRoom) != null && _this$props$chatRoom2.havePendingCall()
                    ? null
                    : this.handleToggle(waitingRoom);
                }
              }),
              external_React_default().createElement(Checkbox, {
                name: "openInvite",
                checked: openInvite,
                label: l.open_invite_desc,
                isLoading: isLoading,
                onToggle: this.handleToggle
              }),
              waitingRoom && openInvite
                ? external_React_default().createElement(
                    Row,
                    null,
                    external_React_default().createElement(
                      "div",
                      {
                        className: "schedule-dialog-banner warn"
                      },
                      external_React_default().createElement(
                        utils.Cw,
                        null,
                        l.waiting_room_invite
                          .replace(
                            "[A]",
                            `<a
                                                href="${l.mega_help_host}/wp-admin/post.php?post=3005&action=edit"
                                                target="_blank"
                                                class="clickurl">
                                            `
                          )
                          .replace("[/A]", "</a>")
                      )
                    )
                  )
                : null,
              external_React_default().createElement(Textarea, {
                name: "description",
                invalid: descriptionInvalid,
                placeholder: l.schedule_description_input,
                value: description,
                onFocus: () =>
                  descriptionInvalid &&
                  this.setState({
                    descriptionInvalid: false
                  }),
                onChange: this.onTextareaChange
              })
            ),
            external_React_default().createElement(Footer, {
              isLoading: isLoading,
              isEdit: isEdit,
              topic: topic,
              onSubmit: this.handleSubmit
            }),
            !(overlayed || this.props.callExpanded) &&
              closeDialog &&
              external_React_default().createElement(CloseDialog, {
                onToggle: this.handleToggle,
                onClose: this.props.onClose
              })
          );
        }
      }
      schedule_class = Schedule;
      Schedule.NAMESPACE = "schedule-dialog";
      Schedule.dialogName = `meetings-${schedule_class.NAMESPACE}`;
      const CloseDialog = ({ onToggle, onClose }) => {
        return external_React_default().createElement(
          external_React_default().Fragment,
          null,
          external_React_default().createElement(modalDialogs.Z.ModalDialog, {
            name: `${Schedule.NAMESPACE}-confirmation`,
            dialogType: "message",
            className: `
                    with-close-btn
                    ${Schedule.NAMESPACE}-confirmation
                `,
            title: l.schedule_discard_dlg_title,
            icon: "sprite-fm-uni icon-question",
            buttons: [
              {
                key: "n",
                label: l.schedule_discard_cancel,
                onClick: () => onToggle("closeDialog")
              },
              {
                key: "y",
                label: l.schedule_discard_confirm,
                className: "positive",
                onClick: onClose
              }
            ],
            noCloseOnClickOutside: true,
            stopKeyPropagation: true,
            hideOverlay: true,
            onClose: () => onToggle("closeDialog")
          }),
          external_React_default().createElement("div", {
            className: `${Schedule.NAMESPACE}-confirmation-overlay`,
            onClick: () => onToggle("closeDialog")
          })
        );
      };
      const Row = ({ children, className }) =>
        external_React_default().createElement(
          "div",
          {
            className: `
            ${Schedule.NAMESPACE}-row
            ${className || ""}
        `
          },
          children
        );
      const Column = ({ children, className }) =>
        external_React_default().createElement(
          "div",
          {
            className: `
            ${Schedule.NAMESPACE}-column
            ${className || ""}
        `
          },
          children
        );
      const Header = ({ chatRoom }) => {
        const $$container = (title) =>
          external_React_default().createElement("header", null, external_React_default().createElement("h2", null, title));
        if (chatRoom) {
          const { scheduledMeeting } = chatRoom;
          return $$container(scheduledMeeting.isRecurring ? l.edit_meeting_series_title : l.edit_meeting_title);
        }
        return $$container(l.schedule_meeting_title);
      };
      const Input = ({ name, placeholder, value, invalid, invalidMessage, autoFocus, isLoading, onFocus, onChange }) => {
        return external_React_default().createElement(
          Row,
          {
            className: invalid ? "invalid-aligned" : ""
          },
          external_React_default().createElement(
            Column,
            null,
            external_React_default().createElement("i", {
              className: "sprite-fm-mono icon-rename"
            })
          ),
          external_React_default().createElement(
            Column,
            null,
            external_React_default().createElement(
              "div",
              {
                className: `
                        mega-input
                        ${invalid ? "error msg" : ""}
                    `
              },
              external_React_default().createElement("input", {
                type: "text",
                name: `${Schedule.NAMESPACE}-${name}`,
                className: isLoading ? "disabled" : "",
                autoFocus: autoFocus,
                autoComplete: "off",
                placeholder: placeholder,
                value: value,
                onFocus: onFocus,
                onChange: ({ target }) => onChange(target.value)
              }),
              invalid &&
                external_React_default().createElement(
                  "div",
                  {
                    className: "message-container mega-banner"
                  },
                  invalidMessage
                )
            )
          )
        );
      };
      const Checkbox = ({ name, className, checked, label, subLabel, isLoading, onToggle }) => {
        return external_React_default().createElement(
          Row,
          {
            className: `
                ${subLabel ? "start-aligned" : ""}
                ${className || ""}
            `
          },
          external_React_default().createElement(
            Column,
            null,
            external_React_default().createElement(
              "div",
              {
                className: `
                        checkdiv
                        ${checked ? "checkboxOn" : "checkboxOff"}
                    `
              },
              external_React_default().createElement("input", {
                name: `${Schedule.NAMESPACE}-${name}`,
                className: isLoading ? "disabled" : "",
                type: "checkbox",
                onChange: () => onToggle(name)
              })
            )
          ),
          external_React_default().createElement(
            Column,
            {
              className: subLabel ? "with-sub-label" : ""
            },
            external_React_default().createElement(
              "label",
              {
                htmlFor: `${Schedule.NAMESPACE}-${name}`,
                className: isLoading ? "disabled" : "",
                onClick: () => onToggle(name)
              },
              label
            ),
            subLabel &&
              external_React_default().createElement(
                "div",
                {
                  className: "sub-label"
                },
                subLabel
              )
          )
        );
      };
      const Switch = ({ name, toggled, label, isLoading, onToggle }) => {
        return external_React_default().createElement(
          Row,
          null,
          external_React_default().createElement(
            Column,
            null,
            external_React_default().createElement("i", {
              className: "sprite-fm-uni icon-mega-logo"
            })
          ),
          external_React_default().createElement(
            Column,
            null,
            external_React_default().createElement(
              "span",
              {
                className: `
                        schedule-label
                        ${isLoading ? "disabled" : ""}
                    `,
                onClick: () => onToggle(name)
              },
              label
            ),
            external_React_default().createElement(
              "div",
              {
                className: `
                        mega-switch
                        ${toggled ? "toggle-on" : ""}
                        ${isLoading ? "disabled" : ""}
                    `,
                onClick: () => onToggle(name)
              },
              external_React_default().createElement("div", {
                className: `
                            mega-feature-switch
                            sprite-fm-mono-after
                            ${toggled ? "icon-check-after" : "icon-minimise-after"}
                        `
              })
            )
          )
        );
      };
      const Textarea = ({ name, placeholder, isLoading, value, invalid, onChange, onFocus }) => {
        return external_React_default().createElement(
          Row,
          {
            className: "start-aligned"
          },
          external_React_default().createElement(
            Column,
            null,
            external_React_default().createElement("i", {
              className: "sprite-fm-mono icon-description"
            })
          ),
          external_React_default().createElement(
            Column,
            null,
            external_React_default().createElement(
              "div",
              {
                className: `mega-input box-style textarea ${invalid ? "error" : ""}`
              },
              external_React_default().createElement("textarea", {
                name: `${Schedule.NAMESPACE}-${name}`,
                className: isLoading ? "disabled" : "",
                placeholder: placeholder,
                value: value,
                onChange: ({ target }) => onChange(target.value),
                onFocus: onFocus
              })
            ),
            invalid &&
              external_React_default().createElement(
                "div",
                {
                  className: "mega-input error msg textarea-error"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "message-container mega-banner"
                  },
                  l.err_schedule_desc_long
                )
              )
          )
        );
      };
      const Footer = ({ isLoading, isEdit, topic, onSubmit }) => {
        return external_React_default().createElement(
          "footer",
          null,
          external_React_default().createElement(
            "div",
            {
              className: "footer-container"
            },
            external_React_default().createElement(
              meetings_button.Z,
              {
                className: `
                        mega-button
                        positive
                        ${isLoading ? "disabled" : ""}
                    `,
                onClick: () => !isLoading && onSubmit(),
                topic: topic
              },
              external_React_default().createElement("span", null, isEdit ? l.update_meeting_button : l.schedule_meeting_button)
            )
          )
        );
      }; // CONCATENATED MODULE: ./js/ui/miniui.jsx
      class ToggleCheckbox extends mixins.wl {
        constructor(props) {
          super(props);
          this.onToggle = () => {
            const newState = !this.state.value;
            this.setState({
              value: newState
            });
            if (this.props.onToggle) {
              this.props.onToggle(newState);
            }
          };
          this.state = {
            value: this.props.value
          };
        }
        render() {
          return external_React_default().createElement(
            "div",
            {
              className: `
                    mega-switch
                    ${this.props.className}
                    ${this.state.value ? "toggle-on" : ""}
                `,
              role: "switch",
              "aria-checked": !!this.state.value,
              onClick: this.onToggle
            },
            external_React_default().createElement("div", {
              className: `mega-feature-switch sprite-fm-mono-after
                         ${this.state.value ? "icon-check-after" : "icon-minimise-after"}`
            })
          );
        }
      }
      const miniui = {
        ToggleCheckbox
      }; // CONCATENATED MODULE: ./js/chat/ui/startGroupChatWizard.jsx
      var React = __webpack_require__(363);

      class StartGroupChatWizard extends mixins.wl {
        constructor(props) {
          super(props);
          this.inputContainerRef = React.createRef();
          this.inputRef = React.createRef();
          var haveContacts = false;
          var keys = M.u.keys();
          for (var i = 0; i < keys.length; i++) {
            if (M.u[keys[i]].c === 1) {
              haveContacts = true;
              break;
            }
          }
          this.state = {
            selected: this.props.selected ? this.props.selected : [],
            haveContacts: haveContacts,
            step: this.props.flowType === 2 || !haveContacts ? 1 : 0,
            keyRotation: false,
            createChatLink: this.props.flowType === 2 ? true : false,
            groupName: "",
            openInvite: 1
          };
          this.onFinalizeClick = this.onFinalizeClick.bind(this);
          this.onSelectClicked = this.onSelectClicked.bind(this);
          this.onSelected = this.onSelected.bind(this);
        }
        onSelected(nodes) {
          this.setState({
            selected: nodes
          });
          if (this.props.onSelected) {
            this.props.onSelected(nodes);
          }
        }
        onSelectClicked() {
          if (this.props.onSelectClicked) {
            this.props.onSelectClicked();
          }
        }
        onFinalizeClick(e) {
          if (e) {
            e.preventDefault();
            e.stopPropagation();
          }
          const { groupName, selected, keyRotation, createChatLink, openInvite } = this.state;
          megaChat.createAndShowGroupRoomFor(selected, groupName.trim(), {
            keyRotation,
            createChatLink: keyRotation ? false : createChatLink,
            openInvite
          });
          this.props.onClose(this);
        }
        render() {
          var self = this;
          var classes = "new-group-chat contrast small-footer contact-picker-widget " + self.props.className;
          var contacts = M.u;
          var haveContacts = self.state.haveContacts;
          var buttons = [];
          var allowNext = false;
          var failedToEnableChatlink = self.state.failedToEnableChatlink && self.state.createChatLink === true && !self.state.groupName;
          if (self.state.keyRotation) {
            failedToEnableChatlink = false;
          }
          var extraContent;
          if (this.props.extraContent) {
            self.state.step = 0;
            extraContent = React.createElement("div", {
              className: "content-block imported"
            });
          } else if (self.state.step === 0 && haveContacts) {
            allowNext = true;
            buttons.push({
              label: self.props.cancelLabel,
              key: "cancel",
              onClick: function (e) {
                self.props.onClose(self);
                e.preventDefault();
                e.stopPropagation();
              }
            });
            buttons.push({
              label: l[556],
              key: "next",
              className: !allowNext ? "disabled positive" : "positive",
              onClick: function (e) {
                e.preventDefault();
                e.stopPropagation();
                self.setState({
                  step: 1
                });
              }
            });
          } else if (self.state.step === 1) {
            allowNext = self.state.createChatLink ? !failedToEnableChatlink : true;
            contacts = [];
            self.state.selected.forEach(function (h) {
              if (h in M.u) {
                contacts.push(M.u[h]);
              }
            });
            if (!haveContacts || this.props.flowType === 2) {
              buttons.push({
                label: self.props.cancelLabel,
                key: "cancel",
                onClick: function (e) {
                  self.props.onClose(self);
                  e.preventDefault();
                  e.stopPropagation();
                }
              });
            } else {
              buttons.push({
                label: l[822],
                key: "back",
                onClick: function (e) {
                  e.preventDefault();
                  e.stopPropagation();
                  self.setState({
                    step: 0
                  });
                }
              });
            }
            buttons.push({
              label: l[726],
              key: "done",
              className: !allowNext ? "positive disabled" : "positive",
              onClick: function (e) {
                if (self.state.createChatLink === true && !self.state.groupName) {
                  self.setState({
                    failedToEnableChatlink: true
                  });
                } else {
                  self.onFinalizeClick(e);
                }
              }
            });
          }
          var chatInfoElements;
          if (self.state.step === 1) {
            var _this$state$groupName;
            var checkboxClassName = self.state.createChatLink ? "checkboxOn" : "checkboxOff";
            if (failedToEnableChatlink && self.state.createChatLink) {
              checkboxClassName += " intermediate-state";
            }
            if (self.state.keyRotation) {
              checkboxClassName = "checkboxOff";
            }
            chatInfoElements = React.createElement(
              React.Fragment,
              null,
              React.createElement(
                "div",
                {
                  className: `
                            contacts-search-header left-aligned top-pad
                            ${failedToEnableChatlink ? "failed" : ""}
                        `
                },
                React.createElement(
                  "div",
                  {
                    className: `
                                mega-input
                                with-icon
                                box-style
                                ${
                                  ((_this$state$groupName = this.state.groupName) == null ? void 0 : _this$state$groupName.length) > 0
                                    ? "valued"
                                    : ""
                                }
                                ${failedToEnableChatlink ? "error msg" : ""}
                            `,
                    ref: this.inputContainerRef
                  },
                  React.createElement("i", {
                    className: "sprite-fm-mono icon-channel-new"
                  }),
                  React.createElement("input", {
                    autoFocus: true,
                    className: "megaInputs",
                    type: "text",
                    ref: this.inputRef,
                    placeholder: l[18509],
                    value: this.state.groupName,
                    maxLength: ChatRoom.TOPIC_MAX_LENGTH,
                    onKeyDown: (e) => {
                      const code = e.which || e.keyCode;
                      if (allowNext && code === 13 && self.state.step === 1) {
                        this.onFinalizeClick();
                      }
                    },
                    onChange: (e) => {
                      const containerRef = this.inputContainerRef.current;
                      const { value } = e.target;
                      containerRef.classList[value.length > 0 ? "add" : "remove"]("valued");
                      this.setState({
                        groupName: value,
                        failedToEnableChatlink: false
                      });
                    }
                  })
                )
              ),
              this.props.flowType === 2
                ? null
                : React.createElement(
                    "div",
                    {
                      className: "group-chat-dialog content"
                    },
                    React.createElement(miniui.ToggleCheckbox, {
                      className: "rotation-toggle",
                      checked: this.state.keyRotation,
                      onToggle: (keyRotation) =>
                        this.setState(
                          {
                            keyRotation
                          },
                          () => this.inputRef.current.focus()
                        )
                    }),
                    React.createElement(
                      "div",
                      {
                        className: "group-chat-dialog header"
                      },
                      l[20576]
                    ),
                    React.createElement(
                      "div",
                      {
                        className: "group-chat-dialog description"
                      },
                      l[20484]
                    ),
                    React.createElement(miniui.ToggleCheckbox, {
                      className: "open-invite-toggle",
                      checked: this.state.openInvite,
                      value: this.state.openInvite,
                      onToggle: (openInvite) =>
                        this.setState(
                          {
                            openInvite
                          },
                          () => this.inputRef.current.focus()
                        )
                    }),
                    React.createElement(
                      "div",
                      {
                        className: "group-chat-dialog header"
                      },
                      l.open_invite_label
                    ),
                    React.createElement(
                      "div",
                      {
                        className: "group-chat-dialog description"
                      },
                      l.open_invite_desc
                    ),
                    React.createElement(
                      "div",
                      {
                        className: `
                                    group-chat-dialog checkbox
                                    ${this.state.keyRotation ? "disabled" : ""}
                                    ${failedToEnableChatlink ? "failed" : ""}
                                `,
                        onClick: () => {
                          delay(
                            "chatWizard-createChatLink",
                            () => {
                              this.setState((state) => ({
                                createChatLink: !state.createChatLink
                              }));
                              this.inputRef.current.focus();
                            },
                            100
                          );
                        }
                      },
                      React.createElement(
                        "div",
                        {
                          className: `checkdiv ${checkboxClassName}`
                        },
                        React.createElement("input", {
                          type: "checkbox",
                          name: "group-encryption",
                          id: "group-encryption",
                          className: "checkboxOn hidden"
                        })
                      ),
                      React.createElement(
                        "label",
                        {
                          htmlFor: "group-encryption",
                          className: "radio-txt lato mid"
                        },
                        l[20575]
                      ),
                      React.createElement("div", {
                        className: "clear"
                      })
                    )
                  ),
              failedToEnableChatlink
                ? React.createElement(
                    "div",
                    {
                      className: "group-chat-dialog description chatlinks-intermediate-msg"
                    },
                    l[20573]
                  )
                : null
            );
          }
          return React.createElement(
            modalDialogs.Z.ModalDialog,
            {
              step: self.state.step,
              title: this.props.flowType === 2 && self.state.createChatLink ? l[20638] : this.props.customDialogTitle || l[19483],
              className: classes,
              dialogType: "tool",
              dialogName: "group-chat-dialog",
              showSelectedNum: self.props.showSelectedNum,
              selectedNum: self.state.selected.length,
              closeDlgOnClickOverlay: self.props.closeDlgOnClickOverlay,
              onClose: () => {
                self.props.onClose(self);
              },
              popupDidMount: (elem) => {
                if (this.props.extraContent) {
                  var _elem$querySelector;
                  (_elem$querySelector = elem.querySelector(".content-block.imported")) == null ||
                    _elem$querySelector.appendChild(this.props.extraContent);
                }
                if (this.props.onExtraContentDidMount) {
                  this.props.onExtraContentDidMount(elem);
                }
              },
              triggerResizeOnUpdate: true,
              buttons: buttons
            },
            React.createElement(
              "div",
              {
                className: "content-block"
              },
              chatInfoElements,
              React.createElement(ui_contacts.ContactPickerWidget, {
                changedHashProp: self.state.step,
                exclude: self.props.exclude,
                contacts: contacts,
                selectableContacts: "true",
                onSelectDone: self.onSelectClicked,
                onSelected: self.onSelected,
                selected: self.state.selected,
                headerClasses: "left-aligned",
                multiple: true,
                readOnly: self.state.step !== 0,
                allowEmpty: true,
                showMeAsSelected: self.state.step === 1,
                className: self.props.pickerClassName,
                disableFrequents: self.props.disableFrequents,
                notSearchInEmails: self.props.notSearchInEmails,
                autoFocusSearchField: self.props.autoFocusSearchField,
                selectCleanSearchRes: self.props.selectCleanSearchRes,
                disableDoubleClick: self.props.disableDoubleClick,
                selectedWidthSize: self.props.selectedWidthSize,
                emptySelectionMsg: self.props.emptySelectionMsg,
                newEmptySearchResult: self.props.newEmptySearchResult,
                newNoContact: self.props.newNoContact,
                highlightSearchValue: self.props.highlightSearchValue,
                emailTooltips: self.props.emailTooltips
              })
            ),
            extraContent
          );
        }
      }
      StartGroupChatWizard.clickTime = 0;
      StartGroupChatWizard.defaultProps = {
        selectLabel: l[1940],
        cancelLabel: l[82],
        hideable: true,
        flowType: 1,
        pickerClassName: "",
        showSelectedNum: false,
        disableFrequents: false,
        notSearchInEmails: false,
        autoFocusSearchField: true,
        selectCleanSearchRes: true,
        disableDoubleClick: false,
        newEmptySearchResult: false,
        newNoContact: false,
        closeDlgOnClickOverlay: true,
        emailTooltips: false
      };
      window.StartGroupChatDialogUI = {
        StartGroupChatWizard
      };
      const startGroupChatWizard = {
        StartGroupChatWizard
      };
      // EXTERNAL MODULE: ./js/chat/ui/meetings/call.jsx + 23 modules
      var call = __webpack_require__(689);
      // EXTERNAL MODULE: ./js/chat/ui/chatToaster.jsx
      var chatToaster = __webpack_require__(142); // CONCATENATED MODULE: ./js/chat/ui/searchPanel/resultTable.jsx
      class ResultTable extends mixins.wl {
        render() {
          const { heading, children } = this.props;
          return external_React_default().createElement(
            "div",
            {
              className: `result-table ${heading ? "" : "nil"}`
            },
            heading
              ? external_React_default().createElement(
                  "div",
                  {
                    className: "result-table-heading"
                  },
                  heading
                )
              : null,
            children
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/searchPanel/resultRow.jsx
      const RESULT_ROW_CLASS = "result-table-row";
      const USER_CARD_CLASS = "user-card";
      const roomIsGroup = (room) => (room && room.type === "group") || room.type === "public";
      const openResult = ({ room, messageId, index }, callback) => {
        document.dispatchEvent(new Event(EVENTS.RESULT_OPEN));
        if (isString(room)) {
          loadSubPage(`fm/chat/p/${room}`);
        } else if (room && room.chatId && !messageId) {
          const chatRoom = megaChat.getChatById(room.chatId);
          if (chatRoom) {
            loadSubPage(chatRoom.getRoomUrl());
          } else {
            loadSubPage(`/fm/chat/contacts/${room.chatId}`);
          }
        } else {
          loadSubPage(room.getRoomUrl());
          if (messageId) {
            room.scrollToMessageId(messageId, index);
          }
        }
        return callback && typeof callback === "function" && callback();
      };
      const lastActivity = (room) => {
        if (!room.lastActivity || !room.ctime) {
          room = megaChat.getChatById(room.chatId);
        }
        if ((room && room.lastActivity) || room.ctime) {
          return room.lastActivity
            ? todayOrYesterday(room.lastActivity * 1000)
              ? getTimeMarker(room.lastActivity)
              : time2date(room.lastActivity, 17)
            : todayOrYesterday(room.ctime * 1000)
            ? getTimeMarker(room.ctime)
            : time2date(room.ctime, 17);
        }
        return l[8000];
      };
      class MessageRow extends mixins.wl {
        render() {
          const { data, matches, room, index, onResultOpen } = this.props;
          const isGroup = room && roomIsGroup(room);
          const contact = room.getParticipantsExceptMe();
          const summary = room.messagesBuff.getRenderableSummary(data);
          return external_React_default().createElement(
            "div",
            {
              ref: (node) => {
                this.nodeRef = node;
              },
              className: `
                    ${RESULT_ROW_CLASS}
                    message
                `,
              onClick: () =>
                openResult(
                  {
                    room,
                    messageId: data.messageId,
                    index
                  },
                  () => onResultOpen(this.nodeRef)
                )
            },
            external_React_default().createElement(
              "div",
              {
                className: "message-result-avatar"
              },
              isGroup
                ? external_React_default().createElement(
                    "div",
                    {
                      className: "chat-topic-icon"
                    },
                    external_React_default().createElement("i", {
                      className: "sprite-fm-uni icon-chat-group"
                    })
                  )
                : external_React_default().createElement(ui_contacts.Avatar, {
                    contact: M.u[contact]
                  })
            ),
            external_React_default().createElement(
              "div",
              {
                className: "user-card"
              },
              external_React_default().createElement(
                "span",
                {
                  className: "title"
                },
                isGroup
                  ? external_React_default().createElement(utils.a0, null, room.getRoomTitle())
                  : external_React_default().createElement(ui_contacts.ContactAwareName, {
                      contact: M.u[contact],
                      overflow: true
                    })
              ),
              isGroup
                ? null
                : external_React_default().createElement(ui_contacts.ContactPresence, {
                    contact: M.u[contact]
                  }),
              external_React_default().createElement("div", {
                className: "clear"
              }),
              external_React_default().createElement(
                "div",
                {
                  className: "message-result-info"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "summary"
                  },
                  external_React_default().createElement(utils.nF, {
                    content: megaChat.highlight(summary, matches, true)
                  })
                ),
                external_React_default().createElement(
                  "div",
                  {
                    className: "result-separator"
                  },
                  external_React_default().createElement("i", {
                    className: "sprite-fm-mono icon-dot"
                  })
                ),
                external_React_default().createElement(
                  "span",
                  {
                    className: "date"
                  },
                  getTimeMarker(data.delay, true)
                )
              )
            )
          );
        }
      }
      class ChatRow extends mixins.wl {
        render() {
          const { room, matches, onResultOpen } = this.props;
          const result = megaChat.highlight(megaChat.html(room.getRoomTitle()), matches, true);
          return external_React_default().createElement(
            "div",
            {
              ref: (node) => {
                this.nodeRef = node;
              },
              className: RESULT_ROW_CLASS,
              onClick: () =>
                openResult(
                  {
                    room
                  },
                  () => onResultOpen(this.nodeRef)
                )
            },
            external_React_default().createElement(
              "div",
              {
                className: "chat-topic-icon"
              },
              external_React_default().createElement("i", {
                className: "sprite-fm-uni icon-chat-group"
              })
            ),
            external_React_default().createElement(
              "div",
              {
                className: USER_CARD_CLASS
              },
              external_React_default().createElement(
                "div",
                {
                  className: "graphic"
                },
                external_React_default().createElement(utils.nF, null, result)
              ),
              lastActivity(room)
            ),
            external_React_default().createElement("div", {
              className: "clear"
            })
          );
        }
      }
      class MemberRow extends mixins.wl {
        render() {
          const { data, matches, room, contact, onResultOpen } = this.props;
          const isGroup = room && roomIsGroup(room);
          return external_React_default().createElement(
            "div",
            {
              ref: (node) => {
                this.nodeRef = node;
              },
              className: RESULT_ROW_CLASS,
              onClick: () =>
                openResult(
                  {
                    room: room || contact.h
                  },
                  () => onResultOpen(this.nodeRef)
                )
            },
            isGroup
              ? external_React_default().createElement(
                  "div",
                  {
                    className: "chat-topic-icon"
                  },
                  external_React_default().createElement("i", {
                    className: "sprite-fm-uni icon-chat-group"
                  })
                )
              : external_React_default().createElement(ui_contacts.Avatar, {
                  contact: contact
                }),
            external_React_default().createElement(
              "div",
              {
                className: USER_CARD_CLASS
              },
              external_React_default().createElement(
                "div",
                {
                  className: "graphic"
                },
                isGroup
                  ? external_React_default().createElement(
                      utils.nF,
                      null,
                      megaChat.highlight(megaChat.html(room.getRoomTitle()), matches, true)
                    )
                  : external_React_default().createElement(
                      external_React_default().Fragment,
                      null,
                      external_React_default().createElement(
                        utils.nF,
                        null,
                        megaChat.highlight(megaChat.html(nicknames.getNickname(data)), matches, true)
                      ),
                      external_React_default().createElement(ui_contacts.ContactPresence, {
                        contact: contact
                      })
                    )
              ),
              lastActivity(room)
            ),
            external_React_default().createElement("div", {
              className: "clear"
            })
          );
        }
      }
      const NilRow = ({ onSearchMessages, isFirstQuery }) => {
        const label = LABEL.SEARCH_MESSAGES_INLINE.replace("[A]", "<a>").replace("[/A]", "</a>");
        return external_React_default().createElement(
          "div",
          {
            className: `
                ${RESULT_ROW_CLASS}
                nil
            `
          },
          external_React_default().createElement(
            "div",
            {
              className: "nil-container"
            },
            external_React_default().createElement("i", {
              className: "sprite-fm-mono icon-preview-reveal"
            }),
            external_React_default().createElement("span", null, LABEL.NO_RESULTS),
            isFirstQuery &&
              external_React_default().createElement(
                "div",
                {
                  className: "search-messages",
                  onClick: onSearchMessages
                },
                external_React_default().createElement(utils.nF, {
                  tag: "div",
                  content: label
                })
              )
          )
        );
      };
      class ResultRow extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.setActive = (nodeRef) => {
            if (nodeRef) {
              const elements = document.querySelectorAll(`.${RESULT_ROW_CLASS}.${"active"}`);
              for (let i = elements.length; i--; ) {
                elements[i].classList.remove("active");
              }
              nodeRef.classList.add("active");
            }
          };
        }
        render() {
          const { type, result, children, onSearchMessages, isFirstQuery } = this.props;
          if (result) {
            const { data, index, matches, room } = result;
            const PROPS = {
              data,
              index,
              matches,
              room,
              onResultOpen: this.setActive
            };
            switch (type) {
              case TYPE.MESSAGE:
                return external_React_default().createElement(MessageRow, PROPS);
              case TYPE.CHAT:
                return external_React_default().createElement(ChatRow, PROPS);
              case TYPE.MEMBER:
                return external_React_default().createElement(
                  MemberRow,
                  (0, esm_extends.Z)({}, PROPS, {
                    contact: M.u[data]
                  })
                );
              default:
                return external_React_default().createElement(
                  "div",
                  {
                    className: RESULT_ROW_CLASS
                  },
                  children
                );
            }
          }
          return external_React_default().createElement(NilRow, {
            onSearchMessages: onSearchMessages,
            isFirstQuery: isFirstQuery
          });
        }
      } // CONCATENATED MODULE: ./js/chat/ui/searchPanel/resultContainer.jsx
      const TYPE = {
        MESSAGE: 1,
        CHAT: 2,
        MEMBER: 3,
        NIL: 4
      };
      const LABEL = {
        MESSAGES: l[6868],
        CONTACTS_AND_CHATS: l[20174],
        NO_RESULTS: l[8674],
        SEARCH_MESSAGES_CTA: l[23547],
        SEARCH_MESSAGES_INLINE: l[23548],
        DECRYPTING_RESULTS: l[23543],
        PAUSE_SEARCH: l[23544],
        SEARCH_PAUSED: l[23549],
        SEARCH_COMPLETE: l[23546]
      };
      class ResultContainer extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.renderResults = (results, status, isFirstQuery, onSearchMessages) => {
            if (status === STATUS.COMPLETED && results.length < 1) {
              return external_React_default().createElement(
                ResultTable,
                null,
                external_React_default().createElement(ResultRow, {
                  type: TYPE.NIL,
                  isFirstQuery: isFirstQuery,
                  onSearchMessages: onSearchMessages
                })
              );
            }
            const RESULT_TABLE = {
              CONTACTS_AND_CHATS: [],
              MESSAGES: []
            };
            for (const resultTypeGroup in results) {
              if (results.hasOwnProperty(resultTypeGroup)) {
                const len = results[resultTypeGroup].length;
                for (let i = 0; i < len; i++) {
                  const result = results[resultTypeGroup].getItem(i);
                  const { MESSAGE, MEMBER, CHAT } = TYPE;
                  const { resultId, type } = result;
                  const table = type === MESSAGE ? "MESSAGES" : "CONTACTS_AND_CHATS";
                  RESULT_TABLE[table] = [
                    ...RESULT_TABLE[table],
                    external_React_default().createElement(ResultRow, {
                      key: resultId,
                      type: type === MESSAGE ? MESSAGE : type === MEMBER ? MEMBER : CHAT,
                      result: result
                    })
                  ];
                }
              }
            }
            return Object.keys(RESULT_TABLE).map((key, index) => {
              const table = {
                ref: RESULT_TABLE[key],
                hasRows: RESULT_TABLE[key] && RESULT_TABLE[key].length,
                isEmpty: RESULT_TABLE[key] && RESULT_TABLE[key].length < 1,
                props: {
                  key: index,
                  heading: key === "MESSAGES" ? LABEL.MESSAGES : LABEL.CONTACTS_AND_CHATS
                }
              };
              if (table.hasRows) {
                return external_React_default().createElement(
                  ResultTable,
                  table.props,
                  table.ref.map((row) => row)
                );
              }
              if (status === STATUS.COMPLETED && key === "MESSAGES") {
                const SEARCH_MESSAGES = external_React_default().createElement(
                  "button",
                  {
                    className: "search-messages mega-button",
                    onClick: onSearchMessages
                  },
                  external_React_default().createElement("span", null, LABEL.SEARCH_MESSAGES_CTA)
                );
                const NO_RESULTS = external_React_default().createElement(ResultRow, {
                  type: TYPE.NIL,
                  isFirstQuery: isFirstQuery,
                  onSearchMessages: onSearchMessages
                });
                return external_React_default().createElement(ResultTable, table.props, isFirstQuery ? SEARCH_MESSAGES : NO_RESULTS);
              }
              return null;
            });
          };
        }
        render() {
          const { results, status, isFirstQuery, onSearchMessages } = this.props;
          return this.renderResults(results, status, isFirstQuery, onSearchMessages);
        }
      } // CONCATENATED MODULE: ./js/chat/ui/searchPanel/searchField.jsx
      var searchField_class;

      const SEARCH_STATUS_CLASS = "search-field-status";
      const BASE_ICON_CLASS = "sprite-fm-mono";
      class SearchField extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.state = {
            hovered: false
          };
          this.renderStatusBanner = () => {
            switch (this.props.status) {
              case STATUS.IN_PROGRESS:
                return external_React_default().createElement(
                  "div",
                  {
                    className: `${SEARCH_STATUS_CLASS} searching info`
                  },
                  LABEL.DECRYPTING_RESULTS
                );
              case STATUS.PAUSED:
                return external_React_default().createElement(
                  "div",
                  {
                    className: `${SEARCH_STATUS_CLASS} paused info`
                  },
                  LABEL.SEARCH_PAUSED
                );
              case STATUS.COMPLETED:
                return external_React_default().createElement(
                  "div",
                  {
                    className: `${SEARCH_STATUS_CLASS} complete success`
                  },
                  LABEL.SEARCH_COMPLETE
                );
              default:
                return null;
            }
          };
          this.renderStatusControls = () => {
            const { status, onToggle } = this.props;
            const handleHover = () =>
              this.setState((state) => ({
                hovered: !state.hovered
              }));
            switch (status) {
              case STATUS.IN_PROGRESS:
                return external_React_default().createElement(
                  "div",
                  {
                    className: "progress-controls",
                    onClick: onToggle
                  },
                  external_React_default().createElement("i", {
                    className: `${BASE_ICON_CLASS} icon-pause`
                  })
                );
              case STATUS.PAUSED:
                return external_React_default().createElement("i", {
                  className: `${BASE_ICON_CLASS} icon-resume`,
                  onClick: onToggle,
                  onMouseOver: handleHover,
                  onMouseOut: handleHover
                });
              case STATUS.COMPLETED:
                return null;
              default:
                return null;
            }
          };
        }
        componentDidMount() {
          super.componentDidMount();
          SearchField.focus();
        }
        render() {
          const { value, searching, status, onChange, onReset } = this.props;
          return external_React_default().createElement(
            "div",
            {
              className: "search-field"
            },
            external_React_default().createElement("i", {
              className: `${BASE_ICON_CLASS} icon-preview-reveal search-icon-find`
            }),
            external_React_default().createElement("input", {
              type: "search",
              autoComplete: "off",
              placeholder: l[102],
              ref: SearchField.inputRef,
              value: value,
              onChange: (ev) => {
                if (this.state.hovered) {
                  this.setState({
                    hovered: false
                  });
                }
                onChange(ev);
              }
            }),
            searching &&
              external_React_default().createElement("i", {
                className: `
                            ${BASE_ICON_CLASS}
                            icon-close-component
                            search-icon-reset
                        `,
                onClick: onReset
              }),
            searching &&
              status &&
              external_React_default().createElement(
                external_React_default().Fragment,
                null,
                this.renderStatusControls(),
                this.renderStatusBanner()
              )
          );
        }
      }
      searchField_class = SearchField;
      SearchField.inputRef = external_React_default().createRef();
      SearchField.select = () => {
        const inputElement = searchField_class.inputRef && searchField_class.inputRef.current;
        const value = inputElement && inputElement.value;
        if (inputElement && value) {
          inputElement.selectionStart = 0;
          inputElement.selectionEnd = value.length;
        }
      };
      SearchField.focus = () =>
        searchField_class.inputRef && searchField_class.inputRef.current && searchField_class.inputRef.current.focus();
      SearchField.hasValue = () =>
        searchField_class.inputRef && searchField_class.inputRef.current && !!searchField_class.inputRef.current.value.length;
      SearchField.isVisible = () =>
        searchField_class.inputRef && searchField_class.inputRef.current && elementIsVisible(searchField_class.inputRef.current); // CONCATENATED MODULE: ./js/chat/ui/searchPanel/searchPanel.jsx
      const STATUS = {
        IN_PROGRESS: 1,
        PAUSED: 2,
        COMPLETED: 3
      };
      const EVENTS = {
        RESULT_OPEN: "chatSearchResultOpen",
        KEYDOWN: "keydown"
      };
      const ACTIONS = {
        PAUSE: "pause",
        RESUME: "resume"
      };
      const SEARCH_PANEL_CLASS = `search-panel`;
      class SearchPanel extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.wrapperRef = null;
          this.state = {
            value: "",
            searching: false,
            status: undefined,
            isFirstQuery: true,
            results: []
          };
          this.unbindEvents = () => {
            if (this.pageChangeListener) {
              mBroadcaster.removeListener(this.pageChangeListener);
            }
            document.removeEventListener(EVENTS.RESULT_OPEN, this.doPause);
            document.removeEventListener(EVENTS.KEYDOWN, this.handleKeyDown);
            megaChat.plugins.chatdIntegration.chatd.off("onClose.search");
            megaChat.plugins.chatdIntegration.chatd.off("onOpen.search");
          };
          this.bindEvents = () => {
            this.pageChangeListener = mBroadcaster.addListener("pagechange", this.doPause);
            document.addEventListener(EVENTS.RESULT_OPEN, this.doPause);
            document.addEventListener(EVENTS.KEYDOWN, this.handleKeyDown);
            megaChat.plugins.chatdIntegration.chatd.rebind("onClose.search", () => this.state.searching && this.doToggle(ACTIONS.PAUSE));
            megaChat.plugins.chatdIntegration.chatd.rebind("onOpen.search", () => this.state.searching && this.doToggle(ACTIONS.RESUME));
          };
          this.doPause = () => {
            if (this.state.status === STATUS.IN_PROGRESS) {
              this.doToggle(ACTIONS.PAUSE);
            }
          };
          this.doSearch = (s, searchMessages) => {
            return ChatSearch.doSearch(
              s,
              (room, result, results) =>
                this.setState({
                  results
                }),
              searchMessages
            )
              .catch((ex) => d && console.error("Search failed (or was reset)", ex))
              .always(() =>
                this.setState({
                  status: STATUS.COMPLETED
                })
              );
          };
          this.doToggle = (action) => {
            const { IN_PROGRESS, PAUSED, COMPLETED } = STATUS;
            const searching = this.state.status === IN_PROGRESS || this.state.status === PAUSED;
            if (action && searching) {
              const chatSearch = ChatSearch.doSearch.cs;
              if (!chatSearch) {
                return delay("chat-toggle", () => this.doToggle(action), 600);
              }
              this.setState(
                {
                  status: action === ACTIONS.PAUSE ? PAUSED : action === ACTIONS.RESUME ? IN_PROGRESS : COMPLETED
                },
                () => chatSearch[action]()
              );
            }
          };
          this.doDestroy = () => ChatSearch && ChatSearch.doSearch && ChatSearch.doSearch.cs && ChatSearch.doSearch.cs.destroy();
          this.handleKeyDown = (ev) => {
            const { keyCode } = ev;
            if (keyCode && keyCode === 27) {
              return SearchField.hasValue() ? this.handleReset() : this.doPause();
            }
          };
          this.handleChange = (ev) => {
            if (SearchField.isVisible()) {
              const { value } = ev.target;
              const searching = value.length > 0;
              this.doDestroy();
              this.setState(
                {
                  value,
                  searching,
                  status: undefined,
                  isFirstQuery: true,
                  results: []
                },
                () => {
                  if (searching) {
                    delay("chat-search", () => this.doSearch(value, false), 1600);
                    if ($.dialog === "onboardingDialog") {
                      closeDialog();
                    }
                  } else {
                    megaChat.plugins.chatOnboarding.checkAndShowStep();
                  }
                }
              );
              this.wrapperRef.scrollToY(0);
            }
          };
          this.handleToggle = () => {
            const inProgress = this.state.status === STATUS.IN_PROGRESS;
            this.setState(
              {
                status: inProgress ? STATUS.PAUSED : STATUS.IN_PROGRESS
              },
              () => {
                delay("chat-toggled", () => SearchField.focus());
                return this.doToggle(inProgress ? ACTIONS.PAUSE : ACTIONS.RESUME);
              }
            );
          };
          this.handleReset = () =>
            this.setState(
              {
                value: "",
                searching: false,
                status: undefined,
                results: []
              },
              () => {
                this.wrapperRef.scrollToY(0);
                onIdle(() => SearchField.focus());
                this.doDestroy();
              }
            );
          this.handleSearchMessages = () =>
            SearchField.hasValue() &&
            this.setState(
              {
                status: STATUS.IN_PROGRESS,
                isFirstQuery: false
              },
              () => {
                this.doSearch(this.state.value, true);
                SearchField.focus();
                SearchField.select();
              }
            );
        }
        componentDidMount() {
          super.componentDidMount();
          this.bindEvents();
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          this.unbindEvents();
        }
        render() {
          const { value, searching, status, isFirstQuery, results } = this.state;
          return external_React_default().createElement(
            "div",
            {
              className: `
                    ${SEARCH_PANEL_CLASS}
                    ${searching ? "expanded" : ""}
                `
            },
            external_React_default().createElement(SearchField, {
              value: value,
              searching: searching,
              status: status,
              onChange: this.handleChange,
              onToggle: this.handleToggle,
              onReset: this.handleReset
            }),
            external_React_default().createElement(
              perfectScrollbar.F,
              {
                className: "search-results-wrapper",
                ref: (wrapper) => {
                  this.wrapperRef = wrapper;
                },
                options: {
                  suppressScrollX: true
                }
              },
              searching &&
                external_React_default().createElement(ResultContainer, {
                  status: status,
                  results: results,
                  isFirstQuery: isFirstQuery,
                  onSearchMessages: this.handleSearchMessages
                })
            )
          );
        }
      }
      // EXTERNAL MODULE: ./js/ui/buttons.jsx
      var buttons = __webpack_require__(204); // CONCATENATED MODULE: ./js/chat/ui/leftPanel/navigation.jsx
      class Navigation extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            unreadChats: 0,
            unreadMeetings: 0,
            contactRequests: 0
          };
          this.state.contactRequests = Object.keys(M.ipc).length;
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          megaChat.unbind(`onUnreadCountUpdate.${LeftPanel.NAMESPACE}`);
          if (this.contactRequestsListener) {
            mBroadcaster.removeListener(this.contactRequestsListener);
          }
        }
        componentDidMount() {
          super.componentDidMount();
          megaChat.rebind(`onUnreadCountUpdate.${LeftPanel.NAMESPACE}`, (ev, notifications) => {
            this.setState({
              unreadChats: notifications.chats,
              unreadMeetings: notifications.meetings
            });
          });
          this.contactRequestsListener = mBroadcaster.addListener("fmViewUpdate:ipc", () => {
            this.setState({
              contactRequests: Object.keys(M.ipc).length
            });
          });
        }
        render() {
          const { view, views, routingSection, renderView } = this.props;
          const { CHATS, MEETINGS } = views;
          const { unreadChats, unreadMeetings, contactRequests } = this.state;
          return external_React_default().createElement(
            "div",
            {
              className: `${LeftPanel.NAMESPACE}-nav`
            },
            external_React_default().createElement(
              "div",
              {
                className: `
                        ${LeftPanel.NAMESPACE}-nav-container
                        ${LeftPanel.NAMESPACE}-chats-tab
                        ${view === CHATS && routingSection === "chat" ? "active" : ""}
                    `,
                onClick: () => renderView(CHATS)
              },
              external_React_default().createElement(
                buttons.z,
                {
                  unreadChats: unreadChats,
                  className: `${LeftPanel.NAMESPACE}-nav-button`,
                  icon: "sprite-fm-mono icon-chat-filled"
                },
                !!unreadChats &&
                  external_React_default().createElement(
                    "div",
                    {
                      className: "notifications-count"
                    },
                    external_React_default().createElement("span", null, unreadChats > 9 ? "9+" : unreadChats)
                  )
              ),
              external_React_default().createElement("span", null, l.chats)
            ),
            external_React_default().createElement(
              "div",
              {
                className: `
                        ${LeftPanel.NAMESPACE}-nav-container
                        ${LeftPanel.NAMESPACE}-meetings-tab
                        ${view === MEETINGS && routingSection === "chat" ? "active" : ""}
                    `,
                onClick: () => renderView(MEETINGS)
              },
              external_React_default().createElement(
                buttons.z,
                {
                  unreadMeetings: unreadMeetings,
                  className: `${LeftPanel.NAMESPACE}-nav-button`,
                  icon: "sprite-fm-mono icon-video-call-filled"
                },
                !!unreadMeetings &&
                  external_React_default().createElement(
                    "div",
                    {
                      className: "notifications-count"
                    },
                    external_React_default().createElement("span", null, unreadMeetings > 9 ? "9+" : unreadMeetings)
                  )
              ),
              external_React_default().createElement("span", null, l.meetings)
            ),
            is_eplusplus || is_chatlink
              ? null
              : external_React_default().createElement(
                  "div",
                  {
                    className: `
                            ${LeftPanel.NAMESPACE}-nav-container
                            ${LeftPanel.NAMESPACE}-contacts-tab
                            ${routingSection === "contacts" ? "active" : ""}
                        `,
                    onClick: () => loadSubPage("fm/chat/contacts")
                  },
                  external_React_default().createElement(
                    buttons.z,
                    {
                      className: `${LeftPanel.NAMESPACE}-nav-button`,
                      contactRequests: contactRequests,
                      icon: "sprite-fm-mono icon-contacts"
                    },
                    !!contactRequests &&
                      external_React_default().createElement(
                        "div",
                        {
                          className: `
                                        notifications-count
                                        ${contactRequests > 99 ? "large" : ""}
                                    `
                        },
                        external_React_default().createElement("span", null, contactRequests)
                      )
                  ),
                  external_React_default().createElement("span", null, l[165])
                )
          );
        }
      }
      // EXTERNAL MODULE: ./js/ui/dropdowns.jsx
      var dropdowns = __webpack_require__(78); // CONCATENATED MODULE: ./js/chat/ui/leftPanel/actions.jsx
      class Actions extends mixins.wl {
        render() {
          const { view, views, routingSection, startMeeting, scheduleMeeting, createGroupChat } = this.props;
          const { CHATS, MEETINGS, LOADING } = views;
          if (is_eplusplus || is_chatlink) {
            return null;
          }
          return external_React_default().createElement(
            "div",
            {
              className: `${LeftPanel.NAMESPACE}-action-buttons`
            },
            view === LOADING &&
              external_React_default().createElement(
                buttons.z,
                {
                  className: "mega-button action loading-sketch"
                },
                external_React_default().createElement("i", null),
                external_React_default().createElement("span", null)
              ),
            view === CHATS &&
              routingSection !== "contacts" &&
              external_React_default().createElement(
                buttons.z,
                {
                  className: "mega-button action",
                  icon: "sprite-fm-mono icon-add-circle",
                  label: l.add_chat
                },
                external_React_default().createElement(dropdowns.DropdownContactsSelector, {
                  className: `
                                main-start-chat-dropdown
                                ${LeftPanel.NAMESPACE}-contact-selector
                            `,
                  onSelectDone: (selected) => {
                    if (selected.length === 1) {
                      return megaChat.createAndShowPrivateRoom(selected[0]).then((room) => room.setActive());
                    }
                    megaChat.createAndShowGroupRoomFor(selected);
                  },
                  multiple: false,
                  horizOffset: 70,
                  topButtons: [
                    {
                      key: "newGroupChat",
                      title: l[19483],
                      icon: "sprite-fm-mono icon-chat-filled",
                      onClick: createGroupChat
                    }
                  ],
                  showAddContact: contactsPanel["default"].hasContacts()
                })
              ),
            view === MEETINGS &&
              routingSection !== "contacts" &&
              external_React_default().createElement(
                buttons.z,
                {
                  className: "mega-button action",
                  icon: "sprite-fm-mono icon-add-circle",
                  label: l.create_meeting
                },
                external_React_default().createElement("i", {
                  className: "sprite-fm-mono icon-arrow-down"
                }),
                external_React_default().createElement(
                  dropdowns.Dropdown,
                  {
                    className: "light",
                    noArrow: "true",
                    vertOffset: 4,
                    positionMy: "left top",
                    positionAt: "left bottom"
                  },
                  external_React_default().createElement(dropdowns.DropdownItem, {
                    className: "link-button",
                    icon: "sprite-fm-mono icon-video-plus",
                    label: l.new_meeting_start,
                    onClick: startMeeting
                  }),
                  external_React_default().createElement("hr", null),
                  external_React_default().createElement(dropdowns.DropdownItem, {
                    className: "link-button",
                    icon: "sprite-fm-mono icon-calendar2",
                    label: l.schedule_meeting_start,
                    onClick: scheduleMeeting
                  })
                )
              ),
            routingSection === "contacts" &&
              external_React_default().createElement(buttons.z, {
                className: "mega-button action",
                icon: "sprite-fm-mono icon-add-circle",
                label: l[71],
                onClick: () => contactAddDialog()
              })
          );
        }
      }
      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js
      var applyDecoratedDescriptor = __webpack_require__(229); // CONCATENATED MODULE: ./js/chat/ui/leftPanel/conversationsListItem.jsx
      var _dec, _dec2, conversationsListItem_class;

      let ConversationsListItem =
        ((_dec = utils.ZP.SoonFcWrap(40, true)),
        (_dec2 = (0, mixins.LY)(0.7, 8)),
        ((conversationsListItem_class = class ConversationsListItem extends mixins.wl {
          constructor(...args) {
            super(...args);
            this.state = {
              isLoading: true
            };
          }
          isLoading() {
            const mb = this.props.chatRoom.messagesBuff;
            if (mb.haveMessages) {
              return false;
            }
            return mb.messagesHistoryIsLoading() || (mb.joined === false && mb.isDecrypting);
          }
          specShouldComponentUpdate() {
            return !this.state.isLoading;
          }
          componentWillUnmount() {
            super.componentWillUnmount();
            this.props.chatRoom.unbind("onUnreadCountUpdate.conversationsListItem");
          }
          componentDidMount() {
            super.componentDidMount();
            this.eventuallyScrollTo();
            const promise = this.isLoading();
            if (promise && promise.always) {
              promise.always(() => {
                if (this.isMounted()) {
                  this.setState({
                    isLoading: false
                  });
                }
              });
            } else if (promise === false) {
              this.setState({
                isLoading: false
              });
            }
            this.props.chatRoom.rebind("onUnreadCountUpdate.conversationsListItem", () => {
              this.safeForceUpdate();
            });
          }
          componentDidUpdate() {
            super.componentDidUpdate();
            this.eventuallyScrollTo();
          }
          eventuallyScrollTo() {
            const chatRoom = this.props.chatRoom || false;
            if (chatRoom._scrollToOnUpdate) {
              if (chatRoom.isCurrentlyActive) {
                chatRoom.scrollToChat();
              } else {
                chatRoom._scrollToOnUpdate = false;
              }
            }
          }
          getConversationTimestamp() {
            const { chatRoom } = this.props;
            if (chatRoom) {
              const lastMessage = chatRoom.messagesBuff.getLatestTextMessage();
              const timestamp = (lastMessage && lastMessage.delay) || chatRoom.ctime;
              return todayOrYesterday(timestamp * 1000) ? getTimeMarker(timestamp) : time2date(timestamp, 17);
            }
            return null;
          }
          getScheduledDateTime() {
            const { scheduledMeeting } = this.props.chatRoom;
            if (scheduledMeeting) {
              const { isRecurring, nextOccurrenceStart } = scheduledMeeting;
              if (isRecurring) {
                return {
                  date: time2date(nextOccurrenceStart / 1000, 19),
                  time: toLocaleTime(nextOccurrenceStart)
                };
              }
              return {
                date: time2date(nextOccurrenceStart / 1000, 19),
                time: toLocaleTime(nextOccurrenceStart)
              };
            }
          }
          render() {
            var classString = "";
            var chatRoom = this.props.chatRoom;
            if (!chatRoom || !chatRoom.chatId) {
              return null;
            }
            var roomId = chatRoom.chatId;
            if (chatRoom.isCurrentlyActive) {
              classString += " active";
            }
            var nameClassString = "user-card-name conversation-name selectable-txt";
            var contactId;
            var presenceClass;
            var id;
            let contact;
            if (chatRoom.type === "private") {
              const handle = chatRoom.getParticipantsExceptMe()[0];
              if (!handle || !(handle in M.u)) {
                return null;
              }
              contact = M.u[handle];
              id = "conversation_" + htmlentities(contact.u);
              presenceClass = chatRoom.megaChat.userPresenceToCssClass(contact.presence);
            } else if (chatRoom.type === "group") {
              contactId = roomId;
              id = "conversation_" + contactId;
              presenceClass = "group";
              classString += " groupchat";
            } else if (chatRoom.type === "public") {
              contactId = roomId;
              id = "conversation_" + contactId;
              presenceClass = "group";
              classString += " groupchat public";
            } else {
              return "unknown room type: " + chatRoom.roomId;
            }
            var unreadCount = chatRoom.messagesBuff.getUnreadCount();
            var isUnread = false;
            var notificationItems = [];
            if (chatRoom.havePendingCall() && chatRoom.state !== ChatRoom.STATE.LEFT) {
              notificationItems.push(
                external_React_default().createElement("i", {
                  className: "tiny-icon " + (chatRoom.isCurrentlyActive ? "blue" : "white") + "-handset",
                  key: "callIcon"
                })
              );
            }
            if (unreadCount > 0) {
              notificationItems.push(
                external_React_default().createElement(
                  "span",
                  {
                    key: "unreadCounter"
                  },
                  unreadCount > 9 ? "9+" : unreadCount
                )
              );
              isUnread = true;
            }
            var lastMessageDiv = null;
            const showHideMsg = mega.config.get("showHideChat");
            var lastMessage = showHideMsg ? "" : chatRoom.messagesBuff.getLatestTextMessage();
            var lastMsgDivClasses;
            if (lastMessage) {
              lastMsgDivClasses = "conversation-message" + (isUnread ? " unread" : "");
              const renderableSummary = chatRoom.messagesBuff.getRenderableSummary(lastMessage);
              if (chatRoom.havePendingCall() || chatRoom.haveActiveCall()) {
                lastMsgDivClasses += " call";
                classString += " call-exists";
              }
              lastMessageDiv = external_React_default().createElement(
                "div",
                {
                  className: lastMsgDivClasses
                },
                external_React_default().createElement(utils.Cw, null, renderableSummary)
              );
              if (
                lastMessage.textContents &&
                lastMessage.textContents[1] === Message.MANAGEMENT_MESSAGE_TYPES.VOICE_CLIP &&
                lastMessage.getAttachmentMeta()[0]
              ) {
                const playTime = secondsToTimeShort(lastMessage.getAttachmentMeta()[0].playtime);
                lastMessageDiv = external_React_default().createElement(
                  "div",
                  {
                    className: lastMsgDivClasses
                  },
                  external_React_default().createElement("i", {
                    className: "sprite-fm-mono icon-audio-filled voice-message-icon"
                  }),
                  playTime
                );
              }
              if (lastMessage.metaType && lastMessage.metaType === Message.MESSAGE_META_TYPE.GEOLOCATION) {
                lastMessageDiv = external_React_default().createElement(
                  "div",
                  {
                    className: lastMsgDivClasses
                  },
                  external_React_default().createElement("i", {
                    className: "sprite-fm-mono icon-location geolocation-icon"
                  }),
                  l[20789]
                );
              }
            } else {
              lastMsgDivClasses = "conversation-message";
              lastMessageDiv = showHideMsg
                ? ""
                : external_React_default().createElement(
                    "div",
                    {
                      className: lastMsgDivClasses
                    },
                    this.state.isLoading ? l[7006] : l[8000]
                  );
            }
            if (chatRoom.type !== "public") {
              nameClassString += " privateChat";
            }
            let roomTitle = external_React_default().createElement(utils.nF, null, megaChat.html(chatRoom.getRoomTitle()));
            if (chatRoom.type === "private") {
              roomTitle = external_React_default().createElement(
                "span",
                null,
                external_React_default().createElement(
                  "div",
                  {
                    className: "user-card-wrapper"
                  },
                  external_React_default().createElement(utils.nF, null, megaChat.html(chatRoom.getRoomTitle()))
                )
              );
            }
            nameClassString += chatRoom.type === "private" || chatRoom.type === "group" ? " badge-pad" : "";
            const { scheduledMeeting, isMeeting } = chatRoom;
            const isUpcoming = scheduledMeeting && scheduledMeeting.isUpcoming;
            const { date, time } = this.getScheduledDateTime() || {};
            return external_React_default().createElement(
              "li",
              {
                id: id,
                className: `
                    ${classString}
                    ${isUpcoming ? "upcoming-conversation" : ""}
                `,
                "data-room-id": roomId,
                "data-jid": contactId,
                onClick: (ev) => this.props.onConversationClick(ev)
              },
              external_React_default().createElement(
                "div",
                {
                  className: "conversation-avatar"
                },
                (chatRoom.type === "group" || chatRoom.type === "public") &&
                  external_React_default().createElement(
                    "div",
                    {
                      className: `
                                chat-topic-icon
                                ${isMeeting ? "meeting-icon" : ""}
                            `
                    },
                    external_React_default().createElement("i", {
                      className: isMeeting ? "sprite-fm-mono icon-video-call-filled" : "sprite-fm-uni icon-chat-group"
                    })
                  ),
                chatRoom.type === "private" &&
                  contact &&
                  external_React_default().createElement(ui_contacts.Avatar, {
                    contact: contact
                  })
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "conversation-data"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "conversation-data-top"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: `conversation-data-name ${nameClassString}`
                    },
                    roomTitle
                  ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "conversation-data-badges"
                    },
                    chatRoom.type === "private" &&
                      external_React_default().createElement("span", {
                        className: `user-card-presence ${presenceClass}`
                      }),
                    (chatRoom.type === "group" || chatRoom.type === "private") &&
                      external_React_default().createElement("i", {
                        className: "sprite-fm-uni icon-ekr-key simpletip",
                        "data-simpletip": l[20935]
                      }),
                    scheduledMeeting &&
                      scheduledMeeting.isUpcoming &&
                      scheduledMeeting.isRecurring &&
                      external_React_default().createElement("i", {
                        className: "sprite-fm-mono icon-repeat"
                      })
                  )
                ),
                external_React_default().createElement("div", {
                  className: "clear"
                }),
                isUpcoming
                  ? external_React_default().createElement(
                      "div",
                      {
                        className: "conversation-message-info"
                      },
                      external_React_default().createElement(
                        "div",
                        {
                          className: "conversation-scheduled-data"
                        },
                        external_React_default().createElement("span", null, date)
                      ),
                      external_React_default().createElement(
                        "div",
                        {
                          className: "conversation-scheduled-data"
                        },
                        external_React_default().createElement("span", null, time),
                        notificationItems.length > 0
                          ? external_React_default().createElement(
                              "div",
                              {
                                className: `
                                            unread-messages
                                            items-${notificationItems.length}
                                            unread-upcoming
                                        `
                              },
                              notificationItems
                            )
                          : null
                      )
                    )
                  : external_React_default().createElement(
                      "div",
                      {
                        className: "conversation-message-info"
                      },
                      lastMessageDiv
                    )
              ),
              isUpcoming
                ? null
                : external_React_default().createElement(
                    "div",
                    {
                      className: "date-time-wrapper"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: "date-time"
                      },
                      this.getConversationTimestamp()
                    ),
                    notificationItems.length > 0
                      ? external_React_default().createElement(
                          "div",
                          {
                            className: "unread-messages-container"
                          },
                          external_React_default().createElement(
                            "div",
                            {
                              className: `unread-messages items-${notificationItems.length}`
                            },
                            notificationItems
                          )
                        )
                      : null
                  )
            );
          }
        }),
        ((0, applyDecoratedDescriptor.Z)(
          conversationsListItem_class.prototype,
          "eventuallyScrollTo",
          [_dec],
          Object.getOwnPropertyDescriptor(conversationsListItem_class.prototype, "eventuallyScrollTo"),
          conversationsListItem_class.prototype
        ),
        (0, applyDecoratedDescriptor.Z)(
          conversationsListItem_class.prototype,
          "render",
          [_dec2],
          Object.getOwnPropertyDescriptor(conversationsListItem_class.prototype, "render"),
          conversationsListItem_class.prototype
        )),
        conversationsListItem_class)); // CONCATENATED MODULE: ./js/chat/ui/leftPanel/toggle.jsx

      class TogglePanel extends mixins.wl {
        componentDidUpdate() {
          super.componentDidUpdate();
          const { $chatTreePanePs: content } = megaChat;
          if (content) {
            const container = document.querySelector(`.${LeftPanel.NAMESPACE}-conversations`);
            const scrollable = content.getContentHeight() > container.offsetHeight - 40;
            container.classList[scrollable ? "add" : "remove"]("scrollable");
            content.reinitialise();
          }
        }
        specShouldComponentUpdate() {
          return !this.props.loading;
        }
        render() {
          const { loading, expanded, heading, children, className, onToggle } = this.props;
          return external_React_default().createElement(
            "div",
            {
              className: `
                    toggle-panel
                    ${expanded ? "expanded" : ""}
                    ${className || ""}
                `,
              onClick: onToggle
            },
            heading &&
              external_React_default().createElement(
                "div",
                {
                  className: "toggle-panel-heading"
                },
                external_React_default().createElement("i", {
                  className: "sprite-fm-mono icon-arrow-down"
                }),
                external_React_default().createElement("span", null, heading)
              ),
            expanded &&
              external_React_default().createElement(
                "div",
                {
                  className: `
                            toggle-panel-content
                            ${loading ? "loading-sketch" : ""}
                        `
                },
                children
              )
          );
        }
      }
      TogglePanel.KEYS = {
        UPCOMING: "upcoming",
        PAST: "past",
        ARCHIVE: "archive"
      };
      class Toggle extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            expanded: null
          };
          this.state.expanded = this.props.expanded || null;
        }
        onMeetingInitialize(scheduledMeeting) {
          assert(scheduledMeeting, "Failed to initialize scheduled meeting.");
          if (!M.chat || !this.isMounted() || !ChatdPersist.isMasterTab()) {
            return;
          }
          const { chatRoom, iAmOwner } = scheduledMeeting;
          if (chatRoom && iAmOwner) {
            this.setState(
              {
                expanded: TogglePanel.KEYS.UPCOMING
              },
              () => chatRoom.setActive()
            );
          }
        }
        specShouldComponentUpdate() {
          return !this.props.loading;
        }
        componentWillUpdate(nextProps) {
          const { view, views } = this.props;
          if (view !== views.MEETINGS && nextProps.view === views.MEETINGS) {
            this.setState({
              expanded: TogglePanel.KEYS.UPCOMING
            });
          }
        }
        componentDidUpdate() {
          super.componentDidUpdate();
          const { view, views, children } = this.props;
          const hasExpandablePanel = children.some((child) => child.key === this.state.expanded);
          if (!hasExpandablePanel && view !== views.MEETINGS) {
            this.setState({
              expanded: TogglePanel.KEYS.PAST
            });
          }
        }
        componentDidMount() {
          super.componentDidMount();
          megaChat.rebind(`${megaChat.plugins.meetingsManager.EVENTS.INITIALIZE}.toggle`, (ev, scheduledMeeting) =>
            this.onMeetingInitialize(scheduledMeeting)
          );
        }
        render() {
          const { loading, children } = this.props;
          if (children) {
            return children.map((child) => {
              return (
                child &&
                external_React_default().cloneElement(child, {
                  loading,
                  expanded: this.state.expanded === child.key,
                  onToggle: () =>
                    this.setState({
                      expanded: child.key
                    })
                })
              );
            });
          }
          return null;
        }
      } // CONCATENATED MODULE: ./js/chat/ui/leftPanel/conversationsList.jsx
      class ConversationsList extends mixins.wl {
        constructor(props) {
          super(props);
          this.backgroundUpdateInterval = null;
          this.state = {
            updated: 0
          };
          this.doUpdate = this.doUpdate.bind(this);
        }
        customIsEventuallyVisible() {
          return M.chat;
        }
        attachRerenderCallbacks() {
          this._megaChatsListener = megaChat.chats.addChangeListener(() => this.onPropOrStateUpdated());
        }
        detachRerenderCallbacks() {
          if (super.detachRerenderCallbacks) {
            super.detachRerenderCallbacks();
          }
          megaChat.chats.removeChangeListener(this._megaChatsListener);
        }
        doUpdate() {
          return (
            this.isComponentVisible() &&
            document.visibilityState === "visible" &&
            this.setState(
              (state) => ({
                updated: ++state.updated
              }),
              () => this.forceUpdate()
            )
          );
        }
        renderLoading() {
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            external_React_default().createElement("span", {
              className: "heading loading-sketch"
            }),
            external_React_default().createElement(
              "ul",
              {
                className: "conversations-pane loading-sketch"
              },
              Array.from(
                {
                  length: this.props.conversations.length
                },
                (el, i) => {
                  return external_React_default().createElement(
                    "li",
                    {
                      key: i
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: "conversation-avatar"
                      },
                      external_React_default().createElement("div", {
                        className: "chat-topic-icon"
                      })
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "conversation-data"
                      },
                      external_React_default().createElement("div", {
                        className: "conversation-data-top"
                      }),
                      external_React_default().createElement(
                        "div",
                        {
                          className: "conversation-message-info"
                        },
                        external_React_default().createElement("div", {
                          className: "conversation-message"
                        })
                      )
                    )
                  );
                }
              )
            )
          );
        }
        renderEmptyState() {
          const { type, view, views } = this.props;
          const isArchived = type === TogglePanel.KEYS.ARCHIVE;
          const isUpcoming = type === TogglePanel.KEYS.UPCOMING;
          const messages = {
            [views.CHATS]: isArchived ? l.no_archived_chats_lhp : l.no_chats_lhp,
            [views.MEETINGS]: (() => {
              if (isArchived) {
                return l.no_archived_meetings_lhp;
              }
              return isUpcoming ? l.no_upcoming_meetings_lhp : l.no_meetings_lhp;
            })()
          };
          return external_React_default().createElement(
            "span",
            {
              className: "empty-conversations"
            },
            messages[view]
          );
        }
        renderConversationsList() {
          const { view, conversations, onConversationClick } = this.props;
          return external_React_default().createElement(
            perfectScrollbar.F,
            {
              className: "chat-lp-scroll-area",
              ref: (ref) => {
                megaChat.$chatTreePanePs = ref;
              },
              view: view,
              conversations: conversations
            },
            external_React_default().createElement(
              "ul",
              {
                className: "conversations-pane"
              },
              conversations.map((chatRoom) => {
                if (chatRoom.roomId) {
                  return external_React_default().createElement(ConversationsListItem, {
                    key: chatRoom.roomId,
                    chatRoom: chatRoom,
                    contact: M.u[chatRoom.getParticipantsExceptMe()[0]] || null,
                    messages: chatRoom.messagesBuff,
                    onConversationClick: () => {
                      loadSubPage(chatRoom.getRoomUrl(false));
                      if (onConversationClick) {
                        onConversationClick(chatRoom);
                      }
                    }
                  });
                }
                return null;
              })
            )
          );
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          clearInterval(this.backgroundUpdateInterval);
          document.removeEventListener("visibilitychange", this.doUpdate);
        }
        componentDidMount() {
          super.componentDidMount();
          this.doUpdate();
          this.backgroundUpdateInterval = setInterval(this.doUpdate, 600000);
          document.addEventListener("visibilitychange", this.doUpdate);
        }
        render() {
          const { view, views, conversations } = this.props;
          if (conversations && conversations.length === 0) {
            return this.renderEmptyState();
          }
          return view === views.LOADING ? this.renderLoading() : this.renderConversationsList();
        }
      }
      ConversationsList.defaultProps = {
        manualDataChangeTracking: true
      }; // CONCATENATED MODULE: ./js/chat/ui/leftPanel/leftPanel.jsx
      class LeftPanel extends mixins.wl {
        renderConversations(type) {
          const { view, views, renderView } = this.props;
          const filteredConversations = this.filterConversations(type);
          return external_React_default().createElement(ConversationsList, {
            type: type,
            view: view,
            views: views,
            conversations: filteredConversations,
            onConversationClick: (chatRoom) => renderView(chatRoom.isMeeting ? views.MEETINGS : views.CHATS)
          });
        }
        filterConversations(type) {
          let { view, views, conversations } = this.props;
          conversations = Object.values(conversations);
          switch (type) {
            case TogglePanel.KEYS.UPCOMING:
              return conversations
                .filter((c) => c.isDisplayable() && c.isMeeting && c.scheduledMeeting && c.scheduledMeeting.isUpcoming)
                .sort((a, b) => {
                  return a.scheduledMeeting.nextOccurrenceStart - b.scheduledMeeting.nextOccurrenceStart || a.ctime - b.ctime;
                });
            case TogglePanel.KEYS.PAST:
              return conversations
                .filter(
                  (c) =>
                    c.isDisplayable() &&
                    (view === views.MEETINGS ? c.isMeeting : !c.isMeeting) &&
                    (!c.scheduledMeeting || c.scheduledMeeting.isCanceled || c.scheduledMeeting.isPast)
                )
                .sort(M.sortObjFn((c) => c.lastActivity || c.ctime, -1));
            case TogglePanel.KEYS.ARCHIVE:
              return conversations
                .filter((c) => c.isArchived() && (view === views.MEETINGS ? c.isMeeting : !c.isMeeting))
                .sort(M.sortObjFn((c) => c.lastActivity || c.ctime, -1));
          }
        }
        render() {
          const { view, views, routingSection, conversations, leftPaneWidth, renderView, startMeeting, scheduleMeeting, createGroupChat } =
            this.props;
          const IS_LOADING = view === views.LOADING;
          return external_React_default().createElement(
            "div",
            (0, esm_extends.Z)(
              {
                className: `
                    fm-left-panel
                    chat-lp-body
                    ${(is_chatlink && "hidden") || ""}
                    ${(megaChat._joinDialogIsShown && "hidden") || ""}
                `
              },
              leftPaneWidth && {
                width: leftPaneWidth
              }
            ),
            external_React_default().createElement("div", {
              className: "left-pane-drag-handle"
            }),
            external_React_default().createElement(SearchPanel, null),
            external_React_default().createElement(Navigation, {
              view: view,
              views: views,
              routingSection: routingSection,
              renderView: renderView
            }),
            external_React_default().createElement(Actions, {
              view: view,
              views: views,
              routingSection: routingSection,
              startMeeting: startMeeting,
              scheduleMeeting: scheduleMeeting,
              createGroupChat: createGroupChat
            }),
            external_React_default().createElement(
              "div",
              {
                className: `
                        ${LeftPanel.NAMESPACE}-conversations
                        ${view === views.MEETINGS ? "meetings-view" : "chats-view"}
                        conversations
                        content-panel
                        active
                    `
              },
              external_React_default().createElement(
                Toggle,
                {
                  view: view,
                  views: views,
                  loading: IS_LOADING,
                  conversations: conversations,
                  expanded: TogglePanel.KEYS.UPCOMING
                },
                view === views.MEETINGS &&
                  external_React_default().createElement(
                    TogglePanel,
                    {
                      key: TogglePanel.KEYS.UPCOMING,
                      heading: l.upcoming_meetings
                    },
                    this.renderConversations(TogglePanel.KEYS.UPCOMING)
                  ),
                external_React_default().createElement(
                  TogglePanel,
                  {
                    key: TogglePanel.KEYS.PAST,
                    className: "lhp-toggle-past",
                    heading: !IS_LOADING && (view === views.CHATS ? l.contacts_and_groups : l.past_meetings)
                  },
                  this.renderConversations(TogglePanel.KEYS.PAST)
                ),
                external_React_default().createElement(
                  TogglePanel,
                  {
                    key: TogglePanel.KEYS.ARCHIVE,
                    heading: !IS_LOADING && view === views.CHATS ? l[19067] : l.archived_meetings
                  },
                  this.renderConversations(TogglePanel.KEYS.ARCHIVE)
                )
              )
            )
          );
        }
      }
      LeftPanel.NAMESPACE = "lhp"; // CONCATENATED MODULE: ./js/chat/ui/conversations.jsx
      const VIEWS = {
        CHATS: 0x00,
        MEETINGS: 0x01,
        LOADING: 0x02
      };
      const conversations_EVENTS = {
        NAV_RENDER_VIEW: "navRenderView"
      };
      class ConversationsApp extends mixins.wl {
        constructor(props) {
          super(props);
          this.chatRoomRef = null;
          this.occurrenceRef = null;
          this.state = {
            leftPaneWidth: Math.min(mega.config.get("leftPaneWidth") | 0, 400) || 384,
            startGroupChatDialog: false,
            startMeetingDialog: false,
            scheduleMeetingDialog: false,
            scheduleOccurrenceDialog: false,
            view: VIEWS.LOADING,
            callExpanded: false
          };
          this._cacheRouting();
          megaChat.rebind("onStartNewMeeting.convApp", () => this.startMeeting());
        }
        startMeeting() {
          if (megaChat.hasSupportForCalls) {
            return (0, call.xt)()
              .then(() =>
                this.setState({
                  startMeetingDialog: true
                })
              )
              .catch(() => d && console.warn("Already in a call."));
          }
          return showToast("warning", l[7211]);
        }
        _cacheRouting() {
          this.routingSection = this.props.megaChat.routingSection;
          this.routingSubSection = this.props.megaChat.routingSubSection;
          this.routingParams = this.props.megaChat.routingParams;
        }
        hasOpenDialog() {
          return [...document.querySelectorAll(".mega-dialog")].some(
            (dialog) => !!(dialog.offsetParent || dialog.offsetWidth || dialog.offsetHeight)
          );
        }
        specShouldComponentUpdate() {
          if (
            this.routingSection !== this.props.megaChat.routingSection ||
            this.routingSubSection !== this.props.megaChat.routingSubSection ||
            this.routingParams !== this.props.megaChat.routingParams
          ) {
            this._cacheRouting();
            return true;
          }
        }
        componentDidMount() {
          super.componentDidMount();
          var self = this;
          $(document).rebind("keydown.megaChatTextAreaFocus", (e) => {
            if (!M.chat || e.megaChatHandled) {
              return;
            }
            const { currentlyOpenedChat } = megaChat;
            const currentRoom = megaChat.getCurrentRoom();
            if (currentlyOpenedChat) {
              if (
                (currentRoom && currentRoom.isReadOnly()) ||
                $(e.target).is(".messages-textarea, input, textarea") ||
                ((e.ctrlKey || e.metaKey || e.which === 19) && e.keyCode === 67) ||
                e.keyCode === 91 ||
                e.keyCode === 17 ||
                e.keyCode === 27 ||
                e.altKey ||
                e.metaKey ||
                e.ctrlKey ||
                e.shiftKey ||
                this.hasOpenDialog() ||
                document.querySelector("textarea:focus,select:focus,input:focus")
              ) {
                return;
              }
              var $typeArea = $(".messages-textarea:visible:first");
              moveCursortoToEnd($typeArea);
              e.megaChatHandled = true;
              $typeArea.triggerHandler(e);
              e.preventDefault();
              e.stopPropagation();
              return false;
            }
          });
          $(document).rebind("mouseup.megaChatTextAreaFocus", (e) => {
            if (!M.chat || e.megaChatHandled || slideshowid) {
              return;
            }
            var $target = $(e.target);
            if (megaChat.currentlyOpenedChat) {
              if (
                $target.is(".messages-textarea,a,input,textarea,select,button") ||
                $target.closest(".messages.scroll-area").length > 0 ||
                $target.closest(".mega-dialog").length > 0 ||
                this.hasOpenDialog() ||
                document.querySelector("textarea:focus,select:focus,input:focus") ||
                window.getSelection().toString()
              ) {
                return;
              }
              var $typeArea = $(".messages-textarea:visible:first");
              if ($typeArea.length === 1 && !$typeArea.is(":focus")) {
                $typeArea.trigger("focus");
                e.megaChatHandled = true;
              }
            }
          });
          self.fmConfigLeftPaneListener = mBroadcaster.addListener("fmconfig:leftPaneWidth", function (value) {
            if (value > 0) {
              megaChat.$leftPane = megaChat.$leftPane || $(".conversationsApp .fm-left-panel");
              delay(
                "CoApp:fmc:thr",
                function () {
                  self.setState({
                    leftPaneWidth: value
                  });
                },
                75
              );
              megaChat.$leftPane.width(value);
              $(".fm-tree-panel", megaChat.$leftPane).width(value);
              self.onResizeDoUpdate();
            }
          });
          var lPaneResizableInit = function () {
            megaChat.$leftPane = megaChat.$leftPane || $(".conversationsApp .fm-left-panel");
            $.leftPaneResizableChat = new FMResizablePane(megaChat.$leftPane, {
              ...$.leftPaneResizable.options,
              maxWidth: 400,
              pagechange: () =>
                function () {
                  this.setWidth();
                }
            });
            $($.leftPaneResizableChat).rebind("resize.clp", () => {
              var w = megaChat.$leftPane.width();
              if (w >= $.leftPaneResizableChat.options.maxWidth) {
                $(".left-pane-drag-handle").css("cursor", "w-resize");
              } else if (w <= $.leftPaneResizableChat.options.minWidth) {
                $(".left-pane-drag-handle").css("cursor", "e-resize");
              } else {
                $(".left-pane-drag-handle").css("cursor", "we-resize");
              }
            });
          };
          if (typeof $.leftPaneResizable === "undefined") {
            mBroadcaster.once("fm:initialized", function () {
              lPaneResizableInit();
            });
          } else {
            lPaneResizableInit();
          }
          megaChat.$leftPane = megaChat.$leftPane || $(".conversationsApp .fm-left-panel");
          if (is_chatlink && !is_eplusplus) {
            megaChat.$leftPane.addClass("hidden");
          } else {
            megaChat.$leftPane.removeClass("hidden");
          }
          megaChat.rebind(megaChat.plugins.meetingsManager.EVENTS.EDIT, (ev, chatOrOccurrence) => {
            if (chatOrOccurrence instanceof ChatRoom || !chatOrOccurrence) {
              this.chatRoomRef = chatOrOccurrence;
              this.setState({
                scheduleMeetingDialog: true
              });
            } else {
              this.occurrenceRef = chatOrOccurrence;
              this.setState({
                scheduleOccurrenceDialog: true
              });
            }
          });
          megaChat.rebind(conversations_EVENTS.NAV_RENDER_VIEW, (ev, view) => {
            if (Object.values(VIEWS).includes(view)) {
              this.renderView(view);
            }
          });
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          $(document).off("keydown.megaChatTextAreaFocus");
          mBroadcaster.removeListener(this.fmConfigLeftPaneListener);
          delete this.props.megaChat.$conversationsAppInstance;
        }
        componentDidUpdate() {
          this.handleOnboardingStep();
        }
        handleOnboardingStep() {
          if (this.state.view === VIEWS.LOADING) {
            return;
          }
          megaChat.plugins.chatOnboarding.checkAndShowStep();
        }
        renderView(view) {
          this.setState(
            {
              view
            },
            () => {
              const { $chatTreePanePs, routingSection } = megaChat;
              $chatTreePanePs == null || $chatTreePanePs.reinitialise();
              if (routingSection !== "chat") {
                loadSubPage("fm/chat");
              }
              megaChat.currentlyOpenedView = view;
            }
          );
        }
        render() {
          const { CHATS, MEETINGS } = VIEWS;
          const { routingSection, chatUIFlags, currentlyOpenedChat, chats } = megaChat;
          const {
            view,
            startGroupChatDialog,
            startMeetingDialog,
            scheduleMeetingDialog,
            scheduleOccurrenceDialog,
            leftPaneWidth,
            callExpanded
          } = this.state;
          const isEmpty = chats && chats.every((c) => c.isArchived()) && routingSection === "chat" && !currentlyOpenedChat && !is_chatlink;
          const isLoading = !currentlyOpenedChat && megaChat.allChatsHadInitialLoadedHistory() === false && routingSection !== "contacts";
          const rightPane = external_React_default().createElement(
            "div",
            {
              className: `
                    fm-right-files-block
                    in-chat
                    ${is_chatlink ? "chatlink" : ""}
                `
            },
            !isLoading &&
              external_React_default().createElement(chatToaster.Z, {
                isRootToaster: true
              }),
            !isLoading &&
              routingSection === "contacts" &&
              external_React_default().createElement(contactsPanel["default"], {
                megaChat: megaChat,
                contacts: M.u,
                received: M.ipc,
                sent: M.opc
              }),
            !isLoading &&
              routingSection === "notFound" &&
              external_React_default().createElement(
                "span",
                null,
                external_React_default().createElement("center", null, "Section not found")
              ),
            !isLoading &&
              isEmpty &&
              external_React_default().createElement(conversationpanel.L2, {
                isMeeting: view === MEETINGS,
                onNewChat: () =>
                  this.setState({
                    startGroupChatDialog: true
                  }),
                onStartMeeting: () => this.startMeeting(),
                onScheduleMeeting: () =>
                  this.setState({
                    scheduleMeetingDialog: true
                  })
              }),
            !isLoading &&
              external_React_default().createElement(
                conversationpanel.GY,
                (0, esm_extends.Z)({}, this.props, {
                  className: routingSection === "chat" ? "" : "hidden",
                  routingSection: routingSection,
                  currentlyOpenedChat: currentlyOpenedChat,
                  isEmpty: isEmpty,
                  chatUIFlags: chatUIFlags,
                  onToggleExpandedFlag: () => {
                    this.setState(() => ({
                      callExpanded: call.ZP.isExpanded()
                    }));
                  },
                  onMount: () => {
                    const chatRoom = megaChat.getCurrentRoom();
                    const view = chatRoom && chatRoom.isMeeting ? MEETINGS : CHATS;
                    this.setState(
                      {
                        view
                      },
                      () => {
                        megaChat.currentlyOpenedView = view;
                      }
                    );
                  }
                })
              )
          );
          return external_React_default().createElement(
            "div",
            {
              key: "conversationsApp",
              className: "conversationsApp"
            },
            startGroupChatDialog &&
              external_React_default().createElement(StartGroupChatWizard, {
                name: "start-group-chat",
                flowType: 1,
                onClose: () =>
                  this.setState({
                    startGroupChatDialog: false
                  }),
                onConfirmClicked: () =>
                  this.setState({
                    startGroupChatDialog: false
                  })
              }),
            startMeetingDialog &&
              external_React_default().createElement(Start, {
                onStart: (topic, audio, video) => {
                  megaChat.createAndStartMeeting(topic, audio, video);
                  this.setState({
                    startMeetingDialog: false
                  });
                },
                onClose: () =>
                  this.setState({
                    startMeetingDialog: false
                  })
              }),
            scheduleMeetingDialog &&
              external_React_default().createElement(Schedule, {
                chatRoom: this.chatRoomRef,
                callExpanded: callExpanded,
                onClose: () => {
                  this.setState(
                    {
                      scheduleMeetingDialog: false
                    },
                    () => {
                      this.chatRoomRef = null;
                    }
                  );
                }
              }),
            scheduleOccurrenceDialog &&
              external_React_default().createElement(Edit, {
                chatRoom: this.occurrenceRef.scheduledMeeting.chatRoom,
                scheduledMeeting: this.occurrenceRef.scheduledMeeting,
                occurrenceId: this.occurrenceRef.uid,
                callExpanded: callExpanded,
                onClose: () => {
                  this.setState(
                    {
                      scheduleOccurrenceDialog: false
                    },
                    () => {
                      this.occurrenceRef = null;
                    }
                  );
                }
              }),
            external_React_default().createElement(LeftPanel, {
              view: view,
              views: VIEWS,
              routingSection: routingSection,
              conversations: chats,
              leftPaneWidth: leftPaneWidth,
              renderView: (view) => this.renderView(view),
              startMeeting: () => this.startMeeting(),
              scheduleMeeting: () =>
                this.setState({
                  scheduleMeetingDialog: true
                }),
              createGroupChat: () =>
                this.setState({
                  startGroupChatDialog: true
                })
            }),
            rightPane
          );
        }
      }
      if (false) {
      }
      const conversations = {
        ConversationsApp: ConversationsApp
      };

      /***/
    },

    /***/ 722: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, {
        bl: () => API,
        wS: () => LABELS,
        ZP: () => GifPanel
      });

      // EXTERNAL MODULE: external "React"
      var external_React_ = __webpack_require__(363);
      var external_React_default = __webpack_require__.n(external_React_);
      // EXTERNAL MODULE: ./js/chat/mixins.js
      var mixins = __webpack_require__(503);
      // EXTERNAL MODULE: ./js/ui/perfectScrollbar.jsx
      var perfectScrollbar = __webpack_require__(285); // CONCATENATED MODULE: ./js/chat/ui/gifPanel/searchField.jsx
      var _class;

      class SearchField extends mixins.wl {
        render() {
          const { value, searching, onChange, onReset, onBack } = this.props;
          return external_React_default().createElement(
            "div",
            {
              className: "gif-panel-search"
            },
            external_React_default().createElement(
              "div",
              {
                className: "gif-search-field"
              },
              searching
                ? external_React_default().createElement("i", {
                    className: "sprite-fm-mono icon-left",
                    onClick: onBack
                  })
                : external_React_default().createElement("i", {
                    className: "sprite-fm-mono icon-preview-reveal"
                  }),
              external_React_default().createElement("input", {
                ref: SearchField.inputRef,
                type: "text",
                placeholder: LABELS.SEARCH,
                autoFocus: true,
                value: value,
                onChange: onChange
              }),
              searching &&
                external_React_default().createElement("i", {
                  className: "sprite-fm-mono icon-close-component",
                  onClick: onReset
                })
            ),
            external_React_default().createElement(
              "div",
              {
                className: "giphy-logo"
              },
              external_React_default().createElement("img", {
                src: staticpath + "images/mega/giphy.gif",
                alt: "PWRD BY GIPHY"
              })
            )
          );
        }
      }
      _class = SearchField;
      SearchField.inputRef = external_React_default().createRef();
      SearchField.focus = () => _class.inputRef && _class.inputRef.current && _class.inputRef.current.focus();
      SearchField.hasValue = () => _class.inputRef && _class.inputRef.current && !!_class.inputRef.current.value.length; // CONCATENATED MODULE: ./js/chat/ui/gifPanel/result.jsx
      class Result extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.resultRef = external_React_default().createRef();
        }
        componentDidMount() {
          var _this$props$onMount, _this$props;
          super.componentDidMount();
          (_this$props$onMount = (_this$props = this.props).onMount) == null ||
            _this$props$onMount.call(_this$props, this.resultRef.current);
        }
        componentWillUnmount() {
          var _this$props$onUnmount, _this$props2;
          super.componentWillUnmount();
          (_this$props$onUnmount = (_this$props2 = this.props).onUnmount) == null ||
            _this$props$onUnmount.call(_this$props2, this.resultRef.current, "unobserve");
        }
        render() {
          const { image, title, onClick } = this.props;
          return external_React_default().createElement(
            "div",
            {
              className: `
                    ${NODE_CONTAINER_CLASS}
                    ${onClick ? "clickable" : ""}
                `,
              style: {
                height: parseInt(image.height)
              }
            },
            external_React_default().createElement(
              "div",
              {
                ref: this.resultRef,
                className: NODE_CLASS,
                style: {
                  backgroundImage: HAS_INTERSECTION_OBSERVER ? "" : `url(${image.url})`
                },
                "data-url": image.url,
                onClick: onClick
              },
              external_React_default().createElement("span", null, title)
            )
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/gifPanel/resultContainer.jsx
      const HAS_INTERSECTION_OBSERVER = typeof IntersectionObserver !== "undefined";
      const NODE_CONTAINER_CLASS = "node-container";
      const NODE_CLASS = "node";
      const RESULT_CONTAINER_CLASS = "gif-panel-results";
      const RESULTS_END_CLASS = "results-end";
      const Nil = ({ children }) =>
        external_React_default().createElement(
          "div",
          {
            className: "no-results-container"
          },
          external_React_default().createElement(
            "div",
            {
              className: "no-results-content"
            },
            external_React_default().createElement("i", {
              className: "huge-icon sad-smile"
            }),
            external_React_default().createElement("span", null, children)
          )
        );
      class ResultContainer extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.intersectionObserver = null;
          this.initializeIntersectionObserver = () => {
            if (HAS_INTERSECTION_OBSERVER) {
              this.intersectionObserver = new IntersectionObserver((entries) => {
                for (let i = 0; i < entries.length; i++) {
                  var _target$classList, _target$classList2;
                  const entry = entries[i];
                  const target = entry.target;
                  if ((_target$classList = target.classList) != null && _target$classList.contains(NODE_CLASS)) {
                    target.style.backgroundImage = entry.isIntersecting ? `url(${target.dataset.url})` : null;
                  }
                  if (
                    entry.isIntersecting &&
                    (_target$classList2 = target.classList) != null &&
                    _target$classList2.contains(RESULTS_END_CLASS)
                  ) {
                    this.props.onPaginate();
                  }
                }
              });
            }
          };
          this.toggleIntersectionObserver = (node, action = "observe") => {
            if (node && this.intersectionObserver) {
              this.intersectionObserver[action](node);
            }
          };
        }
        componentDidMount() {
          super.componentDidMount();
          this.initializeIntersectionObserver();
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            this.intersectionObserver = null;
          }
        }
        componentWillReceiveProps(nextProps) {
          super.componentWillReceiveProps(nextProps);
          if (nextProps !== this.props) {
            this.safeForceUpdate();
          }
        }
        render() {
          const { loading, results, bottom, unavailable, onClick } = this.props;
          if (unavailable) {
            return external_React_default().createElement(Nil, null, LABELS.NOT_AVAILABLE);
          }
          if (loading && results.length < 1) {
            return external_React_default().createElement(
              "div",
              {
                className: RESULT_CONTAINER_CLASS
              },
              Array.from(
                {
                  length: API.LIMIT
                },
                (element, index) =>
                  external_React_default().createElement(
                    "div",
                    {
                      key: index,
                      className: NODE_CONTAINER_CLASS
                    },
                    external_React_default().createElement("div", {
                      className: NODE_CLASS,
                      style: {
                        height: Math.floor(Math.random() * 150) + 100
                      }
                    })
                  )
              )
            );
          }
          if (!loading && results.length < 1) {
            return external_React_default().createElement(Nil, null, LABELS.NO_RESULTS);
          }
          if (results.length) {
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              external_React_default().createElement(
                "div",
                {
                  className: RESULT_CONTAINER_CLASS
                },
                results.map(({ slug, images: { fixed_width_downsampled }, title }, index) => {
                  return external_React_default().createElement(Result, {
                    key: `${slug}--${index}`,
                    image: fixed_width_downsampled,
                    title: title,
                    onClick: () => onClick(results[index]),
                    onMount: this.toggleIntersectionObserver,
                    onUnmount: this.toggleIntersectionObserver
                  });
                })
              ),
              external_React_default().createElement(
                "div",
                {
                  className: RESULTS_END_CLASS,
                  ref: (node) => this.toggleIntersectionObserver(node),
                  style: {
                    visibility: bottom ? "visible" : "hidden"
                  }
                },
                external_React_default().createElement("img", {
                  className: "emoji",
                  alt: "\\ud83d\\ude10",
                  src: `${staticpath}/images/mega/twemojis/2_v2/72x72/1f610.png`
                }),
                external_React_default().createElement("strong", null, LABELS.END_OF_RESULTS)
              )
            );
          }
          return null;
        }
      } // CONCATENATED MODULE: ./js/chat/ui/gifPanel/gifPanel.jsx
      const GIF_PANEL_CLASS = "gif-panel-wrapper";
      const MAX_HEIGHT = 550;
      const API = {
        HOSTNAME: "https://giphy.mega.nz/",
        ENDPOINT: "v1/gifs",
        SCHEME: "giphy://",
        convert: (path) => {
          if (path && typeof path === "string") {
            const FORMAT = [API.SCHEME, API.HOSTNAME];
            if (path.indexOf(API.SCHEME) === 0 || path.indexOf(API.HOSTNAME) === 0) {
              return String.prototype.replace.apply(path, path.indexOf(API.SCHEME) === 0 ? FORMAT : FORMAT.reverse());
            }
          }
        },
        LIMIT: 50,
        OFFSET: 50
      };
      const LABELS = {
        SEARCH: l[24025],
        END_OF_RESULTS: l[24156],
        NO_RESULTS: l[24050],
        NOT_AVAILABLE: l[24512]
      };
      class GifPanel extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.pathRef = "";
          this.controllerRef = null;
          this.fetchRef = null;
          this.delayProcID = null;
          this.defaultState = {
            value: "",
            searching: false,
            results: [],
            loading: true,
            offset: 0,
            bottom: false,
            unavailable: false
          };
          this.state = {
            ...this.defaultState
          };
          this.getContainerHeight = () => (window.innerHeight * 0.6 > MAX_HEIGHT ? MAX_HEIGHT : window.innerHeight * 0.6);
          this.getFormattedPath = (path) => {
            const PATH = path + (path.indexOf("?") === -1 ? "?" : "&");
            const LIMIT = `limit=${API.LIMIT}`;
            return `${API.HOSTNAME + API.ENDPOINT}/${PATH + LIMIT}`;
          };
          this.clickedOutsideComponent = (ev) => {
            const $target = ev && $(ev.target);
            return (
              $target.parents(`.${GIF_PANEL_CLASS}`).length === 0 &&
              [".small-icon.tiny-reset", ".small-icon.gif"].every((outsideElement) => !$target.is(outsideElement))
            );
          };
          this.bindEvents = () => {
            $(document)
              .rebind("mousedown.gifPanel", (ev) => {
                if (this.clickedOutsideComponent(ev)) {
                  this.props.onToggle();
                }
              })
              .rebind("keydown.gifPanel", ({ keyCode }) => {
                if (keyCode && keyCode === 27) {
                  return SearchField.hasValue() ? this.doReset() : this.props.onToggle();
                }
              });
          };
          this.unbindEvents = () => {
            if (this.delayProcID) {
              delay.cancel(this.delayProcID);
            }
            $(document).unbind(".gifPanel");
          };
          this.doFetch = (path) => {
            this.setState(
              {
                loading: true,
                unavailable: false
              },
              () => {
                this.pathRef = path;
                this.controllerRef = typeof AbortController === "function" && new AbortController();
                this.fetchRef = fetch(this.getFormattedPath(path), {
                  signal: this.controllerRef.signal
                })
                  .then((response) => response.json())
                  .then(({ data }) => {
                    this.fetchRef = this.pathRef = null;
                    if (this.isMounted()) {
                      if (data && data.length) {
                        return this.setState((state) => ({
                          results: [...state.results, ...data],
                          loading: false
                        }));
                      }
                      return this.setState(
                        {
                          bottom: true,
                          loading: false
                        },
                        () => this.resultContainerRef && this.resultContainerRef.reinitialise()
                      );
                    }
                  })
                  .catch((ex) => {
                    return ex.name === "AbortError"
                      ? null
                      : this.setState({
                          unavailable: true
                        });
                  });
              }
            );
          };
          this.doPaginate = () => {
            const { value, loading, searching } = this.state;
            if (!loading) {
              this.setState(
                (state) => ({
                  offset: state.offset + API.OFFSET
                }),
                () => {
                  this.doFetch(
                    searching ? `search?q=${escape(value)}&offset=${this.state.offset}` : `trending?offset=${this.state.offset}`
                  );
                }
              );
            }
          };
          this.doReset = () => {
            this.setState(
              {
                ...this.defaultState
              },
              () => {
                this.doFetch("trending");
                onIdle(() => SearchField.focus());
                this.resultContainerRef.scrollToY(0);
              }
            );
          };
          this.handleChange = (ev) => {
            const { value } = ev.target;
            const searching = value.length >= 2;
            if (value.length === 0) {
              return this.doReset();
            }
            if (this.fetchRef !== null && this.pathRef === "trending" && this.controllerRef) {
              this.controllerRef.abort();
              this.fetchRef = this.pathRef = null;
            }
            this.setState(
              (state) => ({
                ...this.defaultState,
                value,
                searching,
                results: searching ? [] : state.results
              }),
              () => {
                this.resultContainerRef.scrollToY(0);
                this.delayProcID = searching ? delay("gif-search", () => this.doFetch(`search?q=${escape(value)}`), 1600) : null;
              }
            );
          };
          this.handleBack = () => this.doReset();
          this.doSend = (result) => {
            const { mp4, webp, mp4_size, webp_size, width, height } = result.images.fixed_height;
            const message =
              Message.MANAGEMENT_MESSAGE_TYPES.MANAGEMENT +
              Message.MANAGEMENT_MESSAGE_TYPES.CONTAINS_META +
              Message.MESSAGE_META_TYPE.GIPHY +
              JSON.stringify({
                textMessage: result.title,
                src: API.convert(mp4),
                src_webp: API.convert(webp),
                s: mp4_size,
                s_webp: webp_size,
                w: width,
                h: height
              });
            this.props.chatRoom.sendMessage(message);
            this.props.onToggle();
          };
        }
        componentDidMount() {
          super.componentDidMount();
          if (this.state.results && this.state.results.length === 0) {
            this.doFetch("trending");
          }
          this.bindEvents();
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          this.unbindEvents();
        }
        render() {
          const { value, searching, results, loading, bottom, unavailable } = this.state;
          return external_React_default().createElement(
            "div",
            {
              className: "gif-panel-wrapper"
            },
            external_React_default().createElement(
              "div",
              {
                className: "gif-panel",
                style: {
                  height: this.getContainerHeight()
                }
              },
              external_React_default().createElement(
                "div",
                {
                  className: "gif-panel-header"
                },
                external_React_default().createElement(SearchField, {
                  value: value,
                  searching: searching,
                  onChange: this.handleChange,
                  onReset: this.doReset,
                  onBack: this.handleBack
                })
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "gif-panel-content"
                },
                external_React_default().createElement(
                  perfectScrollbar.F,
                  {
                    ref: (container) => {
                      this.resultContainerRef = container;
                    },
                    options: {
                      suppressScrollX: true
                    }
                  },
                  external_React_default().createElement(ResultContainer, {
                    results: results,
                    loading: loading,
                    bottom: bottom,
                    unavailable: unavailable,
                    onPaginate: this.doPaginate,
                    onClick: this.doSend
                  })
                )
              )
            )
          );
        }
      }

      /***/
    },

    /***/ 192: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, {
        Z: () => HistoryPanel
      });

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js
      var applyDecoratedDescriptor = __webpack_require__(229);
      // EXTERNAL MODULE: external "React"
      var external_React_ = __webpack_require__(363);
      var external_React_default = __webpack_require__.n(external_React_);
      // EXTERNAL MODULE: ./js/chat/mixins.js
      var mixins = __webpack_require__(503);
      // EXTERNAL MODULE: ./js/ui/utils.jsx
      var utils = __webpack_require__(79); // CONCATENATED MODULE: ./js/chat/ui/messages/alterParticipants.jsx
      var React = __webpack_require__(363);
      var ContactsUI = __webpack_require__(13);
      var ConversationMessageMixin = __webpack_require__(416).y;

      class AltPartsConvMessage extends ConversationMessageMixin {
        haveMoreContactListeners() {
          if (!this.props.message || !this.props.message.meta) {
            return false;
          }
          const { included, excluded } = this.props.message.meta;
          return array.unique([...(included || []), ...(excluded || [])]);
        }
        render() {
          var self = this;
          var message = this.props.message;
          var contact = self.getContact();
          var timestampInt = self.getTimestamp();
          var timestamp = self.getTimestampAsString();
          var datetime = React.createElement(
            "div",
            {
              className: "message date-time simpletip",
              "data-simpletip": time2date(timestampInt, 17)
            },
            timestamp
          );
          var displayName;
          if (contact) {
            displayName = M.getNameByHandle(contact.u);
          } else {
            displayName = contact;
          }
          var messages = [];
          message.meta.included.forEach(function (h) {
            var otherContact = M.u[h]
              ? M.u[h]
              : {
                  u: h,
                  h: h,
                  c: 0
                };
            var avatar = React.createElement(ContactsUI.Avatar, {
              contact: otherContact,
              chatRoom: self.props.chatRoom,
              className: "message avatar-wrapper small-rounded-avatar"
            });
            var otherDisplayName = M.getNameByHandle(otherContact.u);
            const isSelfJoin = h === contact.u;
            let text = isSelfJoin ? l[23756] : l[8907];
            if (self.props.chatRoom.isMeeting) {
              text = isSelfJoin ? l.meeting_mgmt_user_joined : l.meeting_mgmt_user_added;
            }
            text = text.replace("%1", megaChat.html(otherDisplayName));
            if (!isSelfJoin) {
              text = text.replace("%2", `<strong>${megaChat.html(displayName)}</strong>`);
            }
            messages.push(
              React.createElement(
                "div",
                {
                  className: "message body",
                  "data-id": "id" + message.messageId,
                  key: message.messageId + "_" + h
                },
                avatar,
                React.createElement(
                  "div",
                  {
                    className: "message content-area small-info-txt selectable-txt"
                  },
                  React.createElement(ContactsUI.ContactButton, {
                    className: "message",
                    contact: otherContact,
                    chatRoom: self.props.chatRoom,
                    label: React.createElement(utils.dy, null, otherDisplayName)
                  }),
                  datetime,
                  React.createElement(
                    "div",
                    {
                      className: "message text-block"
                    },
                    React.createElement(utils.Cw, null, text)
                  )
                )
              )
            );
          });
          message.meta.excluded.forEach(function (h) {
            var otherContact = M.u[h]
              ? M.u[h]
              : {
                  u: h,
                  h: h,
                  c: 0
                };
            var avatar = React.createElement(ContactsUI.Avatar, {
              contact: otherContact,
              chatRoom: self.props.chatRoom,
              className: "message avatar-wrapper small-rounded-avatar"
            });
            var otherDisplayName = M.getNameByHandle(otherContact.u);
            var text;
            if (otherContact.u === contact.u) {
              text = self.props.chatRoom.isMeeting ? l.meeting_mgmt_left : l[8908];
            } else {
              text = (self.props.chatRoom.isMeeting ? l.meeting_mgmt_kicked : l[8906]).replace(
                "%s",
                `<strong>${megaChat.html(displayName)}</strong>`
              );
            }
            messages.push(
              React.createElement(
                "div",
                {
                  className: "message body",
                  "data-id": "id" + message.messageId,
                  key: message.messageId + "_" + h
                },
                avatar,
                React.createElement(
                  "div",
                  {
                    className: "message content-area small-info-txt selectable-txt"
                  },
                  React.createElement(ContactsUI.ContactButton, {
                    className: "message",
                    chatRoom: self.props.chatRoom,
                    contact: otherContact,
                    label: React.createElement(utils.dy, null, otherDisplayName)
                  }),
                  datetime,
                  React.createElement(
                    "div",
                    {
                      className: "message text-block"
                    },
                    React.createElement(utils.Cw, null, text)
                  )
                )
              )
            );
          });
          return React.createElement("div", null, messages);
        }
      } // CONCATENATED MODULE: ./js/chat/ui/messages/truncated.jsx

      var truncated_React = __webpack_require__(363);
      var truncated_ContactsUI = __webpack_require__(13);
      var truncated_ConversationMessageMixin = __webpack_require__(416).y;

      class TruncatedMessage extends truncated_ConversationMessageMixin {
        render() {
          var self = this;
          var cssClasses = "message body";
          var message = this.props.message;
          var chatRoom = this.props.message.chatRoom;
          var contact = self.getContact();
          var timestampInt = self.getTimestamp();
          var timestamp = self.getTimestampAsString();
          var datetime = truncated_React.createElement(
            "div",
            {
              className: "message date-time simpletip",
              "data-simpletip": time2date(timestampInt, 17)
            },
            timestamp
          );
          var displayName;
          if (contact) {
            displayName = M.getNameByHandle(contact.u);
          } else {
            displayName = contact;
          }
          var avatar = null;
          if (this.props.grouped) {
            cssClasses += " grouped";
          } else {
            avatar = truncated_React.createElement(truncated_ContactsUI.Avatar, {
              contact: contact,
              className: "message avatar-wrapper small-rounded-avatar",
              chatRoom: chatRoom
            });
            datetime = truncated_React.createElement(
              "div",
              {
                className: "message date-time simpletip",
                "data-simpletip": time2date(timestampInt, 17)
              },
              timestamp
            );
          }
          return truncated_React.createElement(
            "div",
            {
              className: cssClasses,
              "data-id": "id" + message.messageId,
              key: message.messageId
            },
            avatar,
            truncated_React.createElement(
              "div",
              {
                className: "message content-area small-info-txt selectable-txt"
              },
              truncated_React.createElement(truncated_ContactsUI.ContactButton, {
                contact: contact,
                className: "message",
                label: truncated_React.createElement(utils.dy, null, displayName),
                chatRoom: chatRoom
              }),
              datetime,
              truncated_React.createElement(
                "div",
                {
                  className: "message text-block"
                },
                l[8905]
              )
            )
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/messages/privilegeChange.jsx

      var privilegeChange_React = __webpack_require__(363);
      var privilegeChange_ContactsUI = __webpack_require__(13);
      var privilegeChange_ConversationMessageMixin = __webpack_require__(416).y;

      class PrivilegeChange extends privilegeChange_ConversationMessageMixin {
        haveMoreContactListeners() {
          if (!this.props.message.meta || !this.props.message.meta.targetUserId) {
            return false;
          }
          var uid = this.props.message.meta.targetUserId;
          if (uid && M.u[uid]) {
            return uid;
          }
          return false;
        }
        render() {
          var self = this;
          var message = this.props.message;
          var chatRoom = this.props.message.chatRoom;
          var contact = self.getContact();
          var timestampInt = self.getTimestamp();
          var timestamp = self.getTimestampAsString();
          var datetime = privilegeChange_React.createElement(
            "div",
            {
              className: "message date-time simpletip",
              "data-simpletip": time2date(timestampInt, 17)
            },
            timestamp
          );
          var displayName;
          if (contact) {
            displayName = M.getNameByHandle(contact.u);
          } else {
            displayName = contact;
          }
          var messages = [];
          var otherContact = M.u[message.meta.targetUserId]
            ? M.u[message.meta.targetUserId]
            : {
                u: message.meta.targetUserId,
                h: message.meta.targetUserId,
                c: 0
              };
          var avatar = privilegeChange_React.createElement(privilegeChange_ContactsUI.Avatar, {
            contact: otherContact,
            className: "message avatar-wrapper small-rounded-avatar",
            chatRoom: chatRoom
          });
          var otherDisplayName = M.getNameByHandle(otherContact.u);
          var newPrivilegeText = "";
          if (message.meta.privilege === 3) {
            newPrivilegeText = l.priv_change_to_op;
          } else if (message.meta.privilege === 2) {
            newPrivilegeText = l.priv_change_to_std;
          } else if (message.meta.privilege === 0) {
            newPrivilegeText = l.priv_change_to_ro;
          }
          const text = newPrivilegeText
            .replace("[S]", "<strong>")
            .replace("[/S]", "</strong>")
            .replace("%s", `<strong>${megaChat.html(displayName)}</strong>`);
          messages.push(
            privilegeChange_React.createElement(
              "div",
              {
                className: "message body",
                "data-id": "id" + message.messageId,
                key: message.messageId
              },
              avatar,
              privilegeChange_React.createElement(
                "div",
                {
                  className: "message content-area small-info-txt selectable-txt"
                },
                privilegeChange_React.createElement(privilegeChange_ContactsUI.ContactButton, {
                  className: "message",
                  chatRoom: self.props.chatRoom,
                  contact: otherContact,
                  label: privilegeChange_React.createElement(utils.dy, null, otherDisplayName)
                }),
                datetime,
                privilegeChange_React.createElement(
                  "div",
                  {
                    className: "message text-block"
                  },
                  privilegeChange_React.createElement(utils.Cw, null, text)
                )
              )
            )
          );
          return privilegeChange_React.createElement("div", null, messages);
        }
      } // CONCATENATED MODULE: ./js/chat/ui/messages/topicChange.jsx

      var topicChange_React = __webpack_require__(363);
      var topicChange_ContactsUI = __webpack_require__(13);
      var topicChange_ConversationMessageMixin = __webpack_require__(416).y;

      class TopicChange extends topicChange_ConversationMessageMixin {
        render() {
          var self = this;
          var message = this.props.message;
          var megaChat = this.props.message.chatRoom.megaChat;
          var chatRoom = this.props.message.chatRoom;
          if (message.meta.isScheduled) {
            return null;
          }
          var contact = self.getContact();
          var timestampInt = self.getTimestamp();
          var timestamp = self.getTimestampAsString();
          var datetime = topicChange_React.createElement(
            "div",
            {
              className: "message date-time simpletip",
              "data-simpletip": time2date(timestampInt, 17)
            },
            timestamp
          );
          var displayName;
          if (contact) {
            displayName = M.getNameByHandle(contact.u);
          } else {
            displayName = contact;
          }
          var messages = [];
          var avatar = topicChange_React.createElement(topicChange_ContactsUI.Avatar, {
            contact: contact,
            chatRoom: chatRoom,
            className: "message avatar-wrapper small-rounded-avatar"
          });
          const topic = megaChat.html(message.meta.topic);
          const oldTopic = megaChat.html(message.meta.oldTopic) || "";
          messages.push(
            topicChange_React.createElement(
              "div",
              {
                className: "message body",
                "data-id": "id" + message.messageId,
                key: message.messageId
              },
              avatar,
              topicChange_React.createElement(
                "div",
                {
                  className: "message content-area small-info-txt selectable-txt"
                },
                topicChange_React.createElement(topicChange_ContactsUI.ContactButton, {
                  className: "message",
                  chatRoom: chatRoom,
                  contact: contact,
                  label: topicChange_React.createElement(utils.dy, null, displayName)
                }),
                datetime,
                topicChange_React.createElement(
                  "div",
                  {
                    className: "message text-block"
                  },
                  topicChange_React.createElement(
                    utils.Cw,
                    null,
                    (chatRoom.scheduledMeeting ? l.schedule_mgmt_title.replace("%1", `<strong>${oldTopic}</strong>`) : l[9081]).replace(
                      "%s",
                      `<strong>${topic}</strong>`
                    )
                  )
                )
              )
            )
          );
          return topicChange_React.createElement("div", null, messages);
        }
      } // CONCATENATED MODULE: ./js/chat/ui/messages/closeOpenMode.jsx

      var closeOpenMode_React = __webpack_require__(363);
      var closeOpenMode_ContactsUI = __webpack_require__(13);
      var closeOpenMode_ConversationMessageMixin = __webpack_require__(416).y;

      class CloseOpenModeMessage extends closeOpenMode_ConversationMessageMixin {
        render() {
          var self = this;
          var cssClasses = "message body";
          var message = this.props.message;
          var contact = self.getContact();
          var timestampInt = self.getTimestamp();
          var timestamp = self.getTimestampAsString();
          var datetime = closeOpenMode_React.createElement(
            "div",
            {
              className: "message date-time",
              title: time2date(timestampInt)
            },
            timestamp
          );
          var displayName;
          if (contact) {
            displayName = M.getNameByHandle(contact.u);
          } else {
            displayName = contact;
          }
          var avatar = null;
          if (this.props.grouped) {
            cssClasses += " grouped";
          } else {
            avatar = closeOpenMode_React.createElement(closeOpenMode_ContactsUI.Avatar, {
              contact: contact,
              className: "message  avatar-wrapper small-rounded-avatar",
              chatRoom: this.props.chatRoom
            });
            datetime = closeOpenMode_React.createElement(
              "div",
              {
                className: "message date-time",
                title: time2date(timestampInt)
              },
              timestamp
            );
          }
          return closeOpenMode_React.createElement(
            "div",
            {
              className: cssClasses,
              "data-id": "id" + message.messageId,
              key: message.messageId
            },
            avatar,
            closeOpenMode_React.createElement(
              "div",
              {
                className: "message content-area small-info-txt selectable-txt"
              },
              closeOpenMode_React.createElement(
                "div",
                {
                  className: "message user-card-name"
                },
                closeOpenMode_React.createElement(utils.dy, null, displayName)
              ),
              datetime,
              closeOpenMode_React.createElement(
                "div",
                {
                  className: "message text-block"
                },
                l[20569]
              )
            )
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/messages/chatHandle.jsx

      var chatHandle_React = __webpack_require__(363);
      var chatHandle_ContactsUI = __webpack_require__(13);
      var chatHandle_ConversationMessageMixin = __webpack_require__(416).y;

      class ChatHandleMessage extends chatHandle_ConversationMessageMixin {
        render() {
          var self = this;
          var cssClasses = "message body";
          var message = this.props.message;
          var contact = self.getContact();
          var timestampInt = self.getTimestamp();
          var timestamp = self.getTimestampAsString();
          var datetime = chatHandle_React.createElement(
            "div",
            {
              className: "message date-time",
              title: time2date(timestampInt)
            },
            timestamp
          );
          var displayName;
          if (contact) {
            displayName = M.getNameByHandle(contact.u);
          } else {
            displayName = contact;
          }
          var avatar = null;
          if (this.props.grouped) {
            cssClasses += " grouped";
          } else {
            avatar = chatHandle_React.createElement(chatHandle_ContactsUI.Avatar, {
              contact: contact,
              className: "message  avatar-wrapper small-rounded-avatar",
              chatRoom: this.props.chatRoom
            });
            datetime = chatHandle_React.createElement(
              "div",
              {
                className: "message date-time",
                title: time2date(timestampInt)
              },
              timestamp
            );
          }
          return chatHandle_React.createElement(
            "div",
            {
              className: cssClasses,
              "data-id": "id" + message.messageId,
              key: message.messageId
            },
            avatar,
            chatHandle_React.createElement(
              "div",
              {
                className: "message content-area small-info-txt selectable-txt"
              },
              chatHandle_React.createElement(
                "div",
                {
                  className: "message user-card-name"
                },
                chatHandle_React.createElement(utils.dy, null, displayName)
              ),
              datetime,
              chatHandle_React.createElement(
                "div",
                {
                  className: "message text-block"
                },
                message.meta.handleUpdate === 1 ? l[20570] : l[20571]
              )
            )
          );
        }
      }

      // EXTERNAL MODULE: ./js/chat/ui/messages/generic.jsx + 14 modules
      var generic = __webpack_require__(931);
      // EXTERNAL MODULE: ./js/ui/perfectScrollbar.jsx
      var perfectScrollbar = __webpack_require__(285);
      // EXTERNAL MODULE: ./js/chat/ui/messages/mixin.jsx
      var mixin = __webpack_require__(416);
      // EXTERNAL MODULE: ./js/chat/ui/contacts.jsx
      var contacts = __webpack_require__(13); // CONCATENATED MODULE: ./js/chat/ui/messages/retentionChange.jsx
      class RetentionChange extends mixin.y {
        render() {
          const { message } = this.props;
          const contact = this.getContact();
          return external_React_default().createElement(
            "div",
            {
              className: "message body",
              "data-id": "id" + message.messageId,
              key: message.messageId
            },
            external_React_default().createElement(contacts.Avatar, {
              contact: contact,
              className: "message avatar-wrapper small-rounded-avatar"
            }),
            external_React_default().createElement(
              "div",
              {
                className: "message content-area small-info-txt selectable-txt"
              },
              external_React_default().createElement(contacts.ContactButton, {
                contact: contact,
                className: "message",
                label: external_React_default().createElement(utils.dy, null, M.getNameByHandle(contact.u))
              }),
              external_React_default().createElement(
                "div",
                {
                  className: "message date-time simpletip",
                  "data-simpletip": time2date(this.getTimestamp(), 17)
                },
                this.getTimestampAsString()
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "message text-block"
                },
                message.getMessageRetentionSummary()
              )
            )
          );
        }
      }
      // EXTERNAL MODULE: ./js/chat/ui/meetings/call.jsx + 23 modules
      var call = __webpack_require__(689);
      // EXTERNAL MODULE: ./js/chat/ui/messages/scheduleMetaChange.jsx
      var scheduleMetaChange = __webpack_require__(97); // CONCATENATED MODULE: ./js/chat/ui/historyPanel.jsx
      var _dec, _class;

      let HistoryPanel =
        ((_dec = (0, mixins.M9)(450, true)),
        ((_class = class HistoryPanel extends mixins.wl {
          constructor(props) {
            super(props);
            this.$container = null;
            this.$messages = null;
            this.state = {
              editing: false,
              toast: false,
              pusherHeight: 0
            };
            this.onKeyboardScroll = ({ keyCode }) => {
              const scrollbar = this.messagesListScrollable;
              const domNode = scrollbar == null ? void 0 : scrollbar.domNode;
              if (domNode && this.isComponentEventuallyVisible() && !this.state.attachCloudDialog) {
                const scrollPositionY = scrollbar.getScrollPositionY();
                const offset = parseInt(domNode.style.height);
                const PAGE = {
                  UP: 33,
                  DOWN: 34
                };
                switch (keyCode) {
                  case PAGE.UP:
                    scrollbar.scrollToY(scrollPositionY - offset, true);
                    this.onMessagesScrollUserScroll(scrollbar, 100);
                    break;
                  case PAGE.DOWN:
                    if (!scrollbar.isAtBottom()) {
                      scrollbar.scrollToY(scrollPositionY + offset, true);
                    }
                    break;
                }
              }
            };
            this.onMessagesScrollUserScroll = (ps, offset = 5) => {
              const { chatRoom } = this.props;
              const { messagesBuff } = chatRoom;
              const scrollPositionY = ps.getScrollPositionY();
              if (messagesBuff.messages.length === 0) {
                chatRoom.scrolledToBottom = true;
                return;
              }
              if (ps.isCloseToBottom(30) === true) {
                if (!chatRoom.scrolledToBottom) {
                  messagesBuff.detachMessages();
                }
                chatRoom.scrolledToBottom = true;
              } else {
                chatRoom.scrolledToBottom = false;
              }
              if (
                !this.scrollPullHistoryRetrieval &&
                !messagesBuff.isRetrievingHistory &&
                (ps.isAtTop() || (scrollPositionY < offset && ps.getScrollHeight() > 500)) &&
                messagesBuff.haveMoreHistory()
              ) {
                ps.disable();
                this.scrollPullHistoryRetrieval = true;
                this.lastScrollPosition = scrollPositionY;
                let msgAppended = 0;
                const scrYOffset = ps.getScrollHeight();
                chatRoom.one("onMessagesBuffAppend.pull", () => {
                  msgAppended++;
                });
                chatRoom.off("onHistoryDecrypted.pull");
                chatRoom.one("onHistoryDecrypted.pull", () => {
                  chatRoom.off("onMessagesBuffAppend.pull");
                  if (msgAppended > 0) {
                    this._reposOnUpdate = scrYOffset;
                  }
                  this.scrollPullHistoryRetrieval = -1;
                });
                messagesBuff.retrieveChatHistory();
              }
              if (this.lastScrollPosition !== scrollPositionY) {
                this.lastScrollPosition = scrollPositionY;
              }
              delay("chat-toast", this.initToast, 200);
            };
            this.initToast = () => {
              var _this$messagesListScr;
              const { chatRoom } = this.props;
              return (
                this.isMounted() &&
                this.setState(
                  {
                    toast:
                      !chatRoom.scrolledToBottom &&
                      !(
                        (_this$messagesListScr = this.messagesListScrollable) != null &&
                        _this$messagesListScr.isCloseToBottom != null &&
                        _this$messagesListScr.isCloseToBottom(30)
                      )
                  },
                  () => (this.state.toast ? null : chatRoom.trigger("onChatIsFocused"))
                )
              );
            };
            this.renderToast = () => {
              const { chatRoom } = this.props;
              const unreadCount = chatRoom.messagesBuff.getUnreadCount();
              return external_React_default().createElement(
                "div",
                {
                  className: `
                    theme-dark-forced
                    messages-toast
                    ${this.state.toast ? "active" : ""}
                `,
                  onClick: () => {
                    this.setState(
                      {
                        toast: false
                      },
                      () => {
                        this.messagesListScrollable.scrollToBottom();
                        chatRoom.scrolledToBottom = true;
                      }
                    );
                  }
                },
                external_React_default().createElement("i", {
                  className: "sprite-fm-mono icon-down"
                }),
                unreadCount > 0 && external_React_default().createElement("span", null, unreadCount > 9 ? "9+" : unreadCount)
              );
            };
            this.handleWindowResize = this._handleWindowResize.bind(this);
          }
          customIsEventuallyVisible() {
            return this.props.chatRoom.isCurrentlyActive;
          }
          componentWillMount() {
            var self = this;
            var chatRoom = self.props.chatRoom;
            chatRoom.rebind("onHistoryDecrypted.cp", function () {
              self.eventuallyUpdate();
            });
            this._messagesBuffChangeHandler = chatRoom.messagesBuff.addChangeListener(
              SoonFc(function () {
                if (self.isComponentEventuallyVisible()) {
                  $(".js-messages-scroll-area", self.findDOMNode()).trigger("forceResize", [true]);
                }
                self.refreshUI();
              })
            );
          }
          componentDidMount() {
            super.componentDidMount();
            const { chatRoom, onMount } = this.props;
            window.addEventListener("resize", this.handleWindowResize);
            window.addEventListener("keydown", this.handleKeyDown);
            this.$container = $(`.conversation-panel[data-room-id="${chatRoom.chatId}"]`);
            this.eventuallyInit();
            chatRoom.trigger("onHistoryPanelComponentDidMount");
            if (onMount) {
              onMount(this);
            }
          }
          componentWillUnmount() {
            super.componentWillUnmount();
            var self = this;
            var chatRoom = self.props.chatRoom;
            if (this._messagesBuffChangeHandler) {
              chatRoom.messagesBuff.removeChangeListener(this._messagesBuffChangeHandler);
              delete this._messagesBuffChangeHandler;
            }
            window.removeEventListener("resize", self.handleWindowResize);
            window.removeEventListener("keydown", self.handleKeyDown);
            $(document).off("fullscreenchange.megaChat_" + chatRoom.roomId);
            $(document).off("keydown.keyboardScroll_" + chatRoom.roomId);
          }
          componentDidUpdate(prevProps, prevState) {
            var self = this;
            self.eventuallyInit(false);
            var domNode = self.findDOMNode();
            var jml = domNode && domNode.querySelector(".js-messages-loading");
            if (jml) {
              if (self.loadingShown) {
                jml.classList.remove("hidden");
              } else {
                jml.classList.add("hidden");
              }
            }
            self.handleWindowResize();
            if (prevState.editing === false && self.state.editing !== false && self.messagesListScrollable) {
              self.messagesListScrollable.reinitialise(false);
              Soon(function () {
                if (self.editDomElement && self.editDomElement.length === 1) {
                  self.messagesListScrollable.scrollToElement(self.editDomElement[0], false);
                }
              });
            }
            if (self._reposOnUpdate !== undefined) {
              var ps = self.messagesListScrollable;
              ps.__prevPosY = ps.getScrollHeight() - self._reposOnUpdate + self.lastScrollPosition;
              ps.scrollToY(ps.__prevPosY, true);
            }
          }
          eventuallyInit(doResize) {
            const self = this;
            if (self.initialised) {
              return;
            }
            if (self.findDOMNode()) {
              self.initialised = true;
            } else {
              return;
            }
            $(self.findDOMNode()).rebind("resized.convpanel", function () {
              self.handleWindowResize();
            });
            self.$messages = $(".messages.scroll-area > .perfectScrollbarContainer", self.$container);
            self.$messages.droppable({
              tolerance: "pointer",
              drop: function (e, ui) {
                $.doDD(e, ui, "drop", 1);
              },
              over: function (e, ui) {
                $.doDD(e, ui, "over", 1);
              },
              out: function (e, ui) {
                $.doDD(e, ui, "out", 1);
              }
            });
            self.lastScrollPosition = null;
            self.props.chatRoom.scrolledToBottom = true;
            self.lastScrollHeight = 0;
            self.lastUpdatedScrollHeight = 0;
            if (doResize !== false) {
              self.handleWindowResize();
            }
          }
          _handleWindowResize(e, scrollToBottom) {
            if (!M.chat) {
              return;
            }
            if (!this.isMounted()) {
              this.componentWillUnmount();
              return;
            }
            if (!this.isComponentEventuallyVisible()) {
              return;
            }
            var self = this;
            self.eventuallyInit(false);
            if (!self.$messages) {
              return;
            }
            if (call.ZP.isExpanded()) {
              const $container = $(".meetings-call");
              const $messages = $(".js-messages-scroll-area", $container);
              const $textarea = $(".chat-textarea-block", $container);
              const $sidebar = $(".sidebar", $container);
              const scrollBlockHeight = parseInt($container.outerHeight(), 10) - parseInt($textarea.outerHeight(), 10) - 20;
              if ($sidebar.hasClass("chat-opened") && scrollBlockHeight !== $messages.outerHeight()) {
                $messages.css("height", scrollBlockHeight);
                self.refreshUI(true);
              }
              return;
            }
            var scrollBlockHeight =
              $(".chat-content-block", self.$container).outerHeight() -
              ($(".chat-topic-block", self.$container).outerHeight() || 0) -
              (is_chatlink
                ? $(".join-chat-block", self.$container).outerHeight()
                : $(".messages-block .chat-textarea-block", self.$container).outerHeight());
            if (scrollBlockHeight !== self.$messages.outerHeight()) {
              self.$messages.css("height", scrollBlockHeight);
              $(".messages.main-pad", self.$messages).css("min-height", scrollBlockHeight);
              self.refreshUI(true);
            } else {
              self.refreshUI(scrollToBottom);
            }
          }
          refreshUI() {
            if (this.isComponentEventuallyVisible()) {
              const room = this.props.chatRoom;
              room.renderContactTree();
              room.megaChat.refreshConversations();
              room.trigger("RefreshUI");
              if (room.scrolledToBottom) {
                delay(
                  `hp:reinit-scroll:${this.getUniqueId()}`,
                  () => {
                    if (this.messagesListScrollable) {
                      this.messagesListScrollable.reinitialise(true, true);
                      if (this.state.pusherHeight || this.messagesListScrollable.getScrollHeight() === 0) {
                        if (room.messagesBuff.haveMoreHistory()) {
                          const innerHeight = $(".messages.content-area > div", this.findDOMNode())
                            .not(".hp-pusher")
                            .toArray()
                            .map((a) => a.getBoundingClientRect().height)
                            .reduce((a, b) => a + b);
                          const pusherHeight = Math.max(this.messagesListScrollable.getClientHeight() - innerHeight + 50, 0);
                          if (Math.abs(this.state.pusherHeight - pusherHeight) > 50) {
                            this.setState({
                              pusherHeight
                            });
                          }
                        } else {
                          this.setState({
                            pusherHeight: 0
                          });
                        }
                      }
                    }
                  },
                  30
                );
              }
            }
          }
          isLoading() {
            const chatRoom = this.props.chatRoom;
            const mb = chatRoom.messagesBuff;
            return (
              this.scrollPullHistoryRetrieval === true ||
              chatRoom.activeSearches ||
              mb.messagesHistoryIsLoading() ||
              mb.joined === false ||
              mb.isDecrypting
            );
          }
          specShouldComponentUpdate() {
            return !this.loadingShown && this.isComponentEventuallyVisible();
          }
          enableScrollbar() {
            const ps = this.messagesListScrollable;
            ps.enable();
            this._reposOnUpdate = undefined;
            this.lastScrollPosition = ps.__prevPosY | 0;
          }
          editMessage(messageId) {
            var self = this;
            self.setState({
              editing: messageId
            });
            self.props.chatRoom.scrolledToBottom = false;
          }
          onMessageEditDone(v, messageContents) {
            var self = this;
            var room = this.props.chatRoom;
            room.scrolledToBottom = true;
            self.editDomElement = null;
            var currentContents = v.textContents;
            v.edited = false;
            if (messageContents === false || messageContents === currentContents) {
              self.messagesListScrollable.scrollToBottom(true);
            } else if (messageContents) {
              room.trigger("onMessageUpdating", v);
              room.megaChat.plugins.chatdIntegration.updateMessage(room, v.internalId ? v.internalId : v.orderValue, messageContents);
              if (
                v.getState &&
                (v.getState() === Message.STATE.NOT_SENT || v.getState() === Message.STATE.SENT) &&
                !v.requiresManualRetry
              ) {
                if (v.textContents) {
                  v.textContents = messageContents;
                }
                if (v.emoticonShortcutsProcessed) {
                  v.emoticonShortcutsProcessed = false;
                }
                if (v.emoticonsProcessed) {
                  v.emoticonsProcessed = false;
                }
                if (v.messageHtml) {
                  delete v.messageHtml;
                }
                v.trigger("onChange", [v, "textContents", "", messageContents]);
                megaChat.plugins.richpreviewsFilter.processMessage({}, v, false, true);
              }
              self.messagesListScrollable.scrollToBottom(true);
            } else if (messageContents.length === 0) {
              this.props.onDeleteClicked(v);
            }
            self.setState({
              editing: false
            });
            self.refreshUI();
            Soon(function () {
              $(".chat-textarea-block:visible textarea").focus();
            }, 300);
          }
          render() {
            var self = this;
            var room = this.props.chatRoom;
            if (!room || !room.roomId) {
              return null;
            }
            var contacts = room.getParticipantsExceptMe();
            var contactHandle;
            var contact;
            var avatarMeta;
            var contactName = "";
            if (contacts && contacts.length === 1) {
              contactHandle = contacts[0];
              contact = M.u[contactHandle];
              avatarMeta = contact ? generateAvatarMeta(contact.u) : {};
              contactName = avatarMeta.fullName;
            } else if (contacts && contacts.length > 1) {
              contactName = room.getRoomTitle();
            }
            var messagesList = [];
            if (this.isLoading()) {
              self.loadingShown = true;
            } else {
              const mb = room.messagesBuff;
              if (this.scrollPullHistoryRetrieval < 0) {
                this.scrollPullHistoryRetrieval = false;
                self.enableScrollbar();
              }
              delete self.loadingShown;
              if (mb.joined === true && !self.scrollPullHistoryRetrieval && mb.haveMoreHistory() === false) {
                var headerText = l[8002];
                headerText = contactName
                  ? headerText.replace("%s", `<span>${megaChat.html(contactName)}</span>`)
                  : megaChat.html(room.getRoomTitle());
                messagesList.push(
                  external_React_default().createElement(
                    "div",
                    {
                      className: "messages notification",
                      key: "initialMsg"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: "header"
                      },
                      external_React_default().createElement(utils.Cw, {
                        tag: "div",
                        content: room.scheduledMeeting ? megaChat.html(room.getRoomTitle()) : headerText
                      })
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "info"
                      },
                      l[8080],
                      external_React_default().createElement(
                        "p",
                        null,
                        external_React_default().createElement("i", {
                          className: "sprite-fm-mono icon-lock"
                        }),
                        external_React_default().createElement(
                          utils.Cw,
                          null,
                          l[8540].replace("[S]", "<strong>").replace("[/S]", "</strong>")
                        )
                      ),
                      external_React_default().createElement(
                        "p",
                        null,
                        external_React_default().createElement("i", {
                          className: "sprite-fm-mono icon-accept"
                        }),
                        external_React_default().createElement(
                          utils.Cw,
                          null,
                          l[8539].replace("[S]", "<strong>").replace("[/S]", "</strong>")
                        )
                      )
                    )
                  )
                );
              }
            }
            var lastTimeMarker;
            var lastMessageFrom = null;
            var lastGroupedMessageTimeStamp = null;
            var grouped = false;
            for (var i = 0; i < room.messagesBuff.messages.length; i++) {
              var v = room.messagesBuff.messages.getItem(i);
              if (!v.protocol && v.revoked !== true) {
                var shouldRender = true;
                if ((v.isManagement && v.isManagement() === true && v.isRenderableManagement() === false) || v.deleted === true) {
                  shouldRender = false;
                }
                var timestamp = v.delay;
                var curTimeMarker = getTimeMarker(timestamp);
                if (shouldRender === true && curTimeMarker && lastTimeMarker !== curTimeMarker) {
                  lastTimeMarker = curTimeMarker;
                  messagesList.push(
                    external_React_default().createElement(
                      "div",
                      {
                        className: "message date-divider selectable-txt",
                        key: v.messageId + "_marker",
                        title: time2date(timestamp)
                      },
                      curTimeMarker
                    )
                  );
                  grouped = false;
                  lastMessageFrom = null;
                  lastGroupedMessageTimeStamp = null;
                }
                if (shouldRender === true) {
                  var userId = v.userId;
                  if (!userId && contact && contact.u) {
                    userId = contact.u;
                  }
                  if (v instanceof Message && v.dialogType !== "truncated") {
                    if (!lastMessageFrom || (userId && lastMessageFrom === userId)) {
                      if (timestamp - lastGroupedMessageTimeStamp < 300) {
                        grouped = true;
                      } else {
                        grouped = false;
                        lastMessageFrom = userId;
                        lastGroupedMessageTimeStamp = timestamp;
                      }
                    } else {
                      grouped = false;
                      lastMessageFrom = userId;
                      if (lastMessageFrom === userId) {
                        lastGroupedMessageTimeStamp = timestamp;
                      } else {
                        lastGroupedMessageTimeStamp = null;
                      }
                    }
                  } else {
                    grouped = false;
                    lastMessageFrom = null;
                    lastGroupedMessageTimeStamp = null;
                  }
                }
                if ((v.dialogType === "remoteCallEnded" || v.dialogType === "remoteCallStarted") && v && v.wrappedChatDialogMessage) {
                  v = v.wrappedChatDialogMessage;
                }
                if (v.dialogType) {
                  var messageInstance = null;
                  if (v.dialogType === "alterParticipants") {
                    messageInstance = external_React_default().createElement(AltPartsConvMessage, {
                      message: v,
                      key: v.messageId,
                      contact: Message.getContactForMessage(v),
                      grouped: grouped,
                      chatRoom: room
                    });
                  } else if (v.dialogType === "truncated") {
                    messageInstance = external_React_default().createElement(TruncatedMessage, {
                      message: v,
                      key: v.messageId,
                      contact: Message.getContactForMessage(v),
                      grouped: grouped,
                      chatRoom: room
                    });
                  } else if (v.dialogType === "privilegeChange") {
                    messageInstance = external_React_default().createElement(PrivilegeChange, {
                      message: v,
                      key: v.messageId,
                      contact: Message.getContactForMessage(v),
                      grouped: grouped,
                      chatRoom: room
                    });
                  } else if (v.dialogType === "topicChange") {
                    messageInstance = external_React_default().createElement(TopicChange, {
                      message: v,
                      key: v.messageId,
                      contact: Message.getContactForMessage(v),
                      grouped: grouped,
                      chatRoom: room
                    });
                  } else if (v.dialogType === "openModeClosed") {
                    messageInstance = external_React_default().createElement(CloseOpenModeMessage, {
                      message: v,
                      key: v.messageId,
                      contact: Message.getContactForMessage(v),
                      grouped: grouped,
                      chatRoom: room
                    });
                  } else if (v.dialogType === "chatHandleUpdate") {
                    messageInstance = external_React_default().createElement(ChatHandleMessage, {
                      message: v,
                      key: v.messageId,
                      contact: Message.getContactForMessage(v),
                      grouped: grouped,
                      chatRoom: room
                    });
                  } else if (v.dialogType === "messageRetention") {
                    messageInstance = external_React_default().createElement(RetentionChange, {
                      message: v,
                      key: v.messageId,
                      contact: Message.getContactForMessage(v)
                    });
                  } else if (v.dialogType === "scheduleMeta") {
                    if (v.meta.onlyTitle) {
                      messageInstance = external_React_default().createElement(TopicChange, {
                        message: v,
                        key: v.messageId,
                        contact: Message.getContactForMessage(v),
                        grouped: grouped,
                        chatRoom: v.chatRoom
                      });
                    } else {
                      if (v.meta.topicChange) {
                        messagesList.push(
                          external_React_default().createElement(TopicChange, {
                            message: v,
                            key: `${v.messageId}-topic`,
                            contact: Message.getContactForMessage(v),
                            grouped: grouped,
                            chatRoom: v.chatRoom
                          })
                        );
                      }
                      messageInstance = external_React_default().createElement(scheduleMetaChange["default"], {
                        message: v,
                        key: v.messageId,
                        mode: v.meta.mode,
                        chatRoom: room,
                        grouped: grouped,
                        link: v.chatRoom.publicLink,
                        contact: Message.getContactForMessage(v)
                      });
                    }
                  }
                  messagesList.push(messageInstance);
                } else {
                  if (!v.chatRoom) {
                    v.chatRoom = room;
                  }
                  messagesList.push(
                    external_React_default().createElement(generic.Z, {
                      message: v,
                      state: v.state,
                      key: v.messageId,
                      contact: Message.getContactForMessage(v),
                      grouped: grouped,
                      onUpdate: () => {
                        self.onResizeDoUpdate();
                      },
                      editing: self.state.editing === v.messageId || self.state.editing === v.pendingMessageId,
                      onEditStarted: ((v, $domElement) => {
                        self.editDomElement = $domElement;
                        self.setState({
                          editing: v.messageId
                        });
                        self.forceUpdate();
                      }).bind(this, v),
                      chatRoom: room,
                      onEditDone: this.onMessageEditDone.bind(this, v),
                      onDeleteClicked: (msg) => {
                        if (this.props.onDeleteClicked) {
                          this.props.onDeleteClicked(msg);
                        }
                      },
                      onResized: () => {
                        this.handleWindowResize();
                      },
                      onEmojiBarChange: () => {
                        this.handleWindowResize();
                      }
                    })
                  );
                }
              }
            }
            return external_React_default().createElement(
              "div",
              {
                className: `
                    messages
                    scroll-area
                    ${this.props.className ? this.props.className : ""}
                `
              },
              external_React_default().createElement(
                "div",
                {
                  className: "dropdown body dropdown-arrow down-arrow tooltip not-sent-notification-manual hidden"
                },
                external_React_default().createElement("i", {
                  className: "dropdown-white-arrow"
                }),
                external_React_default().createElement(
                  "div",
                  {
                    className: "dropdown notification-text"
                  },
                  external_React_default().createElement("i", {
                    className: "small-icon conversations"
                  }),
                  l[8883]
                )
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "dropdown body dropdown-arrow down-arrow tooltip not-sent-notification-cancel hidden"
                },
                external_React_default().createElement("i", {
                  className: "dropdown-white-arrow"
                }),
                external_React_default().createElement(
                  "div",
                  {
                    className: "dropdown notification-text"
                  },
                  external_React_default().createElement("i", {
                    className: "small-icon conversations"
                  }),
                  l[8884]
                )
              ),
              external_React_default().createElement(
                perfectScrollbar.F,
                {
                  onFirstInit: (ps) => {
                    ps.scrollToBottom(true);
                    this.props.chatRoom.scrolledToBottom = 1;
                  },
                  onUserScroll: this.onMessagesScrollUserScroll,
                  className: "js-messages-scroll-area perfectScrollbarContainer",
                  messagesToggledInCall: this.state.messagesToggledInCall,
                  ref: (ref) => {
                    this.messagesListScrollable = ref;
                    $(document).rebind("keydown.keyboardScroll_" + this.props.chatRoom.roomId, this.onKeyboardScroll);
                    if (this.props.onMessagesListScrollableMount) {
                      this.props.onMessagesListScrollableMount(ref);
                    }
                  },
                  chatRoom: this.props.chatRoom,
                  messagesBuff: this.props.chatRoom.messagesBuff,
                  editDomElement: this.state.editDomElement,
                  editingMessageId: this.state.editing,
                  confirmDeleteDialog: this.state.confirmDeleteDialog,
                  renderedMessagesCount: messagesList.length,
                  isLoading:
                    this.props.chatRoom.messagesBuff.messagesHistoryIsLoading() ||
                    this.props.chatRoom.activeSearches > 0 ||
                    this.loadingShown,
                  options: {
                    suppressScrollX: true
                  }
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "messages main-pad"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "messages content-area"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        key: "loadingSpinner",
                        style: {
                          top: "50%"
                        },
                        className: `
                                    loading-spinner
                                    js-messages-loading
                                    light
                                    manual-management
                                    ${this.loadingShown ? "" : "hidden"}
                                `
                      },
                      external_React_default().createElement("div", {
                        className: "main-loader",
                        style: {
                          position: "fixed",
                          top: "50%",
                          left: "50%"
                        }
                      })
                    ),
                    !!this.state.pusherHeight &&
                      external_React_default().createElement("div", {
                        className: "hp-pusher",
                        style: {
                          height: this.state.pusherHeight
                        }
                      }),
                    messagesList
                  )
                )
              ),
              this.renderToast()
            );
          }
        }),
        (0, applyDecoratedDescriptor.Z)(
          _class.prototype,
          "enableScrollbar",
          [_dec],
          Object.getOwnPropertyDescriptor(_class.prototype, "enableScrollbar"),
          _class.prototype
        ),
        _class));

      /***/
    },

    /***/ 941: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        Z: () => Link
      });
      var react0__ = __webpack_require__(363);
      var react0 = __webpack_require__.n(react0__);
      var _mixins1__ = __webpack_require__(503);

      class Link extends _mixins1__.wl {
        constructor(props) {
          super(props);
          this.IS_CLICK_URL = undefined;
          this.IS_CLICK_URL = this.props.to && (this.props.to.startsWith("/") || this.props.to.includes("mega.io"));
        }
        componentDidMount() {
          super.componentDidMount();
          if (this.IS_CLICK_URL) {
            clickURLs();
          }
        }
        render() {
          const { className, to, target, children, onClick } = this.props;
          if (this.IS_CLICK_URL) {
            return react0().createElement(
              "a",
              {
                className: `
                        clickurl
                        ${className || ""}
                    `,
                href: to,
                target: target
              },
              children
            );
          }
          return react0().createElement(
            "a",
            {
              className: className,
              href: "#",
              onClick: (ev) => {
                if (onClick) {
                  ev.preventDefault();
                  return onClick(ev);
                }
                return null;
              }
            },
            children
          );
        }
      }

      /***/
    },

    /***/ 193: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        Z: () => __WEBPACK_DEFAULT_EXPORT__
      });
      var react0__ = __webpack_require__(363);
      var react0 = __webpack_require__.n(react0__);
      var _mixins1__ = __webpack_require__(503);

      class Group extends _mixins1__.wl {
        constructor(props) {
          super(props);
          this.containerRef = react0().createRef();
          this.state = {
            expanded: false
          };
          this.doToggle = this.doToggle.bind(this);
        }
        toggleEvents() {
          return this.state.expanded
            ? $(document)
                .rebind(`mousedown.${Group.NAMESPACE}`, (ev) => !this.containerRef.current.contains(ev.target) && this.doToggle())
                .rebind(`keydown.${Group.NAMESPACE}`, ({ keyCode }) => keyCode && keyCode === 27 && this.doToggle())
            : $(document).unbind(`.${Group.NAMESPACE}`);
        }
        doToggle() {
          this.setState(
            (state) => ({
              expanded: !state.expanded
            }),
            () => this.toggleEvents()
          );
        }
        render() {
          const { active, warn, onHold, screenSharing, children } = this.props;
          if (children && children.length) {
            return react0().createElement(
              "div",
              {
                ref: this.containerRef,
                className: Group.BASE_CLASS
              },
              react0().createElement(
                "div",
                {
                  className: `
                            ${Group.BASE_CLASS}-menu
                            ${this.state.expanded ? "expanded" : ""}
                        `,
                  onClick: this.doToggle
                },
                children.map((item) => {
                  return (
                    item &&
                    react0().createElement(
                      "div",
                      {
                        key: item.key,
                        className: `${Group.BASE_CLASS}-item`
                      },
                      item
                    )
                  );
                })
              ),
              react0().createElement(
                "button",
                {
                  className: "mega-button theme-light-forced round large",
                  onClick: this.doToggle
                },
                active &&
                  react0().createElement("div", {
                    className: "info-indicator active"
                  }),
                warn &&
                  react0().createElement(
                    "div",
                    {
                      className: "info-indicator warn simpletip",
                      "data-simpletip": l.screen_share_crop_tip,
                      "data-simpletipposition": "top",
                      "data-simpletipoffset": "5",
                      "data-simpletip-class": "theme-dark-forced"
                    },
                    react0().createElement("i", {
                      className: "sprite-fm-mono icon-exclamation-filled"
                    })
                  ),
                react0().createElement("i", {
                  className: `
                                sprite-fm-mono
                                ${screenSharing ? "icon-end-screenshare" : ""}
                                ${!onHold && !screenSharing && "icon-options"}
                            `
                })
              )
            );
          }
          return null;
        }
      }
      Group.NAMESPACE = "buttonGroup";
      Group.BASE_CLASS = "button-group";
      class Button extends _mixins1__.wl {
        constructor(...args) {
          super(...args);
          this.buttonRef = react0().createRef();
        }
        componentDidUpdate() {
          super.componentDidUpdate();
          if (this.props.simpletip) {
            $(this.buttonRef.current).trigger("simpletipUpdated");
          }
        }
        componentDidMount() {
          super.componentDidMount();
          if (this.props.didMount) {
            this.props.didMount(this);
          }
        }
        render() {
          const { children, className, style, simpletip, icon, onClick } = this.props;
          return react0().createElement(
            "button",
            {
              ref: this.buttonRef,
              className: `
                    ${className ? className : ""}
                    ${simpletip ? "simpletip" : ""}
                `,
              style: style,
              "data-simpletip": simpletip == null ? void 0 : simpletip.label,
              "data-simpletipposition": simpletip == null ? void 0 : simpletip.position,
              "data-simpletipoffset": simpletip == null ? void 0 : simpletip.offset,
              "data-simpletip-class": simpletip == null ? void 0 : simpletip.className,
              onClick: onClick
            },
            icon &&
              react0().createElement("i", {
                className: `sprite-fm-mono ${icon}`
              }),
            children
          );
        }
      }
      Button.Group = Group;
      const __WEBPACK_DEFAULT_EXPORT__ = Button;

      /***/
    },

    /***/ 689: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, {
        F3: () => EXPANDED_FLAG,
        IK: () => MODE,
        wD: () => TYPE,
        t3: () => VIEW,
        ZP: () => Call,
        xt: () => inProgressAlert,
        nJ: () => isGuest
      });

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
      var esm_extends = __webpack_require__(462);
      // EXTERNAL MODULE: external "React"
      var external_React_ = __webpack_require__(363);
      var external_React_default = __webpack_require__.n(external_React_);
      // EXTERNAL MODULE: ./js/chat/mixins.js
      var mixins = __webpack_require__(503);
      // EXTERNAL MODULE: ./js/chat/ui/contacts.jsx
      var ui_contacts = __webpack_require__(13);
      // EXTERNAL MODULE: ./js/chat/ui/meetings/button.jsx
      var meetings_button = __webpack_require__(193);
      // EXTERNAL MODULE: ./js/ui/utils.jsx
      var utils = __webpack_require__(79); // CONCATENATED MODULE: ./js/chat/ui/meetings/videoNodeMenu.jsx
      class VideoNodeMenu extends mixins.wl {
        constructor(props) {
          super(props);
          this.Contact = this.Contact.bind(this);
          this.Pin = this.Pin.bind(this);
          this.Privilege = this.Privilege.bind(this);
        }
        Contact() {
          const { stream, ephemeralAccounts, onCallMinimize } = this.props;
          const { userHandle } = stream;
          const IS_GUEST = isGuest() || (ephemeralAccounts && ephemeralAccounts.includes(userHandle));
          const HAS_RELATIONSHIP = M.u[userHandle].c === 1;
          if (HAS_RELATIONSHIP) {
            return external_React_default().createElement(
              meetings_button.Z,
              {
                icon: "sprite-fm-mono icon-chat",
                onClick: () => {
                  onCallMinimize();
                  loadSubPage(`fm/chat/p/${userHandle}`);
                }
              },
              external_React_default().createElement("span", null, l[7997])
            );
          }
          return external_React_default().createElement(
            meetings_button.Z,
            {
              className: IS_GUEST ? "disabled" : "",
              icon: "sprite-fm-mono icon-add",
              onClick: () => {
                return IS_GUEST
                  ? false
                  : M.syncContactEmail(userHandle, true)
                      .then((email) => {
                        const OPC = Object.values(M.opc);
                        if (OPC && OPC.length && OPC.some((opc) => opc.m === email)) {
                          return msgDialog("warningb", "", l[17545]);
                        }
                        msgDialog("info", l[150], l[5898]);
                        M.inviteContact(M.u[u_handle].m, email);
                      })
                      .catch(() => mBroadcaster.sendMessage("meetings:ephemeralAdd", userHandle));
              }
            },
            external_React_default().createElement("span", null, l[24581])
          );
        }
        Pin() {
          const { stream, onSpeakerChange } = this.props;
          if (onSpeakerChange) {
            return external_React_default().createElement(
              meetings_button.Z,
              {
                icon: "sprite-fm-mono grid-main",
                onClick: () => onSpeakerChange(stream)
              },
              external_React_default().createElement("span", null, l.display_in_main_view)
            );
          }
          return null;
        }
        Privilege() {
          const { stream, chatRoom } = this.props;
          const { call, userHandle } = stream;
          if (call && call.isPublic) {
            const { OPERATOR, FULL } = ChatRoom.MembersSet.PRIVILEGE_STATE;
            const currentUserModerator = chatRoom.members[u_handle] === OPERATOR;
            const targetUserModerator = chatRoom.members[userHandle] === OPERATOR;
            return (
              currentUserModerator &&
              external_React_default().createElement(
                meetings_button.Z,
                {
                  targetUserModerator: targetUserModerator,
                  icon: "sprite-fm-mono icon-admin-outline",
                  onClick: () => {
                    ["alterUserPrivilege", "onCallPrivilegeChange"].map((event) =>
                      chatRoom.trigger(event, [userHandle, targetUserModerator ? FULL : OPERATOR])
                    );
                  }
                },
                external_React_default().createElement("span", null, targetUserModerator ? l.remove_moderator : l.make_moderator)
              )
            );
          }
          return null;
        }
        render() {
          const { NAMESPACE } = VideoNodeMenu;
          const { userHandle } = this.props.stream;
          if (userHandle !== u_handle) {
            return external_React_default().createElement(
              "div",
              {
                className: `
                        ${NAMESPACE}
                        theme-dark-forced
                    `
              },
              external_React_default().createElement(
                "div",
                {
                  className: `${NAMESPACE}-toggle`
                },
                external_React_default().createElement(utils.dy, null, M.getNameByHandle(userHandle)),
                external_React_default().createElement("i", {
                  className: "sprite-fm-mono icon-side-menu"
                })
              ),
              external_React_default().createElement(
                "div",
                {
                  className: `${NAMESPACE}-content`
                },
                external_React_default().createElement(
                  "ul",
                  null,
                  [this.Contact, this.Pin, this.Privilege].map((button, index) =>
                    external_React_default().createElement(
                      "li",
                      {
                        key: index
                      },
                      button()
                    )
                  )
                )
              )
            );
          }
          return null;
        }
      }
      VideoNodeMenu.NAMESPACE = "node-menu"; // CONCATENATED MODULE: ./js/chat/ui/meetings/videoNode.jsx
      class VideoNode extends mixins.wl {
        constructor(props, source) {
          super(props);
          this.nodeRef = external_React_default().createRef();
          this.contRef = external_React_default().createRef();
          this.statsHudRef = external_React_default().createRef();
          this.isVideo = true;
          this.source = source;
        }
        componentDidMount() {
          super.componentDidMount();
          this.source.registerConsumer(this);
          if (this.props.didMount) {
            var _this$nodeRef;
            this.props.didMount((_this$nodeRef = this.nodeRef) == null ? void 0 : _this$nodeRef.current);
          }
          this.requestVideo(true);
        }
        onVisibilityChange(isVisible) {
          this.requestVideo(isVisible);
        }
        componentDidUpdate() {
          super.componentDidUpdate();
          if (this.props.didUpdate) {
            var _this$nodeRef2;
            this.props.didUpdate((_this$nodeRef2 = this.nodeRef) == null ? void 0 : _this$nodeRef2.current);
          }
          this.requestVideo();
        }
        displayVideoElement(video, container) {
          this.attachVideoElemHandlers(video);
          container.replaceChildren(video);
        }
        attachVideoElemHandlers(video) {
          if (video._snSetup) {
            return;
          }
          video.autoplay = true;
          video.controls = false;
          video.muted = true;
          video.ondblclick = (e) => {
            if (this.props.onDoubleClick) {
              this.props.onDoubleClick(e, this);
            }
          };
          video.onloadeddata = (ev) => {
            if (this.props.onLoadedData) {
              this.props.onLoadedData(ev);
            }
          };
          video._snSetup = true;
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          this.detachVideoElemHandlers();
          this.source.deregisterConsumer(this);
          if (this.props.willUnmount) {
            this.props.willUnmount();
          }
        }
        detachVideoElemHandlers() {
          var _this$contRef$current;
          const video = (_this$contRef$current = this.contRef.current) == null ? void 0 : _this$contRef$current.firstChild;
          if (!video || !video._snSetup) {
            return;
          }
          video.onloadeddata = null;
          video.ondblclick = null;
          delete video._snSetup;
        }
        displayStats(stats) {
          const elem = this.statsHudRef.current;
          if (!elem) {
            return;
          }
          elem.textContent = stats ? `${stats} (${this.ownVideo ? "cloned" : "ref"})` : "";
        }
        renderVideoDebugMode() {
          if (this.source.isFake) {
            return null;
          }
          let className = "video-rtc-stats";
          let title;
          if (this.isLocal) {
            if (window.sfuClient) {
              title = new URL(window.sfuClient.url).host;
            }
            if (this.props.isSelfOverlay) {
              className += " video-rtc-stats-ralign";
            }
          }
          if (!title) {
            title = "";
          }
          return external_React_default().createElement("div", {
            ref: this.statsHudRef,
            className: className,
            title: title
          });
        }
        renderContent() {
          const source = this.source;
          if (source.isStreaming()) {
            return external_React_default().createElement("div", {
              ref: this.contRef,
              className: "video-node-holder"
            });
          }
          delete this._lastResizeWidth;
          return external_React_default().createElement(ui_contacts.Avatar, {
            contact: M.u[source.userHandle]
          });
        }
        getStatusIcon(icon, label) {
          return external_React_default().createElement(
            "span",
            {
              className: "simpletip",
              "data-simpletip-class": "theme-dark-forced",
              "data-simpletipposition": "top",
              "data-simpletipoffset": "5",
              "data-simpletip": label
            },
            external_React_default().createElement("i", {
              className: `sprite-fm-mono ${icon}`
            })
          );
        }
        renderStatus() {
          const { mode, chatRoom } = this.props;
          const source = this.source;
          const sfuClient = chatRoom.call.sfuClient;
          const userHandle = source.userHandle;
          const $$CONTAINER = ({ children }) =>
            external_React_default().createElement(
              "div",
              {
                className: "video-node-status theme-dark-forced"
              },
              children
            );
          const onHoldLabel = l[23542].replace("%s", M.getNameByHandle(userHandle));
          if (source.isOnHold) {
            return external_React_default().createElement($$CONTAINER, null, this.getStatusIcon("icon-pause", onHoldLabel));
          }
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            mode === MODE.MAIN &&
              Call.isModerator(chatRoom, userHandle) &&
              this.getStatusIcon("icon-admin-outline call-role-icon", l[8875]),
            external_React_default().createElement(
              $$CONTAINER,
              null,
              source.audioMuted ? this.getStatusIcon("icon-mic-off-thin-outline", l.muted) : null,
              sfuClient.haveBadNetwork ? this.getStatusIcon("icon-weak-signal", l.poor_connection) : null,
              source.hasScreenAndCam && this.isThumb ? this.getStatusIcon("icon-pc-linux", "Sharing screen") : null
            )
          );
        }
        render() {
          const { mode, minimized, chatRoom, simpletip, className, children, onClick } = this.props;
          const { nodeRef, source, isLocal, isLocalScreen } = this;
          if (!chatRoom.call) {
            return null;
          }
          return external_React_default().createElement(
            "div",
            {
              ref: nodeRef,
              className: `
                    video-node
                    ${onClick ? "clickable" : ""}
                    ${className || ""}
                    ${isLocal && !isLocalScreen ? " local-stream-mirrored" : ""}
                    ${simpletip ? "simpletip" : ""}
                `,
              "data-simpletip": simpletip == null ? void 0 : simpletip.label,
              "data-simpletipposition": simpletip == null ? void 0 : simpletip.position,
              "data-simpletipoffset": simpletip == null ? void 0 : simpletip.offset,
              "data-simpletip-class": simpletip == null ? void 0 : simpletip.className,
              onClick: (ev) => onClick && onClick(source, ev)
            },
            source &&
              external_React_default().createElement(
                external_React_default().Fragment,
                null,
                children || null,
                external_React_default().createElement(
                  "div",
                  {
                    className: "video-node-content"
                  },
                  CallManager2.Call.VIDEO_DEBUG_MODE ? this.renderVideoDebugMode() : null,
                  this.renderContent(),
                  mode === MODE.MINI || minimized ? null : this.renderStatus()
                )
              )
          );
        }
      }
      class DynVideo extends VideoNode {
        onAvChange() {
          this._lastResizeWidth = null;
          this.safeForceUpdate();
        }
        dynRequestVideo(forceVisible) {
          const { source } = this;
          if (source.isFake || source.isDestroyed) {
            return;
          }
          if (source.isStreaming() && this.isMounted() && (this.isComponentVisible() || forceVisible)) {
            const node = this.findDOMNode();
            this.dynRequestVideoBySize(node.offsetWidth, node.offsetHeight);
          } else {
            this.dynRequestVideoBySize(0, 0);
            this.displayStats(null);
          }
        }
        dynRequestVideoQuality(quality) {
          this.requestedQ = quality && CallManager2.FORCE_LOWQ ? 1 : quality;
          if (!this.source.dynUpdateVideoQuality()) {
            this.dynUpdateVideoElem();
          }
        }
        dynRequestVideoBySize(w) {
          if (w === 0) {
            this._lastResizeWidth = 0;
            this.dynRequestVideoQuality(CallManager2.VIDEO_QUALITY.NO_VIDEO);
            return;
          }
          if (this.contRef.current) {
            if (this._lastResizeWidth === w) {
              return;
            }
            this._lastResizeWidth = w;
          } else {
            this._lastResizeWidth = null;
          }
          let newQ;
          if (w > 400) {
            newQ = CallManager2.VIDEO_QUALITY.HIGH;
          } else if (w > 200) {
            newQ = CallManager2.VIDEO_QUALITY.MEDIUM;
          } else if (w > 180) {
            newQ = CallManager2.VIDEO_QUALITY.LOW;
          } else {
            newQ = CallManager2.VIDEO_QUALITY.THUMB;
          }
          this.dynRequestVideoQuality(newQ);
        }
        dynUpdateVideoElem() {
          const vidCont = this.contRef.current;
          if (!this.isMounted() || !vidCont) {
            return;
          }
          const player = this.source.player;
          if (!player) {
            vidCont.replaceChildren();
            return;
          }
          this.dynSetVideoSource(player, vidCont);
        }
      }
      class DynVideoDirect extends DynVideo {
        constructor(props, source) {
          super(props, source);
          this.isDirect = true;
          this.requestVideo = this.dynRequestVideo;
        }
        dynSetVideoSource(srcPlayer, vidCont) {
          if (vidCont.firstChild !== srcPlayer) {
            this.displayVideoElement(srcPlayer, vidCont);
          }
          if (srcPlayer.paused) {
            srcPlayer.play().catch(nop);
          }
        }
      }
      class PeerVideoHiRes extends DynVideoDirect {
        constructor(props) {
          super(props, props.source);
        }
      }
      class DynVideoCloned extends DynVideo {
        constructor(props, source) {
          super(props, source);
          this.ownVideo = document.createElement("video");
        }
        dynSetVideoSource(srcPlayer, vidCont) {
          const cloned = this.ownVideo;
          const currVideo = vidCont.firstChild;
          if (!currVideo) {
            this.displayVideoElement(cloned, vidCont);
          } else {
            assert(currVideo === cloned);
          }
          if (cloned.paused || cloned.srcObject !== srcPlayer.srcObject) {
            cloned.srcObject = srcPlayer.srcObject;
            Promise.resolve(cloned.play()).catch(nop);
          }
        }
      }
      class PeerVideoThumb extends DynVideoCloned {
        constructor(props) {
          super(props, props.source);
          this.isThumb = true;
          if (CallManager2.Call.VIDEO_DEBUG_MODE) {
            this.onRxStats = this._onRxStats;
          }
        }
        requestVideo(forceVisible) {
          if (!this.source.hasScreenAndCam) {
            if (this.fixedThumbPlayer) {
              this.fixedThumbPlayer.destroy();
            }
            this.dynRequestVideo(forceVisible);
          } else {
            delete this.requestedQ;
            this.requestFixedThumbVideo();
          }
        }
        addFixedThumbVideo() {
          assert(this.source.hasScreenAndCam);
          const vidCont = this.contRef.current;
          assert(vidCont);
          if (vidCont.firstChild !== this.ownVideo) {
            vidCont.replaceChildren(this.ownVideo);
          }
        }
        delFixedThumbVideo() {
          SfuClient.playerStop(this.ownVideo);
          const vidCont = this.contRef.current;
          if (!vidCont) {
            return;
          }
          vidCont.replaceChildren();
        }
        requestFixedThumbVideo() {
          if (this.fixedThumbPlayer) {
            this.playFixedThumbVideo();
          } else {
            this.addFixedThumbVideo();
            this.fixedThumbPlayer = this.source.sfuPeer.getThumbVideo((player) => {
              this.fixedThumbPlayer = player;
              return this;
            });
          }
        }
        playFixedThumbVideo() {
          var _this$fixedThumbPlaye;
          const track = (_this$fixedThumbPlaye = this.fixedThumbPlayer.slot) == null ? void 0 : _this$fixedThumbPlaye.inTrack;
          if (!track) {
            return;
          }
          SfuClient.playerPlay(this.ownVideo, track, true);
        }
        attachToTrack(track) {
          if (!this.source.hasScreenAndCam) {
            return;
          }
          SfuClient.playerPlay(this.ownVideo, track);
        }
        detachFromTrack() {
          this.delFixedThumbVideo();
        }
        onPlayerDestroy() {
          delete this.fixedThumbPlayer;
        }
        _onRxStats(track, info, raw) {
          if (!this.source.player) {
            this.displayStats(CallManager2.Call.rxStatsToText(track, info, raw));
          }
        }
      }
      class LocalVideoHiRes extends DynVideoDirect {
        constructor(props) {
          super(props, props.chatRoom.call.getLocalStream());
          this.isLocal = true;
        }
        get isLocalScreen() {
          return this.source.av & Av.Screen;
        }
      }
      class LocalVideoThumb extends VideoNode {
        constructor(props) {
          const source = props.chatRoom.call.getLocalStream();
          super(props, source);
          this.isLocal = this.isThumb = true;
          this.isLocalScreen = source.av & Av.Screen && !(source.av & Av.Camera);
          this.sfuClient = props.chatRoom.call.sfuClient;
          this.ownVideo = document.createElement("video");
        }
        requestVideo() {
          const vidCont = this.contRef.current;
          if (!vidCont) {
            return;
          }
          const currVideo = vidCont.firstChild;
          const track = this.isLocalScreen ? this.sfuClient.localScreenTrack() : this.sfuClient.localCameraTrack();
          if (!track) {
            if (currVideo) {
              vidCont.replaceChildren();
            }
          } else {
            if (!currVideo) {
              this.displayVideoElement(this.ownVideo, vidCont);
            } else {
              assert(currVideo === this.ownVideo);
            }
            SfuClient.playerPlay(this.ownVideo, track, true);
          }
        }
        onAvChange() {
          const av = this.sfuClient.availAv;
          this.isLocalScreen = av & Av.Screen && !(av & Av.Camera);
          this.safeForceUpdate();
        }
      }
      // EXTERNAL MODULE: ./js/ui/dropdowns.jsx
      var dropdowns = __webpack_require__(78);
      // EXTERNAL MODULE: ./js/ui/buttons.jsx
      var buttons = __webpack_require__(204); // CONCATENATED MODULE: ./js/chat/ui/meetings/floatExtendedControls.jsx
      class FloatExtendedControls extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.isActive = (type) => {
            return !!(this.props.call.av & type);
          };
        }
        render() {
          const {
            hasToRenderPermissionsWarning,
            renderPermissionsWarning,
            resetError,
            showScreenDialog,
            onScreenSharingClick,
            onHoldClick
          } = this.props;
          const { onHold, Screen } = SfuClient.Av;
          const screenSharingLabel = this.isActive(Screen) ? l[22890] : l[22889];
          const callHoldLabel = this.isActive(onHold) ? l[23459] : l[23460];
          return external_React_default().createElement(
            buttons.z,
            {
              className: "mega-button theme-light-forced round large button-group",
              icon: "sprite-fm-mono icon-options",
              showScreenDialog: showScreenDialog
            },
            this.isActive(Screen) &&
              external_React_default().createElement("div", {
                className: "info-indicator active"
              }),
            external_React_default().createElement(
              dropdowns.Dropdown,
              {
                className: "button-group-menu theme-dark-forced",
                noArrow: true,
                positionAt: "center top",
                collision: "none",
                vertOffset: 90,
                ref: (r) => {
                  this.dropdownRef = r;
                },
                onBeforeActiveChange: (e) => {
                  if (e) {
                    $(document.body).trigger("closeAllDropdownsExcept", this.dropdownRef);
                  }
                },
                showScreenDialog: showScreenDialog
              },
              external_React_default().createElement(dropdowns.DropdownItem, {
                key: "call-hold",
                className: `
                            theme-dark-forced
                            ${this.isActive(onHold) ? "active" : ""}
                        `,
                label: callHoldLabel,
                icon: `sprite-fm-mono ${this.isActive(onHold) ? "icon-play" : "icon-pause"}`,
                onClick: onHoldClick
              }),
              external_React_default().createElement(dropdowns.DropdownItem, {
                key: "screen-sharing",
                className: `
                            theme-dark-forced
                            ${this.isActive(onHold) ? "disabled" : ""}
                            ${this.isActive(Screen) ? "active" : ""}
                        `,
                label: screenSharingLabel,
                icon: `sprite-fm-mono ${this.isActive(Screen) ? "icon-end-screenshare" : "icon-screen-share"}`,
                onClick: () => {
                  resetError(Av.Screen);
                  onScreenSharingClick();
                }
              }),
              hasToRenderPermissionsWarning(Screen) ? renderPermissionsWarning(Screen, this) : null
            )
          );
        }
      }
      FloatExtendedControls.NAMESPACE = "stream-extended-controls"; // CONCATENATED MODULE: ./js/chat/ui/meetings/micObserver.jsx
      const withMicObserver = (Component) =>
        class extends mixins.wl {
          constructor(props) {
            super(props);
            this.namespace = `SO-${Component.NAMESPACE}`;
            this.signalObserver = `onMicSignalDetected.${this.namespace}`;
            this.inputObserver = `onNoMicInput.${this.namespace}`;
            this.sendObserver = `onAudioSendDenied.${this.namespace}`;
            this.state = {
              signal: true,
              blocked: false
            };
            this.renderSignalWarning = this.renderSignalWarning.bind(this);
            this.renderBlockedWarning = this.renderBlockedWarning.bind(this);
          }
          unbindObservers() {
            [this.signalObserver, this.inputObserver].map((observer) => this.props.chatRoom.unbind(observer));
          }
          bindObservers() {
            this.props.chatRoom
              .rebind(this.signalObserver, ({ data: signal }) =>
                this.setState({
                  signal
                })
              )
              .rebind(this.inputObserver, () =>
                this.setState({
                  signal: false
                })
              )
              .rebind(this.sendObserver, () => {
                this.setState(
                  {
                    blocked: true
                  },
                  () => {
                    if (this.props.minimized) {
                      const toast = new ChatToast(l.max_speakers_toast, {
                        icon: "sprite-fm-uni icon-hazard",
                        close: true
                      });
                      toast.dispatch();
                    }
                  }
                );
              });
          }
          renderSignalDialog() {
            return msgDialog("warningb", null, l.no_mic_title, l.chat_mic_off_tooltip, null, 1);
          }
          renderSignalWarning() {
            return external_React_default().createElement(
              "div",
              {
                className: `
                    ${this.namespace}
                        meetings-signal-issue
                        simpletip
                    `,
                "data-simpletip": l.show_info,
                "data-simpletipposition": "top",
                "data-simpletipoffset": "5",
                "data-simpletip-class": "theme-dark-forced",
                onClick: () => this.renderSignalDialog()
              },
              external_React_default().createElement("i", {
                className: "sprite-fm-mono icon-exclamation-filled"
              })
            );
          }
          renderBlockedWarning() {
            return external_React_default().createElement(
              "div",
              {
                className: "stream-toast theme-dark-forced"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "stream-toast-content"
                },
                external_React_default().createElement("i", {
                  className: "stream-toast-icon sprite-fm-uni icon-warning"
                }),
                external_React_default().createElement(
                  "div",
                  {
                    className: "stream-toast-message"
                  },
                  l.max_speakers_toast
                ),
                external_React_default().createElement(meetings_button.Z, {
                  className: "mega-button action stream-toast-close",
                  icon: "sprite-fm-mono icon-close-component",
                  onClick: () =>
                    this.setState({
                      blocked: false
                    })
                })
              )
            );
          }
          componentWillUnmount() {
            super.componentWillUnmount();
            this.unbindObservers();
          }
          componentDidMount() {
            super.componentDidMount();
            this.bindObservers();
          }
          render() {
            return external_React_default().createElement(
              Component,
              (0, esm_extends.Z)({}, this.props, {
                signal: this.state.signal,
                renderSignalWarning: this.renderSignalWarning,
                blocked: this.state.blocked,
                renderBlockedWarning: this.renderBlockedWarning
              })
            );
          }
        };
      // EXTERNAL MODULE: ./js/chat/ui/meetings/permissionsObserver.jsx
      var permissionsObserver = __webpack_require__(209);
      // EXTERNAL MODULE: ./js/chat/ui/meetings/hostsObserver.jsx
      var hostsObserver = __webpack_require__(419); // CONCATENATED MODULE: ./js/chat/ui/meetings/float.jsx
      class FloatingVideo extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.collapseListener = null;
          this.state = {
            collapsed: false,
            ratio: undefined
          };
          this.gcd = (width, height) => {
            return height === 0 ? width : this.gcd(height, width % height);
          };
          this.getRatio = (width, height) => {
            return `${width / this.gcd(width, height)}:${height / this.gcd(width, height)}`;
          };
          this.getRatioClass = () => {
            const { ratio } = this.state;
            return ratio ? `ratio-${ratio.replace(":", "-")}` : "";
          };
          this.toggleCollapsedMode = () => {
            return this.setState((state) => ({
              collapsed: !state.collapsed
            }));
          };
          this.onLoadedData = (ev) => {
            const { videoWidth, videoHeight } = ev.target;
            this.setState({
              ratio: this.getRatio(videoWidth, videoHeight)
            });
          };
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          mBroadcaster.removeListener(this.collapseListener);
        }
        componentDidMount() {
          super.componentDidMount();
          this.collapseListener = mBroadcaster.addListener("meetings:collapse", () =>
            this.setState({
              collapsed: true
            })
          );
        }
        render() {
          const { peers, minimized, call, floatDetached } = this.props;
          if (peers.length === 0 && !minimized && !call.isSharingScreen()) {
            return null;
          }
          const STREAM_PROPS = {
            ...this.props,
            ratioClass: this.getRatioClass(),
            collapsed: this.state.collapsed,
            toggleCollapsedMode: this.toggleCollapsedMode,
            onLoadedData: this.onLoadedData
          };
          if (minimized) {
            return external_React_default().createElement(
              utils.ZP.RenderTo,
              {
                element: document.body
              },
              external_React_default().createElement(Stream, STREAM_PROPS)
            );
          }
          return floatDetached ? external_React_default().createElement(Stream, STREAM_PROPS) : null;
        }
      }
      FloatingVideo.NAMESPACE = "float-video";
      FloatingVideo.POSITION_MODIFIER = "with-sidebar";
      class Stream extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.containerRef = external_React_default().createRef();
          this.DRAGGABLE = {
            POSITION: {
              top: undefined,
              left: undefined
            },
            OPTIONS: {
              scroll: "false",
              cursor: "move",
              opacity: 1,
              start: () => {
                if (this.state.options) {
                  this.handleOptionsToggle();
                }
                $(document.body).trigger("closeAllDropdownsExcept");
              },
              stop: (event, ui) => {
                this.DRAGGABLE.POSITION = ui.position;
                const { clientWidth, clientHeight } = document.body;
                const { helper } = ui;
                const { left, top } = this.DRAGGABLE.POSITION;
                if (left < clientWidth / 2) {
                  helper.css("left", `${(left / clientWidth) * 100}%`).css("right", "unset");
                } else {
                  helper.css("left", "unset").css("right", `${clientWidth - left - helper.width()}px`);
                }
                if (top < clientHeight / 2) {
                  helper.css("top", `${(top / clientHeight) * 100}%`).css("bottom", "unset");
                } else {
                  helper.css("top", "unset").css("bottom", `${clientHeight - top - helper.height()}px`);
                }
              }
            }
          };
          this.EVENTS = {
            MINIMIZE: ["slideshow:open", "contact:open", "textEditor:open", "chat:open"],
            EXPAND: ["slideshow:close", "textEditor:close"]
          };
          this.LISTENERS = [];
          this.PREV_STATE = {};
          this.state = {
            options: false
          };
          this.getStreamSource = () => {
            const { call, mode, forcedLocal } = this.props;
            return mode === MODE.MINI && !forcedLocal ? call.getActiveStream() : call.getLocalStream();
          };
          this.unbindEvents = () => {
            const events = [...this.EVENTS.MINIMIZE, ...this.EVENTS.EXPAND];
            for (let i = events.length; i--; ) {
              const event = events[i];
              mBroadcaster.removeListener(this.LISTENERS[event]);
            }
            document.removeEventListener("click", this.handleOptionsClose);
          };
          this.bindEvents = () => {
            for (let i = this.EVENTS.MINIMIZE.length; i--; ) {
              const event = this.EVENTS.MINIMIZE[i];
              this.LISTENERS[event] = mBroadcaster.addListener(event, () => {
                this.PREV_STATE.minimised = this.props.minimized;
                return this.props.onCallMinimize();
              });
            }
            for (let i = this.EVENTS.EXPAND.length; i--; ) {
              const event = this.EVENTS.EXPAND[i];
              this.LISTENERS[event] = mBroadcaster.addListener(event, () => {
                if (this.PREV_STATE.minimised) {
                  delete this.PREV_STATE.minimised;
                  return;
                }
                delete this.PREV_STATE.minimised;
                return this.props.view === VIEW.CHAT && this.props.onCallExpand();
              });
            }
            document.addEventListener("click", this.handleOptionsClose);
          };
          this.initDraggable = () => {
            var _this$containerRef;
            const { minimized, wrapperRef } = this.props;
            const containerEl = (_this$containerRef = this.containerRef) == null ? void 0 : _this$containerRef.current;
            if (containerEl) {
              $(containerEl).draggable({
                ...this.DRAGGABLE.OPTIONS,
                containment: minimized ? "body" : wrapperRef == null ? void 0 : wrapperRef.current
              });
            }
          };
          this.repositionDraggable = () => {
            var _this$props$wrapperRe, _this$containerRef2;
            const wrapperEl = (_this$props$wrapperRe = this.props.wrapperRef) == null ? void 0 : _this$props$wrapperRe.current;
            const localEl = (_this$containerRef2 = this.containerRef) == null ? void 0 : _this$containerRef2.current;
            if (localEl.offsetLeft + localEl.offsetWidth > wrapperEl.offsetWidth) {
              localEl.style.left = "unset";
              localEl.style.removeProperty("right");
            }
          };
          this.handleOptionsClose = ({ target }) => {
            if (this.state.options && !target.classList.contains("icon-options")) {
              this.setState({
                options: false
              });
            }
          };
          this.handleOptionsToggle = () =>
            this.setState({
              options: !this.state.options
            });
          this.renderOnHoldVideoNode = () =>
            external_React_default().createElement(LocalVideoHiRes, {
              chatRoom: this.props.chatRoom
            });
          this.renderOptionsDialog = () => {
            const { call, mode, forcedLocal, onScreenSharingClick, onSpeakerChange, onModeChange, toggleCollapsedMode, onMoveIntoGrid } =
              this.props;
            const IS_SPEAKER_VIEW = mode === MODE.MAIN && forcedLocal;
            const { POSITION } = this.DRAGGABLE;
            return external_React_default().createElement(
              "div",
              {
                className: `
                     ${FloatingVideo.NAMESPACE}-options
                     ${POSITION.left < 200 ? "options-top" : ""}
                     ${POSITION.left < 200 && POSITION.top < 100 ? "options-bottom" : ""}
                     theme-dark-forced
                 `
              },
              external_React_default().createElement(
                "ul",
                null,
                external_React_default().createElement(
                  "li",
                  null,
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      icon: `
                                sprite-fm-mono
                                ${IS_SPEAKER_VIEW ? "grid-9" : "grid-main"}
                            `,
                      onClick: () =>
                        this.setState(
                          {
                            options: false
                          },
                          () => {
                            if (IS_SPEAKER_VIEW) {
                              return onModeChange(MODE.THUMBNAIL);
                            }
                            onSpeakerChange(call.getLocalStream());
                          }
                        )
                    },
                    external_React_default().createElement("div", null, IS_SPEAKER_VIEW ? l.switch_to_thumb_view : l.display_in_main_view)
                  )
                ),
                external_React_default().createElement(
                  "li",
                  null,
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      icon: "sprite-fm-mono icon-collapse-up",
                      onClick: onMoveIntoGrid
                    },
                    external_React_default().createElement("div", null, l.move_into_grid_button)
                  )
                ),
                external_React_default().createElement(
                  "li",
                  null,
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      icon: "sprite-fm-mono icon-download-standard",
                      onClick: () =>
                        this.setState(
                          {
                            options: false
                          },
                          () => toggleCollapsedMode()
                        )
                    },
                    external_React_default().createElement("div", null, l.collapse_self_video)
                  )
                )
              ),
              !!(call.av & SfuClient.Av.Screen) &&
                external_React_default().createElement(
                  "ul",
                  {
                    className: "has-separator"
                  },
                  external_React_default().createElement(
                    "li",
                    null,
                    external_React_default().createElement(
                      meetings_button.Z,
                      {
                        className: "end-screen-share",
                        icon: "icon-end-screenshare",
                        onClick: () => {
                          this.setState({
                            options: false
                          });
                          onScreenSharingClick();
                        }
                      },
                      external_React_default().createElement("div", null, l[22890])
                    )
                  )
                )
            );
          };
          this.renderMiniMode = () => {
            const { call, mode, onLoadedData } = this.props;
            if (call.sfuClient.isOnHold()) {
              return this.renderOnHoldVideoNode();
            }
            const source = this.getStreamSource();
            const VideoClass = source.isLocal ? LocalVideoThumb : PeerVideoHiRes;
            return external_React_default().createElement(VideoClass, {
              chatRoom: this.props.chatRoom,
              mode: mode,
              onLoadedData: onLoadedData,
              source: source,
              key: source
            });
          };
          this.renderSelfView = () => {
            const { isOnHold, minimized, onLoadedData, chatRoom } = this.props;
            const { options } = this.state;
            if (isOnHold) {
              return this.renderOnHoldVideoNode();
            }
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              external_React_default().createElement(LocalVideoThumb, {
                isSelfOverlay: true,
                minimized: minimized,
                chatRoom: chatRoom,
                onLoadedData: onLoadedData
              }),
              external_React_default().createElement(
                "div",
                {
                  className: `${FloatingVideo.NAMESPACE}-self-overlay`
                },
                minimized
                  ? null
                  : external_React_default().createElement(meetings_button.Z, {
                      className: `
                                mega-button
                                theme-light-forced
                                action
                                small
                                float-video-options-control
                                ${options ? "active" : ""}
                            `,
                      icon: "sprite-fm-mono icon-options",
                      onClick: () => this.handleOptionsToggle()
                    }),
                options && this.renderOptionsDialog()
              )
            );
          };
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          this.unbindEvents();
        }
        componentDidUpdate(prevProps) {
          super.componentDidUpdate();
          if (this.props.mode !== prevProps.mode) {
            this.initDraggable();
          }
          if (this.props.sidebar !== prevProps.sidebar && this.props.sidebar) {
            this.repositionDraggable();
          }
        }
        componentDidMount() {
          super.componentDidMount();
          this.bindEvents();
          this.initDraggable();
        }
        render() {
          const { NAMESPACE, POSITION_MODIFIER } = FloatingVideo;
          const { mode, minimized, sidebar, ratioClass, collapsed, toggleCollapsedMode, onCallExpand } = this.props;
          const IS_MINI_MODE = mode === MODE.MINI;
          if (collapsed) {
            return external_React_default().createElement(
              "div",
              {
                ref: this.containerRef,
                className: `
                        ${NAMESPACE}
                        collapsed
                        theme-dark-forced
                        ${sidebar && !minimized ? POSITION_MODIFIER : ""}
                    `,
                onClick: toggleCollapsedMode
              },
              external_React_default().createElement("i", {
                className: "sprite-fm-mono icon-arrow-up"
              })
            );
          }
          return external_React_default().createElement(
            "div",
            {
              ref: this.containerRef,
              className: `
                    ${NAMESPACE}
                    ${this.getStreamSource().isStreaming() ? ratioClass : ""}
                    ${IS_MINI_MODE ? "mini" : ""}
                    ${minimized ? "minimized" : ""}
                    ${this.state.options ? "active" : ""}
                    ${sidebar && !minimized ? POSITION_MODIFIER : ""}
                `,
              onClick: ({ target }) => minimized && target.classList.contains(`${NAMESPACE}-overlay`) && onCallExpand()
            },
            IS_MINI_MODE && this.renderMiniMode(),
            !IS_MINI_MODE && this.renderSelfView(),
            minimized &&
              external_React_default().createElement(
                __Minimized,
                (0, esm_extends.Z)({}, this.props, {
                  onOptionsToggle: this.handleOptionsToggle
                })
              )
          );
        }
      }
      class Minimized extends mixins.wl {
        constructor(props) {
          super(props);
          this.SIMPLETIP_PROPS = {
            position: "top",
            offset: 5,
            className: "theme-dark-forced"
          };
          this.waitingPeersListener = undefined;
          this.state = {
            unread: 0,
            waitingRoomPeers: []
          };
          this.isActive = (type) => {
            return this.props.call.av & type;
          };
          this.getUnread = () => {
            const { chatRoom } = this.props;
            chatRoom.rebind(Minimized.UNREAD_EVENT, () =>
              this.setState(
                {
                  unread: chatRoom.getUnreadCount()
                },
                () => this.safeForceUpdate()
              )
            );
          };
          this.renderSignalWarning = () => (this.props.signal ? null : this.props.renderSignalWarning());
          this.renderPermissionsWarning = (type) => {
            const { hasToRenderPermissionsWarning, renderPermissionsWarning } = this.props;
            if (hasToRenderPermissionsWarning(type)) {
              return renderPermissionsWarning(type, this);
            }
            return null;
          };
          this.renderStreamControls = () => {
            const {
              call,
              chatRoom,
              hasToRenderPermissionsWarning,
              renderPermissionsWarning,
              resetError,
              onAudioClick,
              onVideoClick,
              onScreenSharingClick,
              onHoldClick,
              onCallEnd
            } = this.props;
            const audioLabel = this.isActive(SfuClient.Av.Audio) ? l[16214] : l[16708];
            const videoLabel = this.isActive(SfuClient.Av.Camera) ? l[22894] : l[22893];
            const LeaveButton = (0, hostsObserver.N)(({ hasHost, chatRoom, confirmLeave, onLeave }) => {
              return external_React_default().createElement(
                meetings_button.Z,
                {
                  simpletip: {
                    ...this.SIMPLETIP_PROPS,
                    label: l[5884]
                  },
                  className: "mega-button theme-dark-forced round large end-call",
                  icon: "icon-end-call",
                  onClick: (ev) => {
                    ev.stopPropagation();
                    const callParticipants = chatRoom.getCallParticipants();
                    return hasHost(callParticipants) || callParticipants.length === 1
                      ? onLeave()
                      : confirmLeave({
                          title: l.assign_host_leave_call,
                          body: l.assign_host_leave_call_details,
                          cta: l.assign_host_button
                        });
                  }
                },
                external_React_default().createElement("span", null, l[5884])
              );
            });
            return external_React_default().createElement(
              "div",
              {
                className: `${FloatingVideo.NAMESPACE}-controls`
              },
              external_React_default().createElement(
                "div",
                {
                  className: "meetings-signal-container"
                },
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    simpletip: {
                      ...this.SIMPLETIP_PROPS,
                      label: audioLabel
                    },
                    className: `
                            mega-button
                            theme-light-forced
                            round
                            large
                            ${this.isActive(SfuClient.Av.onHold) ? "disabled" : ""}
                            ${this.isActive(SfuClient.Av.Audio) ? "" : "inactive"}
                        `,
                    icon: this.isActive(SfuClient.Av.Audio) ? "icon-audio-filled" : "icon-audio-off",
                    onClick: (ev) => {
                      ev.stopPropagation();
                      resetError(Av.Audio);
                      onAudioClick();
                    }
                  },
                  external_React_default().createElement("span", null, audioLabel)
                ),
                this.renderSignalWarning(),
                this.renderPermissionsWarning(Av.Audio)
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "meetings-signal-container"
                },
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    simpletip: {
                      ...this.SIMPLETIP_PROPS,
                      label: videoLabel
                    },
                    className: `
                            mega-button
                            theme-light-forced
                            round
                            large
                            ${this.isActive(SfuClient.Av.onHold) ? "disabled" : ""}
                            ${this.isActive(SfuClient.Av.Camera) ? "" : "inactive"}
                        `,
                    icon: this.isActive(SfuClient.Av.Camera) ? "icon-video-call-filled" : "icon-video-off",
                    onClick: (ev) => {
                      ev.stopPropagation();
                      resetError(Av.Camera);
                      onVideoClick();
                    }
                  },
                  external_React_default().createElement("span", null, videoLabel)
                ),
                this.renderPermissionsWarning(Av.Camera)
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "meetings-signal-container"
                },
                external_React_default().createElement(FloatExtendedControls, {
                  call: call,
                  chatRoom: chatRoom,
                  onScreenSharingClick: onScreenSharingClick,
                  onHoldClick: onHoldClick,
                  hasToRenderPermissionsWarning: hasToRenderPermissionsWarning,
                  renderPermissionsWarning: renderPermissionsWarning,
                  resetError: resetError,
                  showScreenDialog: !!this.props[`dialog-${Av.Screen}`]
                }),
                this.renderPermissionsWarning(Av.Screen)
              ),
              external_React_default().createElement(LeaveButton, {
                chatRoom: chatRoom,
                participants: chatRoom.getCallParticipants(),
                onLeave: onCallEnd
              })
            );
          };
          this.renderPeersWaiting = () => {
            const { waitingRoomPeers } = this.state;
            return external_React_default().createElement(
              "div",
              {
                className: `
                    ${FloatingVideo.NAMESPACE}-alert
                    theme-dark-forced
                `,
                onClick: this.props.onCallExpand
              },
              waitingRoomPeers.length > 1
                ? l.wr_peers_waiting.replace("%1", waitingRoomPeers.length)
                : external_React_default().createElement(utils.Cw, {
                    tag: "span",
                    content: l.wr_peer_waiting.replace("%s", megaChat.html(M.getNameByHandle(waitingRoomPeers[0])))
                  })
            );
          };
          this.state.waitingRoomPeers = this.props.waitingRoomPeers || [];
        }
        componentDidMount() {
          super.componentDidMount();
          this.getUnread();
          this.waitingPeersListener = mBroadcaster.addListener("meetings:peersWaiting", (waitingRoomPeers) =>
            this.setState(
              {
                waitingRoomPeers
              },
              () => this.safeForceUpdate()
            )
          );
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          this.props.chatRoom.unbind(Minimized.UNREAD_EVENT);
          if (this.waitingPeersListener) {
            mBroadcaster.removeListener(this.waitingPeersListener);
          }
        }
        render() {
          const { onCallExpand } = this.props;
          const { unread, waitingRoomPeers } = this.state;
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            external_React_default().createElement(
              "div",
              {
                className: `${FloatingVideo.NAMESPACE}-overlay`
              },
              external_React_default().createElement(meetings_button.Z, {
                simpletip: {
                  ...this.SIMPLETIP_PROPS,
                  label: l.expand_mini_call
                },
                className: "mega-button theme-light-forced action small expand",
                icon: "sprite-fm-mono icon-call-expand-mode",
                onClick: (ev) => {
                  ev.stopPropagation();
                  onCallExpand();
                }
              }),
              this.renderStreamControls()
            ),
            waitingRoomPeers && waitingRoomPeers.length ? this.renderPeersWaiting() : null,
            unread
              ? external_React_default().createElement(
                  "div",
                  {
                    className: `${FloatingVideo.NAMESPACE}-notifications`
                  },
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      className: "mega-button round large chat-control",
                      icon: "icon-chat-filled"
                    },
                    external_React_default().createElement("span", null, l.chats)
                  ),
                  external_React_default().createElement("span", null, unread > 9 ? "9+" : unread)
                )
              : null
          );
        }
      }
      Minimized.NAMESPACE = "float-video-minimized";
      Minimized.UNREAD_EVENT = "onUnreadCountUpdate.localStreamNotifications";
      const __Minimized = (0, mixins.qC)(withMicObserver, permissionsObserver.Q)(Minimized); // CONCATENATED MODULE: ./js/chat/ui/meetings/participantsNotice.jsx
      class ParticipantsNotice extends mixins.wl {
        constructor(props) {
          super(props);
          this.renderUserAlone = () =>
            external_React_default().createElement(
              "div",
              {
                className: `
                ${ParticipantsNotice.NAMESPACE}
                theme-dark-forced
                user-alone
            `
              },
              this.props.stayOnEnd
                ? external_React_default().createElement(
                    "div",
                    {
                      className: `${ParticipantsNotice.NAMESPACE}-heading`
                    },
                    external_React_default().createElement("h1", null, this.props.everHadPeers ? l.only_one_here : l.waiting_for_others)
                  )
                : external_React_default().createElement(
                    "div",
                    {
                      className: `${ParticipantsNotice.NAMESPACE}-content user-alone`
                    },
                    external_React_default().createElement("h3", null, l.only_one_here),
                    external_React_default().createElement(
                      "p",
                      {
                        className: "theme-dark-forced"
                      },
                      external_React_default().createElement(utils.Cw, null, l.empty_call_dlg_text.replace("%s", "2"))
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "notice-footer"
                      },
                      external_React_default().createElement(
                        meetings_button.Z,
                        {
                          className: "mega-button large stay-on-call",
                          onClick: this.props.onStayConfirm
                        },
                        external_React_default().createElement("span", null, l.empty_call_stay_button)
                      ),
                      external_React_default().createElement(
                        meetings_button.Z,
                        {
                          className: "mega-button positive large stay-on-call",
                          onClick: this.props.onCallEnd
                        },
                        external_React_default().createElement("span", null, l.empty_call_dlg_end)
                      )
                    )
                  )
            );
          this.renderUserWaiting = () => {
            const { chatRoom, onInviteToggle } = this.props;
            const link = `${getBaseUrl()}/${chatRoom.publicLink}`;
            return external_React_default().createElement(
              "div",
              {
                className: `
                    ${ParticipantsNotice.NAMESPACE}
                    ${chatRoom.isMeeting ? "" : "user-alone"}
                    theme-dark-forced
                `
              },
              external_React_default().createElement(
                "div",
                {
                  className: `${ParticipantsNotice.NAMESPACE}-heading`
                },
                chatRoom.type === "private"
                  ? external_React_default().createElement(
                      "h1",
                      null,
                      external_React_default().createElement(utils.dy, null, l.waiting_for_peer.replace("%NAME", chatRoom.getRoomTitle()))
                    )
                  : external_React_default().createElement("h1", null, l.waiting_for_others)
              ),
              chatRoom.isMeeting &&
                chatRoom.publicLink &&
                external_React_default().createElement(
                  "div",
                  {
                    className: `${ParticipantsNotice.NAMESPACE}-content`
                  },
                  external_React_default().createElement("h3", null, l.copy_and_share),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "mega-input with-icon box-style"
                    },
                    external_React_default().createElement("i", {
                      className: "sprite-fm-mono icon-link"
                    }),
                    external_React_default().createElement("input", {
                      type: "text",
                      className: "megaInputs",
                      readOnly: true,
                      defaultValue: link
                    })
                  ),
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      className: "mega-button positive large copy-to-clipboard",
                      onClick: () => copyToClipboard(link, l[7654])
                    },
                    external_React_default().createElement("span", null, l[17835])
                  ),
                  Call.isModerator(chatRoom, u_handle) &&
                    external_React_default().createElement(
                      "div",
                      {
                        className: "peers-invite"
                      },
                      external_React_default().createElement("hr", null),
                      external_React_default().createElement(
                        meetings_button.Z,
                        {
                          className: "mega-button action",
                          onClick: onInviteToggle
                        },
                        l.invite_from_contact_list
                      )
                    )
                )
            );
          };
          this.av = this.props.call.sfuClient.availAv;
        }
        specShouldComponentUpdate(newProps) {
          const { stayOnEnd, hasLeft, isOnHold, call } = this.props;
          const currAv = this.av;
          this.av = call.sfuClient.availAv;
          return newProps.stayOnEnd !== stayOnEnd || newProps.hasLeft !== hasLeft || newProps.isOnHold !== isOnHold || this.av !== currAv;
        }
        render() {
          const { call, hasLeft, streamContainer, chatRoom } = this.props;
          if (call.isDestroyed) {
            return null;
          }
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            call.isSharingScreen()
              ? null
              : external_React_default().createElement(LocalVideoHiRes, {
                  className: "local-stream-mirrored",
                  chatRoom: chatRoom,
                  source: call.getLocalStream()
                }),
            streamContainer(hasLeft ? this.renderUserAlone() : this.renderUserWaiting())
          );
        }
      }
      ParticipantsNotice.NAMESPACE = "participants-notice";
      // EXTERNAL MODULE: ./js/chat/ui/chatToaster.jsx
      var chatToaster = __webpack_require__(142); // CONCATENATED MODULE: ./js/chat/ui/meetings/participantsBlock.jsx
      const MAX_STREAMS_PER_PAGE = 10;
      const SIMPLE_TIP = {
        position: "top",
        offset: 5,
        className: "theme-dark-forced"
      };
      class ParticipantsBlock extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.nodeMenuRef = external_React_default().createRef();
          this.state = {
            page: 0
          };
          this.movePage = (direction) =>
            this.setState((state) => ({
              page: direction === PAGINATION.NEXT ? state.page + 1 : state.page - 1
            }));
          this.renderLocalNode = () => {
            const { call, peers, mode, chatRoom, forcedLocal, onSeparate, onSpeakerChange, onModeChange } = this.props;
            const localStream = call.getLocalStream();
            if (localStream) {
              const IS_SPEAKER_VIEW = mode === MODE.MAIN && forcedLocal;
              return external_React_default().createElement(
                LocalVideoThumb,
                {
                  key: u_handle,
                  className: `
                        local-stream-node
                        ${call.isSharingScreen() ? "" : "local-stream-mirrored"}
                        ${forcedLocal ? "active" : ""}
                    `,
                  simpletip: {
                    ...SIMPLE_TIP,
                    label: l[8885]
                  },
                  mode: mode,
                  chatRoom: chatRoom,
                  source: localStream,
                  localAudioMuted: !(call.av & SfuClient.Av.Audio),
                  onClick: (source, ev) => {
                    const nodeMenuRef = this.nodeMenuRef && this.nodeMenuRef.current;
                    if (nodeMenuRef && nodeMenuRef.contains(ev.target)) {
                      ev.preventDefault();
                      ev.stopPropagation();
                      return;
                    }
                    return onSpeakerChange(localStream);
                  }
                },
                (peers == null ? void 0 : peers.length) &&
                  external_React_default().createElement(
                    "div",
                    {
                      ref: this.nodeMenuRef,
                      className: "node-menu theme-dark-forced"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: "node-menu-toggle"
                      },
                      external_React_default().createElement("i", {
                        className: "sprite-fm-mono icon-options"
                      })
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "node-menu-content"
                      },
                      external_React_default().createElement(
                        "ul",
                        null,
                        external_React_default().createElement(
                          "li",
                          null,
                          external_React_default().createElement(
                            meetings_button.Z,
                            {
                              icon: `
                                            sprite-fm-mono
                                            ${IS_SPEAKER_VIEW ? "grid-9" : "grid-main"}
                                        `,
                              onClick: () => {
                                if (IS_SPEAKER_VIEW) {
                                  return onModeChange(MODE.THUMBNAIL);
                                }
                                return onSpeakerChange(localStream);
                              }
                            },
                            external_React_default().createElement(
                              "span",
                              null,
                              IS_SPEAKER_VIEW ? l.switch_to_thumb_view : l.display_in_main_view
                            )
                          )
                        ),
                        external_React_default().createElement(
                          "li",
                          null,
                          external_React_default().createElement(
                            meetings_button.Z,
                            {
                              icon: "sprite-fm-mono grid-separate",
                              onClick: onSeparate
                            },
                            external_React_default().createElement("span", null, l.separate_from_grid_button)
                          )
                        )
                      )
                    )
                  )
              );
            }
            return null;
          };
        }
        shouldComponentUpdate() {
          const { peers } = this.props;
          return peers && peers.length;
        }
        render() {
          const { call, mode, peers, floatDetached, chatRoom, onSpeakerChange } = this.props;
          if (peers && peers.length) {
            const filteredPeers = Object.values(peers).filter((p) => p instanceof CallManager2.Peer);
            const streaming = [...filteredPeers.filter((p) => p.isScreen), ...filteredPeers.filter((p) => !p.videoMuted)];
            const rest = filteredPeers.filter((p) => !streaming.includes(p));
            const $$PEER = (peer) =>
              external_React_default().createElement(PeerVideoThumb, {
                key: `${peer.userHandle}--${peer.clientId}`,
                className: peer.isActive || peer.clientId === call.forcedActiveStream ? "active" : "",
                simpletip: {
                  ...SIMPLE_TIP,
                  label: M.getNameByHandle(peer.userHandle)
                },
                mode: mode,
                chatRoom: chatRoom,
                source: peer,
                onClick: onSpeakerChange
              });
            if (peers.length <= (floatDetached ? MAX_STREAMS_PER_PAGE : 9)) {
              return external_React_default().createElement(
                "div",
                {
                  className: "stream-participants-block theme-dark-forced"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "participants-container"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: `
                                    participants-grid
                                    ${(floatDetached && peers.length === 1) || peers.length === 0 ? "single-column" : ""}
                                `
                    },
                    floatDetached
                      ? [...streaming, ...rest].map((p) => $$PEER(p))
                      : [...streaming, this.renderLocalNode(), ...rest].map((p) => (p instanceof CallManager2.Peer ? $$PEER(p) : p))
                  )
                )
              );
            }
            const { page } = this.state;
            const chunks = chunkNodes(
              floatDetached
                ? [...streaming, ...rest]
                : [...streaming, Object.values(peers).find((p) => !(p instanceof CallManager2.Peer)), ...rest],
              MAX_STREAMS_PER_PAGE
            );
            return external_React_default().createElement(
              "div",
              {
                className: "carousel"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "carousel-container"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "stream-participants-block theme-dark-forced"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "participants-container"
                    },
                    Object.values(chunks).map((chunk, i) => {
                      const { id, nodes } = chunk;
                      return external_React_default().createElement(
                        "div",
                        {
                          key: id,
                          className: `
                                                carousel-page
                                                ${i === page ? "active" : ""}
                                            `
                        },
                        page === 0
                          ? null
                          : external_React_default().createElement(
                              "button",
                              {
                                className: "carousel-control carousel-button-prev theme-dark-forced",
                                onClick: () => this.movePage(PAGINATION.PREV)
                              },
                              external_React_default().createElement("i", {
                                className: "sprite-fm-mono icon-arrow-up"
                              })
                            ),
                        external_React_default().createElement(
                          "div",
                          {
                            className: `
                                                    participants-grid
                                                    ${nodes.length === 1 ? "single-column" : ""}
                                                `
                          },
                          nodes.map((peer) => {
                            if (peer instanceof CallManager2.Peer) {
                              return $$PEER(peer);
                            }
                            return this.renderLocalNode();
                          })
                        ),
                        page >= Object.values(chunks).length - 1
                          ? null
                          : external_React_default().createElement(
                              "button",
                              {
                                className: "carousel-control carousel-button-next theme-dark-forced",
                                onClick: () => this.movePage(PAGINATION.NEXT)
                              },
                              external_React_default().createElement("i", {
                                className: "sprite-fm-mono icon-arrow-down"
                              })
                            )
                      );
                    })
                  )
                )
              )
            );
          }
          return null;
        }
      }
      // EXTERNAL MODULE: ./js/ui/modalDialogs.jsx + 1 modules
      var modalDialogs = __webpack_require__(182); // CONCATENATED MODULE: ./js/chat/ui/meetings/modeSwitch.jsx
      class ModeSwitch extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.containerRef = external_React_default().createRef();
          this.state = {
            expanded: false,
            settings: false
          };
          this.handleMousedown = ({ target }) =>
            this.containerRef && this.containerRef.current && this.containerRef.current.contains(target) ? null : this.doClose();
          this.handleKeydown = ({ keyCode }) => keyCode && keyCode === 27 && this.doClose();
          this.doClose = () =>
            this.isMounted() &&
            this.setState({
              expanded: false,
              settings: false
            });
          this.doToggle = () =>
            this.isMounted() &&
            this.setState((state) => ({
              expanded: !state.expanded
            }));
          this.setStreamsPerPage = (streamsPerPage) => {
            if (streamsPerPage) {
              var _this$props$onStreams, _this$props;
              (_this$props$onStreams = (_this$props = this.props).onStreamsPerPageChange) == null ||
                _this$props$onStreams.call(_this$props, streamsPerPage);
              this.doClose();
            }
          };
          this.getModeIcon = (mode) => {
            switch (mode) {
              case MODE.THUMBNAIL:
                return "grid-9";
              case MODE.MAIN:
                return "grid-main";
              default:
                return null;
            }
          };
          this.Toggle = () => {
            const { mode } = this.props;
            return external_React_default().createElement(
              "div",
              {
                className: `${ModeSwitch.BASE_CLASS}-toggle`,
                onClick: this.doToggle
              },
              external_React_default().createElement(
                meetings_button.Z,
                null,
                external_React_default().createElement("i", {
                  className: `sprite-fm-mono ${this.getModeIcon(mode)}`
                }),
                mode === MODE.THUMBNAIL && external_React_default().createElement("div", null, l.thumbnail_view),
                mode === MODE.MAIN && external_React_default().createElement("div", null, l.main_view)
              ),
              external_React_default().createElement("i", {
                className: "sprite-fm-mono icon-arrow-down"
              })
            );
          };
          this.Option = ({ label, mode }) => {
            return external_React_default().createElement(
              "div",
              {
                className: `
                    ${ModeSwitch.BASE_CLASS}-option
                    ${mode === this.props.mode ? "active" : ""}
                `,
                onClick: () => {
                  this.doToggle();
                  this.props.onModeChange(mode);
                }
              },
              external_React_default().createElement(
                meetings_button.Z,
                null,
                external_React_default().createElement("i", {
                  className: `sprite-fm-mono ${this.getModeIcon(mode)}`
                }),
                external_React_default().createElement("div", null, label)
              )
            );
          };
          this.Settings = () => {
            const { streamsPerPage } = this.props;
            return external_React_default().createElement(
              "div",
              {
                className: `${ModeSwitch.BASE_CLASS}-settings`
              },
              external_React_default().createElement(
                "div",
                {
                  className: "settings-wrapper"
                },
                external_React_default().createElement("strong", null, l.layout_settings_heading),
                external_React_default().createElement("span", null, l.layout_settings_info),
                external_React_default().createElement(
                  "div",
                  {
                    className: "recurring-radio-buttons"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "recurring-label-wrap"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: `
                                    uiTheme
                                    ${streamsPerPage === STREAMS_PER_PAGE.MIN ? "radioOn" : "radioOff"}
                                `
                      },
                      external_React_default().createElement("input", {
                        type: "radio",
                        name: "9",
                        onClick: () => this.setStreamsPerPage(STREAMS_PER_PAGE.MIN)
                      })
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "radio-txt"
                      },
                      external_React_default().createElement(
                        "span",
                        {
                          className: "recurring-radio-label",
                          onClick: () => this.setStreamsPerPage(STREAMS_PER_PAGE.MIN)
                        },
                        "9"
                      )
                    )
                  ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "recurring-label-wrap"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: `
                                    uiTheme
                                    ${streamsPerPage === STREAMS_PER_PAGE.MED ? "radioOn" : "radioOff"}
                                `
                      },
                      external_React_default().createElement("input", {
                        type: "radio",
                        name: "21",
                        onClick: () => {
                          this.setStreamsPerPage(STREAMS_PER_PAGE.MED);
                        }
                      })
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "radio-txt"
                      },
                      external_React_default().createElement(
                        "span",
                        {
                          className: "recurring-radio-label",
                          onClick: () => this.setStreamsPerPage(STREAMS_PER_PAGE.MED)
                        },
                        "21"
                      )
                    )
                  ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "recurring-label-wrap"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: `
                                    uiTheme
                                    ${streamsPerPage === STREAMS_PER_PAGE.MAX ? "radioOn" : "radioOff"}
                                `
                      },
                      external_React_default().createElement("input", {
                        type: "radio",
                        name: "49",
                        onClick: () => {
                          this.setStreamsPerPage(STREAMS_PER_PAGE.MAX);
                        }
                      })
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "radio-txt"
                      },
                      external_React_default().createElement(
                        "span",
                        {
                          className: "recurring-radio-label",
                          onClick: () => this.setStreamsPerPage(STREAMS_PER_PAGE.MAX)
                        },
                        "49"
                      )
                    )
                  )
                ),
                external_React_default().createElement("small", null, l.layout_settings_warning)
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "settings-close"
                },
                external_React_default().createElement("i", {
                  className: "sprite-fm-mono icon-dialog-close",
                  onClick: this.doClose
                })
              )
            );
          };
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          document.removeEventListener("mousedown", this.handleMousedown);
          document.removeEventListener("keydown", this.handleKeydown);
        }
        componentDidMount() {
          super.componentDidMount();
          document.addEventListener("mousedown", this.handleMousedown);
          document.addEventListener("keydown", this.handleKeydown);
        }
        render() {
          const { Toggle, Option, Settings, containerRef, state, doToggle } = this;
          return external_React_default().createElement(
            "div",
            {
              ref: containerRef,
              className: ModeSwitch.BASE_CLASS
            },
            external_React_default().createElement(Toggle, null),
            external_React_default().createElement(
              "div",
              {
                className: `
                        ${ModeSwitch.BASE_CLASS}-menu
                        ${state.expanded ? "expanded" : ""}
                    `
              },
              external_React_default().createElement(Option, {
                label: l.main_view,
                mode: MODE.MAIN
              }),
              external_React_default().createElement(Option, {
                label: l.thumbnail_view,
                mode: MODE.THUMBNAIL
              }),
              external_React_default().createElement(
                "div",
                {
                  className: `${ModeSwitch.BASE_CLASS}-option`,
                  onClick: () =>
                    this.setState(
                      {
                        settings: true
                      },
                      doToggle
                    )
                },
                external_React_default().createElement(
                  meetings_button.Z,
                  null,
                  external_React_default().createElement("i", {
                    className: "sprite-fm-mono icon-settings"
                  }),
                  external_React_default().createElement("div", null, l.layout_settings_button)
                )
              )
            ),
            state.settings && external_React_default().createElement(Settings, null)
          );
        }
      }
      ModeSwitch.NAMESPACE = "modeSwitch";
      ModeSwitch.BASE_CLASS = "mode"; // CONCATENATED MODULE: ./js/chat/ui/meetings/streamHead.jsx
      class StreamHead extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.delayProcID = null;
          this.headRef = external_React_default().createRef();
          this.durationRef = external_React_default().createRef();
          this.dialogRef = external_React_default().createRef();
          this.topicRef = external_React_default().createRef();
          this.interval = undefined;
          this.state = {
            dialog: false,
            duration: undefined,
            banner: false
          };
          this.updateDurationDOM = () => {
            if (this.durationRef) {
              this.durationRef.current.innerText = this.durationString;
            }
          };
          this.closeTooltips = () => {
            for (const node of this.headRef.current.querySelectorAll(".simpletip")) {
              node.dispatchEvent(StreamHead.EVENTS.SIMPLETIP);
            }
          };
          this.toggleFullscreen = () => (this.fullscreen ? document.exitFullscreen() : document.documentElement.requestFullscreen());
          this.toggleBanner = (callback) =>
            this.setState(
              (state) => ({
                banner: !state.banner
              }),
              () => callback && callback()
            );
          this.handleDialogClose = ({ target }) => {
            if (this.state.dialog) {
              const { topicRef, dialogRef, delayProcID } = this;
              const topicElement = topicRef && topicRef.current;
              const dialogElement = dialogRef && dialogRef.current && dialogRef.current.domNode;
              if (topicElement.contains(target)) {
                return;
              }
              return (
                (target.classList.contains("icon-dialog-close") || !dialogElement.contains(target)) &&
                this.setState(
                  {
                    dialog: false
                  },
                  () => delayProcID && delay.cancel(delayProcID)
                )
              );
            }
          };
          this.getModerators = () => {
            var _this$props$chatRoom;
            const members = (_this$props$chatRoom = this.props.chatRoom) == null ? void 0 : _this$props$chatRoom.members;
            if (members) {
              const moderators = [];
              for (const [handle, role] of Object.entries(members)) {
                if (role === ChatRoom.MembersSet.PRIVILEGE_STATE.OPERATOR) {
                  moderators.push(M.getNameByHandle(handle));
                }
              }
              return mega.utils.trans.listToString(moderators, mega.icu.format(l.meeting_moderators, moderators.length));
            }
          };
          this.Dialog = () => {
            const link = `${getBaseUrl()}/${this.props.chatRoom.publicLink}`;
            const mods = this.getModerators();
            return external_React_default().createElement(
              modalDialogs.Z.ModalDialog,
              (0, esm_extends.Z)(
                {
                  ref: this.dialogRef
                },
                this.state,
                {
                  mods: mods,
                  name: "meeting-info-dialog",
                  title: l[18132],
                  className: "group-chat-link dialog-template-main theme-dark-forced in-call-info",
                  hideOverlay: true
                }
              ),
              external_React_default().createElement(
                "section",
                {
                  className: "content"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "content-block"
                  },
                  external_React_default().createElement(
                    utils.dy,
                    {
                      className: "info"
                    },
                    mods
                  ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "info"
                    },
                    l.copy_and_share
                  ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "link-input-container"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: "mega-input with-icon box-style"
                      },
                      external_React_default().createElement("i", {
                        className: "sprite-fm-mono icon-link"
                      }),
                      external_React_default().createElement("input", {
                        type: "text",
                        className: "megaInputs",
                        readOnly: true,
                        value: link
                      })
                    ),
                    external_React_default().createElement(
                      meetings_button.Z,
                      {
                        className: "mega-button positive copy-to-clipboard",
                        onClick: () => {
                          if (copyToClipboard(link)) {
                            this.toggleBanner(() => {
                              this.delayProcID = delay(`${StreamHead.NAMESPACE}-banner`, this.toggleBanner, 10000);
                            });
                          }
                        }
                      },
                      external_React_default().createElement("span", null, l[63])
                    )
                  ),
                  this.state.banner &&
                    external_React_default().createElement(
                      "div",
                      {
                        className: "banner-copy-success"
                      },
                      l[7654]
                    )
                )
              ),
              external_React_default().createElement(
                "footer",
                null,
                external_React_default().createElement("div", {
                  className: "footer-container"
                })
              )
            );
          };
          this.Pagination = () => {
            const { mode, peers, page, streamsPerPage, floatDetached, chunksLength, onMovePage } = this.props;
            if (mode === MODE.THUMBNAIL && peers && peers.length > (floatDetached ? streamsPerPage : streamsPerPage - 1)) {
              return external_React_default().createElement(
                "div",
                {
                  className: `${StreamHead.NAMESPACE}-pagination`
                },
                external_React_default().createElement(meetings_button.Z, {
                  className: `
                            carousel-button-prev
                            theme-dark-forced
                            ${page !== 0 ? "" : "disabled"}
                        `,
                  icon: "sprite-fm-mono icon-arrow-left",
                  onClick: () => page !== 0 && onMovePage(PAGINATION.PREV)
                }),
                external_React_default().createElement("div", null, page + 1, "/", chunksLength),
                external_React_default().createElement(meetings_button.Z, {
                  className: `
                            carousel-button-next
                            theme-dark-forced
                            ${page < chunksLength - 1 ? "" : "disabled"}
                        `,
                  icon: "sprite-fm-mono icon-arrow-right",
                  onClick: () => page < chunksLength - 1 && onMovePage(PAGINATION.NEXT)
                })
              );
            }
            return null;
          };
        }
        get fullscreen() {
          return document.fullscreenElement;
        }
        get duration() {
          return (Date.now() - this.props.call.ts) / 1000;
        }
        get durationString() {
          return this.duration ? secondsToTimeShort(this.duration) : "--:--:--";
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          clearInterval(this.durationInterval);
          document.removeEventListener(StreamHead.EVENTS.FULLSCREEN, this.closeTooltips);
          document.removeEventListener(StreamHead.EVENTS.CLICK_DIALOG, this.handleDialogClose);
        }
        componentDidMount() {
          super.componentDidMount();
          this.durationInterval = setInterval(this.updateDurationDOM, 1000);
          document.addEventListener(StreamHead.EVENTS.FULLSCREEN, this.closeTooltips);
          document.addEventListener(StreamHead.EVENTS.CLICK_DIALOG, this.handleDialogClose);
        }
        render() {
          const { NAMESPACE } = StreamHead;
          const { dialog } = this.state;
          const { mode, streamsPerPage, chatRoom, onStreamsPerPageChange, onCallMinimize, onModeChange } = this.props;
          const SIMPLETIP = {
            position: "bottom",
            offset: 5,
            className: "theme-dark-forced"
          };
          return external_React_default().createElement(
            "div",
            {
              ref: this.headRef,
              className: `
                    ${NAMESPACE}
                    ${dialog ? "active" : ""}
                `
            },
            dialog && external_React_default().createElement(this.Dialog, null),
            external_React_default().createElement(
              "div",
              {
                className: `${NAMESPACE}-content theme-dark-forced`
              },
              external_React_default().createElement(
                "div",
                {
                  className: `${NAMESPACE}-info`
                },
                external_React_default().createElement(
                  "div",
                  {
                    ref: this.durationRef,
                    className: "stream-duration"
                  },
                  this.durationString
                ),
                external_React_default().createElement(
                  "div",
                  {
                    ref: this.topicRef,
                    className: `
                                stream-topic
                                ${chatRoom.isMeeting && chatRoom.publicLink ? "has-meeting-link" : ""}
                            `,
                    onClick: () =>
                      chatRoom.isMeeting &&
                      chatRoom.publicLink &&
                      this.setState({
                        dialog: !dialog,
                        banner: false
                      })
                  },
                  external_React_default().createElement(utils.dy, null, chatRoom.getRoomTitle()),
                  chatRoom.isMeeting &&
                    chatRoom.publicLink &&
                    external_React_default().createElement("i", {
                      className: `
                                        sprite-fm-mono
                                        ${dialog ? "icon-arrow-up" : "icon-arrow-down"}
                                    `
                    })
                )
              ),
              external_React_default().createElement(this.Pagination, null),
              external_React_default().createElement(
                "div",
                {
                  className: `${NAMESPACE}-controls`
                },
                external_React_default().createElement(ModeSwitch, {
                  mode: mode,
                  streamsPerPage: streamsPerPage,
                  onStreamsPerPageChange: onStreamsPerPageChange,
                  onModeChange: onModeChange
                }),
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    className: "head-control",
                    simpletip: {
                      ...SIMPLETIP,
                      label: this.fullscreen ? l.exit_fullscreen : l[17803]
                    },
                    icon: this.fullscreen ? "icon-fullscreen-leave" : "icon-fullscreen-enter",
                    onClick: this.toggleFullscreen
                  },
                  external_React_default().createElement("span", null, this.fullscreen ? l.exit_fullscreen : l[17803])
                ),
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    className: "head-control",
                    simpletip: {
                      ...SIMPLETIP,
                      label: l.minimize
                    },
                    icon: "icon-call-min-mode",
                    onClick: onCallMinimize
                  },
                  external_React_default().createElement("div", null, l.minimize)
                )
              )
            )
          );
        }
      }
      StreamHead.NAMESPACE = "stream-head";
      StreamHead.EVENTS = {
        FULLSCREEN: "fullscreenchange",
        SIMPLETIP: new Event("simpletipClose"),
        CLICK_DIALOG: "click"
      };
      // EXTERNAL MODULE: ./js/ui/perfectScrollbar.jsx
      var perfectScrollbar = __webpack_require__(285); // CONCATENATED MODULE: ./js/chat/ui/meetings/waitingRoom/admit.jsx
      const NAMESPACE = "admit";
      class Admit extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.peersWaitingRef = external_React_default().createRef();
          this.state = {
            expanded: false
          };
          this.doAdmit = (peers) => {
            var _this$props$call;
            return (_this$props$call = this.props.call) == null || (_this$props$call = _this$props$call.sfuClient) == null
              ? void 0
              : _this$props$call.wrAllowJoin([peers]);
          };
          this.doDeny = (peers) => {
            var _this$props$call2;
            return (_this$props$call2 = this.props.call) == null || (_this$props$call2 = _this$props$call2.sfuClient) == null
              ? void 0
              : _this$props$call2.wrKickOut([peers]);
          };
          this.Icon = ({ icon, label, onClick }) =>
            external_React_default().createElement("i", {
              className: `
                sprite-fm-mono
                simpletip
                ${icon}
            `,
              "data-simpletip": label,
              "data-simpletipposition": "top",
              "data-simpletipoffset": "5",
              "data-simpletip-class": "theme-dark-forced",
              onClick: onClick
            });
          this.renderPeersList = () => {
            const { peers } = this.props;
            return external_React_default().createElement(
              perfectScrollbar.F,
              {
                ref: this.peersWaitingRef,
                options: {
                  suppressScrollX: true
                }
              },
              external_React_default().createElement(
                "div",
                {
                  className: "peers-waiting"
                },
                peers.map((handle) => {
                  return external_React_default().createElement(
                    "div",
                    {
                      key: handle,
                      className: "peers-waiting-card"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: "peer-avatar"
                      },
                      external_React_default().createElement(ui_contacts.Avatar, {
                        contact: M.u[handle]
                      })
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "peer-name"
                      },
                      external_React_default().createElement(utils.dy, null, M.getNameByHandle(handle))
                    ),
                    external_React_default().createElement(
                      "div",
                      {
                        className: "peer-controls"
                      },
                      external_React_default().createElement(this.Icon, {
                        icon: "icon-close-component",
                        label: l.wr_deny,
                        onClick: () => this.doDeny(handle)
                      }),
                      external_React_default().createElement(this.Icon, {
                        icon: "icon-check",
                        label: l.wr_admit,
                        onClick: () => this.doAdmit(handle)
                      })
                    )
                  );
                })
              )
            );
          };
          this.renderMultiplePeersWaiting = () => {
            const { call, peers } = this.props;
            const { expanded } = this.state;
            if (peers && peers.length) {
              return external_React_default().createElement(
                external_React_default().Fragment,
                null,
                external_React_default().createElement(
                  "div",
                  {
                    className: `${NAMESPACE}-head`
                  },
                  external_React_default().createElement("h3", null, l.wr_peers_waiting.replace("%1", peers.length)),
                  expanded
                    ? external_React_default().createElement(this.Icon, {
                        icon: "icon-arrow-up",
                        onClick: () =>
                          this.setState({
                            expanded: false
                          })
                      })
                    : null
                ),
                expanded &&
                  external_React_default().createElement(
                    "div",
                    {
                      className: `${NAMESPACE}-content`
                    },
                    this.renderPeersList()
                  ),
                external_React_default().createElement(
                  "div",
                  {
                    className: `${NAMESPACE}-controls`
                  },
                  expanded
                    ? null
                    : external_React_default().createElement(
                        meetings_button.Z,
                        {
                          className: "mega-button theme-dark-forced",
                          onClick: () =>
                            this.setState({
                              expanded: true
                            })
                        },
                        external_React_default().createElement("span", null, l.wr_see_waiting)
                      ),
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      peers: peers,
                      className: "mega-button positive theme-dark-forced",
                      onClick: () => call.sfuClient.wrAllowJoin(peers)
                    },
                    external_React_default().createElement("span", null, l.wr_admit_all)
                  )
                )
              );
            }
            return null;
          };
          this.renderSinglePeerWaiting = () => {
            const { peers } = this.props;
            const peer = peers[0];
            if (peer) {
              return external_React_default().createElement(
                external_React_default().Fragment,
                null,
                external_React_default().createElement(utils.Cw, {
                  tag: "h3",
                  content: l.wr_peer_waiting.replace("%s", megaChat.html(M.getNameByHandle(peer)))
                }),
                external_React_default().createElement(
                  "div",
                  {
                    className: `${NAMESPACE}-controls`
                  },
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      className: "mega-button theme-dark-forced",
                      onClick: () => this.doDeny(peer)
                    },
                    external_React_default().createElement("span", null, l.wr_deny)
                  ),
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      className: "mega-button positive theme-dark-forced",
                      onClick: () => this.doAdmit(peer)
                    },
                    external_React_default().createElement("span", null, l.wr_admit)
                  )
                )
              );
            }
            return null;
          };
        }
        render() {
          const { chatRoom, peers } = this.props;
          if (chatRoom.iAmOperator()) {
            return external_React_default().createElement(
              "div",
              {
                className: `
                        ${NAMESPACE}
                        theme-dark-forced
                    `
              },
              external_React_default().createElement(
                "div",
                {
                  className: `${NAMESPACE}-wrapper`
                },
                peers && peers.length > 1 ? this.renderMultiplePeersWaiting() : this.renderSinglePeerWaiting()
              )
            );
          }
          return null;
        }
      } // CONCATENATED MODULE: ./js/chat/ui/meetings/stream.jsx
      const stream_NAMESPACE = "stream";
      const STREAM_ACTIONS = {
        ADD: 1,
        REMOVE: 2
      };
      const PAGINATION = {
        PREV: -1,
        NEXT: 1
      };
      const MAX_STREAMS = 99;
      const STREAMS_PER_PAGE = {
        MIN: 9,
        MED: 21,
        MAX: 49
      };
      const chunkNodes = (nodes, size) => {
        if (nodes && nodes.length && size) {
          const chunked = [];
          let index = 0;
          while (index < nodes.length) {
            chunked.push({
              id: index,
              nodes: nodes.slice(index, index + size)
            });
            index += size;
          }
          return chunked;
        }
        return null;
      };
      class stream_Stream extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.wrapperRef = external_React_default().createRef();
          this.containerRef = external_React_default().createRef();
          this.nodeRefs = [];
          this.chunks = [];
          this.chunksLength = 0;
          this.lastRescaledCache = undefined;
          this.state = {
            page: 0,
            overlayed: false,
            streamsPerPage: STREAMS_PER_PAGE.MED,
            floatDetached: false
          };
          this.toggleFloatDetachment = () => {
            this.setState((state) => ({
              floatDetached: !state.floatDetached
            }));
          };
        }
        movePage(direction) {
          return this.setState((state) => ({
            page: direction === PAGINATION.NEXT ? state.page + 1 : state.page - 1
          }));
        }
        getColumns(streamsCount) {
          switch (true) {
            case streamsCount >= 43:
              return 7;
            case streamsCount >= 26:
              return 6;
            case streamsCount >= 17:
              return 5;
            case streamsCount >= 13:
              return 4;
            case streamsCount === 1:
              return 1;
            case streamsCount >= 7:
              return 3;
            default:
              return 2;
          }
        }
        scaleNodes(columns, forced = false) {
          var _Object$values$page;
          const { peers, minimized, mode } = this.props;
          const container = this.containerRef.current;
          this.lastRescaledCache = forced ? null : this.lastRescaledCache;
          if (minimized || !container) {
            return;
          }
          const { floatDetached, streamsPerPage, page } = this.state;
          const parentRef = container.parentNode;
          const parentStyle = getComputedStyle(parentRef);
          const extraVerticalMargin = parseInt(parentStyle.paddingTop) + parseInt(parentStyle.paddingBottom);
          let containerWidth = parentRef.offsetWidth;
          let containerHeight = parentRef.offsetHeight - extraVerticalMargin;
          const nodesPerPage = floatDetached ? streamsPerPage : streamsPerPage - 1;
          const streamsInUI =
            peers.length > nodesPerPage
              ? (_Object$values$page = Object.values(this.chunks)[page]) == null
                ? void 0
                : _Object$values$page.nodes
              : peers;
          if (streamsInUI) {
            const streamCountInUI = peers.length > nodesPerPage || floatDetached ? streamsInUI.length : streamsInUI.length + 1;
            let rows;
            if (mode === MODE.THUMBNAIL) {
              columns = typeof columns === "number" ? columns : this.getColumns(streamCountInUI);
              rows = Math.ceil(streamCountInUI / columns);
            } else {
              rows = 1;
              columns = 1;
            }
            containerWidth -= columns * 6 * 2;
            containerHeight -= rows * 6 * 2;
            let targetWidth = Math.floor(containerWidth / columns);
            let targetHeight = (targetWidth / 16) * 9;
            if (targetHeight * rows > containerHeight) {
              targetHeight = Math.floor(containerHeight / rows);
              targetWidth = (targetHeight / 9) * 16;
            }
            const nodeRefs = this.nodeRefs.flat();
            const nodeRefsLength = nodeRefs.length;
            const viewMode = mode || MODE.MAIN;
            let cache = `${viewMode}:${targetWidth}:${targetHeight}:${nodeRefsLength}:${rows}:${streamCountInUI}:${columns}`;
            for (let i = 0; i < nodeRefsLength; i++) {
              cache += `${nodeRefs[i].cacheKey}:`;
            }
            if (this.lastRescaledCache === cache) {
              return;
            }
            this.lastRescaledCache = cache;
            for (let i = 0; i < nodeRefsLength; i++) {
              const node = nodeRefs[i];
              if (node && node.ref) {
                node.ref.style.width = `${targetWidth}px`;
                node.ref.style.height = `${targetHeight}px`;
              }
            }
            container.style.width = `${(targetWidth + 12) * columns}px`;
          }
        }
        renderNodes() {
          const { mode, peers, call, forcedLocal, chatRoom, ephemeralAccounts, onCallMinimize, onSpeakerChange, onThumbnailDoubleClick } =
            this.props;
          const { page, streamsPerPage, floatDetached } = this.state;
          const filteredPeers = Object.values(peers).filter((p) => p instanceof CallManager2.Peer);
          const streaming = [...filteredPeers.filter((p) => p.isScreen), ...filteredPeers.filter((p) => !p.videoMuted)];
          const rest = filteredPeers.filter((p) => !streaming.includes(p));
          if (mode === MODE.THUMBNAIL) {
            const nodesPerPage = floatDetached ? streamsPerPage : streamsPerPage - 1;
            if (peers.length <= nodesPerPage) {
              const $$PEER = (peer, i) => {
                const cacheKey = `${mode}_${peer.clientId}_${i}`;
                return external_React_default().createElement(
                  PeerVideoHiRes,
                  {
                    key: cacheKey,
                    mode: mode,
                    chatRoom: chatRoom,
                    menu: true,
                    source: peer,
                    ephemeralAccounts: ephemeralAccounts,
                    onCallMinimize: onCallMinimize,
                    onSpeakerChange: onSpeakerChange,
                    onDoubleClick: (e, videoNode) => {
                      e.preventDefault();
                      e.stopPropagation();
                      onThumbnailDoubleClick(videoNode);
                    },
                    didMount: (ref) => {
                      this.nodeRefs.push({
                        clientId: peer.clientId,
                        cacheKey,
                        ref
                      });
                      this.scaleNodes(undefined, true);
                    },
                    willUnmount: () => {
                      this.nodeRefs = this.nodeRefs.filter((nodeRef) => nodeRef.clientId !== peer.clientId);
                    }
                  },
                  this.renderNodeMenu(peer)
                );
              };
              return floatDetached
                ? [...streaming, ...rest].map((p, i) => $$PEER(p, i))
                : [
                    ...streaming.map((p, i) => $$PEER(p, i)),
                    external_React_default().createElement(
                      LocalVideoHiRes,
                      {
                        key: `${mode}_${u_handle}`,
                        chatRoom: chatRoom,
                        className: "with-contain",
                        didMount: (ref) => {
                          this.nodeRefs.push({
                            clientId: u_handle,
                            cacheKey: `${mode}_${u_handle}`,
                            ref
                          });
                          this.scaleNodes(undefined, true);
                        },
                        willUnmount: () => {
                          this.nodeRefs = this.nodeRefs.filter((nodeRef) => nodeRef.clientId !== u_handle);
                        }
                      },
                      this.renderNodeMenu()
                    ),
                    ...rest.map((p, i) => $$PEER(p, i))
                  ];
            }
            this.chunks = chunkNodes(
              floatDetached
                ? [...streaming, ...rest]
                : [...streaming, Object.values(peers).find((p) => !(p instanceof CallManager2.Peer)), ...rest],
              streamsPerPage
            );
            this.chunksLength = Object.values(this.chunks).length;
            return external_React_default().createElement(
              "div",
              {
                className: "carousel"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "carousel-container"
                },
                Object.values(this.chunks).map((chunk, i) => {
                  const { id, nodes } = chunk;
                  return external_React_default().createElement(
                    "div",
                    {
                      key: id,
                      className: `
                                        carousel-page
                                        ${i === page ? "active" : ""}
                                    `
                    },
                    nodes.map((peer) => {
                      if (peer instanceof CallManager2.Peer) {
                        return external_React_default().createElement(
                          PeerVideoHiRes,
                          {
                            key: peer.clientId,
                            source: peer,
                            chatRoom: chatRoom,
                            ephemeralAccounts: ephemeralAccounts,
                            onCallMinimize: onCallMinimize,
                            onSpeakerChange: onSpeakerChange,
                            didMount: (ref) => {
                              if (!this.nodeRefs[i]) {
                                this.nodeRefs[i] = [];
                              }
                              this.nodeRefs[i].push({
                                clientId: peer.clientId,
                                ref
                              });
                              this.scaleNodes(undefined, true);
                            },
                            willUnmount: () => {
                              this.nodeRefs = this.nodeRefs.map((chunk) => chunk.filter((nodeRef) => nodeRef.clientId !== peer.clientId));
                            }
                          },
                          this.renderNodeMenu(peer)
                        );
                      }
                      return external_React_default().createElement(
                        LocalVideoHiRes,
                        {
                          key: `${mode}_${u_handle}`,
                          chatRoom: chatRoom,
                          className: "with-contain",
                          didMount: (ref) => {
                            if (!this.nodeRefs[i]) {
                              this.nodeRefs[i] = [];
                            }
                            this.nodeRefs[i].push({
                              clientId: u_handle,
                              ref
                            });
                            this.scaleNodes(undefined, true);
                          },
                          willUnmount: () => {
                            this.nodeRefs = this.nodeRefs.map((chunk) => chunk.filter((nodeRef) => nodeRef.clientId !== u_handle));
                          }
                        },
                        this.renderNodeMenu()
                      );
                    })
                  );
                })
              )
            );
          }
          let source;
          let VideoType;
          if (forcedLocal) {
            VideoType = LocalVideoHiRes;
            source = call.getLocalStream();
          } else {
            VideoType = PeerVideoHiRes;
            source = call.getActiveStream();
            if (!source) {
              return null;
            }
          }
          return external_React_default().createElement(
            VideoType,
            {
              key: source.clientId,
              chatRoom: chatRoom,
              source: source,
              ephemeralAccounts: ephemeralAccounts,
              onCallMinimize: onCallMinimize
            },
            this.renderNodeMenu(source)
          );
        }
        renderNodeMenu(peer) {
          const { call, chatRoom, ephemeralAccounts, onCallMinimize, onSpeakerChange } = this.props;
          if (peer) {
            return external_React_default().createElement(VideoNodeMenu, {
              privilege: chatRoom.members[peer.userHandle],
              chatRoom: chatRoom,
              stream: peer,
              ephemeralAccounts: ephemeralAccounts,
              onCallMinimize: onCallMinimize,
              onSpeakerChange: onSpeakerChange
            });
          }
          return external_React_default().createElement(
            "div",
            {
              className: "node-menu theme-dark-forced"
            },
            external_React_default().createElement(
              "div",
              {
                className: "node-menu-toggle"
              },
              external_React_default().createElement(utils.dy, null, M.getNameByHandle(u_handle)),
              external_React_default().createElement("i", {
                className: "sprite-fm-mono icon-side-menu"
              })
            ),
            external_React_default().createElement(
              "div",
              {
                className: "node-menu-content"
              },
              external_React_default().createElement(
                "ul",
                null,
                external_React_default().createElement(
                  "li",
                  null,
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      icon: "sprite-fm-mono grid-main",
                      onClick: () => onSpeakerChange(call.getLocalStream())
                    },
                    external_React_default().createElement("span", null, l.display_in_main_view)
                  )
                ),
                external_React_default().createElement(
                  "li",
                  null,
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      icon: "sprite-fm-mono grid-separate",
                      onClick: this.toggleFloatDetachment
                    },
                    external_React_default().createElement("span", null, l.separate_from_grid_button)
                  )
                )
              )
            )
          );
        }
        renderOnHold() {
          return external_React_default().createElement(
            "div",
            {
              className: "on-hold-overlay"
            },
            external_React_default().createElement(
              "div",
              {
                className: "stream-on-hold theme-light-forced",
                onClick: this.props.onHoldClick
              },
              external_React_default().createElement("i", {
                className: "sprite-fm-mono icon-play"
              }),
              external_React_default().createElement("span", null, l[23459])
            )
          );
        }
        renderStreamContainer() {
          const {
            call,
            chatRoom,
            peers,
            stayOnEnd,
            everHadPeers,
            isOnHold,
            mode,
            hasOtherParticipants,
            onInviteToggle,
            onStayConfirm,
            onCallEnd
          } = this.props;
          const streamContainer = (content) =>
            external_React_default().createElement(
              "div",
              {
                ref: this.containerRef,
                className: `
                    ${stream_NAMESPACE}-container
                    ${peers.length === 0 || !hasOtherParticipants ? "with-notice" : ""}
                    ${peers.length === 1 && mode === MODE.THUMBNAIL && this.state.floatDetached ? "single-stream" : ""}
                    ${peers.length === 1 && mode === MODE.THUMBNAIL && !this.state.floatDetached ? "dual-stream" : ""}
                `
              },
              content
            );
          if (peers.length === 0 || !hasOtherParticipants) {
            return external_React_default().createElement(ParticipantsNotice, {
              call: call,
              hasLeft: call.left,
              chatRoom: chatRoom,
              everHadPeers: everHadPeers,
              streamContainer: streamContainer,
              stayOnEnd: stayOnEnd,
              isOnHold: isOnHold,
              onInviteToggle: onInviteToggle,
              onStayConfirm: onStayConfirm,
              onCallEnd: () => onCallEnd(1)
            });
          }
          return streamContainer(this.renderNodes());
        }
        renderToaster() {
          return external_React_default().createElement(chatToaster.Z, {
            showDualNotifications: true,
            hidden: this.props.minimized,
            onShownToast: (toast) => {
              if (toast.options && toast.options.persistent) {
                this.setState({
                  overlayed: true
                });
              }
            },
            onHideToast: (toast) => {
              if (this.state.overlayed && toast.options && toast.options.persistent) {
                this.setState({
                  overlayed: false
                });
              }
            }
          });
        }
        specShouldComponentUpdate(nextProps) {
          if (nextProps.minimized !== this.props.minimized || nextProps.mode !== this.props.mode) {
            return true;
          }
          return null;
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          chatGlobalEventManager.removeEventListener("resize", this.getUniqueId());
          mBroadcaster.removeListener(this.callHoldListener);
        }
        componentDidMount() {
          super.componentDidMount();
          this.scaleNodes();
          chatGlobalEventManager.addEventListener("resize", this.getUniqueId(), () => this.scaleNodes());
          this.callHoldListener = mBroadcaster.addListener("meetings:toggleHold", () => this.scaleNodes(undefined, true));
        }
        componentDidUpdate() {
          super.componentDidMount();
          this.scaleNodes();
          if (this.chunksLength > 0 && this.state.page + 1 > this.chunksLength) {
            this.movePage(PAGINATION.PREV);
          }
        }
        render() {
          const { overlayed, page, streamsPerPage, floatDetached } = this.state;
          const {
            mode,
            call,
            chatRoom,
            minimized,
            peers,
            sidebar,
            hovered,
            forcedLocal,
            view,
            isOnHold,
            waitingRoomPeers,
            onCallMinimize,
            onCallExpand,
            onModeChange,
            onAudioClick,
            onVideoClick,
            onCallEnd,
            onScreenSharingClick,
            onHoldClick,
            onSpeakerChange
          } = this.props;
          return external_React_default().createElement(
            "div",
            {
              ref: this.wrapperRef,
              className: `
                    ${stream_NAMESPACE}
                    ${sidebar ? "" : "full"}
                    ${hovered ? "hovered" : ""}
                `
            },
            waitingRoomPeers && waitingRoomPeers.length
              ? external_React_default().createElement(Admit, {
                  chatRoom: chatRoom,
                  call: call,
                  peers: waitingRoomPeers
                })
              : null,
            this.renderToaster(),
            minimized
              ? null
              : external_React_default().createElement(
                  external_React_default().Fragment,
                  null,
                  external_React_default().createElement(
                    "div",
                    {
                      className: `
                                ${stream_NAMESPACE}-wrapper
                                ${mode === MODE.MAIN ? "with-participants-block" : ""}
                            `
                    },
                    isOnHold
                      ? this.renderOnHold()
                      : overlayed &&
                          external_React_default().createElement("div", {
                            className: "call-overlay"
                          }),
                    this.renderStreamContainer()
                  ),
                  mode === MODE.MAIN &&
                    external_React_default().createElement(
                      ParticipantsBlock,
                      (0, esm_extends.Z)({}, this.props, {
                        floatDetached: floatDetached,
                        onSeparate: this.toggleFloatDetachment
                      })
                    ),
                  external_React_default().createElement(StreamHead, {
                    disableCheckingVisibility: true,
                    mode: mode,
                    peers: peers,
                    page: page,
                    streamsPerPage: streamsPerPage,
                    floatDetached: floatDetached,
                    chunksLength: this.chunksLength,
                    call: call,
                    chatRoom: chatRoom,
                    onCallMinimize: onCallMinimize,
                    onModeChange: onModeChange,
                    onStreamsPerPageChange: (streamsPerPage) =>
                      this.setState({
                        streamsPerPage
                      }),
                    onMovePage: (direction) => this.movePage(direction)
                  })
                ),
            external_React_default().createElement(FloatingVideo, {
              call: call,
              peers: peers,
              mode: mode,
              view: view,
              floatDetached: floatDetached,
              isOnHold: isOnHold,
              chatRoom: chatRoom,
              minimized: minimized,
              sidebar: sidebar,
              forcedLocal: forcedLocal,
              wrapperRef: this.wrapperRef,
              waitingRoomPeers: waitingRoomPeers,
              onAudioClick: onAudioClick,
              onVideoClick: onVideoClick,
              onCallEnd: onCallEnd,
              onScreenSharingClick: onScreenSharingClick,
              onCallMinimize: onCallMinimize,
              onMoveIntoGrid: this.toggleFloatDetachment,
              onCallExpand: async () => {
                await onCallExpand();
                this.scaleNodes(undefined, true);
              },
              onSpeakerChange: onSpeakerChange,
              onModeChange: onModeChange,
              onHoldClick: onHoldClick
            })
          );
        }
      }
      // EXTERNAL MODULE: ./js/chat/ui/composedTextArea.jsx + 1 modules
      var composedTextArea = __webpack_require__(813);
      // EXTERNAL MODULE: ./js/chat/ui/historyPanel.jsx + 7 modules
      var historyPanel = __webpack_require__(192); // CONCATENATED MODULE: ./js/chat/ui/meetings/collapse.jsx
      class Collapse extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.state = {
            expanded: true
          };
        }
        render() {
          const { expanded } = this.state;
          const { heading, badge, children } = this.props;
          return external_React_default().createElement(
            "div",
            {
              className: "collapse"
            },
            heading &&
              external_React_default().createElement(
                "div",
                {
                  className: "collapse-head",
                  onClick: () =>
                    this.setState((state) => ({
                      expanded: !state.expanded
                    }))
                },
                external_React_default().createElement("i", {
                  className: `
                                sprite-fm-mono
                                ${expanded ? "icon-arrow-down" : "icon-arrow-up"}
                            `
                }),
                external_React_default().createElement("h5", null, heading),
                badge !== undefined &&
                  badge > 0 &&
                  external_React_default().createElement(
                    "span",
                    {
                      className: "participants-count"
                    },
                    badge
                  )
              ),
            expanded && children
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/meetings/participants.jsx
      class Participant extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.baseIconClass = "sprite-fm-mono";
        }
        componentDidMount() {
          super.componentDidMount();
          this.props.source.registerConsumer(this);
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          this.props.source.deregisterConsumer(this);
        }
        onAvChange() {
          this.safeForceUpdate();
        }
        render() {
          const { chatRoom, handle, name, source } = this.props;
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            external_React_default().createElement(ui_contacts.Avatar, {
              contact: M.u[handle]
            }),
            external_React_default().createElement(
              "div",
              {
                className: "name"
              },
              external_React_default().createElement(utils.dy, null, handle === u_handle ? `${name} ${l.me}` : name),
              chatRoom.isMeeting &&
                Call.isModerator(chatRoom, handle) &&
                external_React_default().createElement(
                  "span",
                  null,
                  external_React_default().createElement("i", {
                    className: `${this.baseIconClass} icon-admin-outline`
                  })
                )
            ),
            external_React_default().createElement(
              "div",
              {
                className: "status"
              },
              external_React_default().createElement("i", {
                className: `
                            ${this.baseIconClass}
                            ${source.videoMuted ? "icon-video-off-thin-outline inactive" : "icon-video-thin-outline"}
                        `
              }),
              external_React_default().createElement("i", {
                className: `
                            ${this.baseIconClass}
                            ${source.audioMuted ? "icon-mic-off-thin-outline inactive" : "icon-mic-thin-outline"}
                         `
              })
            )
          );
        }
      }
      class Participants extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.FILTER = {
            CALL: 0,
            CHAT: 1
          };
          this.state = {
            filter: this.FILTER.CALL,
            noResponsePeers: [],
            ringingPeers: []
          };
          this.doHangUp = (handle) => {
            if (handle) {
              const { call, chatRoom } = this.props;
              return (
                this.isMounted() &&
                this.setState(
                  (state) => ({
                    ringingPeers: state.ringingPeers.filter((p) => p !== handle)
                  }),
                  () => chatRoom.ringUser(handle, call.callId, 0)
                )
              );
            }
          };
          this.doCall = (handle) => {
            if (handle) {
              const { call, chatRoom } = this.props;
              this.setState(
                (state) => ({
                  ringingPeers: [...state.ringingPeers, handle]
                }),
                () => {
                  chatRoom.ringUser(handle, call.callId, 1);
                  tSleep(40).then(() => {
                    this.doHangUp(handle);
                    return Object.keys(chatRoom.uniqueCallParts).includes(handle)
                      ? null
                      : this.setState((state) => ({
                          noResponsePeers: [...state.noResponsePeers, handle]
                        }));
                  });
                }
              );
            }
          };
          this.getCallState = (handle) => {
            const { noResponsePeers, ringingPeers } = this.state;
            if (this.props.initialCallRinging || ringingPeers.includes(handle)) {
              return l.call_state_calling;
            }
            if (noResponsePeers.includes(handle)) {
              return l.call_state_no_response;
            }
            return l.call_state_not_in_call;
          };
          this.getCallParticipants = () => {
            const { call, chatRoom, peers } = this.props;
            return external_React_default().createElement(
              "ul",
              null,
              external_React_default().createElement(
                "li",
                null,
                external_React_default().createElement(Participant, {
                  call: call,
                  chatRoom: chatRoom,
                  source: call.getLocalStream(),
                  handle: u_handle,
                  name: M.getNameByHandle(u_handle)
                })
              ),
              peers.map((peer) =>
                external_React_default().createElement(
                  "li",
                  {
                    key: `${peer.clientId}-${peer.userHandle}`
                  },
                  external_React_default().createElement(Participant, {
                    chatRoom: chatRoom,
                    source: peer,
                    handle: peer.userHandle,
                    name: peer.name
                  })
                )
              )
            );
          };
          this.getChatParticipants = () => {
            const { chatRoom, initialCallRinging } = this.props;
            const { ringingPeers } = this.state;
            const callParticipants = Object.keys(chatRoom.uniqueCallParts);
            const chatParticipants = chatRoom.getParticipantsExceptMe().filter((h) => !callParticipants.includes(h));
            if (chatParticipants != null && chatParticipants.length) {
              return external_React_default().createElement(
                external_React_default().Fragment,
                null,
                chatParticipants.length > 1
                  ? (() => {
                      const isRingingAll = initialCallRinging || JSON.stringify(ringingPeers) === JSON.stringify(chatParticipants);
                      return external_React_default().createElement(
                        meetings_button.Z,
                        {
                          className: `
                                        mega-button
                                        action
                                        neutral
                                        call-control-all
                                        ${isRingingAll ? "disabled" : ""}
                                    `,
                          icon: "sprite-fm-mono phone-call-01",
                          onClick: () => (isRingingAll ? null : chatParticipants.map((handle) => this.doCall(handle)))
                        },
                        l.call_all_button
                      );
                    })()
                  : null,
                external_React_default().createElement(
                  "ul",
                  null,
                  chatParticipants.map((handle) => {
                    const contact = M.u[handle];
                    const isRinging = initialCallRinging || ringingPeers.includes(handle);
                    return external_React_default().createElement(
                      "li",
                      {
                        key: handle
                      },
                      external_React_default().createElement(ui_contacts.Avatar, {
                        contact: contact
                      }),
                      external_React_default().createElement(
                        "div",
                        {
                          className: "name"
                        },
                        external_React_default().createElement(utils.dy, null, M.getNameByHandle(handle)),
                        external_React_default().createElement("span", {
                          className: `
                                            user-card-presence
                                            ${megaChat.userPresenceToCssClass(contact.presence)}
                                        `
                        }),
                        chatRoom.isMeeting &&
                          Call.isModerator(chatRoom, handle) &&
                          external_React_default().createElement(
                            "span",
                            null,
                            external_React_default().createElement("i", {
                              className: "sprite-fm-mono icon-admin-outline"
                            })
                          ),
                        external_React_default().createElement(
                          "div",
                          {
                            className: "call-state"
                          },
                          this.getCallState(handle)
                        )
                      ),
                      isRinging
                        ? null
                        : external_React_default().createElement(
                            "div",
                            {
                              className: "call-control"
                            },
                            external_React_default().createElement(
                              meetings_button.Z,
                              {
                                className: "mega-button action neutral",
                                onClick: () => this.doCall(handle)
                              },
                              l.call_button
                            )
                          )
                    );
                  })
                )
              );
            }
            return external_React_default().createElement(
              "div",
              {
                className: "participants-empty"
              },
              external_React_default().createElement("span", {
                className: "empty-check-icon"
              }),
              external_React_default().createElement("h3", null, l.all_participants_in_call)
            );
          };
          this.renderParticipantsList = () => {
            const { filter } = this.state;
            return external_React_default().createElement(
              "div",
              {
                className: `
                    participants-list
                    ${filter === this.FILTER.CALL ? "" : "with-chat-participants"}
                    ${this.props.guest ? "guest" : ""}
                `
              },
              external_React_default().createElement(
                perfectScrollbar.F,
                {
                  filter: filter,
                  options: {
                    suppressScrollX: true
                  }
                },
                filter === this.FILTER.CALL ? this.getCallParticipants() : this.getChatParticipants()
              )
            );
          };
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          this.props.chatRoom.off("onCallPeerJoined.participants");
        }
        componentDidMount() {
          super.componentDidMount();
          this.props.chatRoom.rebind("onCallPeerJoined.participants", (ev, userHandle) => {
            const { noResponsePeers, ringingPeers } = this.state;
            if (noResponsePeers.includes(userHandle)) {
              this.setState({
                noResponsePeers: noResponsePeers.filter((h) => h !== userHandle)
              });
            }
            if (ringingPeers.includes(userHandle)) {
              this.setState({
                ringingPeers: ringingPeers.filter((h) => h !== userHandle)
              });
            }
          });
        }
        render() {
          const { CALL, CHAT } = this.FILTER;
          const { chatRoom, peers } = this.props;
          const { filter } = this.state;
          return external_React_default().createElement(
            "div",
            {
              className: "participants"
            },
            chatRoom.type === "private"
              ? null
              : external_React_default().createElement(
                  "div",
                  {
                    className: "participants-nav"
                  },
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      className: filter === CALL ? "active" : "",
                      onClick: () =>
                        this.setState({
                          filter: CALL
                        })
                    },
                    l.call_heading_in_call
                  ),
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      className: filter === CHAT ? "active" : "",
                      onClick: () =>
                        this.setState({
                          filter: CHAT
                        })
                    },
                    l.call_heading_not_in_call
                  )
                ),
            filter === CALL
              ? external_React_default().createElement(
                  Collapse,
                  (0, esm_extends.Z)({}, this.props, {
                    filter: filter,
                    heading: l[16217],
                    badge: (peers == null ? void 0 : peers.length) + 1
                  }),
                  this.renderParticipantsList()
                )
              : this.renderParticipantsList()
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/meetings/guest.jsx
      class Guest extends mixins.wl {
        render() {
          return external_React_default().createElement(
            "div",
            {
              className: "guest-register"
            },
            external_React_default().createElement(
              "div",
              {
                className: "guest-register-content"
              },
              external_React_default().createElement(
                meetings_button.Z,
                {
                  className: "close-guest-register",
                  icon: "icon-close-component",
                  onClick: this.props.onGuestClose
                },
                external_React_default().createElement("span", null, l[148])
              ),
              external_React_default().createElement(
                "div",
                null,
                external_React_default().createElement("i", {
                  className: "sprite-fm-illustration-wide registration"
                }),
                l.meetings_signup
              ),
              external_React_default().createElement(
                meetings_button.Z,
                {
                  className: "mega-button positive register-button",
                  onClick: () => loadSubPage("register")
                },
                l[968]
              )
            )
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/meetings/sidebar.jsx
      const inviteAllowed = (chatRoom) => {
        if (chatRoom) {
          return chatRoom.type !== "private" && Call.isModerator(chatRoom, u_handle) && !chatRoom.iAmReadOnly();
        }
        return false;
      };
      class Sidebar extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.containerRef = external_React_default().createRef();
          this.historyPanel = null;
          this.renderHead = ({ title, children }) => {
            return external_React_default().createElement(
              "div",
              {
                className: "sidebar-head"
              },
              external_React_default().createElement(
                meetings_button.Z,
                {
                  simpletip: {
                    label: l.close_sidebar,
                    className: "theme-dark-forced"
                  },
                  className: "mega-button action small left",
                  icon: "icon-collapse-right",
                  onClick: this.props.onSidebarClose
                },
                external_React_default().createElement("span", null, l.close_sidebar)
              ),
              external_React_default().createElement("h2", null, title),
              children || null
            );
          };
          this.renderParticipantsView = () => {
            const { call, peers, initialCallRinging, chatRoom, guest, onInviteToggle } = this.props;
            const withInvite = inviteAllowed(chatRoom);
            const $$HEAD = this.renderHead({
              title: l[16217],
              children:
                u_type && withInvite
                  ? external_React_default().createElement(
                      meetings_button.Z,
                      {
                        className: "mega-button round positive add",
                        icon: "icon-add",
                        onClick: onInviteToggle
                      },
                      external_React_default().createElement("span", null, l[8007])
                    )
                  : null
            });
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              $$HEAD,
              external_React_default().createElement(Participants, {
                call: call,
                peers: peers,
                initialCallRinging: initialCallRinging,
                chatRoom: chatRoom,
                guest: guest,
                withInvite: withInvite
              })
            );
          };
          this.renderChatView = () => {
            const { chatRoom, onDeleteMessage } = this.props;
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              this.renderHead({
                title: l.chats
              }),
              external_React_default().createElement(historyPanel.Z, {
                ref: (ref) => {
                  this.historyPanel = ref;
                },
                chatRoom: chatRoom,
                className: "in-call",
                onDeleteClicked: onDeleteMessage
              }),
              external_React_default().createElement(composedTextArea.Z, {
                chatRoom: chatRoom,
                parent: this,
                containerRef: this.containerRef
              })
            );
          };
        }
        render() {
          const { view, guest, onGuestClose } = this.props;
          return external_React_default().createElement(
            "div",
            {
              className: "sidebar-wrapper theme-dark-forced"
            },
            external_React_default().createElement(
              "div",
              {
                ref: this.containerRef,
                className: `
                        sidebar
                        ${view === VIEW.CHAT ? "chat-opened" : "theme-dark-forced"}
                    `
              },
              view === VIEW.PARTICIPANTS && this.renderParticipantsView(),
              view === VIEW.CHAT && this.renderChatView(),
              guest &&
                view !== VIEW.CHAT &&
                external_React_default().createElement(Guest, {
                  onGuestClose: onGuestClose
                })
            )
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/meetings/workflow/invite/search.jsx
      var _class;

      class Search extends mixins.wl {
        render() {
          const { value, placeholder, onChange } = this.props;
          return external_React_default().createElement(
            "div",
            {
              className: `${Invite.NAMESPACE}-field`
            },
            external_React_default().createElement("i", {
              className: "sprite-fm-mono icon-preview-reveal"
            }),
            external_React_default().createElement("input", {
              type: "text",
              autoFocus: true,
              placeholder: l[23750].replace("[X]", placeholder),
              ref: Search.inputRef,
              value: value,
              onChange: onChange
            })
          );
        }
      }
      _class = Search;
      Search.inputRef = external_React_default().createRef();
      Search.focus = () => {
        return _class.inputRef && _class.inputRef.current && _class.inputRef.current.focus();
      }; // CONCATENATED MODULE: ./js/chat/ui/meetings/workflow/invite/footer.jsx
      class Footer extends mixins.wl {
        render() {
          const { selected, onClose, onAdd } = this.props;
          return external_React_default().createElement(
            "footer",
            null,
            external_React_default().createElement(
              "div",
              {
                className: "footer-container"
              },
              external_React_default().createElement(
                meetings_button.Z,
                {
                  className: "mega-button",
                  onClick: onClose
                },
                l[82]
              ),
              external_React_default().createElement(
                meetings_button.Z,
                {
                  className: `
                            mega-button
                            positive
                            ${selected.length > 0 ? "" : "disabled"}
                        `,
                  onClick: onAdd
                },
                l.add
              )
            )
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/meetings/workflow/invite/nil.jsx
      class Nil extends mixins.wl {
        render() {
          return external_React_default().createElement(
            "div",
            {
              className: `${Invite.NAMESPACE}-nil`
            },
            external_React_default().createElement("div", {
              className: "fm-empty-contacts-bg"
            }),
            external_React_default().createElement("h2", null, HAS_CONTACTS() ? l[8674] : l[784])
          );
        }
      }
      // EXTERNAL MODULE: ./js/chat/ui/link.jsx
      var ui_link = __webpack_require__(941); // CONCATENATED MODULE: ./js/chat/ui/meetings/workflow/invite/invite.jsx
      const HAS_CONTACTS = () => {
        const keys = M.u.keys();
        for (let i = 0; i < keys.length; i++) {
          if (M.u[keys[i]].c === 1) {
            return true;
          }
        }
      };
      class Invite extends mixins.wl {
        constructor(props) {
          super(props);
          this.wrapperRef = external_React_default().createRef();
          this.state = {
            loading: true,
            value: "",
            searching: false,
            contacts: [],
            contactsInitial: [],
            frequents: [],
            frequentsInitial: [],
            selected: [],
            excluded: [],
            input: false
          };
          this.getSortedContactsList = (frequents, excluded) => {
            frequents = frequents || this.state.frequents;
            excluded = excluded || this.state.excluded;
            const filteredContacts = [];
            (this.props.contacts || M.u).forEach((contact) => {
              if (contact.c === 1 && !frequents.includes(contact.u) && !excluded.includes(contact.u)) {
                filteredContacts.push(contact);
              }
            });
            const sortFn = M.getSortByNameFn2(1);
            filteredContacts.sort((a, b) => sortFn(a, b));
            return filteredContacts;
          };
          this.doMatch = (value, collection) => {
            value = value.toLowerCase();
            return collection.filter((contact) => {
              contact = typeof contact === "string" ? M.getUserByHandle(contact) : contact;
              const name = M.getNameByHandle(contact.u || contact).toLowerCase();
              const email = contact.m && contact.m.toLowerCase();
              return name.includes(value) || email.includes(value);
            });
          };
          this.handleSearch = (ev) => {
            const { value } = ev.target;
            const searching = value.length >= 2;
            const frequents = searching ? this.doMatch(value, this.state.frequentsInitial) : this.state.frequentsInitial;
            const contacts = searching ? this.doMatch(value, this.state.contactsInitial) : this.state.contactsInitial;
            this.setState(
              {
                value,
                searching,
                frequents,
                contacts
              },
              () => {
                const wrapperRef = this.wrapperRef && this.wrapperRef.current;
                if (wrapperRef && searching) {
                  wrapperRef.reinitialise();
                  wrapperRef.scrollToY(0);
                }
              }
            );
          };
          this.handleSelect = (userHandle) => {
            this.setState(
              (state) => ({
                selected: state.selected.includes(userHandle)
                  ? state.selected.filter((c) => c !== userHandle)
                  : [...state.selected, userHandle]
              }),
              () => Search.focus()
            );
          };
          this.handleAdd = () => {
            const { selected } = this.state;
            const { call, chatRoom, onClose } = this.props;
            if (selected.length > 0) {
              if (chatRoom.options.w) {
                var _call$sfuClient;
                call == null || (_call$sfuClient = call.sfuClient) == null || _call$sfuClient.wrAllowJoin(selected);
              }
              chatRoom == null || chatRoom.trigger("onAddUserRequest", [selected]);
              onClose == null || onClose();
            }
          };
          this.getFrequentContacts = () =>
            megaChat.getFrequentContacts().then((response) => {
              if (!this.isMounted()) {
                return;
              }
              const frequents = [];
              const maxFreq = Math.max(response.length - ui_contacts.MAX_FREQUENTS, 0);
              for (let i = response.length - 1; i >= maxFreq; i--) {
                const contact = response[i];
                if (!this.state.excluded.includes(contact.userId)) {
                  frequents.push(contact.userId);
                }
              }
              this.setState({
                frequents,
                frequentsInitial: frequents,
                contacts: this.getSortedContactsList(frequents),
                loading: false
              });
            });
          this.getFilteredFrequents = () => {
            const { frequents, selected } = this.state;
            if (frequents.length === 0) {
              return false;
            }
            return frequents.map((userHandle) => {
              return external_React_default().createElement(ui_contacts.ContactCard, {
                key: userHandle,
                contact: M.u[userHandle],
                chatRoom: false,
                className: `
                        contacts-search
                        short
                        ${selected.includes(userHandle) ? "selected" : ""}
                    `,
                noContextButton: true,
                noContextMenu: true,
                selectable: true,
                onClick: () => this.handleSelect(userHandle)
              });
            });
          };
          this.getFilteredContacts = () => {
            const { contacts, frequents, excluded, selected } = this.state;
            const $$CONTACTS = [];
            for (let i = 0; i < contacts.length; i++) {
              const contact = contacts[i];
              const { u: userHandle } = contact;
              if (!frequents.includes(userHandle) && !excluded.includes(userHandle)) {
                $$CONTACTS.push(
                  external_React_default().createElement(ui_contacts.ContactCard, {
                    key: userHandle,
                    contact: contact,
                    chatRoom: false,
                    className: `
                            contacts-search
                            short
                            ${selected.includes(userHandle) ? "selected" : ""}
                        `,
                    noContextButton: true,
                    noContextMenu: true,
                    selectable: true,
                    onClick: () => this.handleSelect(userHandle)
                  })
                );
              }
            }
            return $$CONTACTS.length === 0 ? false : $$CONTACTS;
          };
          this.renderContent = () => {
            const frequentContacts = this.getFilteredFrequents();
            const contactsFiltered = this.getFilteredContacts();
            if (HAS_CONTACTS()) {
              const { contacts, frequents } = this.state;
              const $$RESULT_TABLE = (header, children) =>
                external_React_default().createElement(
                  "div",
                  {
                    className: "contacts-search-subsection"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "contacts-list-header"
                    },
                    header
                  ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "contacts-search-list"
                    },
                    children
                  )
                );
              if (frequents.length === 0 && contacts.length === 0) {
                return external_React_default().createElement(Nil, null);
              }
              return external_React_default().createElement(
                perfectScrollbar.F,
                {
                  ref: this.wrapperRef,
                  options: {
                    suppressScrollX: true
                  }
                },
                frequentContacts ? $$RESULT_TABLE(l[20141], frequentContacts) : "",
                contactsFiltered ? $$RESULT_TABLE(l[165], contactsFiltered) : ""
              );
            }
            return external_React_default().createElement(Nil, null);
          };
          this.renderLoading = () => {
            return external_React_default().createElement(
              "div",
              {
                className: `${Invite.NAMESPACE}-loading`
              },
              external_React_default().createElement("h2", null, l[1456])
            );
          };
          this.state.excluded = this.props.chatRoom ? this.props.chatRoom.getParticipantsExceptMe() : [];
          this.state.contacts = this.state.contactsInitial = this.getSortedContactsList();
        }
        componentDidMount() {
          super.componentDidMount();
          this.getFrequentContacts();
        }
        render() {
          const { NAMESPACE } = Invite;
          const { value, loading, selected, field, contactsInitial } = this.state;
          const { chatRoom, onClose } = this.props;
          const { isMeeting, publicLink } = chatRoom || {};
          return external_React_default().createElement(
            modalDialogs.Z.ModalDialog,
            (0, esm_extends.Z)({}, this.state, {
              name: NAMESPACE,
              className: `
                    ${NAMESPACE}
                    dialog-template-tool
                `,
              hideOverlay: true,
              onClose: onClose
            }),
            external_React_default().createElement(
              "div",
              {
                className: `${NAMESPACE}-head`
              },
              external_React_default().createElement("h2", null, isMeeting ? l.invite_participants : l[8726]),
              isMeeting &&
                publicLink &&
                external_React_default().createElement(
                  external_React_default().Fragment,
                  null,
                  external_React_default().createElement("p", null, l.copy_and_share),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "link-input-container"
                    },
                    external_React_default().createElement(
                      meetings_button.Z,
                      {
                        className: `mega-button large positive ${publicLink ? "" : "disabled"}`,
                        onClick: () => publicLink && copyToClipboard(`${getBaseUrl()}/${publicLink}`, l[371])
                      },
                      !publicLink ? l[7006] : l[1394]
                    ),
                    external_React_default().createElement(
                      ui_link.Z,
                      {
                        className: "view-link-control",
                        field: field,
                        onClick: () =>
                          this.setState({
                            field: !field
                          })
                      },
                      field ? l.collapse_meeting_link : l.expand_meeting_link,
                      external_React_default().createElement("i", {
                        className: `sprite-fm-mono ${field ? "icon-arrow-up" : "icon-arrow-down"}`
                      })
                    ),
                    field &&
                      publicLink &&
                      external_React_default().createElement(
                        "div",
                        {
                          className: "chat-link-input"
                        },
                        external_React_default().createElement("i", {
                          className: "sprite-fm-mono icon-link"
                        }),
                        external_React_default().createElement("input", {
                          type: "text",
                          readOnly: true,
                          value: `${getBaseUrl()}/${publicLink}`
                        })
                      )
                  )
                ),
              HAS_CONTACTS() &&
                external_React_default().createElement(Search, {
                  value: value,
                  placeholder: contactsInitial.length,
                  onChange: this.handleSearch
                })
            ),
            external_React_default().createElement(
              "div",
              {
                className: "fm-dialog-body"
              },
              external_React_default().createElement(
                "div",
                {
                  className: `${NAMESPACE}-contacts`
                },
                loading ? this.renderLoading() : this.renderContent()
              )
            ),
            external_React_default().createElement(Footer, {
              selected: selected,
              onAdd: this.handleAdd,
              onClose: onClose
            })
          );
        }
      }
      Invite.NAMESPACE = "invite-meeting"; // CONCATENATED MODULE: ./js/chat/ui/meetings/workflow/ephemeral.jsx
      class Ephemeral extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.buttons = [
            {
              key: "ok",
              label: l[81],
              onClick: this.props.onClose
            }
          ];
        }
        render() {
          const { ephemeralAccounts, onClose } = this.props;
          const ephemeralAccount = ephemeralAccounts && ephemeralAccounts[ephemeralAccounts.length - 1];
          return external_React_default().createElement(
            modalDialogs.Z.ModalDialog,
            {
              name: Ephemeral.NAMESPACE,
              dialogType: "message",
              icon: "sprite-fm-uni icon-info",
              title: external_React_default().createElement(ui_contacts.ContactAwareName, {
                emoji: true,
                contact: M.u[ephemeralAccount]
              }),
              noCloseOnClickOutside: true,
              buttons: this.buttons,
              onClose: onClose
            },
            external_React_default().createElement("p", null, l.ephemeral_info)
          );
        }
      }
      Ephemeral.NAMESPACE = "ephemeral-dialog"; // CONCATENATED MODULE: ./js/chat/ui/meetings/offline.jsx
      class Offline extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.buttons = [
            {
              key: "ok",
              label: l[82],
              onClick: this.props.onClose
            },
            {
              key: "leave",
              label: l[5883],
              className: "negative",
              onClick: this.props.onCallEnd
            }
          ];
        }
        render() {
          return external_React_default().createElement(
            modalDialogs.Z.ModalDialog,
            {
              name: Offline.NAMESPACE,
              dialogType: "message",
              icon: "sprite-fm-uni icon-warning",
              title: l.no_internet,
              noCloseOnClickOutside: true,
              buttons: this.buttons,
              onClose: this.props.onClose
            },
            external_React_default().createElement("p", null, l.no_connection)
          );
        }
      }
      Offline.NAMESPACE = "reconnect-dialog";
      // EXTERNAL MODULE: ./js/chat/ui/conversationpanel.jsx + 14 modules
      var conversationpanel = __webpack_require__(21); // CONCATENATED MODULE: ./js/chat/ui/meetings/streamControls.jsx
      class StreamControls extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.endContainerRef = external_React_default().createRef();
          this.endButtonRef = external_React_default().createRef();
          this.SIMPLETIP = {
            position: "top",
            offset: 8,
            className: "theme-dark-forced"
          };
          this.state = {
            endCallOptions: false,
            endCallPending: false
          };
          this.LeaveButton = (0, hostsObserver.N)(({ hasHost, chatRoom, confirmLeave, onLeave }) => {
            return external_React_default().createElement(
              meetings_button.Z,
              {
                className: "mega-button",
                onClick: () =>
                  hasHost(chatRoom.getCallParticipants())
                    ? onLeave()
                    : confirmLeave({
                        title: l.assign_host_leave_call,
                        body: l.assign_host_leave_call_details,
                        cta: l.assign_host_button
                      })
              },
              external_React_default().createElement("span", null, l.leave)
            );
          });
          this.handleMousedown = ({ target }) =>
            this.endContainerRef && this.endContainerRef.current && this.endContainerRef.current.contains(target)
              ? null
              : this.isMounted() &&
                this.setState({
                  endCallOptions: false
                });
          this.renderDebug = () => {
            return external_React_default().createElement(
              "div",
              {
                className: "stream-debug",
                style: {
                  position: "absolute",
                  left: 25,
                  bottom: 36,
                  display: "flex",
                  alignItems: "center",
                  color: "tomato"
                }
              },
              external_React_default().createElement(
                meetings_button.Z,
                {
                  className: "mega-button round small theme-dark-forced positive",
                  simpletip: {
                    ...this.SIMPLETIP,
                    label: "Add Stream"
                  },
                  onClick: () => this.props.onStreamToggle(STREAM_ACTIONS.ADD)
                },
                external_React_default().createElement("span", null, l.add)
              ),
              external_React_default().createElement(
                meetings_button.Z,
                {
                  className: "mega-button round small theme-dark-forced negative",
                  simpletip: {
                    ...this.SIMPLETIP,
                    label: "Remove Stream"
                  },
                  onClick: () => this.props.peers.length > 1 && this.props.onStreamToggle(STREAM_ACTIONS.REMOVE)
                },
                external_React_default().createElement("span", null, l[83])
              ),
              external_React_default().createElement("span", null, this.props.peers.length + 1)
            );
          };
          this.renderEndCallOptions = () => {
            const { chatRoom, onCallEnd } = this.props;
            const { endCallOptions, endCallPending } = this.state;
            return external_React_default().createElement(
              "div",
              {
                className: `
                    end-options
                    theme-dark-forced
                    ${endCallOptions ? "" : "hidden"}
                `
              },
              external_React_default().createElement(
                "div",
                {
                  className: "end-options-content"
                },
                external_React_default().createElement(this.LeaveButton, {
                  chatRoom: chatRoom,
                  participants: chatRoom.getCallParticipants(),
                  onLeave: onCallEnd
                }),
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    className: `
                            mega-button
                            positive
                            ${endCallPending ? "disabled" : ""}
                        `,
                    onClick: () =>
                      endCallPending
                        ? null
                        : this.setState(
                            {
                              endCallPending: true
                            },
                            () => chatRoom.endCallForAll()
                          )
                  },
                  external_React_default().createElement("span", null, l.end_for_all)
                )
              )
            );
          };
          this.renderEndCall = () => {
            const { chatRoom, peers, onCallEnd } = this.props;
            return external_React_default().createElement(
              "div",
              {
                ref: this.endContainerRef,
                className: "end-call-container"
              },
              this.renderEndCallOptions(),
              external_React_default().createElement(
                meetings_button.Z,
                {
                  simpletip: {
                    ...this.SIMPLETIP,
                    label: l[5884]
                  },
                  className: "mega-button theme-dark-forced round large negative end-call",
                  icon: "icon-end-call",
                  didMount: (button) => {
                    this.endButtonRef = button.buttonRef;
                  },
                  onClick: () =>
                    chatRoom.type !== "private" && peers.length && Call.isModerator(chatRoom, u_handle)
                      ? this.setState(
                          (state) => ({
                            endCallOptions: !state.endCallOptions
                          }),
                          () => this.endButtonRef && $(this.endButtonRef.current).trigger("simpletipClose")
                        )
                      : onCallEnd()
                },
                external_React_default().createElement("span", null, l[5884])
              )
            );
          };
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          document.removeEventListener("mousedown", this.handleMousedown);
        }
        componentDidMount() {
          super.componentDidMount();
          document.addEventListener("mousedown", this.handleMousedown);
        }
        render() {
          const {
            call,
            chatRoom,
            signal,
            onAudioClick,
            onVideoClick,
            onScreenSharingClick,
            onHoldClick,
            renderSignalWarning,
            hasToRenderPermissionsWarning,
            renderPermissionsWarning,
            resetError,
            blocked,
            renderBlockedWarning
          } = this.props;
          const avFlags = call.av;
          const audioLabel = avFlags & Av.Audio ? l[16214] : l[16708];
          const videoLabel = avFlags & Av.Camera ? l[22894] : l[22893];
          const screenSharingLabel = avFlags & Av.Screen ? l[22890] : l[22889];
          const callHoldLabel = avFlags & Av.onHold ? l[23459] : l[23460];
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            blocked && renderBlockedWarning(),
            external_React_default().createElement(
              "div",
              {
                className: StreamControls.NAMESPACE
              },
              d ? this.renderDebug() : "",
              external_React_default().createElement(
                "ul",
                null,
                external_React_default().createElement(
                  "li",
                  null,
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      simpletip: {
                        ...this.SIMPLETIP,
                        label: audioLabel
                      },
                      className: `
                                    mega-button
                                    theme-light-forced
                                    round
                                    large
                                    ${avFlags & Av.onHold ? "disabled" : ""}
                                    ${avFlags & Av.Audio ? "" : "inactive"}
                                `,
                      icon: `${avFlags & Av.Audio ? "icon-audio-filled" : "icon-audio-off"}`,
                      onClick: () => {
                        resetError(Av.Audio);
                        onAudioClick();
                      }
                    },
                    external_React_default().createElement("span", null, audioLabel)
                  ),
                  signal ? null : renderSignalWarning(),
                  hasToRenderPermissionsWarning(Av.Audio) ? renderPermissionsWarning(Av.Audio) : null
                ),
                external_React_default().createElement(
                  "li",
                  null,
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      simpletip: {
                        ...this.SIMPLETIP,
                        label: videoLabel
                      },
                      className: `
                                    mega-button
                                    theme-light-forced
                                    round
                                    large
                                    ${avFlags & Av.onHold ? "disabled" : ""}
                                    ${avFlags & Av.Camera ? "" : "inactive"}
                                `,
                      icon: `${avFlags & Av.Camera ? "icon-video-call-filled" : "icon-video-off"}`,
                      onClick: () => {
                        resetError(Av.Camera);
                        onVideoClick();
                      }
                    },
                    external_React_default().createElement("span", null, videoLabel)
                  ),
                  hasToRenderPermissionsWarning(Av.Camera) ? renderPermissionsWarning(Av.Camera) : null
                ),
                external_React_default().createElement(
                  "li",
                  null,
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      key: "screen-sharing",
                      simpletip: {
                        ...this.SIMPLETIP,
                        label: screenSharingLabel
                      },
                      className: `
                                    mega-button
                                    theme-light-forced
                                    round
                                    large
                                    ${avFlags & Av.onHold ? "disabled" : ""}
                                    ${avFlags & Av.Screen ? "active" : ""}
                                `,
                      icon: avFlags & Av.Screen ? "icon-end-screenshare" : "icon-screen-share",
                      onClick: () => {
                        resetError(Av.Screen);
                        onScreenSharingClick();
                      }
                    },
                    external_React_default().createElement("span", null, screenSharingLabel)
                  ),
                  hasToRenderPermissionsWarning(Av.Screen) ? renderPermissionsWarning(Av.Screen, this) : null
                ),
                external_React_default().createElement(
                  "li",
                  null,
                  external_React_default().createElement(
                    meetings_button.Z,
                    {
                      key: "call-hold",
                      simpletip: {
                        ...this.SIMPLETIP,
                        label: callHoldLabel
                      },
                      className: `
                                    mega-button
                                    theme-light-forced
                                    round
                                    large
                                    ${avFlags & Av.onHold ? "active" : ""}
                                `,
                      icon: avFlags & Av.onHold ? "icon-play" : "icon-pause",
                      onClick: onHoldClick
                    },
                    external_React_default().createElement("span", null, callHoldLabel)
                  )
                ),
                external_React_default().createElement("li", null, this.renderEndCall())
              )
            )
          );
        }
      }
      StreamControls.NAMESPACE = "stream-controls";
      const streamControls = (0, mixins.qC)(withMicObserver, permissionsObserver.Q)(StreamControls); // CONCATENATED MODULE: ./js/chat/ui/meetings/sidebarControls.jsx
      class SidebarControls extends mixins.wl {
        render() {
          const { npeers, view, sidebar, chatRoom, onChatToggle, onParticipantsToggle } = this.props;
          const SIMPLETIP = {
            position: "top",
            offset: 5,
            className: "theme-dark-forced"
          };
          const notifications = chatRoom.getUnreadCount();
          return external_React_default().createElement(
            "div",
            {
              className: "sidebar-controls"
            },
            external_React_default().createElement(
              "ul",
              null,
              external_React_default().createElement(
                "li",
                null,
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    className: `
                                mega-button
                                theme-dark-forced
                                round
                                large
                                ${sidebar && view === VIEW.CHAT ? "selected" : ""}
                            `,
                    simpletip: {
                      ...SIMPLETIP,
                      label: l.chats
                    },
                    icon: "icon-chat-filled",
                    onClick: onChatToggle
                  },
                  external_React_default().createElement("span", null, l.chats)
                ),
                notifications > 0 &&
                  external_React_default().createElement(
                    "span",
                    {
                      className: "notifications-count"
                    },
                    notifications > 9 ? "9+" : notifications
                  )
              ),
              external_React_default().createElement(
                "li",
                null,
                external_React_default().createElement(
                  meetings_button.Z,
                  {
                    className: `
                                mega-button
                                theme-dark-forced
                                round
                                large
                                ${sidebar && view === VIEW.PARTICIPANTS ? "selected" : ""}
                            `,
                    simpletip: {
                      ...SIMPLETIP,
                      label: l[16217]
                    },
                    icon: "icon-contacts",
                    onClick: onParticipantsToggle
                  },
                  external_React_default().createElement("span", null, l[16217])
                ),
                external_React_default().createElement(
                  "span",
                  {
                    className: "participants-count"
                  },
                  npeers + 1
                )
              )
            )
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/meetings/call.jsx
      const call_NAMESPACE = "meetings-call";
      const EXPANDED_FLAG = "in-call";
      const MOUSE_OUT_DELAY = 2500;
      const MODE = {
        THUMBNAIL: 1,
        MAIN: 2,
        MINI: 3
      };
      const VIEW = {
        DEFAULT: 0,
        CHAT: 1,
        PARTICIPANTS: 2
      };
      const TYPE = {
        AUDIO: 1,
        VIDEO: 2
      };
      const isGuest = () => !u_type;
      const inProgressAlert = (isJoin, chatRoom) => {
        return new Promise((resolve, reject) => {
          if (megaChat.haveAnyActiveCall()) {
            if (window.sfuClient) {
              const { chatRoom: activeCallRoom } = megaChat.activeCall;
              const peers = activeCallRoom
                ? activeCallRoom.getParticipantsExceptMe(activeCallRoom.getCallParticipants()).map((h) => M.getNameByHandle(h))
                : [];
              let body = isJoin ? l.cancel_to_join : l.cancel_to_start;
              if (peers.length) {
                body = mega.utils.trans.listToString(peers, isJoin ? l.cancel_with_to_join : l.cancel_with_to_start);
              }
              msgDialog("warningb", null, l.call_in_progress, body, null, 1);
              return reject();
            }
            if (chatRoom.getCallParticipants().includes(u_handle)) {
              return resolve();
            }
            return msgDialog(
              `warningb:!^${l[2005]}!${isJoin ? l.join_call_anyway : l.start_call_anyway}`,
              null,
              isJoin ? l.join_multiple_calls_title : l.start_multiple_calls_title,
              isJoin ? l.join_multiple_calls_text : l.start_multiple_calls_text,
              (join) => {
                if (join) {
                  return resolve();
                }
                return reject();
              },
              1
            );
          }
          resolve();
        });
      };
      class Call extends mixins.wl {
        constructor(props) {
          super(props);
          this.ephemeralAddListener = undefined;
          this.delayProcID = null;
          this.pCallTimer = null;
          this.offlineDelayed = undefined;
          this.callStartTimeout = undefined;
          this.flagMap = attribCache.bitMapsManager.exists("obv4") ? attribCache.bitMapsManager.get("obv4") : undefined;
          this.state = {
            mode: undefined,
            view: VIEW.PARTICIPANTS,
            sidebar: false,
            forcedLocal: false,
            hovered: false,
            invite: false,
            ephemeral: false,
            offline: false,
            ephemeralAccounts: [],
            everHadPeers: false,
            guest: isGuest(),
            waitingRoomPeers: [],
            initialCallRinging: false,
            onboarding: false
          };
          this.handleRetryTimeout = () => {
            var _call$sfuClient;
            const { call, chatRoom } = this.props;
            if (
              (call == null || (_call$sfuClient = call.sfuClient) == null ? void 0 : _call$sfuClient.connState) ===
              SfuClient.ConnState.kDisconnectedRetrying
            ) {
              this.handleCallEnd();
              chatRoom.trigger("onRetryTimeout");
              ion.sound.play(megaChat.SOUNDS.CALL_END);
            }
          };
          this.handleCallOnline = () => {
            if (this.pCallTimer) {
              this.pCallTimer.abort();
              this.pCallTimer = null;
            }
            this.setState({
              offline: false
            });
          };
          this.customIsEventuallyVisible = () => true;
          this.bindCallEvents = () => {
            const { chatRoom } = this.props;
            chatRoom.rebind(`onCallPeerLeft.${call_NAMESPACE}`, () => {
              const { minimized, peers, call } = this.props;
              if (minimized) {
                this.setState(
                  {
                    mode: peers.length === 0 ? MODE.THUMBNAIL : MODE.MINI
                  },
                  () => {
                    call.setViewMode(this.state.mode);
                  }
                );
              }
            });
            chatRoom.rebind(`onCallPeerJoined.${call_NAMESPACE}`, () => {
              const { minimized, peers, call } = this.props;
              if (minimized) {
                this.setState(
                  {
                    mode: peers.length === 0 ? MODE.THUMBNAIL : MODE.MINI
                  },
                  () => {
                    call.setViewMode(this.state.mode);
                  }
                );
              }
              if (call.hasOtherParticipant()) {
                if (!this.state.everHadPeers) {
                  this.setState({
                    everHadPeers: true
                  });
                }
                clearTimeout(this.callStartTimeout);
              }
            });
            chatRoom.rebind(`onCallLeft.${call_NAMESPACE}`, () => this.props.minimized && this.props.onCallEnd());
            chatRoom.rebind(`wrOnUsersEntered.${call_NAMESPACE}`, (ev, users) =>
              Object.entries(users).forEach(([handle, host]) => {
                return host || this.state.waitingRoomPeers.includes(handle)
                  ? null
                  : this.isMounted() &&
                      this.setState(
                        {
                          waitingRoomPeers: [...this.state.waitingRoomPeers, handle]
                        },
                        () => {
                          const { waitingRoomPeers } = this.state;
                          if (waitingRoomPeers && waitingRoomPeers.length === 1) {
                            ion.sound.play(megaChat.SOUNDS.CALL_JOIN_WAITING);
                          }
                          mBroadcaster.sendMessage("meetings:peersWaiting", waitingRoomPeers);
                        }
                      );
              })
            );
            chatRoom.rebind(
              `wrOnUserLeft.${call_NAMESPACE}`,
              (ev, user) =>
                this.isMounted() &&
                this.setState(
                  {
                    waitingRoomPeers: this.state.waitingRoomPeers.filter((h) => h !== user)
                  },
                  () => mBroadcaster.sendMessage("meetings:peersWaiting", this.state.waitingRoomPeers)
                )
            );
            chatRoom.rebind(`wrOnUserDump.${call_NAMESPACE}`, (ev, users) =>
              Object.entries(users).forEach(([handle, host]) => {
                return host || this.state.waitingRoomPeers.includes(handle)
                  ? null
                  : this.isMounted() &&
                      this.setState({
                        waitingRoomPeers: [...this.state.waitingRoomPeers, handle]
                      });
              })
            );
          };
          this.unbindCallEvents = () =>
            [
              `onCallPeerLeft.${call_NAMESPACE}`,
              `onCallPeerJoined.${call_NAMESPACE}`,
              `onCallLeft.${call_NAMESPACE}`,
              `wrOnUsersEntered.${call_NAMESPACE}`,
              `wrOnUserLeft.${call_NAMESPACE}`,
              `alterUserPrivilege.${call_NAMESPACE}`
            ].map((event) => this.props.chatRoom.off(event));
          this.handleCallMinimize = () => {
            const { call, peers, onCallMinimize } = this.props;
            const { mode, sidebar, view } = this.state;
            const { callToutId, stayOnEnd } = call;
            Call.STATE.PREVIOUS =
              mode !== MODE.MINI
                ? {
                    mode,
                    sidebar,
                    view
                  }
                : Call.STATE.PREVIOUS;
            return peers.length > 0
              ? this.setState(
                  {
                    mode: MODE.MINI,
                    sidebar: false
                  },
                  () => {
                    onCallMinimize();
                    call.setViewMode(MODE.MINI);
                  }
                )
              : (() => {
                  onCallMinimize();
                  if (typeof callToutId !== "undefined" && !stayOnEnd) {
                    onIdle(() => call.showTimeoutDialog());
                  }
                })();
          };
          this.handleCallExpand = async () => {
            return new Promise((resolve) => {
              this.setState(
                {
                  ...Call.STATE.PREVIOUS
                },
                () => {
                  this.props.onCallExpand();
                  resolve();
                }
              );
            });
          };
          this.handleStreamToggle = (action) => {
            const { peers } = this.props;
            if (action === STREAM_ACTIONS.ADD && peers.length === MAX_STREAMS) {
              return;
            }
            return action === STREAM_ACTIONS.ADD ? peers.addFakeDupStream() : peers.removeFakeDupStream();
          };
          this.handleSpeakerChange = (videoNode) => {
            if (videoNode) {
              this.handleModeChange(MODE.MAIN);
              this.props.call.setForcedActiveStream(videoNode.clientId);
              this.setState({
                forcedLocal: videoNode.isLocal
              });
            }
          };
          this.handleModeChange = (mode) => {
            this.props.call.setViewMode(mode);
            this.setState({
              mode,
              sidebar: false,
              forcedLocal: false
            });
          };
          this.handleChatToggle = () => {
            if (this.state.sidebar && this.state.view === VIEW.CHAT) {
              return this.setState({
                ...Call.STATE.DEFAULT
              });
            }
            return this.setState({
              sidebar: true,
              view: VIEW.CHAT
            });
          };
          this.handleParticipantsToggle = () => {
            if (this.state.sidebar && this.state.view === VIEW.CHAT) {
              return this.setState({
                sidebar: true,
                view: VIEW.PARTICIPANTS
              });
            }
            return this.setState({
              sidebar: !this.state.sidebar,
              view: VIEW.PARTICIPANTS
            });
          };
          this.handleInviteToggle = () => {
            if (M.u.length > 1) {
              const participants = (0, conversationpanel.hU)(this.props.chatRoom);
              if ((0, conversationpanel.R7)(participants)) {
                msgDialog(
                  `confirmationa:!^${l[8726]}!${l[82]}`,
                  null,
                  `${l.all_contacts_added}`,
                  `${l.all_contacts_added_to_chat}`,
                  (res) => {
                    if (res) {
                      contactAddDialog(null, false);
                    }
                  }
                );
              } else {
                this.setState({
                  invite: !this.state.invite
                });
              }
            } else {
              msgDialog(`confirmationa:!^${l[8726]}!${l[82]}`, null, `${l.no_contacts}`, `${l.no_contacts_text}`, (resp) => {
                if (resp) {
                  contactAddDialog(null, false);
                }
              });
            }
          };
          this.handleHoldToggle = async () => {
            await this.props.call.toggleHold();
            mBroadcaster.sendMessage("meetings:toggleHold");
          };
          this.handleScreenSharingToggle = () => {
            const { call } = this.props;
            const userAgent = navigator.userAgent.match(/Chrom(e|ium)\/(\d+)\./);
            const version = parseInt(userAgent[2], 10);
            if (version === 92) {
              return msgDialog("info", undefined, l[47], l.chrome_screensharing);
            }
            return call.toggleScreenSharing();
          };
          this.handleCallEnd = () => {
            var _this$props$call;
            (_this$props$call = this.props.call) == null || _this$props$call.destroy();
          };
          this.handleEphemeralAdd = (handle) =>
            handle &&
            this.setState((state) => ({
              ephemeral: true,
              ephemeralAccounts: [...state.ephemeralAccounts, handle]
            }));
          this.handleStayConfirm = () => {
            const { call } = this.props;
            call.handleStayConfirm();
            onIdle(() => this.safeForceUpdate());
          };
          const { SOUNDS } = megaChat;
          [SOUNDS.RECONNECT, SOUNDS.CALL_END, SOUNDS.CALL_JOIN_WAITING].map((sound) => ion.sound.preload(sound));
          this.state.mode = props.call.viewMode;
          this.state.onboarding = this.state.hovered = this.flagMap && !this.flagMap.getSync(OBV4_FLAGS.CHAT_CALL_UI);
          this.handleMouseMove = this.handleMouseMove.bind(this);
          this.handleMouseOut = this.handleMouseOut.bind(this);
        }
        handleMouseMove() {
          this.setState({
            hovered: true
          });
          if (this.delayProcID) {
            delay.cancel(this.delayProcID);
            this.delayProcID = null;
          }
        }
        handleMouseOut() {
          if (this.state.hovered) {
            this.delayProcID = delay(
              "meetings-call-hover",
              () => {
                if (this.isMounted()) {
                  this.setState({
                    hovered: false
                  });
                }
              },
              MOUSE_OUT_DELAY
            );
          }
        }
        handleCallOffline() {
          if (!this.pCallTimer) {
            (this.pCallTimer = tSleep(30)).then(() => {
              this.setState({
                offline: true
              });
            });
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          const { minimized, willUnmount, chatRoom } = this.props;
          chatRoom.megaChat.off(`sfuConnClose.${call_NAMESPACE}`);
          chatRoom.megaChat.off(`sfuConnOpen.${call_NAMESPACE}`);
          mBroadcaster.removeListener(this.ephemeralAddListener);
          if (this.pageChangeListener) {
            mBroadcaster.removeListener(this.pageChangeListener);
          }
          clearTimeout(this.callStartTimeout);
          delay.cancel("callOffline");
          this.unbindCallEvents();
          willUnmount == null || willUnmount(minimized);
        }
        componentDidMount() {
          super.componentDidMount();
          const { call, didMount, chatRoom } = this.props;
          this.ephemeralAddListener = mBroadcaster.addListener("meetings:ephemeralAdd", (handle) => this.handleEphemeralAdd(handle));
          this.pageChangeListener = mBroadcaster.addListener("pagechange", () => {
            const currentRoom = megaChat.getCurrentRoom();
            if (Call.isExpanded() && (!M.chat || (currentRoom && currentRoom.chatId !== chatRoom.chatId))) {
              this.handleCallMinimize();
            }
          });
          chatRoom.megaChat.rebind(`sfuConnOpen.${call_NAMESPACE}`, this.handleCallOnline);
          chatRoom.megaChat.rebind(`sfuConnClose.${call_NAMESPACE}`, () => this.handleCallOffline());
          this.callStartTimeout = setTimeout(() => {
            if (!mega.config.get("callemptytout") && !call.hasOtherParticipant()) {
              call.left = true;
              call.initCallTimeout();
            }
          }, 300000);
          setTimeout(() => {
            var _call$peers;
            return (
              ((_call$peers = call.peers) == null ? void 0 : _call$peers.length) &&
              !call.hasOtherParticipant() &&
              this.setState({
                everHadPeers: true
              })
            );
          }, 2e3);
          if (sessionStorage.previewMedia) {
            const { audio, video } = JSON.parse(sessionStorage.previewMedia);
            sessionStorage.removeItem("previewMedia");
            tSleep(2)
              .then(() => audio && call.sfuClient.muteAudio())
              .then(() => video && call.sfuClient.muteCamera())
              .catch(dump);
          }
          this.bindCallEvents();
          didMount == null || didMount();
          chatRoom.rebind("onCallState.callComp", (ev, { arg }) =>
            this.setState({
              initialCallRinging: arg
            })
          );
        }
        render() {
          const { minimized, peers, call, chatRoom, parent, onDeleteMessage } = this.props;
          const {
            mode,
            view,
            sidebar,
            hovered,
            forcedLocal,
            invite,
            ephemeral,
            ephemeralAccounts,
            guest,
            offline,
            onboarding,
            everHadPeers,
            initialCallRinging,
            waitingRoomPeers
          } = this.state;
          const { stayOnEnd } = call;
          const STREAM_PROPS = {
            mode,
            peers,
            sidebar,
            hovered,
            forcedLocal,
            call,
            view,
            chatRoom,
            parent,
            stayOnEnd,
            everHadPeers,
            waitingRoomPeers,
            hasOtherParticipants: call.hasOtherParticipant(),
            isOnHold: call.sfuClient.isOnHold(),
            onSpeakerChange: this.handleSpeakerChange,
            onInviteToggle: this.handleInviteToggle,
            onStayConfirm: this.handleStayConfirm
          };
          return external_React_default().createElement(
            "div",
            {
              className: `
                    meetings-call
                    ${minimized ? "minimized" : ""}
                `,
              onMouseMove: onboarding ? null : this.handleMouseMove,
              onMouseOut: onboarding ? null : this.handleMouseOut
            },
            external_React_default().createElement(
              stream_Stream,
              (0, esm_extends.Z)({}, STREAM_PROPS, {
                minimized: minimized,
                ephemeralAccounts: ephemeralAccounts,
                onCallMinimize: this.handleCallMinimize,
                onCallExpand: this.handleCallExpand,
                onCallEnd: this.handleCallEnd,
                onStreamToggle: this.handleStreamToggle,
                onModeChange: this.handleModeChange,
                onChatToggle: this.handleChatToggle,
                onParticipantsToggle: this.handleParticipantsToggle,
                onAudioClick: () => call.toggleAudio(),
                onVideoClick: () => call.toggleVideo(),
                onScreenSharingClick: this.handleScreenSharingToggle,
                onHoldClick: this.handleHoldToggle,
                onThumbnailDoubleClick: (videoNode) => this.handleSpeakerChange(videoNode)
              })
            ),
            sidebar &&
              external_React_default().createElement(
                Sidebar,
                (0, esm_extends.Z)({}, STREAM_PROPS, {
                  guest: guest,
                  initialCallRinging: initialCallRinging,
                  onGuestClose: () =>
                    this.setState({
                      guest: false
                    }),
                  onSidebarClose: () =>
                    this.setState({
                      ...Call.STATE.DEFAULT
                    }),
                  onDeleteMessage: onDeleteMessage
                })
              ),
            minimized
              ? null
              : external_React_default().createElement(
                  external_React_default().Fragment,
                  null,
                  external_React_default().createElement(streamControls, {
                    call: call,
                    minimized: minimized,
                    peers: peers,
                    chatRoom: chatRoom,
                    onAudioClick: () => call.toggleAudio(),
                    onVideoClick: () => call.toggleVideo(),
                    onScreenSharingClick: this.handleScreenSharingToggle,
                    onCallEnd: this.handleCallEnd,
                    onStreamToggle: this.handleStreamToggle,
                    onHoldClick: this.handleHoldToggle
                  }),
                  external_React_default().createElement(SidebarControls, {
                    chatRoom: chatRoom,
                    npeers: peers.length,
                    mode: mode,
                    view: view,
                    sidebar: sidebar,
                    onChatToggle: this.handleChatToggle,
                    onParticipantsToggle: this.handleParticipantsToggle
                  })
                ),
            invite &&
              external_React_default().createElement(Invite, {
                contacts: M.u,
                call: call,
                chatRoom: chatRoom,
                onClose: () =>
                  this.setState({
                    invite: false
                  })
              }),
            ephemeral &&
              external_React_default().createElement(Ephemeral, {
                ephemeralAccounts: ephemeralAccounts,
                onClose: () =>
                  this.setState({
                    ephemeral: false
                  })
              }),
            offline &&
              external_React_default().createElement(Offline, {
                onClose: () => {
                  if (offline) {
                    this.setState(
                      {
                        offline: false
                      },
                      () => delay("call:timeout", this.handleRetryTimeout, 3e4)
                    );
                  }
                },
                onCallEnd: () => {
                  this.setState(
                    {
                      offline: false
                    },
                    () => this.handleRetryTimeout()
                  );
                }
              }),
            onboarding &&
              external_React_default().createElement(
                "div",
                {
                  className: "meetings-call-onboarding"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "mega-dialog mega-onboarding-dialog dialog-template-message",
                    id: "ob-dialog",
                    role: "dialog",
                    "aria-labelledby": "ob-dialog-title",
                    "aria-modal": "true"
                  },
                  external_React_default().createElement("i", {
                    className: "sprite-fm-mono icon-tooltip-arrow tooltip-arrow top",
                    id: "ob-dialog-arrow"
                  }),
                  external_React_default().createElement(
                    "header",
                    null,
                    external_React_default().createElement(
                      "div",
                      null,
                      external_React_default().createElement(
                        "h2",
                        {
                          id: "ob-dialog-title"
                        },
                        l.onboarding_call_title
                      ),
                      external_React_default().createElement(
                        "p",
                        {
                          id: "ob-dialog-text"
                        },
                        l.onboarding_call_body
                      )
                    )
                  ),
                  external_React_default().createElement(
                    "footer",
                    null,
                    external_React_default().createElement(
                      "div",
                      {
                        className: "footer-container"
                      },
                      external_React_default().createElement(
                        "button",
                        {
                          className: "mega-button js-next small theme-light-forced",
                          onClick: () => {
                            this.setState(
                              {
                                onboarding: false,
                                hovered: false
                              },
                              () => {
                                this.flagMap.setSync(OBV4_FLAGS.CHAT_CALL_UI, 1);
                                this.flagMap.safeCommit();
                              }
                            );
                          }
                        },
                        external_React_default().createElement("span", null, l.ok_button)
                      )
                    )
                  )
                )
              )
          );
        }
      }
      Call.STATE = {
        DEFAULT: {
          sidebar: false
        },
        PREVIOUS: {
          mode: null,
          sidebar: null,
          view: null
        }
      };
      Call.isModerator = (chatRoom, handle) => {
        if (chatRoom && handle) {
          return chatRoom.members[handle] === ChatRoom.MembersSet.PRIVILEGE_STATE.OPERATOR;
        }
        return false;
      };
      Call.isExpanded = () => document.body.classList.contains(EXPANDED_FLAG);
      Call.getUnsupportedBrowserMessage = () =>
        navigator.userAgent.match(/Chrom(e|ium)\/(\d+)\./) ? l.alert_unsupported_browser_version : l.alert_unsupported_browser;

      /***/
    },

    /***/ 419: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        N: () => withHostsObserver
      });
      var _extends5__ = __webpack_require__(462);
      var react0__ = __webpack_require__(363);
      var react0 = __webpack_require__.n(react0__);
      var _mixins_js1__ = __webpack_require__(503);
      var _ui_modalDialogs_jsx2__ = __webpack_require__(182);
      var _contacts_jsx3__ = __webpack_require__(13);
      var _ui_buttons_jsx4__ = __webpack_require__(204);

      const withHostsObserver = (Component) => {
        return class extends _mixins_js1__.wl {
          constructor(...args) {
            super(...args);
            this.state = {
              dialog: false,
              selected: []
            };
            this.hasHost = (participants) =>
              participants.some(
                (handle) => this.props.chatRoom.members[handle] === ChatRoom.MembersSet.PRIVILEGE_STATE.OPERATOR && handle !== u_handle
              );
            this.toggleDialog = () => {
              this.setState(
                (state) => ({
                  dialog: !state.dialog,
                  selected: []
                }),
                () => this.safeForceUpdate()
              );
            };
            this.renderDialog = () => {
              var _this$props$participa;
              const { selected } = this.state;
              return react0().createElement(
                _ui_modalDialogs_jsx2__.Z.ModalDialog,
                (0, _extends5__.Z)({}, this.state, {
                  className: "assign-host contact-picker-widget",
                  dialogName: "assign-host-dialog",
                  dialogType: "tool",
                  onClose: () =>
                    this.setState(
                      {
                        dialog: false
                      },
                      () => this.safeForceUpdate()
                    )
                }),
                react0().createElement("header", null, react0().createElement("h2", null, l.assign_host_title)),
                react0().createElement(
                  "div",
                  {
                    className: "content-block"
                  },
                  react0().createElement(_contacts_jsx3__.ContactPickerWidget, {
                    className: "popup contacts-search small-footer",
                    contacts:
                      (_this$props$participa = this.props.participants) == null
                        ? void 0
                        : _this$props$participa.filter((h) => h !== u_handle),
                    multiple: true,
                    hideSearch: true,
                    disableFrequents: true,
                    participantsList: true,
                    disableDoubleClick: true,
                    emailTooltips: true,
                    nothingSelectedButtonLabel: l.add_hosts_placeholder,
                    onClose: () =>
                      this.setState({
                        dialog: false
                      }),
                    onSelect: (selected) =>
                      this.setState(
                        {
                          selected
                        },
                        () => this.safeForceUpdate()
                      )
                  })
                ),
                react0().createElement(
                  "footer",
                  null,
                  react0().createElement(
                    "div",
                    {
                      className: "footer-container"
                    },
                    react0().createElement(_ui_buttons_jsx4__.z, {
                      label: l[82],
                      className: "mega-button",
                      onClick: this.toggleDialog
                    }),
                    react0().createElement(_ui_buttons_jsx4__.z, {
                      label: l.assign_and_leave,
                      className: `
                                        mega-button
                                        positive
                                        ${selected.length ? "" : "disabled"}
                                    `,
                      onClick: () => selected.length && this.assignAndLeave()
                    })
                  )
                )
              );
            };
            this.assignAndLeave = () => {
              const { chatRoom, onLeave } = this.props;
              const { selected } = this.state;
              for (let i = selected.length; i--; ) {
                chatRoom.trigger("alterUserPrivilege", [selected[i], ChatRoom.MembersSet.PRIVILEGE_STATE.OPERATOR]);
              }
              this.toggleDialog();
              onLeave == null || onLeave();
              $(document).trigger("closeDropdowns");
            };
            this.confirmLeave = ({ title, body, cta }) => {
              msgDialog(`confirmationa:!^${cta}!${l[82]}`, null, title, body, (cb) => cb && this.toggleDialog(), 1);
            };
          }
          render() {
            return react0().createElement(
              react0().Fragment,
              null,
              react0().createElement(
                Component,
                (0, _extends5__.Z)({}, this.props, {
                  confirmLeave: this.confirmLeave,
                  hasHost: this.hasHost
                })
              ),
              this.state.dialog && this.renderDialog()
            );
          }
        };
      };

      /***/
    },

    /***/ 209: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        Q: () => withPermissionsObserver
      });
      var _extends4__ = __webpack_require__(462);
      var react0__ = __webpack_require__(363);
      var react0 = __webpack_require__.n(react0__);
      var _mixins_js1__ = __webpack_require__(503);
      var _ui_modalDialogs_jsx2__ = __webpack_require__(182);
      var _ui_utils_jsx3__ = __webpack_require__(79);

      const errors = {
        browser: "NotAllowedError: Permission denied",
        system: "NotAllowedError: Permission denied by system",
        dismissed: "NotAllowedError: Permission dismissed",
        nil: "NotFoundError: Requested device not found"
      };
      const isUserActionError = (error) => {
        return error && error === errors.browser;
      };
      const withPermissionsObserver = (Component) => {
        return class extends _mixins_js1__.wl {
          constructor(props) {
            super(props);
            this.namespace = `PO-${Component.NAMESPACE}`;
            this.observer = `onLocalMediaError.${this.namespace}`;
            this.childRef = undefined;
            this.platform = ua.details.os;
            this.helpURL = `${l.mega_help_host}/chats-meetings/meetings/enable-camera-mic-browser-system-permission`;
            this.macURI = "x-apple.systempreferences:com.apple.preference.security";
            this.winURI = "ms-settings";
            this.CONTENT = {
              [Av.Audio]: {
                system: {
                  title: l.no_mic_title,
                  info:
                    this.platform === "Windows"
                      ? l.no_mic_system_windows
                          .replace("[A]", `<a href=${this.helpURL} target="_blank" class="clickurl">`)
                          .replace("[/A]", "</a>")
                      : l.no_mic_system_mac
                          .replace("[A]", `<a href="${this.helpURL}" target="_blank" class="clickurl">`)
                          .replace("[/A]", "</a>"),
                  buttons: [
                    this.platform === "Apple" || this.platform === "Windows"
                      ? {
                          key: "open-settings",
                          label: l.open_system_settings,
                          className: "positive",
                          onClick: () => {
                            window.open(
                              this.platform === "Apple" ? `${this.macURI}?Privacy_Microphone` : `${this.winURI}:privacy-microphone`,
                              "_blank",
                              "noopener,noreferrer"
                            );
                            this.closePermissionsDialog(Av.Audio);
                          }
                        }
                      : {
                          key: "ok",
                          label: l.ok_button,
                          className: "positive",
                          onClick: () => this.closePermissionsDialog(Av.Audio)
                        }
                  ]
                },
                browser: {
                  title: l.no_mic_title,
                  cover: "permissions-mic",
                  info: l.allow_mic_access.replace("[X]", '<i class="sprite-fm-theme icon-mic-disabled"></i>'),
                  buttons: [
                    {
                      key: "ok",
                      label: l.ok_button,
                      className: "positive",
                      onClick: () => this.closePermissionsDialog(Av.Audio)
                    }
                  ]
                },
                nil: {
                  title: l.no_mic_detected_title,
                  info: l.no_mic_detected_info,
                  buttons: [
                    {
                      key: "ok",
                      label: l.ok_button,
                      className: "positive",
                      onClick: () => this.closePermissionsDialog(Av.Audio)
                    }
                  ]
                }
              },
              [Av.Camera]: {
                system: {
                  title: l.no_camera_title,
                  info:
                    this.platform === "Windows"
                      ? l.no_camera_system_windows
                          .replace("[A]", `<a href="${this.helpURL}" target="_blank" class="clickurl">`)
                          .replace("[/A]", "</a>")
                      : l.no_camera_system_mac
                          .replace("[A]", `<a href="${this.helpURL}" target="_blank" class="clickurl">`)
                          .replace("[/A]", "</a>"),
                  buttons: [
                    this.platform === "Apple" || this.platform === "Windows"
                      ? {
                          key: "open-settings",
                          label: l.open_system_settings,
                          className: "positive",
                          onClick: () => {
                            window.open(
                              this.platform === "Apple" ? `${this.macURI}?Privacy_Camera` : `${this.winURI}:privacy-webcam`,
                              "_blank",
                              "noopener,noreferrer"
                            );
                            this.closePermissionsDialog(Av.Camera);
                          }
                        }
                      : {
                          key: "ok",
                          label: l.ok_button,
                          className: "positive",
                          onClick: () => this.closePermissionsDialog(Av.Camera)
                        }
                  ]
                },
                browser: {
                  title: l.no_camera_title,
                  cover: "permissions-camera",
                  info: l.allow_camera_access.replace("[X]", '<i class="sprite-fm-theme icon-camera-disabled"></i>'),
                  buttons: [
                    {
                      key: "ok",
                      label: l.ok_button,
                      className: "positive",
                      onClick: () => this.closePermissionsDialog(Av.Camera)
                    }
                  ]
                },
                nil: {
                  title: l.no_camera_detected_title,
                  info: l.no_camera_detected_info,
                  buttons: [
                    {
                      key: "ok",
                      label: l.ok_button,
                      className: "positive",
                      onClick: () => this.closePermissionsDialog(Av.Camera)
                    }
                  ]
                }
              },
              [Av.Screen]: {
                title: l.no_screen_title,
                info: l.no_screen_system
                  .replace("[A]", `<a href="${this.helpURL}" target="_blank" class="clickurl">`)
                  .replace("[/A]", "</a>"),
                buttons: [
                  {
                    key: "open-settings",
                    label: l.open_system_settings,
                    className: "positive",
                    onClick: () => {
                      window.open(`${this.macURI}?Privacy_ScreenCapture`, "_blank", "noopener,noreferrer");
                      this.closePermissionsDialog(Av.Screen);
                    }
                  }
                ]
              }
            };
            this.state = {
              errMic: "",
              errCamera: "",
              errScreen: "",
              [`dialog-${Av.Audio}`]: null,
              [`dialog-${Av.Camera}`]: null,
              [`dialog-${Av.Screen}`]: null
            };
            this.getPermissionsDialogContent = () => {
              const { CONTENT, state } = this;
              const { errMic, errCamera } = state;
              const { browser, system, nil } = errors;
              return {
                [Av.Audio]: {
                  ...(errMic === browser && CONTENT[Av.Audio].browser),
                  ...(errMic === system && CONTENT[Av.Audio].system),
                  ...(errMic === nil && CONTENT[Av.Audio].nil)
                },
                [Av.Camera]: {
                  ...(errCamera === browser && CONTENT[Av.Camera].browser),
                  ...(errCamera === system && CONTENT[Av.Camera].system),
                  ...(errCamera === nil && CONTENT[Av.Camera].nil)
                },
                [Av.Screen]: CONTENT[Av.Screen]
              };
            };
            this.resetError = (av) => {
              this.setState({
                errMic: av === Av.Audio ? "" : this.state.errMic,
                errCamera: av === Av.Camera ? "" : this.state.errCamera,
                errScreen: av === Av.Screen ? "" : this.state.errScreen
              });
            };
            this.hasToRenderPermissionsWarning = this.hasToRenderPermissionsWarning.bind(this);
            this.renderPermissionsWarning = this.renderPermissionsWarning.bind(this);
          }
          hasToRenderPermissionsWarning(av) {
            const CONFIG = {
              [Av.Audio]: {
                showOnUserActionError: true,
                err: this.state.errMic
              },
              [Av.Camera]: {
                showOnUserActionError: true,
                err: this.state.errCamera
              },
              [Av.Screen]: {
                showOnUserActionError: false,
                err: this.state.errScreen
              }
            };
            const current = CONFIG[av];
            if (current) {
              return isUserActionError(current.err) ? current.showOnUserActionError : current.err;
            }
            return false;
          }
          closePermissionsDialog(av) {
            this.setState(
              {
                [`dialog-${av}`]: false
              },
              () => {
                var _this$childRef;
                return (_this$childRef = this.childRef) == null ? void 0 : _this$childRef.safeForceUpdate();
              }
            );
          }
          renderPermissionsDialog(av, child) {
            const content = this.getPermissionsDialogContent();
            const { title, info, buttons, cover } = content[av] || {};
            return react0().createElement(
              _ui_modalDialogs_jsx2__.Z.ModalDialog,
              {
                dialogName: `${this.namespace}-permissions-${av}`,
                className: `
                        meetings-permissions-dialog
                        dialog-template-message
                        with-close-btn
                        warning
                    `,
                buttons: buttons,
                hideOverlay: Component.NAMESPACE === "preview-meeting" && !document.body.classList.contains("not-logged"),
                onClose: () => {
                  this.setState(
                    {
                      [`dialog-${av}`]: false
                    },
                    () => child && child.safeForceUpdate()
                  );
                }
              },
              react0().createElement(
                "header",
                null,
                cover
                  ? null
                  : react0().createElement(
                      "div",
                      {
                        className: "graphic"
                      },
                      react0().createElement("i", {
                        className: "warning sprite-fm-uni icon-warning"
                      })
                    ),
                react0().createElement(
                  "div",
                  {
                    className: "info-container"
                  },
                  react0().createElement(
                    "h3",
                    {
                      id: "msgDialog-title"
                    },
                    title
                  ),
                  cover &&
                    react0().createElement(
                      "div",
                      {
                        className: "permissions-warning-cover"
                      },
                      react0().createElement("span", {
                        className: cover
                      })
                    ),
                  react0().createElement(_ui_utils_jsx3__.Cw, {
                    tag: "p",
                    className: "permissions-warning-info",
                    content: info
                  })
                )
              )
            );
          }
          renderPermissionsWarning(av, child) {
            const { errMic, errCamera } = this.state;
            const dismissed = errMic === errors.dismissed || errCamera === errors.dismissed;
            return react0().createElement(
              "div",
              {
                className: `
                        ${this.namespace}
                        meetings-signal-issue
                        simpletip
                        ${dismissed ? "with-small-area" : ""}
                    `,
                "data-simpletip": l.show_info,
                "data-simpletipposition": "top",
                "data-simpletipoffset": "5",
                "data-simpletip-class": "theme-dark-forced",
                onClick: () =>
                  dismissed
                    ? null
                    : this.setState(
                        {
                          [`dialog-${av}`]: true
                        },
                        () => {
                          if (child) {
                            this.childRef = child;
                          }
                        }
                      )
              },
              react0().createElement("i", {
                className: "sprite-fm-mono icon-exclamation-filled"
              }),
              this.state[`dialog-${av}`] && this.renderPermissionsDialog(av, child)
            );
          }
          componentWillUnmount() {
            super.componentWillUnmount();
            megaChat.unbind(this.observer);
          }
          componentDidMount() {
            super.componentDidMount();
            megaChat.rebind(this.observer, (ev, errAv) => {
              this.setState({
                errMic: errAv && errAv.mic ? String(errAv.mic) : this.state.errMic,
                errCamera: errAv && errAv.camera ? String(errAv.camera) : this.state.errCamera,
                errScreen: errAv && errAv.screen ? String(errAv.screen) : this.state.errScreen
              });
            });
            megaChat.rebind(`onLocalMediaQueryError.${this.namespace}`, (ev, { type, err }) => {
              if (type === "screen" && String(err) === errors.system) {
                this.setState(
                  {
                    [`dialog-${Av.Screen}`]: true
                  },
                  () => this.safeForceUpdate()
                );
              }
            });
          }
          render() {
            return react0().createElement(
              Component,
              (0, _extends4__.Z)({}, this.props, this.state, {
                errMic: this.state.errMic,
                errCamera: this.state.errCamera,
                errScreen: this.state.errScreen,
                hasToRenderPermissionsWarning: this.hasToRenderPermissionsWarning,
                resetError: this.resetError,
                renderPermissionsWarning: this.renderPermissionsWarning
              })
            );
          }
        };
      };

      /***/
    },

    /***/ 435: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        K6: () => stringToTime,
        KC: () => isSameDay,
        Ny: () => getNearestHalfHour,
        Pm: () => isTomorrow,
        Sv: () => getUserTimezone,
        nl: () => getTimeIntervals,
        p6: () => stringToDate,
        zI: () => addMonths,
        zk: () => isToday
      });

      const stringToDate = (string) => {
        return moment(string, ["DD MMM YYYY", "DD-MM-YYYY", "DD.MM.YYYY", "MMM DD YYYY", "YYYY MMM DD", "YYYY DD MMM"]);
      };
      const stringToTime = (string) => moment(string, ["HH:mm", "hh:mm A"]);
      const isSameDay = (a, b) => {
        return new Date(a).toDateString() === new Date(b).toDateString();
      };
      const isToday = (timestamp) => {
        return new Date(timestamp).toDateString() === new Date().toDateString();
      };
      const isTomorrow = (timestamp) => {
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        return tomorrow.toDateString() === new Date(timestamp).toDateString();
      };
      const getDaysInMonth = (year, month) => {
        return new Date(year, month, 0).getDate();
      };
      const addMonths = (timestamp, months) => {
        const date = new Date(timestamp);
        return new Date(date.setMonth(date.getMonth() + months)).getTime();
      };
      const getNearestHalfHour = (timestamp = Date.now()) => {
        const { SCHEDULED_MEETINGS_INTERVAL } = ChatRoom;
        return new Date(Math.ceil(timestamp / SCHEDULED_MEETINGS_INTERVAL) * SCHEDULED_MEETINGS_INTERVAL).getTime();
      };
      const getUserTimezone = () => {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      };
      const getTimeIntervals = (timestamp, offsetFrom, interval = 30) => {
        const increments = [];
        if (timestamp) {
          const [targetDate, initialDate] = [new Date(timestamp), new Date(timestamp)].map((date) => {
            date.setHours(0);
            date.setMinutes(0);
            return date;
          });
          while (targetDate.getDate() === initialDate.getDate()) {
            const timestamp = targetDate.getTime();
            const diff = offsetFrom && isSameDay(timestamp, offsetFrom) && timestamp - offsetFrom;
            increments.push({
              value: timestamp,
              label: toLocaleTime(timestamp),
              duration: diff && diff > 0 ? diff : undefined
            });
            targetDate.setMinutes(targetDate.getMinutes() + interval);
          }
        }
        return increments;
      };

      /***/
    },

    /***/ 336: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        default: () => Incoming
      });
      var _extends7__ = __webpack_require__(462);
      var react0__ = __webpack_require__(363);
      var react0 = __webpack_require__.n(react0__);
      var _mixins1__ = __webpack_require__(503);
      var _contacts_jsx2__ = __webpack_require__(13);
      var _ui_modalDialogs_jsx3__ = __webpack_require__(182);
      var _button_jsx4__ = __webpack_require__(193);
      var _call_jsx5__ = __webpack_require__(689);
      var _ui_utils_jsx6__ = __webpack_require__(79);

      class Incoming extends _mixins1__.wl {
        constructor(props) {
          super(props);
          this.state = {
            video: false,
            unsupported: undefined,
            hoveredSwitch: true
          };
          this.renderSwitchControls = () => {
            const className = `mega-button large round switch ${this.state.hoveredSwitch ? "hovered" : ""}`;
            const toggleHover = () =>
              this.setState((state) => ({
                hoveredSwitch: !state.hoveredSwitch
              }));
            return react0().createElement(
              "div",
              {
                className: "switch-button"
              },
              react0().createElement(
                "div",
                {
                  className: "switch-button-container simpletip",
                  "data-simpletip": l.end_and_answer,
                  "data-simpletipposition": "top",
                  onMouseEnter: toggleHover,
                  onMouseLeave: toggleHover,
                  onClick: (ev) => {
                    ev.stopPropagation();
                    this.props.onSwitch();
                  }
                },
                react0().createElement(_button_jsx4__.Z, {
                  className: `${className} negative`,
                  icon: "icon-end-call"
                }),
                react0().createElement(_button_jsx4__.Z, {
                  className: `${className} positive`,
                  icon: "icon-phone"
                })
              )
            );
          };
          this.renderAnswerControls = () => {
            const { video, unsupported } = this.state;
            const { onAnswer, onToggleVideo } = this.props;
            return react0().createElement(
              react0().Fragment,
              null,
              react0().createElement(
                _button_jsx4__.Z,
                {
                  className: `
                        mega-button
                        positive
                        answer
                        ${unsupported ? "disabled" : ""}
                    `,
                  icon: "icon-phone",
                  simpletip: unsupported
                    ? null
                    : {
                        position: "top",
                        label: l[7205]
                      },
                  onClick: unsupported ? null : onAnswer
                },
                react0().createElement("span", null, l[7205])
              ),
              react0().createElement(
                _button_jsx4__.Z,
                {
                  className: `
                        mega-button
                        large
                        round
                        video
                        ${video ? "" : "negative"}
                        ${unsupported ? "disabled" : ""}
                    `,
                  icon: video ? "icon-video-call-filled" : "icon-video-off",
                  simpletip: unsupported
                    ? null
                    : {
                        position: "top",
                        label: video ? l[22894] : l[22893]
                      },
                  onClick: () =>
                    unsupported
                      ? null
                      : this.setState(
                          {
                            video: !video
                          },
                          () => onToggleVideo(video)
                        )
                },
                react0().createElement("span", null, video ? l[22894] : l[22893])
              )
            );
          };
          this.state.unsupported = !megaChat.hasSupportForCalls;
        }
        componentDidMount() {
          super.componentDidMount();
          this._old$dialog = $.dialog;
          $.dialog = "chat-incoming-call";
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          $.dialog = this._old$dialog;
        }
        render() {
          const { chatRoom } = this.props;
          if (chatRoom) {
            const { NAMESPACE } = Incoming;
            const { callerId, onClose, onReject } = this.props;
            const { unsupported } = this.state;
            const CALL_IN_PROGRESS = window.sfuClient;
            const isPrivateRoom = chatRoom.type === "private";
            const rejectLabel = isPrivateRoom ? l[20981] : l[82];
            return react0().createElement(
              _ui_modalDialogs_jsx3__.Z.ModalDialog,
              (0, _extends7__.Z)({}, this.state, {
                name: NAMESPACE,
                className: NAMESPACE,
                roomName: chatRoom.getRoomTitle(),
                onClose: () => onClose()
              }),
              react0().createElement(
                "div",
                {
                  className: "fm-dialog-body"
                },
                react0().createElement(
                  "div",
                  {
                    className: `${NAMESPACE}-avatar`
                  },
                  react0().createElement(_contacts_jsx2__.Avatar, {
                    contact: M.u[callerId]
                  })
                ),
                react0().createElement(
                  "div",
                  {
                    className: `${NAMESPACE}-info`
                  },
                  react0().createElement("h1", null, react0().createElement(_ui_utils_jsx6__.dy, null, chatRoom.getRoomTitle())),
                  react0().createElement("span", null, isPrivateRoom ? l[17878] : l[19995])
                ),
                react0().createElement(
                  "div",
                  {
                    className: `
                                ${NAMESPACE}-controls
                                ${CALL_IN_PROGRESS ? "call-in-progress" : ""}
                            `
                  },
                  react0().createElement(
                    _button_jsx4__.Z,
                    {
                      className: `
                                    mega-button
                                    large
                                    round
                                    negative
                                    ${unsupported ? "disabled" : ""}
                                `,
                      icon: "icon-end-call",
                      simpletip: unsupported
                        ? null
                        : {
                            position: "top",
                            label: rejectLabel
                          },
                      onClick: unsupported ? null : onReject
                    },
                    react0().createElement("span", null, rejectLabel)
                  ),
                  CALL_IN_PROGRESS ? this.renderSwitchControls() : this.renderAnswerControls()
                ),
                unsupported &&
                  react0().createElement(
                    "div",
                    {
                      className: `${NAMESPACE}-unsupported`
                    },
                    react0().createElement(
                      "div",
                      {
                        className: "unsupported-message"
                      },
                      _call_jsx5__.ZP.getUnsupportedBrowserMessage()
                    )
                  )
              )
            );
          }
          console.error("Incoming dialog received missing chatRoom prop.");
          return null;
        }
      }
      Incoming.NAMESPACE = "incoming-dialog";
      window.ChatCallIncomingDialog = Incoming;

      /***/
    },

    /***/ 889: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        Z: () => __WEBPACK_DEFAULT_EXPORT__
      });
      var react0__ = __webpack_require__(363);
      var react0 = __webpack_require__.n(react0__);
      var _mixins_js1__ = __webpack_require__(503);
      var _contacts_jsx2__ = __webpack_require__(13);
      var _call_jsx3__ = __webpack_require__(689);
      var _button_jsx4__ = __webpack_require__(193);
      var _permissionsObserver_jsx5__ = __webpack_require__(209);

      class Preview extends _mixins_js1__.wl {
        constructor(props) {
          super(props);
          this.videoRef = react0().createRef();
          this.stream = null;
          this.state = {
            audio: false,
            video: false,
            avatarMeta: undefined
          };
          this.getTrackType = (type) => (!type ? "getTracks" : type === Preview.STREAMS.AUDIO ? "getAudioTracks" : "getVideoTracks");
          this.startStream = (type) => {
            this.stopStream();
            const { audio, video } = this.state;
            navigator.mediaDevices
              .getUserMedia({
                audio,
                video
              })
              .then((stream) => {
                const videoRef = this.videoRef.current;
                if (videoRef) {
                  videoRef.srcObject = stream;
                  this.stream = stream;
                  if (this.props.onToggle) {
                    this.props.onToggle(this.state.audio, this.state.video);
                  }
                }
              })
              .catch((ex) => {
                const stream = type === Preview.STREAMS.AUDIO ? "audio" : "video";
                return (
                  this.isMounted &&
                  this.setState(
                    (state) => ({
                      [stream]: !state[stream]
                    }),
                    () => {
                      megaChat.trigger("onLocalMediaError", {
                        [type === Preview.STREAMS.AUDIO ? "mic" : "camera"]: `${ex.name}: ${ex.message}`
                      });
                      console.error(`${ex.name}: ${ex.message}`);
                    }
                  )
                );
              });
          };
          this.stopStream = (type) => {
            if (this.stream) {
              const trackType = this.getTrackType(type);
              const tracks = this.stream[trackType]();
              for (const track of tracks) {
                track.stop();
              }
            }
          };
          this.toggleStream = (type) => {
            var _this$props$resetErro, _this$props;
            const stream = type === Preview.STREAMS.AUDIO ? "audio" : "video";
            this.setState(
              (state) => ({
                [stream]: !state[stream]
              }),
              () => {
                if (this.props.onToggle) {
                  this.props.onToggle(this.state.audio, this.state.video);
                }
                return this.state[stream] ? this.startStream(type) : this.stopStream(type);
              }
            );
            (_this$props$resetErro = (_this$props = this.props).resetError) == null ||
              _this$props$resetErro.call(_this$props, type === Preview.STREAMS.AUDIO ? Av.Audio : Av.Camera);
          };
          this.renderAvatar = () => {
            if ((0, _call_jsx3__.nJ)()) {
              return react0().createElement(
                "div",
                {
                  className: "avatar-guest"
                },
                react0().createElement("i", {
                  className: "sprite-fm-uni icon-owner"
                })
              );
            }
            if (is_chatlink) {
              const { avatarUrl, color, shortName } = this.state.avatarMeta || {};
              return react0().createElement(
                "div",
                {
                  className: `
                        avatar-wrapper
                        ${color ? `color${color}` : ""}
                    `
                },
                avatarUrl &&
                  react0().createElement("img", {
                    src: avatarUrl,
                    alt: ""
                  }),
                color && react0().createElement("span", null, shortName)
              );
            }
            return react0().createElement(_contacts_jsx2__.Avatar, {
              contact: M.u[u_handle]
            });
          };
          this.state.audio = this.props.audio || this.state.audio;
          if (this.props.video) {
            this.state.video = this.props.video;
            this.startStream(Preview.STREAMS.VIDEO);
            this.props.onToggle(this.state.audio, this.state.video);
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          this.stopStream();
        }
        componentDidMount() {
          super.componentDidMount();
          if (this.props.onToggle) {
            this.props.onToggle(this.state.audio, this.state.video);
          }
          this.setState({
            avatarMeta: is_chatlink ? generateAvatarMeta(u_handle) : undefined
          });
        }
        render() {
          const { NAMESPACE } = Preview;
          const { hasToRenderPermissionsWarning, renderPermissionsWarning } = this.props;
          const { audio, video } = this.state;
          const SIMPLETIP_PROPS = {
            label: undefined,
            position: "top",
            className: "theme-dark-forced"
          };
          return react0().createElement(
            "div",
            {
              className: `
                    ${NAMESPACE}
                    local-stream-mirrored
                `
            },
            video &&
              react0().createElement("div", {
                className: `${NAMESPACE}-video-overlay`
              }),
            react0().createElement("video", {
              className: video ? "streaming" : "",
              muted: true,
              autoPlay: true,
              ref: this.videoRef
            }),
            !video && this.renderAvatar(),
            react0().createElement(
              "div",
              {
                className: `${NAMESPACE}-controls`
              },
              react0().createElement(
                "div",
                {
                  className: "preview-control-wrapper"
                },
                react0().createElement(
                  _button_jsx4__.Z,
                  {
                    simpletip: {
                      ...SIMPLETIP_PROPS,
                      label: audio ? l[16214] : l[16708]
                    },
                    className: `
                                mega-button
                                round
                                large
                                theme-light-forced
                                ${audio ? "" : "inactive"}
                            `,
                    icon: audio ? "icon-audio-filled" : "icon-audio-off",
                    onClick: () => {
                      this.toggleStream(Preview.STREAMS.AUDIO);
                    }
                  },
                  react0().createElement("span", null, audio ? l[16214] : l[16708])
                ),
                hasToRenderPermissionsWarning(Av.Audio) ? renderPermissionsWarning(Av.Audio) : null
              ),
              react0().createElement(
                "div",
                {
                  className: "preview-control-wrapper"
                },
                react0().createElement(
                  _button_jsx4__.Z,
                  {
                    simpletip: {
                      ...SIMPLETIP_PROPS,
                      label: video ? l[22894] : l[22893]
                    },
                    className: `
                                mega-button
                                round
                                large
                                theme-light-forced
                                ${video ? "" : "inactive"}
                            `,
                    icon: video ? "icon-video-call-filled" : "icon-video-off",
                    onClick: () => this.toggleStream(Preview.STREAMS.VIDEO)
                  },
                  react0().createElement("span", null, video ? l[22894] : l[22893])
                ),
                hasToRenderPermissionsWarning(Av.Camera) ? renderPermissionsWarning(Av.Camera) : null
              )
            )
          );
        }
      }
      Preview.NAMESPACE = "preview-meeting";
      Preview.STREAMS = {
        AUDIO: 1,
        VIDEO: 2
      };
      const __WEBPACK_DEFAULT_EXPORT__ = (0, _mixins_js1__.qC)(_permissionsObserver_jsx5__.Q)(Preview);

      /***/
    },

    /***/ 931: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, {
        Z: () => GenericConversationMessage
      });

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
      var esm_extends = __webpack_require__(462);
      // EXTERNAL MODULE: external "React"
      var external_React_ = __webpack_require__(363);
      var external_React_default = __webpack_require__.n(external_React_);
      // EXTERNAL MODULE: ./js/chat/ui/messages/mixin.jsx
      var mixin = __webpack_require__(416);
      // EXTERNAL MODULE: ./js/chat/ui/contacts.jsx
      var ui_contacts = __webpack_require__(13);
      // EXTERNAL MODULE: ./js/ui/utils.jsx
      var utils = __webpack_require__(79); // CONCATENATED MODULE: ./js/chat/ui/messages/abstractGenericMessage.jsx
      class AbstractGenericMessage extends mixin.y {
        getAvatar() {
          const contact = this.getContact() || Message.getContactForMessage(this.props.message);
          if (this.props.grouped) {
            return null;
          }
          return contact
            ? external_React_default().createElement(ui_contacts.Avatar, {
                contact: this.getContact(),
                className: "message avatar-wrapper small-rounded-avatar",
                chatRoom: this.props.chatRoom
              })
            : null;
        }
        getName() {
          const contact = this.getContact() || Message.getContactForMessage(this.props.message);
          if (this.props.grouped) {
            return null;
          }
          return contact
            ? external_React_default().createElement(ui_contacts.ContactButton, {
                contact: contact,
                className: "message",
                label: external_React_default().createElement(utils.dy, null, M.getNameByHandle(contact.u)),
                chatRoom: this.props.message.chatRoom,
                dropdownDisabled: !!this.props.dialog
              })
            : null;
        }
        renderMessageActionButtons(buttons) {
          if (!buttons) {
            return null;
          }
          const cnt = buttons.length;
          if (cnt === 0) {
            return null;
          }
          return external_React_default().createElement(
            "div",
            {
              className: `right-aligned-msg-buttons ${cnt && cnt > 1 ? `total-${cnt}` : ""}`
            },
            buttons
          );
        }
        render() {
          const { message, grouped, additionalClasses, hideActionButtons } = this.props;
          if (message.deleted) {
            return null;
          }
          return external_React_default().createElement(
            "div",
            {
              "data-id": message.messageId,
              className: `
                    ${this.getClassNames ? this.getClassNames() : grouped ? "grouped" : ""}
                    ${additionalClasses}
                    ${message.messageId}
                    message
                    body
                `
            },
            this.getAvatar && this.getAvatar(),
            external_React_default().createElement(
              "div",
              {
                className: "message content-area selectable-txt"
              },
              this.getName && this.getName(),
              this.getMessageTimestamp
                ? this.getMessageTimestamp()
                : grouped
                ? null
                : external_React_default().createElement(
                    "div",
                    {
                      className: "message date-time simpletip",
                      "data-simpletip": time2date(this.getTimestamp(), 17)
                    },
                    this.getTimestampAsString()
                  ),
              !hideActionButtons && this.getMessageActionButtons && this.renderMessageActionButtons(this.getMessageActionButtons()),
              this.getContents && this.getContents(),
              hideActionButtons ? null : this.getEmojisImages()
            )
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/messages/utils.jsx
      var getMessageString;
      (function () {
        var MESSAGE_STRINGS;
        var MESSAGE_STRINGS_GROUP;
        let MESSAGE_STRINGS_MEETING;
        var _sanitizeStrings = function (arg) {
          if (typeof arg === "undefined") {
            return arg;
          } else if (typeof arg === "string") {
            return escapeHTML(arg);
          } else if (arg.forEach) {
            arg.forEach(function (v, k) {
              arg[k] = _sanitizeStrings(v);
            });
          } else if (typeof arg === "object") {
            Object.keys(arg).forEach(function (k) {
              arg[k] = _sanitizeStrings(arg[k]);
            });
          }
          return arg;
        };
        getMessageString = function (type, isGroupCall, isMeeting) {
          if (!MESSAGE_STRINGS) {
            MESSAGE_STRINGS = {
              "outgoing-call": l[5891].replace("[X]", "[[[X]]]"),
              "incoming-call": l[19964] || "[[%s]] is calling...",
              "call-timeout": [l[18698].replace("[X]", "[[[X]]]")],
              "call-starting": l[7206].replace("[X]", "[[[X]]]"),
              "call-feedback": l[7998].replace("[X]", "[[[X]]]"),
              "call-initialising": l[7207].replace("[X]", "[[[X]]]"),
              "call-ended": [l[19965] || "Call ended.", l[7208]],
              remoteCallEnded: [l[19965] || "Call ended.", l[7208]],
              "call-failed-media": l[7204],
              "call-failed": [l[19966] || "Call failed.", l[7208]],
              "call-handled-elsewhere": l[5895].replace("[X]", "[[[X]]]"),
              "call-missed": l[17870],
              "call-rejected": l[19040],
              "call-canceled": l[19041],
              remoteCallStarted: l[5888],
              "call-started": l[5888].replace("[X]", "[[[X]]]"),
              alterParticipants: undefined,
              privilegeChange: l[8915],
              truncated: l[8905]
            };
            _sanitizeStrings(MESSAGE_STRINGS);
          }
          if (isGroupCall && !MESSAGE_STRINGS_GROUP) {
            MESSAGE_STRINGS_GROUP = {
              "call-ended": [l[19967], l[7208]],
              remoteCallEnded: [l[19967], l[7208]],
              "call-handled-elsewhere": l[19968],
              "call-canceled": l[19969],
              "call-started": l[19970]
            };
            _sanitizeStrings(MESSAGE_STRINGS_GROUP);
          }
          if (isMeeting && !MESSAGE_STRINGS_MEETING) {
            MESSAGE_STRINGS_MEETING = {
              "call-ended": [l.meeting_mgmt_call_ended, l[7208]],
              remoteCallEnded: [l.meeting_mgmt_call_ended, l[7208]],
              "call-started": l.meeting_mgmt_call_started
            };
          }
          if (isMeeting && MESSAGE_STRINGS_MEETING[type]) {
            return MESSAGE_STRINGS_MEETING[type];
          }
          if (isGroupCall && MESSAGE_STRINGS_GROUP[type]) {
            return MESSAGE_STRINGS_GROUP[type];
          }
          return MESSAGE_STRINGS[type];
        };
      })();
      mega.ui = mega.ui || {};
      mega.ui.chat = mega.ui.chat || {};
      mega.ui.chat.getMessageString = getMessageString; // CONCATENATED MODULE: ./js/chat/ui/messages/types/local.jsx

      const MESSAGE_TYPE = {
        OUTGOING: "outgoing-call",
        INCOMING: "incoming-call",
        TIMEOUT: "call-timeout",
        STARTING: "call-starting",
        FEEDBACK: "call-feedback",
        INITIALISING: "call-initialising",
        ENDED: "call-ended",
        ENDED_REMOTE: "remoteCallEnded",
        FAILED: "call-failed",
        FAILED_MEDIA: "call-failed-media",
        HANDLED_ELSEWHERE: "call-handled-elsewhere",
        MISSED: "call-missed",
        REJECTED: "call-rejected",
        CANCELLED: "call-canceled",
        STARTED: "call-started",
        STARTED_REMOTE: "remoteCallStarted",
        ALTER_PARTICIPANTS: "alterParticipants",
        PRIVILEGE_CHANGE: "privilegeChange",
        TRUNCATED: "truncated"
      };
      class Local extends AbstractGenericMessage {
        componentDidMount() {
          super.componentDidMount();
          this._setClassNames();
        }
        _roomIsGroup() {
          return this.props.message.chatRoom.type === "group" || this.props.message.chatRoom.type === "public";
        }
        _getParticipantNames(message) {
          return (
            message.meta &&
            message.meta.participants &&
            !!message.meta.participants.length &&
            message.meta.participants.map((handle) => `[[${megaChat.html(M.getNameByHandle(handle))}]]`)
          );
        }
        _getExtraInfo(message) {
          const { meta, type } = message;
          const participantNames = this._getParticipantNames(message);
          const HAS_PARTICIPANTS = participantNames && !!participantNames.length && participantNames.length > 1;
          const HAS_DURATION = meta && meta.duration;
          const ENDED = type === MESSAGE_TYPE.ENDED || type === MESSAGE_TYPE.FAILED || type === MESSAGE_TYPE.CANCELLED;
          let messageExtraInfo = [HAS_PARTICIPANTS ? mega.utils.trans.listToString(participantNames, l[20234]) : ""];
          if (ENDED) {
            messageExtraInfo = [
              ...messageExtraInfo,
              HAS_PARTICIPANTS ? ". " : "",
              HAS_DURATION ? l[7208].replace("[X]", `[[${secToDuration(meta.duration)}]]`) : ""
            ];
          }
          return (
            messageExtraInfo &&
            messageExtraInfo.reduce((acc, cur) => (acc + cur).replace(/\[\[/g, '<span class="bold">').replace(/]]/g, "</span>"))
          );
        }
        _setClassNames() {
          let cssClass;
          switch (this.props.message.type) {
            case MESSAGE_TYPE.REJECTED:
              cssClass = "sprite-fm-theme icon-handset-rejected";
              break;
            case MESSAGE_TYPE.MISSED:
              cssClass = "sprite-fm-theme icon-handset-missed";
              break;
            case MESSAGE_TYPE.OUTGOING:
            case MESSAGE_TYPE.HANDLED_ELSEWHERE:
              cssClass = "sprite-fm-theme icon-handset-outgoing";
              break;
            case MESSAGE_TYPE.FAILED:
            case MESSAGE_TYPE.FAILED_MEDIA:
              cssClass = "sprite-fm-theme icon-handset-failed";
              break;
            case MESSAGE_TYPE.ENDED:
            case MESSAGE_TYPE.TIMEOUT:
              cssClass = "sprite-fm-theme icon-handset-ended";
              break;
            case MESSAGE_TYPE.CANCELLED:
              cssClass = "sprite-fm-theme icon-handset-cancelled";
              break;
            case MESSAGE_TYPE.FEEDBACK:
            case MESSAGE_TYPE.STARTING:
            case MESSAGE_TYPE.STARTED:
              cssClass = "sprite-fm-mono icon-phone";
              break;
            case MESSAGE_TYPE.INCOMING:
              cssClass = "sprite-fm-theme icon-handset-incoming";
              break;
            default:
              cssClass = "sprite-fm-mono " + this.props.message.type;
              break;
          }
          this.props.message.cssClass = cssClass;
        }
        _getIcon(message) {
          const MESSAGE_ICONS = {
            [MESSAGE_TYPE.STARTED]: `<i class="${"call-info-icon"} sprite-fm-mono icon-phone">&nbsp;</i>`,
            [MESSAGE_TYPE.ENDED]: `<i class="${"call-info-icon"} sprite-fm-theme icon-handset-ended">&nbsp;</i>`,
            DEFAULT: `<i class="${"call-info-icon"} ${message.cssClass}">&nbsp;</i>`
          };
          return MESSAGE_ICONS[message.type] || MESSAGE_ICONS.DEFAULT;
        }
        _getText() {
          const { message } = this.props;
          const IS_GROUP = this._roomIsGroup();
          let messageText = getMessageString(message.type, IS_GROUP, message.chatRoom.isMeeting);
          if (!messageText) {
            return console.error(`Message with type: ${message.type} -- no text string defined. Message: ${message}`);
          }
          messageText = CallManager2._getMltiStrTxtCntsForMsg(message, messageText.splice ? messageText : [messageText], true);
          messageText = megaChat.html(messageText);
          message.textContents = String(messageText).replace("[[", '<span class="bold">').replace("]]", "</span>");
          if (IS_GROUP) {
            messageText = `
                ${this._getIcon(message)}
                <div class="call-info-content">
                    <span class="call-info-message bold">${messageText}</span>
                    ${this._getExtraInfo(message)}
                </div>
            `;
          }
          return messageText;
        }
        _getAvatarsListing() {
          const { message } = this.props;
          if (
            this._roomIsGroup() &&
            message.type === MESSAGE_TYPE.STARTED &&
            message.messageId === `${MESSAGE_TYPE.STARTED}-${message.chatRoom.getActiveCallMessageId()}`
          ) {
            const unique = message.chatRoom.uniqueCallParts ? Object.keys(message.chatRoom.uniqueCallParts) : [];
            return unique.map((handle) =>
              external_React_default().createElement(ui_contacts.Avatar, {
                key: handle,
                contact: M.u[handle],
                simpletip: handle in M.u && M.u[handle].name,
                className: "message avatar-wrapper small-rounded-avatar"
              })
            );
          }
          return null;
        }
        _getButtons() {
          const { message } = this.props;
          if (message.buttons && Object.keys(message.buttons).length) {
            return external_React_default().createElement(
              "div",
              {
                className: "buttons-block"
              },
              Object.keys(message.buttons).map((key) => {
                const button = message.buttons[key];
                return external_React_default().createElement(
                  "button",
                  {
                    key: key,
                    className: button.classes,
                    onClick: (e) => button.callback(e.target)
                  },
                  button.icon &&
                    external_React_default().createElement(
                      "div",
                      null,
                      external_React_default().createElement("i", {
                        className: `small-icon ${button.icon}`
                      })
                    ),
                  external_React_default().createElement("span", null, button.text)
                );
              }),
              external_React_default().createElement("div", {
                className: "clear"
              })
            );
          }
        }
        getAvatar() {
          const { message, grouped } = this.props;
          if (message.type === MESSAGE_TYPE.FEEDBACK) {
            return null;
          }
          const $$AVATAR = external_React_default().createElement(ui_contacts.Avatar, {
            contact: message.authorContact,
            className: "message avatar-wrapper small-rounded-avatar",
            chatRoom: message.chatRoom
          });
          const $$ICON = external_React_default().createElement(
            "div",
            {
              className: "feedback call-status-block"
            },
            external_React_default().createElement("i", {
              className: `sprite-fm-mono ${message.cssClass}`
            })
          );
          return message.showInitiatorAvatar ? (grouped ? null : $$AVATAR) : $$ICON;
        }
        getMessageTimestamp() {
          var _this$props$message;
          const callId =
            (_this$props$message = this.props.message) == null || (_this$props$message = _this$props$message.meta) == null
              ? void 0
              : _this$props$message.callId;
          let debugMsg = "";
          if (d && callId) {
            debugMsg = `: callId: ${callId}`;
          }
          return external_React_default().createElement(
            "div",
            {
              className: "message date-time simpletip",
              "data-simpletip": time2date(this.getTimestamp(), 17)
            },
            this.getTimestampAsString(),
            debugMsg
          );
        }
        getClassNames() {
          const {
            message: { showInitiatorAvatar, type },
            grouped
          } = this.props;
          const classNames = [
            showInitiatorAvatar && grouped && "grouped",
            this._roomIsGroup() && type !== MESSAGE_TYPE.OUTGOING && type !== MESSAGE_TYPE.INCOMING && "with-border"
          ];
          return classNames.filter((className) => className).join(" ");
        }
        getName() {
          const { message, grouped } = this.props;
          const contact = this.getContact();
          return message.showInitiatorAvatar && !grouped
            ? external_React_default().createElement(ui_contacts.ContactButton, {
                contact: contact,
                className: "message",
                label: external_React_default().createElement(
                  utils.dy,
                  null,
                  message.authorContact ? M.getNameByHandle(message.authorContact.u) : ""
                ),
                chatRoom: message.chatRoom
              })
            : M.getNameByHandle(contact.u);
        }
        getContents() {
          const {
            message: { getState }
          } = this.props;
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            external_React_default().createElement(
              "div",
              {
                className: "message text-block"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "message call-inner-block"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "call-info"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "call-info-container"
                    },
                    external_React_default().createElement(
                      utils.Cw,
                      {
                        className: "info-wrapper"
                      },
                      this._getText()
                    )
                  ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "call-info-avatars"
                    },
                    this._getAvatarsListing(),
                    external_React_default().createElement("div", {
                      className: "clear"
                    })
                  )
                )
              )
            ),
            getState && getState() === Message.STATE.NOT_SENT ? null : this._getButtons()
          );
        }
      }
      // EXTERNAL MODULE: ./js/ui/dropdowns.jsx
      var dropdowns = __webpack_require__(78);
      // EXTERNAL MODULE: ./js/ui/buttons.jsx
      var buttons = __webpack_require__(204); // CONCATENATED MODULE: ./js/chat/ui/messages/types/contact.jsx
      class Contact extends AbstractGenericMessage {
        constructor(...args) {
          super(...args);
          this.DIALOG = {
            ADDED: (addedEmail) => msgDialog("info", l[150], l[5898].replace("[X]", addedEmail)),
            DUPLICATE: () => msgDialog("warningb", "", l[17545])
          };
        }
        haveMoreContactListeners() {
          const { message } = this.props;
          const textContents = message.textContents.substring(2, message.textContents.length);
          const attachmentMeta = JSON.parse(textContents);
          if (!attachmentMeta) {
            return false;
          }
          const contacts = attachmentMeta.map((v) => v.u);
          return contacts.length ? contacts : false;
        }
        _doAddContact(contactEmail) {
          return M.inviteContact(M.u[u_handle] ? M.u[u_handle].m : u_attr.email, contactEmail);
        }
        _handleAddContact(contactEmail) {
          var _this$props$chatRoom;
          if ((_this$props$chatRoom = this.props.chatRoom) != null && _this$props$chatRoom.isAnonymous()) {
            return this._doAddContact(contactEmail)
              .then((addedEmail) => this.DIALOG.ADDED(addedEmail))
              .catch(this.DIALOG.DUPLICATE);
          }
          return Object.values(M.opc).some((opc) => opc.m === contactEmail)
            ? this.DIALOG.DUPLICATE()
            : this._doAddContact(contactEmail).then((addedEmail) => this.DIALOG.ADDED(addedEmail));
        }
        _getContactAvatar(contact, className) {
          return external_React_default().createElement(ui_contacts.Avatar, {
            className: `avatar-wrapper ${className}`,
            contact: M.u[contact.u],
            chatRoom: this.props.chatRoom
          });
        }
        _getContactDeleteButton(message) {
          if (message.userId === u_handle && unixtime() - message.delay < MESSAGE_NOT_EDITABLE_TIMEOUT) {
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              external_React_default().createElement("hr", null),
              external_React_default().createElement(dropdowns.DropdownItem, {
                icon: "sprite-fm-mono icon-dialog-close",
                label: l[83],
                onClick: (e) => this.props.onDelete(e, message)
              })
            );
          }
        }
        _getContactCard(message, contact, contactEmail) {
          const HAS_RELATIONSHIP = M.u[contact.u].c === 1;
          let name = external_React_default().createElement(ui_contacts.ContactAwareName, {
            emoji: true,
            contact: M.u[contact.u]
          });
          const { chatRoom } = this.props;
          const isAnonView = chatRoom.isAnonymous();
          if (megaChat.FORCE_EMAIL_LOADING) {
            name += "(" + contact.m + ")";
          }
          return external_React_default().createElement(
            buttons.z,
            {
              className: "tiny-button",
              icon: "tiny-icon icons-sprite grey-dots"
            },
            external_React_default().createElement(
              dropdowns.Dropdown,
              {
                className: "white-context-menu shared-contact-dropdown",
                noArrow: true,
                positionMy: "left bottom",
                positionAt: "right bottom",
                horizOffset: 4
              },
              external_React_default().createElement(
                "div",
                {
                  className: "dropdown-avatar rounded"
                },
                this._getContactAvatar(contact, "context-avatar"),
                !isAnonView
                  ? external_React_default().createElement(
                      "div",
                      {
                        className: "dropdown-user-name"
                      },
                      external_React_default().createElement(
                        "div",
                        {
                          className: "name"
                        },
                        HAS_RELATIONSHIP &&
                          (this.isLoadingContactInfo()
                            ? external_React_default().createElement("em", {
                                className: "contact-name-loading"
                              })
                            : name),
                        !HAS_RELATIONSHIP && name,
                        external_React_default().createElement(ui_contacts.ContactPresence, {
                          className: "small",
                          contact: contact
                        })
                      ),
                      external_React_default().createElement(
                        "div",
                        {
                          className: "email"
                        },
                        M.u[contact.u].m
                      )
                    )
                  : external_React_default().createElement("div", {
                      className: "dropdown-user-name"
                    })
              ),
              external_React_default().createElement(ui_contacts.ContactFingerprint, {
                contact: M.u[contact.u]
              }),
              HAS_RELATIONSHIP &&
                external_React_default().createElement(
                  external_React_default().Fragment,
                  null,
                  external_React_default().createElement(dropdowns.DropdownItem, {
                    icon: "sprite-fm-mono icon-user-filled",
                    label: l[5868],
                    onClick: () => {
                      loadSubPage("fm/chat/contacts/" + contact.u);
                      mBroadcaster.sendMessage("contact:open");
                    }
                  }),
                  external_React_default().createElement("hr", null),
                  external_React_default().createElement(dropdowns.DropdownItem, {
                    icon: "sprite-fm-mono icon-chat-filled",
                    label: l[8632],
                    onClick: () => {
                      loadSubPage("fm/chat/p/" + contact.u);
                      mBroadcaster.sendMessage("chat:open");
                    }
                  })
                ),
              u_type &&
                u_type > 2 &&
                contact.u !== u_handle &&
                !HAS_RELATIONSHIP &&
                !is_eplusplus &&
                external_React_default().createElement(dropdowns.DropdownItem, {
                  icon: "sprite-fm-mono icon-add",
                  label: l[71],
                  onClick: () => this._handleAddContact(contactEmail)
                }),
              this._getContactDeleteButton(message)
            )
          );
        }
        getContents() {
          const { message, chatRoom } = this.props;
          const textContents = message.textContents.substr(2, message.textContents.length);
          const attachmentMeta = JSON.parse(textContents);
          const isAnonView = chatRoom.isAnonymous();
          if (!attachmentMeta) {
            return console.error(`Message w/ type: ${message.type} -- no attachment meta defined. Message: ${message}`);
          }
          let contacts = [];
          attachmentMeta.forEach((v) => {
            const contact = M.u && v.u in M.u && M.u[v.u].m ? M.u[v.u] : v;
            const contactEmail = contact.email ? contact.email : contact.m;
            if (!M.u[contact.u]) {
              M.u.set(
                contact.u,
                new MegaDataObject(MEGA_USER_STRUCT, {
                  u: contact.u,
                  name: contact.name,
                  m: contact.email ? contact.email : contactEmail,
                  c: undefined
                })
              );
            } else if (M.u[contact.u] && !M.u[contact.u].m) {
              M.u[contact.u].m = contact.email ? contact.email : contactEmail;
            }
            contacts = [
              ...contacts,
              external_React_default().createElement(
                "div",
                {
                  key: contact.u
                },
                !isAnonView
                  ? external_React_default().createElement(
                      "div",
                      {
                        className: "message shared-info"
                      },
                      external_React_default().createElement(
                        "div",
                        {
                          className: "message data-title selectable-txt"
                        },
                        external_React_default().createElement(utils.dy, null, M.getNameByHandle(contact.u))
                      ),
                      M.u[contact.u]
                        ? external_React_default().createElement(ui_contacts.ContactVerified, {
                            className: "right-align",
                            contact: M.u[contact.u]
                          })
                        : null,
                      external_React_default().createElement(
                        "div",
                        {
                          className: "user-card-email selectable-txt"
                        },
                        contactEmail
                      )
                    )
                  : external_React_default().createElement("div", {
                      className: "message shared-info"
                    }),
                external_React_default().createElement(
                  "div",
                  {
                    className: "message shared-data"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "data-block-view semi-big"
                    },
                    M.u[contact.u]
                      ? external_React_default().createElement(ui_contacts.ContactPresence, {
                          className: "small",
                          contact: M.u[contact.u]
                        })
                      : null,
                    this._getContactCard(message, contact, contactEmail),
                    this._getContactAvatar(contact, "medium-avatar")
                  ),
                  external_React_default().createElement("div", {
                    className: "clear"
                  })
                )
              )
            ];
          });
          return external_React_default().createElement(
            "div",
            {
              className: "message shared-block"
            },
            contacts
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/messages/types/attachment.jsx
      class Attachment extends AbstractGenericMessage {
        _isRevoked(node) {
          return !M.chd[node.ch] || node.revoked;
        }
        _isUserRegistered() {
          return typeof u_type !== "undefined" && u_type > 2;
        }
        getContents() {
          const { message, chatRoom } = this.props;
          const contact = this.getContact();
          let NODE_DOESNT_EXISTS_ANYMORE = {};
          let attachmentMeta = message.getAttachmentMeta() || [];
          let files = [];
          for (let i = 0; i < attachmentMeta.length; i++) {
            let v = attachmentMeta[i];
            if (this._isRevoked(v)) {
              continue;
            }
            const { icon, isImage, isVideo, isAudio, isText, showThumbnail, isPreviewable } = M.getMediaProperties(v);
            var dropdown = null;
            var noThumbPrev = "";
            var previewButton = null;
            if (isPreviewable) {
              if (!showThumbnail) {
                noThumbPrev = "no-thumb-prev";
              }
              var previewLabel = isAudio ? l[17828] : isVideo ? l[16275] : l[1899];
              var previewIcon = isAudio ? "icon-play" : isVideo ? "icon-video-call-filled" : "icon-preview-reveal";
              if (isText) {
                previewLabel = l[16797];
                previewIcon = "icon-file-edit";
              }
              previewButton = external_React_default().createElement(
                "span",
                {
                  key: "previewButton"
                },
                external_React_default().createElement(dropdowns.DropdownItem, {
                  label: previewLabel,
                  icon: `sprite-fm-mono ${previewIcon}`,
                  disabled: mega.paywall,
                  onClick: (e) => this.props.onPreviewStart(v, e)
                })
              );
            }
            if (contact.u === u_handle) {
              dropdown = external_React_default().createElement(
                buttons.z,
                {
                  className: "tiny-button",
                  icon: "tiny-icon icons-sprite grey-dots"
                },
                external_React_default().createElement(dropdowns.Dropdown, {
                  ref: (refObj) => {
                    this.dropdown = refObj;
                  },
                  className: "white-context-menu attachments-dropdown",
                  noArrow: true,
                  positionMy: "left top",
                  positionAt: "left bottom",
                  horizOffset: -4,
                  vertOffset: 3,
                  onBeforeActiveChange: (newState) => {
                    if (newState === true) {
                      this.forceUpdate();
                    }
                  },
                  dropdownItemGenerator: (dd) => {
                    var linkButtons = [];
                    var firstGroupOfButtons = [];
                    var revokeButton = null;
                    var downloadButton = null;
                    if (message.isEditable && message.isEditable()) {
                      revokeButton = external_React_default().createElement(dropdowns.DropdownItem, {
                        icon: "sprite-fm-mono icon-dialog-close",
                        label: l[83],
                        onClick: () => {
                          chatRoom.megaChat.plugins.chatdIntegration.updateMessage(chatRoom, message.internalId || message.orderValue, "");
                        }
                      });
                    }
                    if (!M.d[v.h] && !NODE_DOESNT_EXISTS_ANYMORE[v.h]) {
                      dbfetch.acquire(v.h).always(() => {
                        if (!M.d[v.h]) {
                          NODE_DOESNT_EXISTS_ANYMORE[v.h] = true;
                          dd.doRerender();
                        } else {
                          dd.doRerender();
                        }
                      });
                      return external_React_default().createElement(
                        "span",
                        {
                          className: "loading"
                        },
                        l[5533]
                      );
                    } else if (!NODE_DOESNT_EXISTS_ANYMORE[v.h]) {
                      downloadButton = external_React_default().createElement(dropdowns.DropdownItem, {
                        icon: "sprite-fm-mono icon-download-small",
                        label: l[1187],
                        disabled: mega.paywall,
                        onClick: () => this.props.onDownloadStart(v)
                      });
                      if (M.getNodeRoot(v.h) !== M.RubbishID) {
                        this.props.onAddLinkButtons(v.h, linkButtons);
                      }
                      firstGroupOfButtons.push(
                        external_React_default().createElement(dropdowns.DropdownItem, {
                          icon: "sprite-fm-mono icon-info",
                          label: l[6859],
                          key: "infoDialog",
                          onClick: () => {
                            $.selected = [v.h];
                            propertiesDialog();
                          }
                        })
                      );
                      this.props.onAddFavouriteButtons(v.h, firstGroupOfButtons);
                      linkButtons.push(
                        external_React_default().createElement(dropdowns.DropdownItem, {
                          icon: "sprite-fm-mono icon-send-to-chat",
                          label: l[17764],
                          key: "sendToChat",
                          disabled: mega.paywall,
                          onClick: () => {
                            $.selected = [v.h];
                            openCopyDialog("conversations");
                          }
                        })
                      );
                    }
                    if (
                      !previewButton &&
                      firstGroupOfButtons.length === 0 &&
                      !downloadButton &&
                      linkButtons.length === 0 &&
                      !revokeButton
                    ) {
                      return null;
                    }
                    if (previewButton && (firstGroupOfButtons.length > 0 || downloadButton || linkButtons.length > 0 || revokeButton)) {
                      previewButton = [
                        previewButton,
                        external_React_default().createElement("hr", {
                          key: "preview-sep"
                        })
                      ];
                    }
                    return external_React_default().createElement(
                      "div",
                      null,
                      previewButton,
                      firstGroupOfButtons,
                      firstGroupOfButtons.length > 0 ? external_React_default().createElement("hr", null) : "",
                      downloadButton,
                      linkButtons,
                      revokeButton && downloadButton ? external_React_default().createElement("hr", null) : "",
                      revokeButton
                    );
                  }
                })
              );
            } else {
              dropdown = external_React_default().createElement(
                buttons.z,
                {
                  className: "tiny-button",
                  icon: "tiny-icon icons-sprite grey-dots"
                },
                external_React_default().createElement(
                  dropdowns.Dropdown,
                  {
                    className: "white-context-menu attachments-dropdown",
                    noArrow: true,
                    positionMy: "left top",
                    positionAt: "left bottom",
                    horizOffset: -4,
                    vertOffset: 3
                  },
                  previewButton,
                  previewButton && external_React_default().createElement("hr", null),
                  external_React_default().createElement(dropdowns.DropdownItem, {
                    icon: "sprite-fm-mono icon-download-small",
                    label: l[1187],
                    disabled: mega.paywall,
                    onClick: () => this.props.onDownloadStart(v)
                  }),
                  !is_chatlink &&
                    this._isUserRegistered() &&
                    external_React_default().createElement(
                      external_React_default().Fragment,
                      null,
                      external_React_default().createElement(dropdowns.DropdownItem, {
                        icon: "sprite-fm-mono icon-cloud",
                        label: l[1988],
                        disabled: mega.paywall,
                        onClick: () => this.props.onAddToCloudDrive(v, false)
                      }),
                      external_React_default().createElement(dropdowns.DropdownItem, {
                        icon: "sprite-fm-mono icon-send-to-chat",
                        label: l[17764],
                        disabled: mega.paywall,
                        onClick: () => this.props.onAddToCloudDrive(v, true)
                      })
                    )
                )
              );
            }
            if (M.getNodeShare(v.h).down) {
              dropdown = null;
            }
            var attachmentClasses = "message shared-data";
            var preview = external_React_default().createElement(
              "div",
              {
                className: "data-block-view medium " + noThumbPrev,
                onClick: ({ target }) => {
                  if (isPreviewable && !target.classList.contains("tiny-button")) {
                    this.props.onPreviewStart(v);
                  }
                }
              },
              dropdown,
              external_React_default().createElement(
                "div",
                {
                  className: "data-block-bg"
                },
                external_React_default().createElement("div", {
                  className: "block-view-file-type " + icon
                })
              )
            );
            if (showThumbnail) {
              var src = v.src || window.noThumbURI || "";
              var thumbClass = v.src ? "" : " no-thumb";
              var thumbOverlay = null;
              if (isImage) {
                thumbClass += " image";
                thumbOverlay = external_React_default().createElement("div", {
                  className: "thumb-overlay",
                  onClick: () => this.props.onPreviewStart(v)
                });
              } else {
                thumbClass = thumbClass + " video " + (isPreviewable ? " previewable" : "non-previewable");
                thumbOverlay = external_React_default().createElement(
                  "div",
                  {
                    className: "thumb-overlay",
                    onClick: () => isPreviewable && this.props.onPreviewStart(v)
                  },
                  isPreviewable &&
                    external_React_default().createElement(
                      "div",
                      {
                        className: "thumb-overlay-play"
                      },
                      external_React_default().createElement(
                        "div",
                        {
                          className: "thumb-overlay-circle"
                        },
                        external_React_default().createElement("i", {
                          className: "sprite-fm-mono icon-play"
                        })
                      )
                    ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "video-thumb-details"
                    },
                    v.playtime &&
                      external_React_default().createElement("i", {
                        className: "sprite-fm-mono icon-play"
                      }),
                    external_React_default().createElement("span", null, secondsToTimeShort(v.playtime || -1))
                  )
                );
              }
              preview = src
                ? external_React_default().createElement(
                    "div",
                    {
                      id: v.ch,
                      className: `shared-link thumb ${thumbClass}`
                    },
                    thumbOverlay,
                    dropdown,
                    external_React_default().createElement("img", {
                      alt: "",
                      className: "thumbnail-placeholder " + v.h,
                      src: src,
                      key: "thumb-" + v.ch,
                      onClick: () => isPreviewable && this.props.onPreviewStart(v)
                    })
                  )
                : preview;
            }
            files.push(
              external_React_default().createElement(
                "div",
                {
                  className: attachmentClasses,
                  key: "atch-" + v.ch
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "message shared-info"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "message data-title selectable-txt"
                    },
                    l[17669],
                    external_React_default().createElement(
                      "span",
                      {
                        className: "file-name"
                      },
                      v.name
                    )
                  ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "message file-size"
                    },
                    bytesToSize(v.s)
                  )
                ),
                preview,
                external_React_default().createElement("div", {
                  className: "clear"
                })
              )
            );
          }
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            external_React_default().createElement(
              "div",
              {
                className: "message shared-block"
              },
              files
            )
          );
        }
      }
      // EXTERNAL MODULE: ./js/chat/mixins.js
      var mixins = __webpack_require__(503); // CONCATENATED MODULE: ./js/chat/ui/messages/types/partials/audioPlayer.jsx
      class AudioPlayer extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            currentTime: null,
            progressWidth: 0,
            isBeingPlayed: false,
            isPaused: false
          };
          this.handleOnTimeUpdate = this.handleOnTimeUpdate.bind(this);
          this.handleOnMouseDown = this.handleOnMouseDown.bind(this);
        }
        play() {
          const audio = this.audioEl;
          if (audio.paused) {
            const result = audio.play();
            if (result instanceof Promise) {
              result.catch((ex) => {
                if (ex.name !== "AbortError") {
                  console.error(ex);
                }
              });
            }
            const audios = document.getElementsByClassName("audio-player__player");
            Array.prototype.filter
              .call(audios, (audioElement) => audioElement.id !== this.props.audioId)
              .forEach((audioElement) => {
                if (!audioElement.paused) {
                  audioElement.pause();
                }
              });
            this.setState({
              isPaused: false
            });
          } else {
            audio.pause();
            this.setState({
              isPaused: true
            });
          }
        }
        handleOnTimeUpdate() {
          const { currentTime, duration } = this.audioEl;
          this.setState({
            currentTime: secondsToTimeShort(currentTime),
            progressWidth: (currentTime / duration) * 100
          });
        }
        handleOnMouseDown(event) {
          event.preventDefault();
          const { sliderPin, slider } = this;
          const shiftX = event.clientX - sliderPin.getBoundingClientRect().left;
          const onMouseMove = (event) => {
            let newLeft = event.clientX - shiftX - slider.getBoundingClientRect().left;
            if (newLeft < 0) {
              newLeft = 0;
            }
            const rightEdge = slider.offsetWidth - sliderPin.offsetWidth;
            if (newLeft > rightEdge) {
              newLeft = rightEdge;
            }
            sliderPin.style.left = `${newLeft}px`;
            const pinPosition = newLeft / slider.getBoundingClientRect().width;
            const newTime = Math.ceil(this.props.playtime * pinPosition);
            const newCurrentTime = secondsToTimeShort(newTime);
            this.audioEl.currentTime = newTime;
            this.setState({
              currentTime: newCurrentTime,
              progressWidth: pinPosition > 1 ? 100 : pinPosition * 100
            });
          };
          function onMouseUp() {
            document.removeEventListener("mouseup", onMouseUp);
            document.removeEventListener("mousemove", onMouseMove);
          }
          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
          sliderPin.ondragstart = () => false;
        }
        render() {
          const { source, audioId, loading, playtime } = this.props;
          const { progressWidth, isBeingPlayed, isPaused, currentTime } = this.state;
          let playtimeStyles = null;
          if (isBeingPlayed) {
            playtimeStyles = {
              color: "var(--secondary-red)"
            };
          }
          let btnClass = "icon-pause";
          if (!isBeingPlayed || isPaused) {
            btnClass = "icon-play";
          }
          let controls = external_React_default().createElement(
            "span",
            {
              onClick: () => {
                this.play();
                if (this.props.source === null) {
                  this.props.getAudioFile();
                }
              }
            },
            external_React_default().createElement("i", {
              className: `sprite-fm-mono ${btnClass}`
            })
          );
          if (loading) {
            controls = external_React_default().createElement("div", {
              className: "small-blue-spinner audio-player__spinner"
            });
          }
          return external_React_default().createElement(
            "div",
            {
              className: "audio-player"
            },
            controls,
            external_React_default().createElement(
              "div",
              {
                className: "slider",
                ref: (slider) => {
                  this.slider = slider;
                }
              },
              external_React_default().createElement("div", {
                className: "slider__progress",
                style: {
                  width: `${progressWidth}%`
                }
              }),
              external_React_default().createElement("div", {
                className: "slider__progress__pin",
                style: {
                  left: `${progressWidth}%`
                },
                ref: (sliderPin) => {
                  this.sliderPin = sliderPin;
                },
                onMouseDown: this.handleOnMouseDown
              })
            ),
            external_React_default().createElement(
              "span",
              {
                className: "audio-player__time",
                style: playtimeStyles
              },
              currentTime || secondsToTimeShort(playtime)
            ),
            external_React_default().createElement("audio", {
              src: source,
              className: "audio-player__player",
              id: audioId,
              ref: (audio) => {
                this.audioEl = audio;
              },
              onPlaying: () =>
                this.setState({
                  isBeingPlayed: true
                }),
              onPause: () =>
                this.setState({
                  isPaused: true
                }),
              onEnded: () =>
                this.setState({
                  progressWidth: 0,
                  isBeingPlayed: false,
                  currentTime: 0
                }),
              onTimeUpdate: this.handleOnTimeUpdate
            })
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/messages/types/partials/audioContainer.jsx
      class AudioContainer extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            audioBlobUrl: null,
            loading: false
          };
          this.getAudioFile = this.getAudioFile.bind(this);
        }
        getAudioFile() {
          const { mime, h } = this.props;
          this.setState({
            loading: true
          });
          if (mime !== "audio/mp4") {
            if (d) {
              console.warn("cannot play this file type (%s)", mime, h, [this]);
            }
            return false;
          }
          M.gfsfetch(h, 0, -1)
            .then(({ buffer }) => {
              this.setState(() => {
                return {
                  audioBlobUrl: mObjectURL([buffer], "audio/mp4"),
                  loading: false
                };
              });
            })
            .catch((ex) => {
              console.error(ex);
            });
          return true;
        }
        componentWillUnmount() {
          if (super.componentWillUnmount) {
            super.componentWillUnmount();
          }
          URL.revokeObjectURL(this.state.audioBlobUrl);
        }
        render() {
          const { audioBlobUrl, loading } = this.state;
          const { playtime, mime, audioId } = this.props;
          return external_React_default().createElement(
            "div",
            {
              className: "audio-container"
            },
            external_React_default().createElement(AudioPlayer, {
              source: audioBlobUrl,
              audioId: audioId,
              loading: loading,
              mime: mime,
              getAudioFile: this.getAudioFile,
              playtime: playtime
            })
          );
        }
      }
      AudioContainer.defaultProps = {
        h: null,
        mime: null
      }; // CONCATENATED MODULE: ./js/chat/ui/messages/types/voiceClip.jsx
      const voiceClip_MESSAGE_NOT_EDITABLE_TIMEOUT = (window.MESSAGE_NOT_EDITABLE_TIMEOUT = 3600);
      class VoiceClip extends AbstractGenericMessage {
        constructor(props) {
          super(props);
        }
        _getActionButtons() {
          const { message } = this.props;
          const contact = this.getContact();
          const iAmSender = contact && contact.u === u_handle;
          const stillEditable = unixtime() - message.delay < voiceClip_MESSAGE_NOT_EDITABLE_TIMEOUT;
          const isBeingEdited = this.props.isBeingEdited() === true;
          const chatIsReadOnly = this.props.chatRoom.isReadOnly() === true;
          if (iAmSender && stillEditable && !isBeingEdited && !chatIsReadOnly && !this.props.dialog) {
            return external_React_default().createElement(
              buttons.z,
              {
                className: "tiny-button",
                icon: "tiny-icon icons-sprite grey-dots"
              },
              external_React_default().createElement(
                dropdowns.Dropdown,
                {
                  className: "white-context-menu attachments-dropdown",
                  noArrow: true,
                  positionMy: "left bottom",
                  positionAt: "right bottom",
                  horizOffset: 4
                },
                external_React_default().createElement(dropdowns.DropdownItem, {
                  icon: "sprite-fm-mono icon-dialog-close",
                  label: l[1730],
                  onClick: (e) => this.props.onDelete(e, message)
                })
              )
            );
          }
          return null;
        }
        _getAudioContainer() {
          const { message } = this.props;
          const attachmentMeta = message.getAttachmentMeta();
          if (attachmentMeta && attachmentMeta.length) {
            return attachmentMeta.map((voiceClip) =>
              external_React_default().createElement(AudioContainer, {
                key: voiceClip.h,
                h: voiceClip.h,
                mime: voiceClip.mime,
                playtime: voiceClip.playtime,
                audioId: `vm${message.messageId}`
              })
            );
          }
        }
        getContents() {
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            this.props.message.getState() === Message.STATE.NOT_SENT ? null : this._getActionButtons(),
            this._getAudioContainer()
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/messages/types/partials/metaRichpreview.jsx
      var React = __webpack_require__(363);
      var ConversationMessageMixin = __webpack_require__(416).y;
      var MetaRichPreviewLoading = __webpack_require__(480).F;
      class MetaRichpreview extends ConversationMessageMixin {
        getBase64Url(b64incoming) {
          if (!b64incoming || !b64incoming.split) {
            return;
          }
          var exti = b64incoming.split(":");
          var b64i = exti[1];
          exti = exti[0];
          return "data:image/" + exti + ";base64," + b64i;
        }
        render() {
          var self = this;
          var message = this.props.message;
          var output = [];
          var metas = message.meta && message.meta.extra ? message.meta.extra : [];
          var failedToLoad = message.meta.isLoading && unixtime() - message.meta.isLoading > 300;
          var isLoading = !!message.meta.isLoading;
          if (failedToLoad) {
            return null;
          }
          for (var i = 0; i < metas.length; i++) {
            var meta = metas[i];
            if (!meta.d && !meta.t && !message.meta.isLoading) {
              continue;
            }
            var previewCss = {};
            if (meta.i) {
              previewCss["backgroundImage"] = "url(" + self.getBase64Url(meta.i) + ")";
              previewCss["backgroundRepeat"] = "no-repeat";
              previewCss["backgroundPosition"] = "center center";
            }
            var previewContainer;
            if (isLoading) {
              previewContainer = React.createElement(MetaRichPreviewLoading, {
                message: message,
                isLoading: message.meta.isLoading
              });
            } else {
              var domainName = meta.url;
              domainName = domainName.replace("https://", "").replace("http://", "").split("/")[0];
              previewContainer = React.createElement(
                "div",
                {
                  className: "message richpreview body"
                },
                meta.i
                  ? React.createElement(
                      "div",
                      {
                        className: "message richpreview img-wrapper"
                      },
                      React.createElement("div", {
                        className: "message richpreview preview",
                        style: previewCss
                      })
                    )
                  : undefined,
                React.createElement(
                  "div",
                  {
                    className: "message richpreview inner-wrapper"
                  },
                  React.createElement(
                    "div",
                    {
                      className: "message richpreview data-title selectable-txt"
                    },
                    React.createElement(
                      "span",
                      {
                        className: "message richpreview title"
                      },
                      meta.t
                    )
                  ),
                  React.createElement(
                    "div",
                    {
                      className: "message richpreview desc"
                    },
                    ellipsis(meta.d, "end", 82)
                  ),
                  React.createElement(
                    "div",
                    {
                      className: "message richpreview url-container"
                    },
                    meta.ic
                      ? React.createElement(
                          "span",
                          {
                            className: "message richpreview url-favicon"
                          },
                          React.createElement("img", {
                            src: self.getBase64Url(meta.ic),
                            width: 16,
                            height: 16,
                            onError: (e) => {
                              e.target.parentNode.removeChild(e.target);
                            },
                            alt: ""
                          })
                        )
                      : "",
                    React.createElement(
                      "span",
                      {
                        className: "message richpreview url"
                      },
                      domainName
                    )
                  )
                )
              );
            }
            output.push(
              React.createElement(
                "div",
                {
                  key: meta.url,
                  className:
                    "message richpreview container " +
                    (meta.i ? "have-preview" : "no-preview") +
                    " " +
                    (meta.d ? "have-description" : "no-description") +
                    " " +
                    (isLoading ? "is-loading" : "done-loading"),
                  onClick: function (url) {
                    if (!message.meta.isLoading) {
                      window.open(url, "_blank", "noopener,noreferrer");
                    }
                  }.bind(this, meta.url)
                },
                previewContainer,
                React.createElement("div", {
                  className: "clear"
                })
              )
            );
          }
          return React.createElement(
            "div",
            {
              className: "message richpreview previews-container"
            },
            output
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/messages/types/partials/metaRichpreviewConfirmation.jsx

      var metaRichpreviewConfirmation_React = __webpack_require__(363);
      var metaRichpreviewConfirmation_ConversationMessageMixin = __webpack_require__(416).y;
      class MetaRichprevConfirmation extends metaRichpreviewConfirmation_ConversationMessageMixin {
        doAllow() {
          var message = this.props.message;
          var megaChat = this.props.message.chatRoom.megaChat;
          delete message.meta.requiresConfirmation;
          RichpreviewsFilter.confirmationDoConfirm();
          megaChat.plugins.richpreviewsFilter.processMessage({}, message);
          message.trackDataChange();
        }
        doNotNow() {
          var message = this.props.message;
          delete message.meta.requiresConfirmation;
          RichpreviewsFilter.confirmationDoNotNow();
          message.trackDataChange();
        }
        doNever() {
          var message = this.props.message;
          msgDialog("confirmation", l[870], l[18687], "", function (e) {
            if (e) {
              delete message.meta.requiresConfirmation;
              RichpreviewsFilter.confirmationDoNever();
              message.trackDataChange();
            }
          });
        }
        render() {
          var self = this;
          var notNowButton = null;
          var neverButton = null;
          if (RichpreviewsFilter.confirmationCount >= 2) {
            neverButton = metaRichpreviewConfirmation_React.createElement(
              "button",
              {
                className: "mega-button right negative",
                onClick: function () {
                  self.doNever();
                }
              },
              metaRichpreviewConfirmation_React.createElement("span", null, l[1051])
            );
          }
          notNowButton = metaRichpreviewConfirmation_React.createElement(
            "button",
            {
              className: "mega-button right",
              onClick: function () {
                self.doNotNow();
              }
            },
            metaRichpreviewConfirmation_React.createElement("span", null, l[18682])
          );
          return metaRichpreviewConfirmation_React.createElement(
            "div",
            {
              className: "message richpreview previews-container"
            },
            metaRichpreviewConfirmation_React.createElement(
              "div",
              {
                className: "message richpreview container confirmation"
              },
              metaRichpreviewConfirmation_React.createElement(
                "div",
                {
                  className: "message richpreview body"
                },
                metaRichpreviewConfirmation_React.createElement(
                  "div",
                  {
                    className: "message richpreview img-wrapper"
                  },
                  metaRichpreviewConfirmation_React.createElement("div", {
                    className: " message richpreview preview-confirmation sprite-fm-illustration img-chat-url-preview "
                  })
                ),
                metaRichpreviewConfirmation_React.createElement(
                  "div",
                  {
                    className: "message richpreview inner-wrapper"
                  },
                  metaRichpreviewConfirmation_React.createElement(
                    "div",
                    {
                      className: "message richpreview data-title selectable-txt"
                    },
                    metaRichpreviewConfirmation_React.createElement(
                      "span",
                      {
                        className: "message richpreview title"
                      },
                      l[18679]
                    )
                  ),
                  metaRichpreviewConfirmation_React.createElement(
                    "div",
                    {
                      className: "message richpreview desc"
                    },
                    l[18680]
                  )
                ),
                metaRichpreviewConfirmation_React.createElement(
                  "div",
                  {
                    className: "buttons-block"
                  },
                  metaRichpreviewConfirmation_React.createElement(
                    "button",
                    {
                      className: "mega-button right positive",
                      onClick: () => {
                        self.doAllow();
                      }
                    },
                    metaRichpreviewConfirmation_React.createElement("span", null, l[18681])
                  ),
                  notNowButton,
                  neverButton
                )
              ),
              metaRichpreviewConfirmation_React.createElement("div", {
                className: "clear"
              })
            )
          );
        }
      } // CONCATENATED MODULE: ./js/chat/ui/messages/types/partials/geoLocation.jsx

      function GeoLocation(props) {
        const { latitude, lng } = props;
        const handleOnclick = (lat, lng) => {
          const openGmaps = () => {
            window.open(`https://www.google.com/maps/search/?api=1&query=${lat},${lng}`, "_blank", "noopener,noreferrer");
          };
          if (GeoLocationLinks.gmapsConfirmation === -1 || GeoLocationLinks.gmapsConfirmation === false) {
            msgDialog("confirmation", "geolocation-link", l[20788], l.confirm_ext_link, (answer) => {
              if (answer) {
                GeoLocationLinks.confirmationDoConfirm();
                closeDialog();
                openGmaps();
              } else {
                GeoLocationLinks.confirmationDoNever();
              }
            });
          } else if (GeoLocationLinks.gmapsConfirmation) {
            openGmaps();
          }
        };
        return external_React_default().createElement(
          "div",
          {
            className: "geolocation-container"
          },
          external_React_default().createElement(
            "div",
            {
              className: "geolocation",
              onClick: () => handleOnclick(latitude, lng)
            },
            external_React_default().createElement(
              "div",
              {
                className: "geolocation__details"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "geolocation__icon"
                },
                external_React_default().createElement("i", {
                  className: "sprite-fm-mono icon-location"
                })
              ),
              external_React_default().createElement(
                "ul",
                {
                  className: "geolocation__data-list"
                },
                external_React_default().createElement(
                  "li",
                  null,
                  external_React_default().createElement(
                    "span",
                    {
                      className: "geolocation__title"
                    },
                    l[20789]
                  )
                ),
                external_React_default().createElement(
                  "li",
                  null,
                  external_React_default().createElement(
                    "p",
                    null,
                    external_React_default().createElement("span", {
                      className: "geolocation__coordinates-icon"
                    }),
                    external_React_default().createElement(
                      "span",
                      {
                        className: "geolocation__coordinates"
                      },
                      "https://maps.google.com"
                    )
                  )
                )
              )
            )
          )
        );
      }
      const geoLocation = GeoLocation;
      // EXTERNAL MODULE: ./js/chat/ui/messages/types/partials/metaRichPreviewLoading.jsx
      var metaRichPreviewLoading = __webpack_require__(480); // CONCATENATED MODULE: ./js/chat/ui/messages/types/partials/metaRichpreviewMegaLinks.jsx
      class MetaRichpreviewMegaLinks extends mixin.y {
        render() {
          var message = this.props.message;
          var chatRoom = this.props.message.chatRoom;
          var previewContainer;
          var output = [];
          var megaLinks = message.megaLinks ? message.megaLinks : [];
          for (var i = 0; i < megaLinks.length; i++) {
            var megaLinkInfo = megaLinks[i];
            if (megaLinkInfo.failed) {
              continue;
            }
            if (megaLinkInfo.hadLoaded() === false) {
              if (megaLinkInfo.startedLoading() === false) {
                megaLinkInfo
                  .getInfo()
                  .then(() => {
                    const { megaLinks } = this.props.message;
                    const contactLinkHandles = megaLinks.filter((link) => link.is_contactlink).map((link) => link.info.h);
                    if (contactLinkHandles.length) {
                      this.addContactListenerIfMissing(contactLinkHandles);
                    }
                  })
                  .catch(reportError)
                  .finally(() => {
                    message.trackDataChange();
                    onIdle(() => {
                      this.safeForceUpdate();
                    });
                  });
              }
              previewContainer = external_React_default().createElement(metaRichPreviewLoading.F, {
                message: message,
                isLoading: megaLinkInfo.hadLoaded()
              });
            } else if (megaLinkInfo.is_contactlink) {
              var fakeContact = M.u[megaLinkInfo.info.h]
                ? M.u[megaLinkInfo.info.h]
                : {
                    u: megaLinkInfo.info.h,
                    m: megaLinkInfo.info.e,
                    firstName: megaLinkInfo.info.fn,
                    lastName: megaLinkInfo.info.ln,
                    name: megaLinkInfo.info.fn + " " + megaLinkInfo.info.ln
                  };
              if (!M.u[fakeContact.u]) {
                M.u.set(
                  fakeContact.u,
                  new MegaDataObject(MEGA_USER_STRUCT, {
                    u: fakeContact.u,
                    name: fakeContact.firstName + " " + fakeContact.lastName,
                    m: fakeContact.m ? fakeContact.m : "",
                    c: undefined
                  })
                );
              }
              var contact = M.u[megaLinkInfo.info.h];
              previewContainer = external_React_default().createElement(
                "div",
                {
                  key: megaLinkInfo.info.h,
                  className: "message shared-block contact-link"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "message shared-info"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "message data-title selectable-txt"
                    },
                    contact.name
                  ),
                  external_React_default().createElement(ui_contacts.ContactVerified, {
                    className: "right-align",
                    contact: contact
                  }),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "user-card-email selectable-txt"
                    },
                    contact.m
                  )
                ),
                external_React_default().createElement(
                  "div",
                  {
                    className: "message shared-data"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "data-block-view semi-big"
                    },
                    external_React_default().createElement(ui_contacts.ContactPresence, {
                      className: "small",
                      contact: contact
                    }),
                    external_React_default().createElement(ui_contacts.Avatar, {
                      className: "avatar-wrapper medium-avatar",
                      contact: contact,
                      chatRoom: chatRoom
                    })
                  ),
                  external_React_default().createElement("div", {
                    className: "clear"
                  })
                )
              );
            } else {
              var desc;
              var is_icon = megaLinkInfo.is_dir ? true : !(megaLinkInfo.havePreview() && megaLinkInfo.info.preview_url);
              if (megaLinkInfo.is_chatlink) {
                desc = l[8876].replace("%1", megaLinkInfo.info.ncm);
              } else if (!megaLinkInfo.is_dir) {
                desc = bytesToSize(megaLinkInfo.info.size);
              } else {
                const totalNumberOfFiles = megaLinkInfo.info.s[1];
                const numOfVersionedFiles = megaLinkInfo.info.s[4];
                const folderCount = megaLinkInfo.info.s[2];
                const totalFileSize = megaLinkInfo.info.size;
                const versionsSize = megaLinkInfo.info.s[3];
                desc = external_React_default().createElement(
                  "span",
                  null,
                  fm_contains(totalNumberOfFiles - numOfVersionedFiles, folderCount - 1),
                  external_React_default().createElement("br", null),
                  bytesToSize(totalFileSize - versionsSize)
                );
              }
              previewContainer = external_React_default().createElement(
                "div",
                {
                  className:
                    "message richpreview body " + ((is_icon ? "have-icon" : "no-icon") + " " + (megaLinkInfo.is_chatlink ? "is-chat" : ""))
                },
                megaLinkInfo.havePreview() && megaLinkInfo.info.preview_url
                  ? external_React_default().createElement(
                      "div",
                      {
                        className: "message richpreview img-wrapper"
                      },
                      external_React_default().createElement("div", {
                        className: "message richpreview preview",
                        style: {
                          backgroundImage: "url(" + megaLinkInfo.info.preview_url + ")"
                        }
                      })
                    )
                  : external_React_default().createElement(
                      "div",
                      {
                        className: "message richpreview img-wrapper"
                      },
                      megaLinkInfo.is_chatlink
                        ? external_React_default().createElement("i", {
                            className: "huge-icon conversations"
                          })
                        : external_React_default().createElement("div", {
                            className:
                              "message richpreview icon block-view-file-type " +
                              (megaLinkInfo.is_dir ? "folder" : fileIcon(megaLinkInfo.info))
                          })
                    ),
                external_React_default().createElement(
                  "div",
                  {
                    className: "message richpreview inner-wrapper"
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "message richpreview data-title selectable-txt"
                    },
                    external_React_default().createElement(
                      "span",
                      {
                        className: "message richpreview title"
                      },
                      external_React_default().createElement(utils.dy, null, megaLinkInfo.info.name || megaLinkInfo.info.topic || "")
                    )
                  ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "message richpreview desc"
                    },
                    desc
                  ),
                  external_React_default().createElement(
                    "div",
                    {
                      className: "message richpreview url-container"
                    },
                    external_React_default().createElement(
                      "span",
                      {
                        className: "message richpreview url-favicon"
                      },
                      external_React_default().createElement("img", {
                        src: "https://mega.nz/favicon.ico?v=3&c=1",
                        width: 16,
                        height: 16,
                        onError: (e) => {
                          if (e && e.target && e.target.parentNode) {
                            e.target.parentNode.removeChild(e.target);
                          }
                        },
                        alt: ""
                      })
                    ),
                    external_React_default().createElement(
                      "span",
                      {
                        className: "message richpreview url"
                      },
                      ellipsis(megaLinkInfo.getLink(), "end", 40)
                    )
                  )
                )
              );
            }
            output.push(
              external_React_default().createElement(
                "div",
                {
                  key: megaLinkInfo.node_key + "_" + output.length,
                  className:
                    "message richpreview container " +
                    (megaLinkInfo.havePreview() ? "have-preview" : "no-preview") +
                    " " +
                    (megaLinkInfo.d ? "have-description" : "no-description") +
                    " " +
                    (!megaLinkInfo.hadLoaded() ? "is-loading" : "done-loading"),
                  onClick: function (url, megaLinkInfo) {
                    if (megaLinkInfo.hadLoaded()) {
                      if (window.sfuClient && megaLinkInfo.is_chatlink) {
                        const { chatRoom: callRoom } = megaChat.activeCall;
                        const peers = callRoom
                          ? callRoom.getParticipantsExceptMe(callRoom.getCallParticipants()).map((h) => M.getNameByHandle(h))
                          : [];
                        const body = peers.length ? mega.utils.trans.listToString(peers, l.cancel_with_to_join) : l.cancel_to_join;
                        return msgDialog(
                          "confirmation",
                          undefined,
                          l.call_in_progress,
                          body,
                          (e) => e && window.open(url, "_blank", "noopener,noreferrer")
                        );
                      }
                      window.open(url, "_blank", "noopener,noreferrer");
                    }
                  }.bind(this, megaLinkInfo.getLink(), megaLinkInfo)
                },
                previewContainer,
                external_React_default().createElement("div", {
                  className: "clear"
                })
              )
            );
          }
          return external_React_default().createElement(
            "div",
            {
              className: "message richpreview previews-container"
            },
            output
          );
        }
      }

      // EXTERNAL MODULE: ./js/chat/ui/typingArea.jsx + 1 modules
      var typingArea = __webpack_require__(825);
      // EXTERNAL MODULE: ./js/ui/perfectScrollbar.jsx
      var perfectScrollbar = __webpack_require__(285); // CONCATENATED MODULE: ./js/chat/ui/messages/types/text.jsx
      class Text extends AbstractGenericMessage {
        isRichPreview(message) {
          return message.metaType === Message.MESSAGE_META_TYPE.RICH_PREVIEW;
        }
        isGeoLocation(message) {
          return message.metaType === Message.MESSAGE_META_TYPE.GEOLOCATION;
        }
        getClassNames() {
          const { message, isBeingEdited, grouped } = this.props;
          const REQUIRES_CONFIRMATION =
            this.isRichPreview(message) &&
            message.meta.requiresConfirmation &&
            !isBeingEdited() &&
            (message.source === Message.SOURCE.SENT || message.confirmed === true);
          return `
            ${REQUIRES_CONFIRMATION ? "preview-requires-confirmation-container" : ""}
            ${grouped ? "grouped" : ""}
        `;
        }
        getMessageActionButtons() {
          const { chatRoom, message, isBeingEdited } = this.props;
          if (isBeingEdited()) {
            return [];
          }
          let extraPreButtons = [];
          let messageActionButtons = null;
          const IS_GEOLOCATION = this.isGeoLocation(message);
          if (!message.deleted && this.isRichPreview(message)) {
            if (!message.meta.requiresConfirmation) {
              if (message.isEditable()) {
                if (message.meta.isLoading) {
                  extraPreButtons = [
                    ...extraPreButtons,
                    external_React_default().createElement(dropdowns.DropdownItem, {
                      icon: "sprite-fm-mono icon-eye-hidden",
                      key: "stop-link-preview",
                      label: l[18684],
                      className: "",
                      onClick: (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        chatRoom.megaChat.plugins.richpreviewsFilter.cancelLoading(chatRoom, message);
                      }
                    })
                  ];
                } else {
                  extraPreButtons = [
                    ...extraPreButtons,
                    external_React_default().createElement(dropdowns.DropdownItem, {
                      key: "remove-link-preview",
                      icon: "sprite-fm-mono icon-eye-hidden",
                      label: l[18684],
                      className: "",
                      onClick: (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        chatRoom.megaChat.plugins.richpreviewsFilter.revertToText(chatRoom, message);
                      }
                    })
                  ];
                }
              }
            } else if (!isBeingEdited() && !(message.source === Message.SOURCE.SENT || message.confirmed === true)) {
              extraPreButtons = [
                ...extraPreButtons,
                external_React_default().createElement(dropdowns.DropdownItem, {
                  key: "insert-link-preview",
                  icon: "icons-sprite bold-eye",
                  label: l[18683],
                  className: "",
                  onClick: (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    chatRoom.megaChat.plugins.richpreviewsFilter.insertPreview(message);
                  }
                })
              ];
            }
          }
          if (!message.deleted) {
            const contact = this.getContact();
            if (
              contact &&
              contact.u === u_handle &&
              unixtime() - message.delay < MESSAGE_NOT_EDITABLE_TIMEOUT &&
              isBeingEdited() !== true &&
              chatRoom.isReadOnly() === false &&
              !message.requiresManualRetry
            ) {
              const editButton =
                !IS_GEOLOCATION &&
                external_React_default().createElement(dropdowns.DropdownItem, {
                  icon: "sprite-fm-mono icon-rename",
                  label: l[1342],
                  onClick: () => this.props.onEditToggle(true)
                });
              messageActionButtons = external_React_default().createElement(
                buttons.z,
                {
                  key: "delete-msg",
                  className: "tiny-button",
                  icon: "sprite-fm-mono icon-options"
                },
                external_React_default().createElement(
                  dropdowns.Dropdown,
                  {
                    className: "white-context-menu attachments-dropdown",
                    noArrow: true,
                    positionMy: "left bottom",
                    positionAt: "right bottom",
                    horizOffset: 4
                  },
                  extraPreButtons,
                  editButton,
                  editButton ? external_React_default().createElement("hr", null) : null,
                  external_React_default().createElement(dropdowns.DropdownItem, {
                    icon: "sprite-fm-mono icon-dialog-close",
                    label: l[1730],
                    onClick: (e) => this.props.onDelete(e, message)
                  })
                )
              );
            }
          }
          let parentButtons;
          if (super.getMessageActionButtons) {
            parentButtons = super.getMessageActionButtons();
          }
          let returnedButtons = [];
          if (messageActionButtons) {
            returnedButtons.push(messageActionButtons);
          }
          if (message.messageHtml && message.messageHtml.includes('<pre class="rtf-multi">') && message.messageHtml.includes("</pre>")) {
            returnedButtons.push(
              external_React_default().createElement(buttons.z, {
                key: "copy-msg",
                className: "tiny-button simpletip copy-txt-block",
                icon: "sprite-fm-mono icon-copy",
                attrs: {
                  "data-simpletip": l.copy_txt_block_tip,
                  "data-simpletipoffset": "3",
                  "data-simpletipposition": "top"
                },
                onClick: () => {
                  copyToClipboard(message.textContents.replace(/```/g, ""), l.copy_txt_block_toast);
                }
              })
            );
          }
          if (parentButtons) {
            returnedButtons.push(parentButtons);
          }
          return returnedButtons;
        }
        getContents() {
          const { message, chatRoom, onUpdate, isBeingEdited, spinnerElement } = this.props;
          let messageNotSendIndicator;
          let textMessage = message.messageHtml;
          const IS_GEOLOCATION = this.isGeoLocation(message);
          const { lng, la: latitude } = IS_GEOLOCATION && message.meta.extra[0];
          if (message.textContents === "" && !message.dialogType) {
            message.deleted = true;
          }
          let subMessageComponent = [];
          if (!message.deleted) {
            if (this.isRichPreview(message)) {
              if (!message.meta.requiresConfirmation) {
                subMessageComponent = [
                  ...subMessageComponent,
                  external_React_default().createElement(MetaRichpreview, {
                    key: "richprev",
                    message: message,
                    chatRoom: chatRoom
                  })
                ];
              } else if (!isBeingEdited()) {
                if (message.source === Message.SOURCE.SENT || message.confirmed === true) {
                  subMessageComponent = [
                    ...subMessageComponent,
                    external_React_default().createElement(MetaRichprevConfirmation, {
                      key: "confirm",
                      message: message,
                      chatRoom: chatRoom
                    })
                  ];
                }
              }
            }
            if (message.megaLinks) {
              subMessageComponent = [
                ...subMessageComponent,
                external_React_default().createElement(MetaRichpreviewMegaLinks, {
                  key: "richprevml",
                  message: message,
                  chatRoom: chatRoom
                })
              ];
            }
          }
          if (
            message &&
            message.getState &&
            (message.getState() === Message.STATE.NOT_SENT || message.getState() === Message.STATE.NOT_SENT_EXPIRED)
          ) {
            if (!spinnerElement) {
              if (message.requiresManualRetry) {
                if (isBeingEdited() !== true) {
                  messageNotSendIndicator = external_React_default().createElement(
                    "div",
                    {
                      className: "not-sent-indicator"
                    },
                    external_React_default().createElement(
                      "span",
                      {
                        className: "tooltip-trigger",
                        key: "retry",
                        "data-tooltip": "not-sent-notification-manual",
                        onClick: (e) => this.props.onRetry(e, message)
                      },
                      external_React_default().createElement("i", {
                        className: "small-icon refresh-circle"
                      })
                    ),
                    external_React_default().createElement(
                      "span",
                      {
                        className: "tooltip-trigger",
                        key: "cancel",
                        "data-tooltip": "not-sent-notification-cancel",
                        onClick: (e) => this.props.onCancelRetry(e, message)
                      },
                      external_React_default().createElement("i", {
                        className: "sprite-fm-mono icon-dialog-close"
                      })
                    )
                  );
                }
              } else {
                messageNotSendIndicator = external_React_default().createElement(
                  "div",
                  {
                    className: "not-sent-indicator tooltip-trigger",
                    "data-tooltip": "not-sent-notification"
                  },
                  external_React_default().createElement("i", {
                    className: "small-icon yellow-triangle"
                  })
                );
              }
            }
          }
          let messageDisplayBlock;
          if (isBeingEdited() === true) {
            let msgContents = message.textContents;
            msgContents = megaChat.plugins.emoticonsFilter.fromUtfToShort(msgContents);
            messageDisplayBlock = external_React_default().createElement(typingArea.j, {
              iconClass: "small-icon writing-pen textarea-icon",
              initialText: msgContents,
              chatRoom: chatRoom,
              showButtons: true,
              editing: true,
              className: "edit-typing-area",
              onUpdate: () => (onUpdate ? onUpdate : null),
              onConfirm: (messageContents) => {
                this.props.onEditToggle(false);
                if (this.props.onEditDone) {
                  Soon(() => {
                    const tmpMessageObj = {
                      textContents: messageContents
                    };
                    megaChat.plugins.emoticonsFilter.processOutgoingMessage({}, tmpMessageObj);
                    this.props.onEditDone(tmpMessageObj.textContents);
                    if (this.isMounted()) {
                      this.forceUpdate();
                    }
                  });
                }
                return true;
              },
              onResized: this.props.onResized ? this.props.onResized : false
            });
          } else {
            if (message.updated > 0 && !message.metaType) {
              textMessage = `${textMessage} <em class="edited">${l[8887]}</em>`;
            }
            if (this.props.initTextScrolling) {
              messageDisplayBlock = external_React_default().createElement(
                perfectScrollbar.F,
                {
                  className: "message text-block scroll"
                },
                external_React_default().createElement(
                  "div",
                  {
                    className: "message text-scroll"
                  },
                  external_React_default().createElement(utils.Cw, null, textMessage)
                )
              );
            } else {
              messageDisplayBlock = external_React_default().createElement(
                "div",
                {
                  className: "message text-block"
                },
                external_React_default().createElement(utils.Cw, null, textMessage)
              );
            }
          }
          return external_React_default().createElement(
            external_React_default().Fragment,
            null,
            messageNotSendIndicator,
            IS_GEOLOCATION ? null : messageDisplayBlock,
            subMessageComponent,
            spinnerElement,
            IS_GEOLOCATION &&
              external_React_default().createElement(geoLocation, {
                latitude: latitude,
                lng: lng
              })
          );
        }
      }
      // EXTERNAL MODULE: ./js/chat/ui/gifPanel/gifPanel.jsx + 3 modules
      var gifPanel = __webpack_require__(722); // CONCATENATED MODULE: ./js/chat/ui/messages/types/giphy.jsx
      class Giphy extends AbstractGenericMessage {
        constructor(...args) {
          super(...args);
          this.gifRef = external_React_default().createRef();
          this.viewStateListener = `viewstateChange.giphy--${this.getUniqueId()}`;
          this.state = {
            src: undefined
          };
        }
        componentDidMount() {
          super.componentDidMount();
          megaChat.rebind(this.viewStateListener, ({ data }) => {
            const gifRef = this.gifRef && this.gifRef.current;
            if (gifRef) {
              const { state } = data;
              if ((state === "active" && gifRef.paused) || (state !== "active" && !gifRef.paused)) {
                this.toggle();
              }
            }
          });
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          megaChat.off(this.viewStateListener);
        }
        onVisibilityChange(isIntersecting) {
          this.setState(
            {
              src: isIntersecting ? gifPanel.bl.convert(this.props.message.meta.src) : undefined
            },
            () => {
              var _this$gifRef;
              (_this$gifRef = this.gifRef) == null ||
                (_this$gifRef = _this$gifRef.current) == null ||
                _this$gifRef[isIntersecting ? "load" : "pause"]();
              this.safeForceUpdate();
            }
          );
        }
        toggle() {
          const video = this.gifRef.current;
          Promise.resolve(video[video.paused ? "play" : "pause"]()).catch(nop);
        }
        getMessageActionButtons() {
          const { onDelete, message } = this.props;
          const $$BUTTONS = [
            message.isEditable() &&
              external_React_default().createElement(
                buttons.z,
                {
                  key: "delete-GIPHY-button",
                  className: "tiny-button",
                  icon: "sprite-fm-mono icon-options"
                },
                external_React_default().createElement(
                  dropdowns.Dropdown,
                  {
                    className: "white-context-menu attachments-dropdown",
                    noArrow: true,
                    positionMy: "left bottom",
                    positionAt: "right bottom",
                    horizOffset: 4
                  },
                  external_React_default().createElement(dropdowns.DropdownItem, {
                    icon: "sprite-fm-mono icon-dialog-close",
                    label: l[1730],
                    onClick: (e) => onDelete(e, message)
                  })
                )
              ),
            super.getMessageActionButtons && super.getMessageActionButtons()
          ];
          return $$BUTTONS.filter((button) => button);
        }
        getContents() {
          const { message, hideActionButtons } = this.props;
          const { s, w, h, src } = message.meta;
          const autoPlay = parseInt(s, 10) < 4e6;
          return external_React_default().createElement("video", {
            className: "giphy-block",
            ref: this.gifRef,
            title: message.textContents,
            autoPlay: autoPlay,
            loop: true,
            muted: true,
            controls: false,
            width: w,
            height: h,
            style: {
              cursor: autoPlay ? "default" : "pointer",
              height: `${h}px`
            },
            onClick: () => !autoPlay && this.toggle(),
            src: hideActionButtons ? gifPanel.bl.convert(src) : this.state.src
          });
        }
      } // CONCATENATED MODULE: ./js/chat/ui/messages/generic.jsx
      const CLICKABLE_ATTACHMENT_CLASSES = ".message.data-title, .message.file-size, .data-block-view.semi-big, .data-block-view.medium";
      class GenericConversationMessage extends mixin.y {
        constructor(props) {
          super(props);
          this.state = {
            editing: this.props.editing
          };
          this.pid = "__geom_" + String(Math.random()).substr(2);
        }
        isBeingEdited() {
          return this.state.editing === true || this.props.editing === true;
        }
        componentDidUpdate(oldProps, oldState) {
          const isBeingEdited = this.isBeingEdited();
          const isMounted = this.isMounted();
          if (isBeingEdited && isMounted) {
            const $generic = $(this.findDOMNode());
            const $textarea = $("textarea", $generic);
            if ($textarea.length > 0 && !$textarea.is(":focus")) {
              $textarea.trigger("focus");
              moveCursortoToEnd($textarea[0]);
            }
            if (!oldState.editing && this.props.onEditStarted) {
              this.props.onEditStarted($generic);
              moveCursortoToEnd($textarea);
            }
          }
          if (isMounted && !isBeingEdited && oldState.editing === true && this.props.onUpdate) {
            this.props.onUpdate();
          }
        }
        componentDidMount() {
          super.componentDidMount();
          var self = this;
          var $node = $(self.findDOMNode());
          if (self.isBeingEdited() && self.isMounted()) {
            var $generic = $(self.findDOMNode());
            var $textarea = $("textarea", $generic);
            if ($textarea.length > 0 && !$textarea.is(":focus")) {
              $textarea.trigger("focus");
              moveCursortoToEnd($textarea[0]);
            }
          }
          $node.rebind("click.dropdownShortcut", CLICKABLE_ATTACHMENT_CLASSES, function (e) {
            const $target = $(e.target);
            if ($target.hasClass("button")) {
              return;
            }
            if ($target.hasClass("no-thumb-prev") || $target.parents(".no-thumb-prev").length) {
              return;
            }
            let $block;
            if ($target.is(".shared-data")) {
              $block = $target;
            } else if ($target.is(".shared-info") || $target.parents(".shared-info").length > 0) {
              $block = $target.is(".shared-info") ? $target.next() : $target.parents(".shared-info").next();
            } else {
              $block = $target.parents(".message.shared-data");
            }
            Soon(function () {
              $(".tiny-button", $block).trigger("click");
            });
          });
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          var self = this;
          var $node = $(self.findDOMNode());
          self.props.message.off("onChange.GenericConversationMessage" + self.getUniqueId());
          $node.off("click.dropdownShortcut", CLICKABLE_ATTACHMENT_CLASSES);
        }
        haveMoreContactListeners() {
          if (!this.props.message || !this.props.message.meta) {
            return false;
          }
          if (this.props.message.meta && this.props.message.meta.participants) {
            return this.props.message.meta.participants;
          }
          return false;
        }
        doDelete(e, msg) {
          e.preventDefault(e);
          e.stopPropagation(e);
          if (msg.getState() === Message.STATE.NOT_SENT_EXPIRED) {
            this.doCancelRetry(e, msg);
          } else {
            this.props.onDeleteClicked(this.props.message);
          }
        }
        doCancelRetry(e, msg) {
          e.preventDefault(e);
          e.stopPropagation(e);
          const chatRoom = this.props.message.chatRoom;
          const messageId = msg.messageId;
          chatRoom.messagesBuff.messages.removeByKey(messageId);
          chatRoom.megaChat.plugins.chatdIntegration.discardMessage(chatRoom, messageId);
        }
        doRetry(e, msg) {
          e.preventDefault(e);
          e.stopPropagation(e);
          const chatRoom = this.props.message.chatRoom;
          this.doCancelRetry(e, msg);
          chatRoom._sendMessageToTransport(msg).then((internalId) => {
            msg.internalId = internalId;
            this.safeForceUpdate();
          });
        }
        _favourite(h) {
          if (M.isInvalidUserStatus()) {
            return;
          }
          var newFavState = Number(!M.isFavourite(h));
          M.favourite([h], newFavState);
        }
        _addFavouriteButtons(h, arr) {
          var self = this;
          if (M.getNodeRights(h) > 1) {
            var isFav = M.isFavourite(h);
            arr.push(
              external_React_default().createElement(dropdowns.DropdownItem, {
                icon: `
                        sprite-fm-mono
                        context
                        ${isFav ? "icon-favourite-removed" : "icon-favourite"}
                    `,
                label: isFav ? l[5872] : l[5871],
                isFav: isFav,
                key: "fav",
                disabled: mega.paywall,
                onClick: (e) => {
                  self._favourite(h);
                  e.stopPropagation();
                  e.preventDefault();
                  return false;
                }
              })
            );
            return isFav;
          }
          return false;
        }
        _isNodeHavingALink(h) {
          return M.getNodeShare(h) !== false;
        }
        _addLinkButtons(h, arr) {
          var self = this;
          var haveLink = self._isNodeHavingALink(h) === true;
          var getManageLinkText = haveLink ? l[6909] : l[5622];
          arr.push(
            external_React_default().createElement(dropdowns.DropdownItem, {
              icon: "sprite-fm-mono icon-link",
              key: "getLinkButton",
              label: getManageLinkText,
              disabled: mega.paywall,
              onClick: self._getLink.bind(self, h)
            })
          );
          if (haveLink) {
            arr.push(
              external_React_default().createElement(dropdowns.DropdownItem, {
                icon: "sprite-fm-mono context icon-link-remove",
                key: "removeLinkButton",
                label: l[6821],
                disabled: mega.paywall,
                onClick: self._removeLink.bind(self, h)
              })
            );
            return true;
          }
          return false;
        }
        _startDownload(v) {
          M.addDownload([v]);
        }
        _addToCloudDrive(v, openSendToChat) {
          $.selected = [v.h];
          $.chatAttachmentShare = true;
          if ($.dialog === "onboardingDialog") {
            closeDialog();
          }
          openSaveToDialog(
            v,
            function (node, target) {
              if (Array.isArray(target)) {
                megaChat.openChatAndAttachNodes(target, node.ch || node.h).catch(tell);
              } else {
                target = target || M.RootID;
                M.injectNodes(node, target, function (res) {
                  if (!Array.isArray(res) || !res.length) {
                    if (d) {
                      console.warn("Unable to inject nodes... no longer existing?", res);
                    }
                  } else {
                    msgDialog("info", l[8005], target === M.RootID ? l[8006] : l[22903].replace("%s", escapeHTML(M.d[target].name)));
                  }
                });
              }
            },
            openSendToChat ? "conversations" : false
          );
        }
        _getLink(h, e) {
          if (u_type === 0) {
            ephemeralDialog(l[1005]);
          } else {
            $.selected = [h];
            mega.Share.initCopyrightsDialog([h]);
          }
          if (e) {
            e.preventDefault();
            e.stopPropagation();
          }
        }
        _removeLink(h, e) {
          if (u_type === 0) {
            ephemeralDialog(l[1005]);
          } else {
            var exportLink = new mega.Share.ExportLink({
              updateUI: true,
              nodesToProcess: [h]
            });
            exportLink.removeExportLink();
          }
          if (e) {
            e.preventDefault();
            e.stopPropagation();
          }
        }
        _startPreview(v, e) {
          if ($(e && e.target).is(".tiny-button")) {
            return;
          }
          assert(M.chat, "Not in chat.");
          if (e) {
            e.preventDefault();
            e.stopPropagation();
          }
          M.viewMediaFile(v);
        }
        render() {
          const { message, chatRoom } = this.props;
          const megaChat = this.props.message.chatRoom.megaChat;
          let textContents = message.textContents;
          let additionalClasses = "";
          let spinnerElement = null;
          let messageIsNowBeingSent = false;
          if (this.props.className) {
            additionalClasses += this.props.className;
          }
          if (message instanceof Message) {
            if (!message.wasRendered || !message.messageHtml) {
              message.messageHtml = htmlentities(textContents).replace(/\n/gi, "<br/>").replace(/\t/g, "    ");
              message.processedBy = {};
              const evtObj = {
                message,
                room: chatRoom
              };
              megaChat.trigger("onPreBeforeRenderMessage", evtObj);
              const event = new MegaDataEvent("onBeforeRenderMessage");
              megaChat.trigger(event, evtObj);
              megaChat.trigger("onPostBeforeRenderMessage", evtObj);
              if (event.isPropagationStopped()) {
                this.logger.warn(`Event propagation stopped receiving (rendering) of message: ${message}`);
                return false;
              }
              message.wasRendered = 1;
            }
            var state = message.getState();
            var stateText = message.getStateText(state);
            if (state === Message.STATE.NOT_SENT) {
              messageIsNowBeingSent = unixtime() - message.delay < 5;
              if (messageIsNowBeingSent) {
                additionalClasses += " sending";
                spinnerElement = external_React_default().createElement("div", {
                  className: "small-blue-spinner"
                });
                if (!message.sending) {
                  message.sending = true;
                  delay(
                    this.pid + message.messageId,
                    () => {
                      if (chatRoom.messagesBuff.messages[message.messageId] && message.sending === true) {
                        chatRoom.messagesBuff.trackDataChange();
                        if (this.isMounted()) {
                          this.forceUpdate();
                        }
                      }
                    },
                    (5 - (unixtime() - message.delay)) * 1000
                  );
                }
              } else {
                additionalClasses += " not-sent";
                if (message.sending === true) {
                  message.sending = false;
                  message.trigger("onChange", [message, "sending", true, false]);
                }
                if (message.requiresManualRetry) {
                  additionalClasses += " retrying requires-manual-retry";
                } else {
                  additionalClasses += " retrying";
                }
              }
            } else {
              additionalClasses += " " + stateText;
            }
          }
          const MESSAGE = {
            TYPE: {
              ATTACHMENT: textContents[1] === Message.MANAGEMENT_MESSAGE_TYPES.ATTACHMENT,
              CONTACT: textContents[1] === Message.MANAGEMENT_MESSAGE_TYPES.CONTACT,
              REVOKE_ATTACHMENT: textContents[1] === Message.MANAGEMENT_MESSAGE_TYPES.REVOKE_ATTACHMENT,
              VOICE_CLIP: textContents[1] === Message.MANAGEMENT_MESSAGE_TYPES.VOICE_CLIP,
              GIPHY: message.metaType && message.metaType === Message.MESSAGE_META_TYPE.GIPHY,
              TEXT: textContents[0] !== Message.MANAGEMENT_MESSAGE_TYPES.MANAGEMENT,
              INLINE: !(message instanceof Message) && message.type && !!message.type.length,
              REVOKED: message.revoked
            },
            props: {
              ...this.props,
              additionalClasses
            },
            isBeingEdited: () => this.isBeingEdited(),
            onDelete: (e, message) => this.doDelete(e, message)
          };
          switch (true) {
            case MESSAGE.TYPE.REVOKED || MESSAGE.TYPE.REVOKE_ATTACHMENT:
              return null;
            case MESSAGE.TYPE.ATTACHMENT:
              return external_React_default().createElement(
                Attachment,
                (0, esm_extends.Z)({}, MESSAGE.props, {
                  onPreviewStart: (v, e) => this._startPreview(v, e),
                  onDownloadStart: (v) => this._startDownload(v),
                  onAddLinkButtons: (h, arr) => this._addLinkButtons(h, arr),
                  onAddToCloudDrive: (v, openSendToChat) => this._addToCloudDrive(v, openSendToChat),
                  onAddFavouriteButtons: (h, arr) => this._addFavouriteButtons(h, arr)
                })
              );
            case MESSAGE.TYPE.CONTACT:
              return external_React_default().createElement(
                Contact,
                (0, esm_extends.Z)({}, MESSAGE.props, {
                  onDelete: MESSAGE.onDelete
                })
              );
            case MESSAGE.TYPE.VOICE_CLIP:
              return external_React_default().createElement(
                VoiceClip,
                (0, esm_extends.Z)({}, MESSAGE.props, {
                  isBeingEdited: MESSAGE.isBeingEdited,
                  onDelete: MESSAGE.onDelete
                })
              );
            case MESSAGE.TYPE.INLINE:
              return external_React_default().createElement(Local, MESSAGE.props);
            case MESSAGE.TYPE.GIPHY:
              return external_React_default().createElement(
                Giphy,
                (0, esm_extends.Z)({}, MESSAGE.props, {
                  onDelete: MESSAGE.onDelete
                })
              );
            case MESSAGE.TYPE.TEXT:
              return external_React_default().createElement(
                Text,
                (0, esm_extends.Z)({}, MESSAGE.props, {
                  onEditToggle: (editing) =>
                    this.setState({
                      editing
                    }),
                  onDelete: MESSAGE.onDelete,
                  onRetry: (e, message) => this.doRetry(e, message),
                  onCancelRetry: (e, message) => this.doCancelRetry(e, message),
                  isBeingEdited: MESSAGE.isBeingEdited,
                  spinnerElement: spinnerElement
                })
              );
            default:
              return null;
          }
        }
      }

      /***/
    },

    /***/ 416: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        y: () => ConversationMessageMixin
      });
      var react0__ = __webpack_require__(363);
      var react0 = __webpack_require__.n(react0__);
      var _mixins1__ = __webpack_require__(503);
      var _ui_buttons_jsx2__ = __webpack_require__(204);
      var _ui_emojiDropdown_jsx3__ = __webpack_require__(768);

      class ConversationMessageMixin extends _mixins1__._p {
        constructor(props) {
          super(props);
          this.attachRerenderCallbacks = false;
          this.__cmmUpdateTickCount = 0;
          this._contactChangeListeners = false;
          this.onAfterRenderWasTriggered = false;
          lazy(this, "__cmmId", () => {
            return this.getUniqueId() + "--" + String(Math.random()).slice(-7);
          });
          this._emojiOnActiveStateChange = this._emojiOnActiveStateChange.bind(this);
          this.emojiSelected = this.emojiSelected.bind(this);
          const { message: msg } = this.props;
          if (
            msg instanceof Message &&
            msg._reactions &&
            msg.messageId.length === 11 &&
            msg.isSentOrReceived() &&
            !Object.hasOwnProperty.call(msg, "reacts")
          ) {
            msg.reacts
              .forceLoad()
              .then(() => {
                this.addContactListenerIfMissing(this._reactionContacts());
              })
              .catch(dump.bind(null, `reactions.load.${msg.messageId}`));
          }
        }
        componentWillMount() {
          if (super.componentWillMount) {
            super.componentWillMount();
          }
          const chatRoom = this.props.chatRoom;
          if (chatRoom) {
            chatRoom
              .rebind("onChatShown." + this.__cmmId, () => {
                if (!this._contactChangeListeners) {
                  this.addContactListeners();
                }
              })
              .rebind("onChatHidden." + this.__cmmId, () => {
                if (this._contactChangeListeners) {
                  this.removeContactListeners();
                }
              });
          }
          this.addContactListeners();
        }
        haveMeetingsCall() {
          return document.querySelector(".meetings-call") && document.querySelector(".chat-opened");
        }
        removeContactListeners() {
          const users = this._contactChangeListeners;
          if (d > 3) {
            console.warn("%s.removeContactListeners", this.getReactId(), [this], users);
          }
          for (let i = users.length; i--; ) {
            users[i].removeEventHandler(this);
          }
          this._contactChangeListeners = false;
        }
        _reactionContacts() {
          const { message } = this.props;
          const { reacts } = message;
          const handles = [];
          const reactions = Object.values(reacts.reactions);
          for (let i = 0; i < reactions.length; i++) {
            handles.push(...Object.keys(reactions[i]));
          }
          return array.unique(handles);
        }
        addContactListeners() {
          const users = this._contactChangeListeners || [];
          const addUser = (user) => {
            if (user instanceof MegaDataMap && users.indexOf(user) < 0) {
              users.push(user);
            }
          };
          addUser(this.getContact());
          if (this.haveMoreContactListeners) {
            var moreIds = this.haveMoreContactListeners();
            if (moreIds) {
              for (let i = moreIds.length; i--; ) {
                var handle = moreIds[i];
                addUser(handle in M.u && M.u[handle]);
              }
            }
          }
          if (d > 3) {
            console.warn("%s.addContactListeners", this.getReactId(), [this], users);
          }
          for (let i = users.length; i--; ) {
            users[i].addChangeListener(this);
          }
          this._contactChangeListeners = users;
        }
        addContactListenerIfMissing(contacts) {
          if (!Array.isArray(contacts)) {
            contacts = [contacts];
          }
          const added = [];
          for (let i = 0; i < contacts.length; i++) {
            const user = M.u[contacts[i]];
            if (user && !this._contactChangeListeners.includes(user)) {
              this._contactChangeListeners.push(user);
              user.addChangeListener(this);
              added.push(user.h);
            }
          }
          if (d > 1) {
            console.warn("%s.addContactListenerIfMissing", this.getReactId(), [this], added);
          }
        }
        handleChangeEvent(x, z, k) {
          if (k === "ts" || k === "ats") {
            return;
          }
          delay(
            this.__cmmId,
            () => {
              this.eventuallyUpdate();
              this.__cmmUpdateTickCount = -2;
            },
            ++this.__cmmUpdateTickCount > 5 ? -1 : 90
          );
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          const chatRoom = this.props.chatRoom;
          if (chatRoom) {
            chatRoom.off("onChatShown." + this.__cmmId).off("onChatHidden." + this.__cmmId);
          }
          if (this._contactChangeListeners) {
            this.removeContactListeners();
          }
        }
        getContact() {
          if (this.props.contact) {
            return this.props.contact;
          }
          var message = this.props.message;
          return Message.getContactForMessage(message);
        }
        getTimestampAsString() {
          return toLocaleTime(this.getTimestamp());
        }
        getTimestamp() {
          var message = this.props.message;
          var timestampInt;
          if (message.getDelay) {
            timestampInt = message.getDelay();
          } else if (message.delay) {
            timestampInt = message.delay;
          } else {
            timestampInt = unixtime();
          }
          if (timestampInt && message.updated && message.updated > 0) {
            timestampInt += message.updated;
          }
          return timestampInt;
        }
        componentDidUpdate() {
          var self = this;
          var chatRoom = self.props.message.chatRoom;
          if (!self.onAfterRenderWasTriggered) {
            var msg = self.props.message;
            var shouldRender = true;
            if (msg.isManagement && msg.isManagement() === true && msg.isRenderableManagement() === false) {
              shouldRender = false;
            }
            if (shouldRender) {
              chatRoom.trigger("onAfterRenderMessage", self.props.message);
              self.onAfterRenderWasTriggered = true;
            }
          }
        }
        getCurrentUserReactions() {
          const { reactions } = this.props.message.reacts;
          return Object.keys(reactions).filter((utf) => {
            var _reactions$utf;
            return (_reactions$utf = reactions[utf]) == null ? void 0 : _reactions$utf[u_handle];
          });
        }
        emojiSelected(e, slug, meta) {
          const { chatRoom, message, onEmojiBarChange } = this.props;
          if (chatRoom.isReadOnly()) {
            return false;
          }
          const { reactions } = this.props.message.reacts;
          const CURRENT_USER_REACTIONS = this.getCurrentUserReactions().length;
          const REACTIONS_LIMIT = {
            TOTAL: 50,
            PER_PERSON: 24
          };
          const addReaction = () => chatRoom.messagesBuff.userAddReaction(message.messageId, slug, meta);
          const emoji = megaChat._emojiData.emojisSlug[slug] || meta;
          if (emoji && message.reacts.getReaction(u_handle, emoji.u)) {
            if (onEmojiBarChange && Object.keys(reactions).length === 1 && Object.keys(reactions[emoji.u]).length === 1) {
              onEmojiBarChange(false);
            }
            return chatRoom.messagesBuff.userDelReaction(message.messageId, slug, meta);
          }
          if (emoji && reactions[emoji.u] && CURRENT_USER_REACTIONS < REACTIONS_LIMIT.PER_PERSON) {
            return addReaction();
          }
          if (CURRENT_USER_REACTIONS >= REACTIONS_LIMIT.PER_PERSON) {
            return msgDialog("info", "", l[24205].replace("%1", REACTIONS_LIMIT.PER_PERSON));
          }
          if (Object.keys(reactions).length >= REACTIONS_LIMIT.TOTAL) {
            return msgDialog("info", "", l[24206].replace("%1", REACTIONS_LIMIT.TOTAL));
          } else if (onEmojiBarChange && Object.keys(reactions).length === 0) {
            onEmojiBarChange(true);
          }
          return addReaction();
        }
        _emojiOnActiveStateChange(newVal) {
          this.setState(() => {
            return {
              reactionsDropdownActive: newVal
            };
          });
        }
        getEmojisImages() {
          const { chatRoom, message } = this.props;
          var isReadOnlyClass = chatRoom.isReadOnly() ? " disabled" : "";
          var emojisImages =
            message._reactions &&
            message.reacts.reactions &&
            Object.keys(message.reacts.reactions).map((utf) => {
              var reaction = message.reacts.reactions[utf];
              var count = Object.keys(reaction).length;
              if (!count) {
                return null;
              }
              const filename = twemoji.convert.toCodePoint(utf);
              const currentUserReacted = !!reaction[u_handle];
              var names = [];
              if (reaction) {
                ChatdIntegration._ensureContactExists(Object.keys(reaction));
                var rKeys = Object.keys(reaction);
                for (var i = 0; i < rKeys.length; i++) {
                  var uid = rKeys[i];
                  if (reaction[uid]) {
                    var c = M.u[uid] || {};
                    names.push(uid === u_handle ? l[24071] || "You" : c.name ? c.name : c.m || "(missing name)");
                  }
                }
              }
              var emojiData = megaChat._emojiData.emojisUtf[utf];
              if (!emojiData) {
                emojiData = Object.create(null);
                emojiData.u = utf;
              }
              var slug = (emojiData && emojiData.n) || "";
              var tipText;
              slug = slug ? `:${slug}:` : utf;
              if (Object.keys(reaction).length === 1 && reaction[u_handle]) {
                tipText = (l[24068] || "You (click to remove) [G]reacted with %s[/G]").replace("%s", slug);
              } else {
                tipText = mega.utils.trans.listToString(names, (l[24069] || "%s [G]reacted with %s2[/G]").replace("%s2", slug));
              }
              var notFoundEmoji = slug && slug[0] !== ":";
              return react0().createElement(
                "div",
                {
                  key: slug,
                  onClick: (
                    (e, slug, meta) => () =>
                      this.emojiSelected(e, slug, meta)
                  )(null, slug, emojiData),
                  className: `
                            reactions-bar__reaction
                            simpletip
                            ${currentUserReacted ? "user-reacted" : ""}
                            ${notFoundEmoji ? "emoji-loading-error" : ""}
                            ${isReadOnlyClass}
                        `,
                  "data-simpletip": tipText,
                  "data-simpletipoffset": "3",
                  "data-simpletipposition": "top"
                },
                react0().createElement("img", {
                  width: "10",
                  height: "10",
                  className: "emoji emoji-loading",
                  draggable: "false",
                  onError: (e) => {
                    var textNode = document.createElement("em");
                    textNode.classList.remove("emoji-loading");
                    textNode.append(document.createTextNode(utf));
                    e.target.replaceWith(textNode);
                    textNode.parentNode.classList.add("emoji-loading-error");
                  },
                  onLoad: (e) => {
                    e.target.classList.remove("emoji-loading");
                  },
                  src: staticpath + "images/mega/twemojis/2_v2/72x72/" + filename + ".png"
                }),
                react0().createElement(
                  "span",
                  {
                    className: "message text-block"
                  },
                  count
                )
              );
            });
          emojisImages =
            emojisImages &&
            emojisImages.filter(function (v) {
              return !!v;
            });
          if (emojisImages && emojisImages.length > 0) {
            const reactionBtn = !chatRoom.isReadOnly()
              ? react0().createElement(
                  _ui_buttons_jsx2__.z,
                  {
                    className: "popup-button reactions-button hover-colorized simpletip",
                    icon: "sprite-fm-theme icon-emoji-reactions reactions-icon",
                    disabled: false,
                    key: "add-reaction-button",
                    attrs: {
                      "data-simpletip": l[24070] || "Add reaction...",
                      "data-simpletipoffset": "3",
                      "data-simpletipposition": "top"
                    }
                  },
                  react0().createElement(_ui_emojiDropdown_jsx3__.l, {
                    horizOffset: this.haveMeetingsCall() ? -150 : 0,
                    onActiveChange: this._emojiOnActiveStateChange,
                    className: "popup emoji reactions-dropdown",
                    onClick: this.emojiSelected
                  })
                )
              : null;
            emojisImages.push(reactionBtn);
          }
          return emojisImages
            ? react0().createElement(
                "div",
                {
                  className: "reactions-bar",
                  id: "reactions-bar"
                },
                emojisImages
              )
            : null;
        }
        getMessageActionButtons() {
          const { chatRoom, message } = this.props;
          return message instanceof Message && message.isSentOrReceived() && !chatRoom.isReadOnly()
            ? react0().createElement(
                _ui_buttons_jsx2__.z,
                {
                  className: "popup-button reactions-button tiny-button simpletip",
                  icon: `${"sprite-fm-theme reactions-icon"} icon-emoji-reactions`,
                  iconHovered: `${"sprite-fm-theme reactions-icon"} icon-emoji-reactions-active`,
                  disabled: false,
                  key: "add-reaction-button",
                  attrs: {
                    "data-simpletip": l[24070] || "Add reaction...",
                    "data-simpletipoffset": "3",
                    "data-simpletipposition": "top"
                  }
                },
                react0().createElement(_ui_emojiDropdown_jsx3__.l, {
                  horizOffset: this.haveMeetingsCall() ? -110 : 0,
                  noArrow: true,
                  onActiveChange: this._emojiOnActiveStateChange,
                  className: "popup emoji reactions-dropdown",
                  onClick: this.emojiSelected
                })
              )
            : null;
        }
      }

      /***/
    },

    /***/ 97: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        default: () => ScheduleMetaChange
      });
      var react0__ = __webpack_require__(363);
      var react0 = __webpack_require__.n(react0__);
      var _mixin_jsx1__ = __webpack_require__(416);
      var _contacts_jsx2__ = __webpack_require__(13);
      var _ui_utils_jsx3__ = __webpack_require__(79);
      var _ui_buttons_jsx4__ = __webpack_require__(204);

      class ScheduleMetaChange extends _mixin_jsx1__.y {
        constructor(...args) {
          super(...args);
          this.state = {
            link: ""
          };
        }
        componentDidMount() {
          super.componentDidMount();
          if (this.props.mode === ScheduleMetaChange.MODE.CREATED) {
            if (is_chatlink) {
              this.setState({
                link: `chat/${is_chatlink.ph}#${is_chatlink.key}`
              });
            } else {
              const { chatRoom } = this.props;
              chatRoom
                .updatePublicHandle()
                .then(() => {
                  if (this.isMounted() && !this.state.link && chatRoom.publicLink) {
                    this.setState({
                      link: `${getBaseUrl()}/${chatRoom.publicLink}`
                    });
                  }
                })
                .catch(dump);
            }
          }
          if (this.props.message.meta.ap) {
            const { meetingsManager } = megaChat.plugins;
            this.redrawListener = `${meetingsManager.EVENTS.OCCURRENCES_UPDATE}.redraw${this.getUniqueId()}`;
            megaChat.rebind(this.redrawListener, () => {
              onIdle(() => {
                const { meta } = this.props.message;
                if (!meta.ap) {
                  return;
                }
                this.props.message.meta = meetingsManager.noCsMeta(meta.handle, meta.ap, megaChat.chats[meta.cid]);
                this.safeForceUpdate();
              });
              megaChat.off(this.redrawListener);
              delete this.redrawListener;
            });
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          if (this.redrawListener) {
            megaChat.off(this.redrawListener);
          }
        }
        componentDidUpdate(prevProps) {
          if (this.props.mode === ScheduleMetaChange.MODE.CREATED && prevProps.link !== this.props.link) {
            this.setState({
              link: this.props.link ? `${getBaseUrl()}/${this.props.link}` : ""
            });
          }
        }
        onAddToCalendar() {
          const { chatRoom } = this.props;
          const { id, title } = (chatRoom && chatRoom.scheduledMeeting) || {};
          if (id) {
            delay(
              `fetchical${id}`,
              () => {
                asyncApiReq({
                  a: "mcsmfical",
                  id
                })
                  .then(([, res]) => {
                    delay(
                      `saveical${id}`,
                      () => {
                        M.saveAs(base64urldecode(res), `${title.replace(/\W/g, "")}.ics`)
                          .then(nop)
                          .catch(() => {
                            msgDialog("error", "", l.calendar_add_failed, "");
                          });
                      },
                      1000
                    );
                  })
                  .catch(() => {
                    msgDialog("error", "", l.calendar_add_failed, "");
                  });
              },
              250
            );
          }
        }
        static getTitleText(meta) {
          const { mode, recurring, occurrence, converted, prevTiming } = meta;
          const { MODE } = ScheduleMetaChange;
          switch (mode) {
            case MODE.CREATED: {
              return recurring ? l.schedule_mgmt_new_recur : l.schedule_mgmt_new;
            }
            case MODE.EDITED: {
              if (converted) {
                return recurring ? l.schedule_mgmt_update_convert_recur : l.schedule_mgmt_update_convert;
              }
              if (occurrence) {
                return l.schedule_mgmt_update_occur;
              }
              if (prevTiming) {
                return recurring ? l.schedule_mgmt_update_recur : l.schedule_mgmt_update;
              }
              return l.schedule_mgmt_update_desc;
            }
            case MODE.CANCELLED: {
              if (recurring) {
                return occurrence ? l.schedule_mgmt_cancel_occur : l.schedule_mgmt_cancel_recur;
              }
              return l.schedule_mgmt_cancel;
            }
          }
          return "";
        }
        renderTimingBlock() {
          const { message, mode } = this.props;
          const { meta } = message;
          const { MODE } = ScheduleMetaChange;
          if (mode === MODE.CANCELLED && !meta.occurrence) {
            return null;
          }
          const [now, prev] = megaChat.plugins.meetingsManager.getOccurrenceStrings(meta);
          return react0().createElement(
            "div",
            {
              className: "schedule-timing-block"
            },
            meta.prevTiming && react0().createElement("s", null, prev || ""),
            now
          );
        }
        checkAndFakeOccurrenceMeta(meta) {
          const { MODE } = ScheduleMetaChange;
          if (meta.occurrence && meta.mode === MODE.CANCELLED && !meta.calendar) {
            const meeting = megaChat.plugins.meetingsManager.getMeetingOrOccurrenceParent(meta.handle);
            if (meeting) {
              const occurrences = meeting.getOccurrencesById(meta.handle);
              if (occurrences) {
                meta.calendar = {
                  date: new Date(occurrences[0].start).getDate(),
                  month: time2date(Math.floor(occurrences[0].start / 1000), 12)
                };
                meta.timeRules.startTime = Math.floor(occurrences[0].start / 1000);
                meta.timeRules.endTime = Math.floor(occurrences[0].end / 1000);
              }
            }
          }
        }
        render() {
          const { chatRoom, message, mode, contact } = this.props;
          const { meta, messageId } = message;
          const { scheduledMeeting } = chatRoom;
          const { MODE } = ScheduleMetaChange;
          const { link } = this.state;
          if (meta.gone) {
            return null;
          }
          this.checkAndFakeOccurrenceMeta(meta);
          return react0().createElement(
            "div",
            null,
            react0().createElement(
              "div",
              {
                className: "message body",
                "data-id": `id${messageId}`,
                key: messageId
              },
              react0().createElement(_contacts_jsx2__.Avatar, {
                contact: contact.u,
                className: "message avatar-wrapper small-rounded-avatar",
                chatRoom: chatRoom
              }),
              react0().createElement(
                "div",
                {
                  className: "message schedule-message content-area small-info-txt selectable-txt"
                },
                react0().createElement(_contacts_jsx2__.ContactButton, {
                  className: "message",
                  chatRoom: chatRoom,
                  contact: contact,
                  label: react0().createElement(_ui_utils_jsx3__.dy, null, M.getNameByHandle(contact.u))
                }),
                react0().createElement(
                  "div",
                  {
                    className: "message date-time simpletip",
                    "data-simpletip": time2date(this.getTimestamp())
                  },
                  this.getTimestampAsString()
                ),
                react0().createElement(
                  "div",
                  {
                    className: "message text-block"
                  },
                  ScheduleMetaChange.getTitleText(meta),
                  " ",
                  !!d && meta.handle
                ),
                react0().createElement(
                  "div",
                  {
                    className: "message body-block"
                  },
                  (meta.prevTiming || meta.calendar || (meta.topic && meta.onlyTitle) || meta.recurring) &&
                    react0().createElement(
                      "div",
                      {
                        className: "schedule-detail-block"
                      },
                      meta.calendar &&
                        scheduledMeeting &&
                        ((meta.recurring && !scheduledMeeting.recurring) ||
                          (meta.occurrence && meta.mode === MODE.CANCELLED) ||
                          !meta.recurring) &&
                        react0().createElement(
                          "div",
                          {
                            className: "schedule-calendar-icon"
                          },
                          react0().createElement(
                            "div",
                            {
                              className: "schedule-date"
                            },
                            meta.calendar.date
                          ),
                          react0().createElement(
                            "div",
                            {
                              className: "schedule-month"
                            },
                            meta.calendar.month
                          )
                        ),
                      react0().createElement(
                        "div",
                        {
                          className: "schedule-detail-main"
                        },
                        react0().createElement(
                          "div",
                          {
                            className: "schedule-meeting-title"
                          },
                          mode === MODE.CANCELLED
                            ? react0().createElement("s", null, meta.topic || chatRoom.topic)
                            : meta.topic || chatRoom.topic
                        ),
                        this.renderTimingBlock()
                      ),
                      chatRoom.iAmInRoom() &&
                        scheduledMeeting &&
                        mode !== MODE.CANCELLED &&
                        react0().createElement(
                          _ui_buttons_jsx4__.z,
                          {
                            className: "mega-button",
                            onClick: () => this.onAddToCalendar()
                          },
                          react0().createElement(
                            "span",
                            null,
                            mode === MODE.CREATED && !meta.occurrence ? l.schedule_add_calendar : l.schedule_update_calendar
                          )
                        )
                    ),
                  mode === MODE.CREATED &&
                    scheduledMeeting &&
                    scheduledMeeting.description &&
                    react0().createElement(
                      "div",
                      {
                        className: "schedule-description"
                      },
                      react0().createElement(_ui_utils_jsx3__.Cw, null, megaChat.html(scheduledMeeting.description).replace(/\n/g, "<br>"))
                    ),
                  link &&
                    react0().createElement(
                      "div",
                      null,
                      react0().createElement(
                        "div",
                        {
                          className: "schedule-meeting-link"
                        },
                        react0().createElement("span", null, link),
                        react0().createElement(
                          _ui_buttons_jsx4__.z,
                          {
                            className: "mega-button positive",
                            onClick: () => {
                              copyToClipboard(link, l[7654]);
                            }
                          },
                          react0().createElement("span", null, l[63])
                        )
                      ),
                      react0().createElement("span", null, l.schedule_link_note)
                    )
                )
              )
            )
          );
        }
      }
      ScheduleMetaChange.MODE = {
        CREATED: 1,
        EDITED: 2,
        CANCELLED: 3
      };
      window.ScheduleMetaChange = ScheduleMetaChange;

      /***/
    },

    /***/ 480: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        F: () => MetaRichpreviewLoading
      });
      var React = __webpack_require__(363);
      var ConversationMessageMixin = __webpack_require__(416).y;
      class MetaRichpreviewLoading extends ConversationMessageMixin {
        render() {
          return React.createElement(
            "div",
            {
              className: "loading-spinner light small"
            },
            React.createElement("div", {
              className: "main-loader"
            })
          );
        }
      }

      /***/
    },

    /***/ 825: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, {
        j: () => TypingArea
      });

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js
      var applyDecoratedDescriptor = __webpack_require__(229);
      // EXTERNAL MODULE: external "React"
      var external_React_ = __webpack_require__(363);
      var external_React_default = __webpack_require__.n(external_React_);
      // EXTERNAL MODULE: ./js/ui/utils.jsx
      var utils = __webpack_require__(79);
      // EXTERNAL MODULE: ./js/chat/mixins.js
      var mixins = __webpack_require__(503);
      // EXTERNAL MODULE: ./js/ui/emojiDropdown.jsx
      var emojiDropdown = __webpack_require__(768);
      // EXTERNAL MODULE: ./js/ui/buttons.jsx
      var ui_buttons = __webpack_require__(204); // CONCATENATED MODULE: ./js/chat/ui/emojiAutocomplete.jsx
      var React = __webpack_require__(363);

      class EmojiAutocomplete extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            selected: 0
          };
          this.loading = false;
          this.data_emojis = [];
        }
        preload_emojis() {
          if (this.loading === false) {
            this.loading = true;
            megaChat.getEmojiDataSet("emojis").then((emojis) => {
              this.loading = 0;
              this.data_emojis = emojis;
              this.safeForceUpdate();
            });
          }
        }
        unbindKeyEvents() {
          $(document).off("keydown.emojiAutocomplete" + this.getUniqueId());
        }
        bindKeyEvents() {
          var self = this;
          $(document).rebind("keydown.emojiAutocomplete" + self.getUniqueId(), function (e) {
            if (!self.props.emojiSearchQuery) {
              self.unbindKeyEvents();
              return;
            }
            var key = e.keyCode || e.which;
            if (!$(e.target).is("textarea")) {
              console.error("this should never happen.");
              return;
            }
            if (e.altKey || e.metaKey) {
              return;
            }
            var selected = $.isNumeric(self.state.selected) ? self.state.selected : 0;
            if (document.body.classList.contains("rtl") && (key === 37 || key === 39)) {
              key = key === 37 ? 39 : 37;
            }
            var handled = false;
            if (!e.shiftKey && (key === 37 || key === 38)) {
              selected = selected - 1;
              selected = selected < 0 ? self.maxFound - 1 : selected;
              if (self.found[selected] && self.state.selected !== selected) {
                self.setState({
                  selected: selected,
                  prefilled: true
                });
                handled = true;
                self.props.onPrefill(false, ":" + self.found[selected].n + ":");
              }
            } else if (!e.shiftKey && (key === 39 || key === 40 || key === 9)) {
              selected = selected + (key === 9 ? (e.shiftKey ? -1 : 1) : 1);
              selected = selected < 0 ? Object.keys(self.found).length - 1 : selected;
              selected = selected >= self.props.maxEmojis || selected >= Object.keys(self.found).length ? 0 : selected;
              if (self.found[selected] && (key === 9 || self.state.selected !== selected)) {
                self.setState({
                  selected: selected,
                  prefilled: true
                });
                self.props.onPrefill(false, ":" + self.found[selected].n + ":");
                handled = true;
              }
            } else if (key === 13) {
              self.unbindKeyEvents();
              if (selected === -1) {
                if (self.found.length > 0) {
                  for (var i = 0; i < self.found.length; i++) {
                    if (":" + self.found[i].n + ":" === self.props.emojiSearchQuery + ":") {
                      self.props.onSelect(false, ":" + self.found[0].n + ":");
                      handled = true;
                    }
                  }
                }
                if (!handled && key === 13) {
                  self.props.onCancel();
                }
                return;
              } else if (self.found.length > 0 && self.found[selected]) {
                self.props.onSelect(false, ":" + self.found[selected].n + ":");
                handled = true;
              } else {
                self.props.onCancel();
              }
            } else if (key === 27) {
              self.unbindKeyEvents();
              self.props.onCancel();
              handled = true;
            }
            if (handled) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            } else {
              if (self.isMounted()) {
                self.setState({
                  prefilled: false
                });
              }
            }
          });
        }
        componentDidUpdate() {
          if (!this.props.emojiSearchQuery) {
            this.unbindKeyEvents();
          } else {
            this.bindKeyEvents();
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          this.unbindKeyEvents();
        }
        render() {
          var self = this;
          if (!self.props.emojiSearchQuery) {
            return null;
          }
          self.preload_emojis();
          if (self.loading) {
            return React.createElement(
              "div",
              {
                className: "textarea-autofill-bl"
              },
              React.createElement(
                "div",
                {
                  className: "textarea-autofill-info"
                },
                l[5533]
              )
            );
          }
          var q = self.props.emojiSearchQuery.substr(1, self.props.emojiSearchQuery.length);
          var exactMatch = [];
          var partialMatch = [];
          var emojis = self.data_emojis || [];
          for (var i = 0; i < emojis.length; i++) {
            var emoji = emojis[i];
            var match = emoji.n.indexOf(q);
            if (match !== -1) {
              if (match === 0) {
                exactMatch.push(emoji);
              } else if (partialMatch.length < self.props.maxEmojis - exactMatch.length) {
                partialMatch.push(emoji);
              }
            }
            if (exactMatch.length >= self.props.maxEmojis) {
              break;
            }
          }
          exactMatch.sort(function (a, b) {
            if (a.n === q) {
              return -1;
            } else if (b.n === q) {
              return 1;
            } else {
              return 0;
            }
          });
          var found = exactMatch.concat(partialMatch).slice(0, self.props.maxEmojis);
          exactMatch = partialMatch = null;
          this.maxFound = found.length;
          this.found = found;
          if (!found || found.length === 0) {
            queueMicrotask(() => {
              self.props.onCancel();
            });
            return null;
          }
          var emojisDomList = [];
          for (var i = 0; i < found.length; i++) {
            var meta = found[i];
            var filename = twemoji.convert.toCodePoint(meta.u);
            emojisDomList.push(
              React.createElement(
                "div",
                {
                  className: "emoji-preview shadow " + (this.state.selected === i ? "active" : ""),
                  key: meta.n + "_" + (this.state.selected === i ? "selected" : "inselected"),
                  title: ":" + meta.n + ":",
                  onClick: function (e) {
                    self.props.onSelect(e, e.target.title);
                    self.unbindKeyEvents();
                  }
                },
                React.createElement("img", {
                  width: "20",
                  height: "20",
                  className: "emoji emoji-loading",
                  draggable: "false",
                  alt: meta.u,
                  onLoad: (e) => {
                    e.target.classList.remove("emoji-loading");
                  },
                  onError: (e) => {
                    e.target.classList.remove("emoji-loading");
                    e.target.classList.add("emoji-loading-error");
                  },
                  src: staticpath + "images/mega/twemojis/2_v2/72x72/" + filename + ".png"
                }),
                React.createElement(
                  "div",
                  {
                    className: "emoji title"
                  },
                  ":" + meta.n + ":"
                )
              )
            );
          }
          return React.createElement(
            "div",
            {
              className: "textarea-autofill-bl"
            },
            React.createElement(
              utils.Cw,
              {
                tag: "div",
                className: "textarea-autofill-info"
              },
              l.emoji_suggestion_instruction
            ),
            React.createElement(
              "div",
              {
                className: "textarea-autofill-emoji"
              },
              emojisDomList
            )
          );
        }
      }
      EmojiAutocomplete.defaultProps = {
        requiresUpdateOnResize: true,
        emojiSearchQuery: false,
        disableCheckingVisibility: true,
        maxEmojis: 12
      };
      // EXTERNAL MODULE: ./js/chat/ui/gifPanel/gifPanel.jsx + 3 modules
      var gifPanel = __webpack_require__(722);
      // EXTERNAL MODULE: ./js/ui/perfectScrollbar.jsx
      var perfectScrollbar = __webpack_require__(285); // CONCATENATED MODULE: ./js/chat/ui/typingArea.jsx
      var _dec, _class;

      let TypingArea =
        ((_dec = (0, mixins.M9)(54, true)),
        ((_class = class TypingArea extends mixins.wl {
          constructor(props) {
            super(props);
            this.typingAreaRef = external_React_default().createRef();
            this.state = {
              emojiSearchQuery: false,
              typedMessage: "",
              textareaHeight: 20,
              gifPanelActive: false
            };
            this.getTextareaMaxHeight = () => {
              const { containerRef } = this.props;
              if (containerRef && containerRef.current) {
                return this.isMounted() ? containerRef.current.offsetHeight * 0.4 : 100;
              }
              return 100;
            };
            const { chatRoom } = props;
            this.logger = d && MegaLogger.getLogger("TypingArea", {}, (chatRoom && chatRoom.logger) || megaChat.logger);
            this.onEmojiClicked = this.onEmojiClicked.bind(this);
            this.onTypeAreaKeyUp = this.onTypeAreaKeyUp.bind(this);
            this.onTypeAreaKeyDown = this.onTypeAreaKeyDown.bind(this);
            this.onTypeAreaBlur = this.onTypeAreaBlur.bind(this);
            this.onTypeAreaChange = this.onTypeAreaChange.bind(this);
            this.onCopyCapture = this.onCopyCapture.bind(this);
            this.onPasteCapture = this.onPasteCapture.bind(this);
            this.onCutCapture = this.onCutCapture.bind(this);
            this.state.typedMessage = this.props.initialText || "";
          }
          onEmojiClicked(e, slug) {
            if (this.props.disabled) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }
            slug = slug[0] === ":" || slug.substr(-1) === ":" ? slug : `:${slug}:`;
            const textarea = $(".messages-textarea", this.typingAreaRef.current)[0];
            const cursorPosition = this.getCursorPosition(textarea);
            this.setState(
              {
                typedMessage: this.state.typedMessage.slice(0, cursorPosition) + slug + this.state.typedMessage.slice(cursorPosition)
              },
              () => {
                textarea.selectionEnd = cursorPosition + slug.length;
                this.onTypeAreaChange(e, this.state.typedMessage);
              }
            );
          }
          stoppedTyping() {
            if (this.props.disabled || !this.props.chatRoom) {
              return;
            }
            this.iAmTyping = false;
            this.props.chatRoom.trigger("stoppedTyping");
          }
          typing() {
            if (this.props.disabled || !this.props.chatRoom) {
              return;
            }
            var self = this;
            var now = Date.now();
            delay(this.getReactId(), () => self.iAmTyping && self.stoppedTyping(), 4e3);
            if (!self.iAmTyping || now - self.lastTypingStamp > 4e3) {
              self.iAmTyping = true;
              self.lastTypingStamp = now;
              self.props.chatRoom.trigger("typing");
            }
          }
          triggerOnUpdate(forced) {
            var self = this;
            if (!self.props.onUpdate || !self.isMounted()) {
              return;
            }
            var shouldTriggerUpdate = forced ? forced : false;
            if (!shouldTriggerUpdate && self.state.typedMessage !== self.lastTypedMessage) {
              self.lastTypedMessage = self.state.typedMessage;
              shouldTriggerUpdate = true;
            }
            if (!shouldTriggerUpdate) {
              var $textarea = $(".chat-textarea:visible textarea:visible", self.typingAreaRef.current);
              if (!self._lastTextareaHeight || self._lastTextareaHeight !== $textarea.height()) {
                self._lastTextareaHeight = $textarea.height();
                shouldTriggerUpdate = true;
                if (self.props.onResized) {
                  self.props.onResized();
                }
              }
            }
            if (shouldTriggerUpdate) {
              self.props.onUpdate();
            }
          }
          onCancelClicked() {
            var self = this;
            self.setState({
              typedMessage: ""
            });
            if (self.props.chatRoom && self.iAmTyping) {
              self.stoppedTyping();
            }
            self.onConfirmTrigger(false);
            self.triggerOnUpdate();
          }
          onSaveClicked() {
            var self = this;
            if (self.props.disabled || !self.isMounted()) {
              return;
            }
            var val = $.trim($(".chat-textarea:visible textarea:visible", this.typingAreaRef.current).val());
            if (self.onConfirmTrigger(val) !== true) {
              self.setState({
                typedMessage: ""
              });
            }
            if (self.props.chatRoom && self.iAmTyping) {
              self.stoppedTyping();
            }
            self.triggerOnUpdate();
          }
          onConfirmTrigger(val) {
            const { onConfirm, persist, chatRoom } = this.props;
            const result = onConfirm(val);
            if (val !== false && result !== false) {
              $(".textarea-scroll", this.typingAreaRef.current).scrollTop(0);
            }
            if (persist) {
              const { persistedTypeArea } = chatRoom.megaChat.plugins;
              if (persistedTypeArea) {
                if (d > 2) {
                  this.logger.info("Removing persisted-typed value...");
                }
                persistedTypeArea.removePersistedTypedValue(chatRoom);
              }
            }
            return result;
          }
          onTypeAreaKeyDown(e) {
            if (this.props.disabled) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }
            var self = this;
            var key = e.keyCode || e.which;
            var element = e.target;
            var val = $.trim(element.value);
            if (self.state.emojiSearchQuery) {
              return;
            }
            if (key === 13 && !e.shiftKey && !e.ctrlKey && !e.altKey) {
              if (e.isPropagationStopped() || e.isDefaultPrevented()) {
                return;
              }
              if (self.onConfirmTrigger(val) !== true) {
                self.setState({
                  typedMessage: ""
                });
                $(document).trigger("closeDropdowns");
              }
              e.preventDefault();
              e.stopPropagation();
              if (self.props.chatRoom && self.iAmTyping) {
                self.stoppedTyping();
              }
            }
          }
          onTypeAreaKeyUp(e) {
            if (this.props.disabled) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }
            var self = this;
            var key = e.keyCode || e.which;
            var element = e.target;
            var val = $.trim(element.value);
            if (key === 13 && !e.shiftKey && !e.ctrlKey && !e.altKey) {
              e.preventDefault();
              e.stopPropagation();
            } else if (key === 13) {
              if (self.state.emojiSearchQuery) {
                return;
              }
              if (e.altKey) {
                var content = element.value;
                var cursorPos = self.getCursorPosition(element);
                content = content.substring(0, cursorPos) + "\n" + content.substring(cursorPos, content.length);
                self.setState({
                  typedMessage: content
                });
                self.onUpdateCursorPosition = cursorPos + 1;
                e.preventDefault();
              } else if ($.trim(val).length === 0) {
                e.preventDefault();
              }
            } else if (key === 38) {
              if (self.state.emojiSearchQuery) {
                return;
              }
              if ($.trim(val).length === 0) {
                if (self.props.onUpEditPressed && self.props.onUpEditPressed() === true) {
                  e.preventDefault();
                }
              }
            } else if (key === 27) {
              if (self.state.emojiSearchQuery) {
                return;
              }
              if (self.props.showButtons === true) {
                e.preventDefault();
                self.onCancelClicked(e);
              }
            } else {
              if (self.prefillMode && (key === 8 || key === 32 || key === 186 || key === 13)) {
                self.prefillMode = false;
              }
              var currentContent = element.value;
              var currentCursorPos = self.getCursorPosition(element) - 1;
              if (self.prefillMode && (currentCursorPos > self.state.emojiEndPos || currentCursorPos < self.state.emojiStartPos)) {
                self.prefillMode = false;
                self.setState({
                  emojiSearchQuery: false,
                  emojiStartPos: false,
                  emojiEndPos: false
                });
                return;
              }
              if (self.prefillMode) {
                return;
              }
              var char = String.fromCharCode(key);
              if (
                key === 16 ||
                key === 17 ||
                key === 18 ||
                key === 91 ||
                key === 8 ||
                key === 37 ||
                key === 39 ||
                key === 40 ||
                key === 38 ||
                key === 9 ||
                /[\w:-]/.test(char)
              ) {
                var parsedResult = mega.utils.emojiCodeParser(currentContent, currentCursorPos);
                self.setState({
                  emojiSearchQuery: parsedResult[0],
                  emojiStartPos: parsedResult[1],
                  emojiEndPos: parsedResult[2]
                });
                return;
              }
              if (self.state.emojiSearchQuery) {
                self.setState({
                  emojiSearchQuery: false
                });
              }
            }
          }
          onTypeAreaBlur(e) {
            if (this.props.disabled) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }
            var self = this;
            if (self.state.emojiSearchQuery) {
              setTimeout(function () {
                if (self.isMounted()) {
                  self.setState({
                    emojiSearchQuery: false,
                    emojiStartPos: false,
                    emojiEndPos: false
                  });
                }
              }, 300);
            }
          }
          onTypeAreaChange(e, value) {
            if (this.props.disabled) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }
            var self = this;
            value = String(value || e.target.value || "").replace(/^\s+/, "");
            if (self.state.typedMessage !== value) {
              self.setState({
                typedMessage: value
              });
              self.forceUpdate();
            }
            if (value.length) {
              self.typing();
            } else {
              self.stoppedTyping();
            }
            if (this.props.persist) {
              const { chatRoom } = this.props;
              const { megaChat } = chatRoom;
              const { persistedTypeArea } = megaChat.plugins;
              if (persistedTypeArea) {
                if (d > 2) {
                  this.logger.debug("%s persisted-typed value...", value.length ? "Updating" : "Removing");
                }
                if (value.length) {
                  persistedTypeArea.updatePersistedTypedValue(chatRoom, value);
                } else {
                  persistedTypeArea.removePersistedTypedValue(chatRoom);
                }
              }
            }
            self.updateScroll();
          }
          focusTypeArea() {
            if (this.props.disabled) {
              return;
            }
            if (
              $(".chat-textarea:visible textarea:visible", this.typingAreaRef.current).length > 0 &&
              !$(".chat-textarea:visible textarea:visible:first", this.typingAreaRef.current).is(":focus")
            ) {
              moveCursortoToEnd($(".chat-textarea:visible:first textarea", this.typingAreaRef.current)[0]);
            }
          }
          componentDidMount() {
            super.componentDidMount();
            this._lastTextareaHeight = 20;
            this.lastTypedMessage = this.props.initialText || this.lastTypedMessage;
            chatGlobalEventManager.addEventListener("resize", `typingArea${this.getUniqueId()}`, () => this.handleWindowResize());
            this.triggerOnUpdate(true);
            this.updateScroll();
            megaChat.rebind(`viewstateChange.gifpanel${this.getUniqueId()}`, (e) => {
              const { gifPanelActive } = this.state;
              const { state } = e.data;
              if (state === "active" && !gifPanelActive && this.gifResume) {
                this.setState({
                  gifPanelActive: true
                });
                delete this.gifResume;
              } else if (state !== "active" && gifPanelActive && !this.gifResume) {
                this.gifResume = true;
                this.setState({
                  gifPanelActive: false
                });
              }
            });
          }
          componentWillMount() {
            const { chatRoom, initialText, persist } = this.props;
            const { megaChat, roomId } = chatRoom;
            const { persistedTypeArea } = megaChat.plugins;
            if (persist && persistedTypeArea) {
              if (!initialText) {
                persistedTypeArea
                  .getPersistedTypedValue(chatRoom)
                  .then((res) => {
                    if (res && this.isMounted() && !this.state.typedMessage) {
                      this.setState({
                        typedMessage: res
                      });
                    }
                  })
                  .catch((ex) => {
                    if (this.logger && ex !== undefined) {
                      this.logger.warn(`Failed to retrieve persistedTypeArea for ${roomId}: ${ex}`, [ex]);
                    }
                  });
              }
              persistedTypeArea.addChangeListener(this.getUniqueId(), (e, k, v) => {
                if (roomId === k) {
                  this.setState({
                    typedMessage: v || ""
                  });
                  this.triggerOnUpdate(true);
                }
              });
            }
          }
          componentWillUnmount() {
            super.componentWillUnmount();
            var self = this;
            self.triggerOnUpdate();
            if (megaChat.plugins.persistedTypeArea) {
              megaChat.plugins.persistedTypeArea.removeChangeListener(self.getUniqueId());
            }
            chatGlobalEventManager.removeEventListener("resize", "typingArea" + self.getUniqueId());
            megaChat.off(`viewstateChange.gifpanel${this.getUniqueId()}`);
          }
          componentDidUpdate() {
            if (
              this.isComponentEventuallyVisible() &&
              !window.getSelection().toString() &&
              $("textarea:focus,select:focus,input:focus").filter(":visible").length === 0
            ) {
              this.focusTypeArea();
            }
            this.updateScroll();
            if (this.onUpdateCursorPosition) {
              var el = $(".chat-textarea:visible:first textarea:visible", this.typingAreaRef.current)[0];
              el.selectionStart = el.selectionEnd = this.onUpdateCursorPosition;
              this.onUpdateCursorPosition = false;
            }
          }
          updateScroll() {
            if (!this.isComponentEventuallyVisible() || (!this.$node && !this.typingAreaRef && !this.typingAreaRef.current)) {
              return;
            }
            var $node = (this.$node = this.$node || this.typingAreaRef.current);
            const $textarea = (this.$textarea = this.$textarea || $("textarea:first", $node));
            const $scrollBlock = (this.$scrollBlock = this.$scrollBlock || $textarea.closest(".textarea-scroll"));
            const $preview = $(".message-preview", $scrollBlock).safeHTML(`${$textarea.val().replace(/\n/g, "<br />")} <br>`);
            const textareaHeight = $preview.height();
            $scrollBlock.height(Math.min(textareaHeight, this.getTextareaMaxHeight()));
            if (textareaHeight !== this._lastTextareaHeight) {
              this._lastTextareaHeight = textareaHeight;
              this.setState({
                textareaHeight: textareaHeight
              });
              if (this.props.onResized) {
                this.props.onResized();
              }
              $textarea.height(textareaHeight);
            }
            if (this.textareaScroll) {
              this.textareaScroll.reinitialise();
            }
          }
          getCursorPosition(el) {
            var pos = 0;
            if ("selectionStart" in el) {
              pos = el.selectionStart;
            } else if ("selection" in document) {
              el.focus();
              var sel = document.selection.createRange(),
                selLength = document.selection.createRange().text.length;
              sel.moveStart("character", -el.value.length);
              pos = sel.text.length - selLength;
            }
            return pos;
          }
          customIsEventuallyVisible() {
            return this.props.chatRoom.isCurrentlyActive;
          }
          handleWindowResize(e) {
            if (!this.isComponentEventuallyVisible()) {
              return;
            }
            if (e) {
              this.updateScroll();
            }
            this.triggerOnUpdate();
          }
          isActive() {
            return document.hasFocus() && this.$messages && this.$messages.is(":visible");
          }
          resetPrefillMode() {
            this.prefillMode = false;
          }
          onCopyCapture() {
            this.resetPrefillMode();
          }
          onCutCapture() {
            this.resetPrefillMode();
          }
          onPasteCapture() {
            this.resetPrefillMode();
          }
          render() {
            var self = this;
            var room = this.props.chatRoom;
            var buttons = null;
            if (self.props.showButtons === true) {
              buttons = [
                external_React_default().createElement(ui_buttons.z, {
                  key: "save",
                  className: `${"mega-button right"} positive`,
                  label: l[776],
                  onClick: self.onSaveClicked.bind(self)
                }),
                external_React_default().createElement(ui_buttons.z, {
                  key: "cancel",
                  className: "mega-button right",
                  label: l[1718],
                  onClick: self.onCancelClicked.bind(self)
                })
              ];
            }
            var textareaStyles = {
              height: self.state.textareaHeight
            };
            var textareaScrollBlockStyles = {};
            var newHeight = Math.min(self.state.textareaHeight, self.getTextareaMaxHeight());
            if (newHeight > 0) {
              textareaScrollBlockStyles["height"] = newHeight;
            }
            var emojiAutocomplete = null;
            if (self.state.emojiSearchQuery) {
              emojiAutocomplete = external_React_default().createElement(EmojiAutocomplete, {
                emojiSearchQuery: self.state.emojiSearchQuery,
                emojiStartPos: self.state.emojiStartPos,
                emojiEndPos: self.state.emojiEndPos,
                typedMessage: self.state.typedMessage,
                onPrefill: function (e, emojiAlias) {
                  if ($.isNumeric(self.state.emojiStartPos) && $.isNumeric(self.state.emojiEndPos)) {
                    var msg = self.state.typedMessage;
                    var pre = msg.substr(0, self.state.emojiStartPos);
                    var post = msg.substr(self.state.emojiEndPos + 1, msg.length);
                    var startPos = self.state.emojiStartPos;
                    var fwdPos = startPos + emojiAlias.length;
                    var endPos = fwdPos;
                    self.onUpdateCursorPosition = fwdPos;
                    self.prefillMode = true;
                    if (post.substr(0, 2) == "::" && emojiAlias.substr(-1) == ":") {
                      emojiAlias = emojiAlias.substr(0, emojiAlias.length - 1);
                      endPos -= 1;
                    } else {
                      post = post ? (post.substr(0, 1) !== " " ? " " + post : post) : " ";
                      self.onUpdateCursorPosition++;
                    }
                    self.setState({
                      typedMessage: pre + emojiAlias + post,
                      emojiEndPos: endPos
                    });
                  }
                },
                onSelect: function (e, emojiAlias, forceSend) {
                  if ($.isNumeric(self.state.emojiStartPos) && $.isNumeric(self.state.emojiEndPos)) {
                    var msg = self.state.typedMessage;
                    var pre = msg.substr(0, self.state.emojiStartPos);
                    var post = msg.substr(self.state.emojiEndPos + 1, msg.length);
                    if (post.substr(0, 2) == "::" && emojiAlias.substr(-1) == ":") {
                      emojiAlias = emojiAlias.substr(0, emojiAlias.length - 1);
                    } else {
                      post = post ? (post.substr(0, 1) !== " " ? " " + post : post) : " ";
                    }
                    var val = pre + emojiAlias + post;
                    self.prefillMode = false;
                    self.setState({
                      typedMessage: val,
                      emojiSearchQuery: false,
                      emojiStartPos: false,
                      emojiEndPos: false
                    });
                    if (forceSend) {
                      if (self.onConfirmTrigger($.trim(val)) !== true) {
                        self.setState({
                          typedMessage: ""
                        });
                      }
                    }
                  }
                },
                onCancel: function () {
                  self.prefillMode = false;
                  self.setState({
                    emojiSearchQuery: false,
                    emojiStartPos: false,
                    emojiEndPos: false
                  });
                }
              });
            }
            var disabledTextarea = room.pubCu25519KeyIsMissing === true || this.props.disabled ? true : false;
            return external_React_default().createElement(
              "div",
              {
                ref: this.typingAreaRef,
                className: `
                    typingarea-component
                    ${this.props.className}
                `
              },
              this.state.gifPanelActive &&
                external_React_default().createElement(gifPanel.ZP, {
                  chatRoom: this.props.chatRoom,
                  onToggle: () => {
                    this.setState({
                      gifPanelActive: false
                    });
                    delete this.gifResume;
                  }
                }),
              external_React_default().createElement(
                "div",
                {
                  className: `
                        chat-textarea
                        ${this.props.className}
                    `
                },
                emojiAutocomplete,
                self.props.children,
                self.props.editing
                  ? null
                  : external_React_default().createElement(ui_buttons.z, {
                      className: `
                                popup-button
                                gif-button
                                ${this.state.gifPanelActive ? "active" : ""}
                            `,
                      icon: "small-icon gif",
                      disabled: this.props.disabled,
                      onClick: () =>
                        this.setState((state) => {
                          delete this.gifResume;
                          return {
                            gifPanelActive: !state.gifPanelActive
                          };
                        })
                    }),
                external_React_default().createElement(
                  ui_buttons.z,
                  {
                    className: "popup-button emoji-button",
                    icon: "sprite-fm-theme icon-emoji",
                    iconHovered: "sprite-fm-theme icon-emoji-active",
                    disabled: this.props.disabled
                  },
                  external_React_default().createElement(emojiDropdown.l, {
                    className: "popup emoji",
                    vertOffset: 17,
                    onClick: this.onEmojiClicked
                  })
                ),
                external_React_default().createElement("hr", null),
                external_React_default().createElement(
                  perfectScrollbar.F,
                  {
                    chatRoom: self.props.chatRoom,
                    className: "chat-textarea-scroll textarea-scroll",
                    options: {
                      suppressScrollX: true
                    },
                    style: textareaScrollBlockStyles,
                    ref: (ref) => {
                      self.textareaScroll = ref;
                    }
                  },
                  external_React_default().createElement(
                    "div",
                    {
                      className: "messages-textarea-placeholder"
                    },
                    self.state.typedMessage
                      ? null
                      : external_React_default().createElement(
                          utils.dy,
                          null,
                          (l[18763] || `Write message to \u201c%s\u201d\u2026`).replace("%s", room.getRoomTitle())
                        )
                  ),
                  external_React_default().createElement("textarea", {
                    className: `
                                ${"messages-textarea"}
                                ${disabledTextarea ? "disabled" : ""}
                            `,
                    onKeyUp: this.onTypeAreaKeyUp,
                    onKeyDown: this.onTypeAreaKeyDown,
                    onBlur: this.onTypeAreaBlur,
                    onChange: this.onTypeAreaChange,
                    onCopyCapture: this.onCopyCapture,
                    onPasteCapture: this.onPasteCapture,
                    onCutCapture: this.onCutCapture,
                    value: self.state.typedMessage,
                    style: textareaStyles,
                    disabled: disabledTextarea,
                    readOnly: disabledTextarea
                  }),
                  external_React_default().createElement("div", {
                    className: "message-preview"
                  })
                )
              ),
              buttons
            );
          }
        }),
        (0, applyDecoratedDescriptor.Z)(
          _class.prototype,
          "handleWindowResize",
          [_dec],
          Object.getOwnPropertyDescriptor(_class.prototype, "handleWindowResize"),
          _class.prototype
        ),
        _class));

      /***/
    },

    /***/ 204: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        z: () => Button
      });
      var _extends2__ = __webpack_require__(462);
      var react0__ = __webpack_require__(363);
      var react0 = __webpack_require__.n(react0__);
      var _chat_mixins1__ = __webpack_require__(503);

      let _buttonGroups = {};
      class Button extends _chat_mixins1__.wl {
        constructor(props) {
          super(props);
          this.buttonClass = `.button`;
          this.state = {
            focused: false,
            hovered: false,
            iconHovered: ""
          };
          this.onBlur = (e) => {
            if (!this.isMounted()) {
              return;
            }
            if (!e || !$(e.target).closest(this.buttonClass).is(this.findDOMNode())) {
              this.setState(
                {
                  focused: false
                },
                () => {
                  this.unbindEvents();
                  this.safeForceUpdate();
                }
              );
            }
          };
          this.onClick = (e) => {
            if (this.props.disabled === true) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }
            if ($(e.target).closest(".popup").closest(this.buttonClass).is(this.findDOMNode()) && this.state.focused === true) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }
            if ($(e.target).is("input, textarea, select")) {
              return;
            }
            if (this.state.focused === false) {
              if (this.props.onClick) {
                this.props.onClick(this, e);
              } else if (react0().Children.count(this.props.children) > 0) {
                this.setState({
                  focused: true
                });
              }
            } else if (this.state.focused === true) {
              this.setState({
                focused: false
              });
              this.unbindEvents();
            }
          };
          this.state.iconHovered = this.props.iconHovered || "";
        }
        componentWillUpdate(nextProps, nextState) {
          if (nextProps.disabled === true && nextState.focused === true) {
            nextState.focused = false;
          }
          if (this.state.focused !== nextState.focused && nextState.focused === true) {
            $(".conversationsApp, .join-meeting, .main-blur-block").rebind("mousedown.button" + this.getUniqueId(), this.onBlur);
            $(document).rebind("keyup.button" + this.getUniqueId(), (e) => {
              if (this.state.focused === true && e.keyCode === 27) {
                this.onBlur();
              }
            });
            if (this._pageChangeListener) {
              mBroadcaster.removeListener(this._pageChangeListener);
            }
            this._pageChangeListener = mBroadcaster.addListener("pagechange", () => {
              if (this.state.focused === true) {
                this.onBlur();
              }
            });
            $(document).rebind("closeDropdowns." + this.getUniqueId(), () => this.onBlur());
            if (this.props.group) {
              if (_buttonGroups[this.props.group] && _buttonGroups[this.props.group] !== this) {
                _buttonGroups[this.props.group].setState({
                  focused: false
                });
                _buttonGroups[this.props.group].unbindEvents();
              }
              _buttonGroups[this.props.group] = this;
            }
          }
          if (this.props.group && nextState.focused === false && _buttonGroups[this.props.group] === this) {
            _buttonGroups[this.props.group] = null;
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          this.unbindEvents();
        }
        renderChildren() {
          var self = this;
          if (react0().Children.count(self.props.children) < 1) {
            return null;
          }
          return react0().Children.map(
            this.props.children,
            function (child) {
              if (!child) {
                return;
              }
              if (typeof child.type === "string" || typeof child.type === "undefined") {
                return child;
              }
              return react0().cloneElement(child, {
                active: self.state.focused,
                closeDropdown: function () {
                  self.setState({
                    focused: false
                  });
                  self.unbindEvents();
                },
                onActiveChange: function (newVal) {
                  var $element = $(self.findDOMNode());
                  var $scrollables = $element.parents(".ps");
                  if ($scrollables.length > 0) {
                    if (newVal === true) {
                      $scrollables.each((k, element) => {
                        Ps.disable(element);
                      });
                    } else {
                      $scrollables.each((k, element) => {
                        Ps.enable(element);
                      });
                    }
                  }
                  if (child.props.onActiveChange) {
                    child.props.onActiveChange.call(this, newVal);
                  }
                }
              });
            }.bind(this)
          );
        }
        unbindEvents() {
          $(document).off("keyup.button" + this.getUniqueId());
          $(document).off("closeDropdowns." + this.getUniqueId());
          $(".conversationsApp, .join-meeting, .main-blur-block").unbind("mousedown.button" + this.getUniqueId());
          if (this._pageChangeListener) {
            mBroadcaster.removeListener(this._pageChangeListener);
          }
        }
        render() {
          const { className, disabled, style, icon, iconHovered, label, attrs, toggle, secondLabel, secondLabelClass } = this.props;
          const isMegaButton = className && className.indexOf("mega-button") > -1;
          const TagName = isMegaButton ? "button" : "div";
          return react0().createElement(
            TagName,
            (0, _extends2__.Z)(
              {
                className: `
                    button
                    ${className || ""}
                    ${disabled ? "disabled" : ""}
                    ${this.state.focused ? "active active-dropdown" : ""}
                `,
                style: style,
                onClick: this.onClick,
                onMouseEnter: () =>
                  iconHovered &&
                  this.setState({
                    hovered: true
                  }),
                onMouseLeave: () =>
                  iconHovered &&
                  this.setState({
                    hovered: false
                  })
              },
              attrs
            ),
            icon &&
              !isMegaButton &&
              react0().createElement(
                "div",
                null,
                react0().createElement("i", {
                  className: this.state.hovered ? this.state.iconHovered : icon
                })
              ),
            icon &&
              isMegaButton &&
              react0().createElement(
                "div",
                null,
                react0().createElement("i", {
                  className: this.state.hovered ? this.state.iconHovered : icon
                })
              ),
            label && react0().createElement("span", null, label),
            secondLabel &&
              react0().createElement(
                "span",
                {
                  className: secondLabelClass ? secondLabelClass : ""
                },
                secondLabel
              ),
            toggle &&
              react0().createElement(
                "div",
                {
                  className: `
                            mega-switch
                            ${toggle.className ? toggle.className : ""}
                            ${toggle.enabled ? "toggle-on" : ""}
                        `,
                  role: "switch",
                  "aria-checked": !!toggle.enabled,
                  onClick: (ev) => {
                    ev.stopPropagation();
                    if (this.props.toggle.onClick) {
                      this.props.toggle.onClick();
                    }
                  }
                },
                react0().createElement("div", {
                  className: `mega-feature-switch sprite-fm-mono-after
                                ${toggle.enabled ? "icon-check-after" : "icon-minimise-after"}`
                })
              ),
            this.renderChildren()
          );
        }
      }

      /***/
    },

    /***/ 78: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        Dropdown: () => Dropdown,
        DropdownContactsSelector: () => DropdownContactsSelector,
        DropdownItem: () => DropdownItem
      });
      var _utils_jsx0__ = __webpack_require__(79);
      var _chat_mixins1__ = __webpack_require__(503);
      var _chat_ui_contacts_jsx2__ = __webpack_require__(13);
      var React = __webpack_require__(363);

      class Dropdown extends _chat_mixins1__.wl {
        constructor(props) {
          super(props);
          this.onActiveChange = this.onActiveChange.bind(this);
          this.onResized = this.onResized.bind(this);
        }
        componentWillUpdate(nextProps) {
          if (this.props.active != nextProps.active) {
            this.onActiveChange(nextProps.active);
          }
        }
        specShouldComponentUpdate(nextProps, nextState) {
          if (this.props.active != nextProps.active) {
            if (this.props.onBeforeActiveChange) {
              this.props.onBeforeActiveChange(nextProps.active);
            }
            return true;
          } else if (this.props.focused != nextProps.focused) {
            return true;
          } else if (this.state && this.state.active != nextState.active) {
            return true;
          }
          return undefined;
        }
        onActiveChange(newVal) {
          if (this.props.onActiveChange) {
            this.props.onActiveChange(newVal);
          }
        }
        reposElementUsing(element, obj, info) {
          var $element;
          if (this.popupElement) {
            $element = $(this.popupElement);
          } else {
            return;
          }
          var self = this;
          var vertOffset = 0;
          var horizOffset = 0;
          if (!self.props.noArrow) {
            var $arrow = $(".dropdown-white-arrow", $element);
            var arrowHeight;
            if (self.props.arrowHeight) {
              arrowHeight = self.props.arrowHeight;
              if (info.vertical === "top") {
                arrowHeight = 0;
              } else {
                arrowHeight *= -1;
              }
            } else {
              arrowHeight = $arrow.outerHeight();
            }
            if (info.vertical === "top") {
              $(element).removeClass("down-arrow").addClass("up-arrow");
            } else {
              $(element).removeClass("up-arrow").addClass("down-arrow");
            }
            vertOffset += info.vertical === "top" ? arrowHeight : 0;
          }
          if (self.props.vertOffset) {
            vertOffset += self.props.vertOffset * (info.vertical === "top" ? 1 : -1);
          }
          if (self.props.horizOffset) {
            horizOffset += self.props.horizOffset;
          }
          $(element).css({
            left: obj.left + 0 + horizOffset + "px",
            top: obj.top + vertOffset + "px"
          });
          if (this.props.positionLeft) {
            $(element).css({
              left: this.props.positionLeft
            });
          }
        }
        onResized() {
          var self = this;
          if (this.props.active === true && this.popupElement) {
            var $element = $(this.popupElement);
            var $positionToElement = $(".button.active-dropdown:visible");
            if ($positionToElement.length === 0) {
              return;
            }
            var $container = $positionToElement.closest(".messages.scroll-area");
            if ($container.length === 0) {
              $container = $(document.body);
            }
            $element.css("margin-left", "");
            $element.position({
              of: $positionToElement,
              my: self.props.positionMy ? self.props.positionMy : "center top",
              at: self.props.positionAt ? self.props.positionAt : "center bottom",
              collision: this.props.collision || "flipfit",
              within: $container,
              using: function (obj, info) {
                self.reposElementUsing(this, obj, info);
              }
            });
          }
        }
        componentDidMount() {
          super.componentDidMount();
          chatGlobalEventManager.addEventListener("resize", "drpdwn" + this.getUniqueId(), this.onResized.bind(this));
          this.onResized();
          var self = this;
          $(document.body).rebind("closeAllDropdownsExcept.drpdwn" + this.getUniqueId(), function (e, target) {
            if (self.props.active && target !== self) {
              if (self.props && self.props.closeDropdown) {
                self.props.closeDropdown();
              }
            }
          });
        }
        componentDidUpdate() {
          this.onResized();
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          $(document.body).unbind("closeAllDropdownsExcept.drpdwn" + this.getUniqueId());
          if (this.props.active) {
            this.onActiveChange(false);
          }
          chatGlobalEventManager.removeEventListener("resize", "drpdwn" + this.getUniqueId());
        }
        doRerender() {
          var self = this;
          setTimeout(function () {
            self.safeForceUpdate();
          }, 100);
          setTimeout(function () {
            self.onResized();
          }, 200);
        }
        renderChildren() {
          var self = this;
          return React.Children.map(this.props.children, function (child) {
            if (child) {
              var activeVal = self.props.active || self.state.active;
              activeVal = String(activeVal);
              return React.cloneElement(child, {
                active: activeVal
              });
            }
            return null;
          });
        }
        render() {
          if (this.props.active !== true) {
            return null;
          }
          var classes = "dropdown body " + (this.props.noArrow ? "" : "dropdown-arrow up-arrow") + " " + this.props.className;
          var styles;
          if (this.popupElement) {
            styles = {
              zIndex: 123,
              position: "absolute",
              width: this.props.styles ? this.props.styles.width : undefined
            };
          }
          var self = this;
          var child = null;
          if (this.props.children) {
            child = React.createElement("div", null, self.renderChildren());
          } else if (this.props.dropdownItemGenerator) {
            child = this.props.dropdownItemGenerator(this);
          }
          if (!child && !this.props.forceShowWhenEmpty) {
            if (this.props.active !== false) {
              queueMicrotask(function () {
                self.onActiveChange(false);
              });
            }
            return null;
          }
          return React.createElement(
            _utils_jsx0__.ZP.RenderTo,
            {
              element: document.body,
              className: classes,
              style: styles,
              popupDidMount: (popupElement) => {
                self.popupElement = popupElement;
                self.onResized();
              },
              popupWillUnmount: () => {
                delete self.popupElement;
              }
            },
            React.createElement(
              "div",
              {
                onClick: function () {
                  $(document.body).trigger("closeAllDropdownsExcept", self);
                }
              },
              this.props.noArrow
                ? null
                : React.createElement("i", {
                    className: "dropdown-white-arrow"
                  }),
              child
            )
          );
        }
      }
      Dropdown.defaultProps = {
        requiresUpdateOnResize: true
      };
      class DropdownContactsSelector extends _chat_mixins1__.wl {
        constructor(props) {
          super(props);
          this.state = {
            selected: this.props.selected ? this.props.selected : []
          };
          this.onSelectClicked = this.onSelectClicked.bind(this);
          this.onSelected = this.onSelected.bind(this);
        }
        specShouldComponentUpdate(nextProps, nextState) {
          if (this.props.active != nextProps.active) {
            return true;
          } else if (this.props.focused != nextProps.focused) {
            return true;
          } else if (this.state && this.state.active != nextState.active) {
            return true;
          } else if (this.state && JSON.stringify(this.state.selected) != JSON.stringify(nextState.selected)) {
            return true;
          } else {
            return undefined;
          }
        }
        onSelected(nodes) {
          this.setState({
            selected: nodes
          });
          if (this.props.onSelected) {
            this.props.onSelected(nodes);
          }
          this.forceUpdate();
        }
        onSelectClicked() {
          this.props.onSelectClicked();
        }
        render() {
          var self = this;
          return React.createElement(
            Dropdown,
            {
              className: "popup contacts-search " + this.props.className + " tooltip-blur",
              active: this.props.active,
              closeDropdown: this.props.closeDropdown,
              ref: function (r) {
                self.dropdownRef = r;
              },
              positionMy: this.props.positionMy,
              positionAt: this.props.positionAt,
              arrowHeight: this.props.arrowHeight,
              horizOffset: this.props.horizOffset,
              vertOffset: this.props.vertOffset,
              noArrow: true
            },
            React.createElement(_chat_ui_contacts_jsx2__.ContactPickerWidget, {
              onClose: this.props.closeDropdown,
              onEventuallyUpdated: () => {
                var _self$dropdownRef;
                (_self$dropdownRef = self.dropdownRef) == null || _self$dropdownRef.doRerender();
              },
              active: this.props.active,
              className: "popup contacts-search tooltip-blur small-footer",
              contacts: M.u,
              selectFooter: this.props.selectFooter,
              megaChat: this.props.megaChat,
              exclude: this.props.exclude,
              allowEmpty: this.props.allowEmpty,
              multiple: this.props.multiple,
              topButtons: this.props.topButtons,
              showAddContact: this.props.showAddContact,
              onSelectDone: this.props.onSelectDone,
              multipleSelectedButtonLabel: this.props.multipleSelectedButtonLabel,
              singleSelectedButtonLabel: this.props.singleSelectedButtonLabel,
              nothingSelectedButtonLabel: this.props.nothingSelectedButtonLabel
            })
          );
        }
      }
      DropdownContactsSelector.defaultProps = {
        requiresUpdateOnResize: true
      };
      class DropdownItem extends _chat_mixins1__.wl {
        constructor(props) {
          super(props);
          this.state = {
            isClicked: false
          };
          this.onClick = this.onClick.bind(this);
          this.onMouseOver = this.onMouseOver.bind(this);
        }
        renderChildren() {
          var self = this;
          return React.Children.map(this.props.children, function (child) {
            var props = {
              active: self.state.isClicked,
              closeDropdown: function () {
                self.setState({
                  isClicked: false
                });
              }
            };
            return React.cloneElement(child, props);
          });
        }
        onClick(ev) {
          const { children, persistent, onClick } = this.props;
          if (children) {
            ev.stopPropagation();
            ev.preventDefault();
            this.setState({
              isClicked: !this.state.isClicked
            });
          }
          if (!persistent) {
            $(document).trigger("closeDropdowns");
          }
          return onClick && onClick(ev);
        }
        onMouseOver(e) {
          if (this.props.submenu) {
            var $contextItem = $(e.target).closest(".contains-submenu");
            var $subMenu = $contextItem.next(".submenu");
            var contextTopPos = $contextItem.position().top;
            var contextleftPos = 0;
            $contextItem.addClass("opened");
            $subMenu.addClass("active");
            contextleftPos = $contextItem.offset().left + $contextItem.outerWidth() + $subMenu.outerWidth() + 10;
            if (contextleftPos > $(document.body).width()) {
              $subMenu.addClass("left-position");
            }
            $subMenu.css({
              top: contextTopPos
            });
          } else if (!$(e.target).parent(".submenu").length) {
            var $dropdown = $(e.target).closest(".dropdown.body");
            $dropdown.find(".contains-submenu").removeClass("opened");
            $dropdown.find(".submenu").removeClass("active");
          }
        }
        render() {
          const { className, disabled, label, icon, submenu } = this.props;
          return React.createElement(
            "div",
            {
              className: `
                    dropdown-item
                    ${className ? className : ""}
                    ${submenu ? "contains-submenu" : ""}
                    ${disabled ? "disabled" : ""}
                `,
              onClick: disabled ? undefined : (ev) => this.onClick(ev),
              onMouseOver: this.onMouseOver
            },
            icon &&
              React.createElement("i", {
                className: icon
              }),
            label && React.createElement("span", null, label),
            submenu
              ? React.createElement("i", {
                  className: "sprite-fm-mono icon-arrow-right submenu-icon"
                })
              : "",
            React.createElement("div", null, this.renderChildren())
          );
        }
      }
      DropdownItem.defaultProps = {
        requiresUpdateOnResize: true
      };

      /***/
    },

    /***/ 768: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        l: () => DropdownEmojiSelector
      });
      var _extends1__ = __webpack_require__(462);
      var _chat_mixins0__ = __webpack_require__(503);

      var React = __webpack_require__(363);

      var DropdownsUI = __webpack_require__(78);
      var PerfectScrollbar = __webpack_require__(285).F;
      class DropdownEmojiSelector extends _chat_mixins0__.wl {
        constructor(props) {
          super(props);
          this.emojiSearchField = React.createRef();
          this.data_categories = null;
          this.data_emojis = null;
          this.data_emojiByCategory = null;
          this.customCategoriesOrder = ["frequently_used", "people", "nature", "food", "activity", "travel", "objects", "symbols", "flags"];
          this.frequentlyUsedEmojis = [
            "slight_smile",
            "grinning",
            "smile",
            "rofl",
            "wink",
            "yum",
            "rolling_eyes",
            "stuck_out_tongue",
            "smiling_face_with_3_hearts",
            "heart_eyes",
            "kissing_heart",
            "sob",
            "pleading_face",
            "thumbsup",
            "pray",
            "wave",
            "fire",
            "sparkles"
          ];
          this.heightDefs = {
            categoryTitleHeight: 55,
            emojiRowHeight: 35,
            containerHeight: 302,
            totalScrollHeight: 302,
            numberOfEmojisPerRow: 9
          };
          this.categoryLabels = {
            frequently_used: l[17737],
            people: l[8016],
            objects: l[17735],
            activity: l[8020],
            nature: l[8017],
            travel: l[8021],
            symbols: l[17736],
            food: l[8018],
            flags: l[17703]
          };
          this.state = this.getInitialState();
          this.onSearchChange = this.onSearchChange.bind(this);
          this.onUserScroll = this.onUserScroll.bind(this);
          this._onScrollChanged = this._onScrollChanged.bind(this);
        }
        getInitialState() {
          return clone({
            previewEmoji: null,
            searchValue: "",
            browsingCategory: false,
            isActive: false,
            isLoading: true,
            loadFailed: false,
            visibleCategories: "0"
          });
        }
        _generateEmoji(meta) {
          var filename = twemoji.convert.toCodePoint(meta.u);
          return React.createElement("img", {
            width: "20",
            height: "20",
            className: "emoji emoji-loading",
            draggable: "false",
            alt: meta.u,
            title: ":" + meta.n + ":",
            onLoad: (e) => {
              e.target.classList.remove("emoji-loading");
            },
            onError: (e) => {
              e.target.classList.remove("emoji-loading");
              e.target.classList.add("emoji-loading-error");
            },
            src: staticpath + "images/mega/twemojis/2_v2/72x72/" + filename + ".png"
          });
        }
        _generateEmojiElement(emoji, cat) {
          var self = this;
          var categoryName = self.data_categories[cat];
          return React.createElement(
            "div",
            {
              "data-emoji": emoji.n,
              className: "button square-button emoji",
              key: categoryName + "_" + emoji.n,
              onMouseEnter: (e) => {
                if (self.mouseEnterTimer) {
                  clearTimeout(self.mouseEnterTimer);
                }
                e.stopPropagation();
                e.preventDefault();
                self.mouseEnterTimer = setTimeout(function () {
                  self.setState({
                    previewEmoji: emoji
                  });
                }, 250);
              },
              onMouseLeave: (e) => {
                if (self.mouseEnterTimer) {
                  clearTimeout(self.mouseEnterTimer);
                }
                e.stopPropagation();
                e.preventDefault();
                self.setState({
                  previewEmoji: null
                });
              },
              onClick: (e) => {
                if (self.props.onClick) {
                  self.props.onClick(e, emoji.n, emoji);
                  $(document).trigger("closeDropdowns");
                }
              }
            },
            self._generateEmoji(emoji)
          );
        }
        componentWillUpdate(nextProps, nextState) {
          if (nextState.searchValue !== this.state.searchValue || nextState.browsingCategories !== this.state.browsingCategories) {
            this._cachedNodes = {};
            if (this.scrollableArea) {
              this.scrollableArea.scrollToY(0);
            }
            this._onScrollChanged(0, nextState);
          }
          if (nextState.isActive === true) {
            var self = this;
            if (nextState.isLoading === true || (!self.loadingPromise && (!self.data_categories || !self.data_emojis))) {
              const p = [megaChat.getEmojiDataSet("categories"), megaChat.getEmojiDataSet("emojis")];
              this.loadingPromise = Promise.all(p)
                .then(([categories, emojis]) => {
                  this.data_emojis = emojis;
                  this.data_categories = categories;
                  self.data_categories.push("frequently_used");
                  self.data_categoriesWithCustomOrder = [];
                  self.customCategoriesOrder.forEach(function (catName) {
                    self.data_categoriesWithCustomOrder.push(self.data_categories.indexOf(catName));
                  });
                  self.data_emojiByCategory = {};
                  var frequentlyUsedEmojisMeta = {};
                  self.data_emojis.forEach(function (emoji) {
                    var cat = emoji.c;
                    if (!self.data_emojiByCategory[cat]) {
                      self.data_emojiByCategory[cat] = [];
                    }
                    if (self.frequentlyUsedEmojis.indexOf(emoji.n) > -1) {
                      frequentlyUsedEmojisMeta[emoji.n] = emoji.u;
                    }
                    emoji.element = self._generateEmojiElement(emoji, cat);
                    self.data_emojiByCategory[cat].push(emoji);
                  });
                  self.data_emojiByCategory[8] = [];
                  self.frequentlyUsedEmojis.forEach(function (slug) {
                    var emoji = {
                      n: slug,
                      u: frequentlyUsedEmojisMeta[slug]
                    };
                    emoji.element = self._generateEmojiElement(emoji, 99);
                    self.data_emojiByCategory[8].push(emoji);
                  });
                  self._onScrollChanged(0);
                  self.setState({
                    isLoading: false
                  });
                })
                .catch((ex) => {
                  if (d) {
                    console.error("Emoji loading failed.", ex);
                  }
                  this.setState({
                    loadFailed: true,
                    isLoading: false
                  });
                });
            }
          } else if (nextState.isActive === false) {
            if (this.data_emojis) {
              for (let i = this.data_emojis.length; i--; ) {
                delete this.data_emojis[i].element;
              }
            }
            this.data_emojis = null;
            this.data_categories = null;
            this.data_emojiByCategory = null;
            this.loadingPromise = null;
          }
        }
        onSearchChange(e) {
          var self = this;
          self.setState({
            searchValue: e.target.value,
            browsingCategory: false
          });
        }
        onUserScroll($ps) {
          if (this.state.browsingCategory) {
            var $cat = $('.emoji-category-container[data-category-name="' + this.state.browsingCategory + '"]');
            if (!elementInViewport($cat)) {
              this.setState({
                browsingCategory: false
              });
            }
          }
          this._onScrollChanged($ps.getScrollPositionY());
        }
        generateEmojiElementsByCategory(categoryId, posTop, stateObj) {
          var self = this;
          if (!self._cachedNodes) {
            self._cachedNodes = {};
          }
          if (!stateObj) {
            stateObj = self.state;
          }
          if (typeof self._cachedNodes[categoryId] !== "undefined") {
            return self._cachedNodes[categoryId];
          }
          var categoryName = self.data_categories[categoryId];
          var emojis = [];
          var searchValue = stateObj.searchValue;
          var totalEmojis = 0;
          self.data_emojiByCategory[categoryId].forEach(function (meta) {
            var slug = meta.n;
            if (searchValue.length > 0) {
              if ((":" + slug + ":").toLowerCase().indexOf(searchValue.toLowerCase()) < 0) {
                return;
              }
            }
            totalEmojis++;
            emojis.push(meta.element);
          });
          if (emojis.length > 0) {
            var totalHeight =
              self.heightDefs.categoryTitleHeight +
              Math.ceil(totalEmojis / self.heightDefs.numberOfEmojisPerRow) * self.heightDefs.emojiRowHeight;
            return (self._cachedNodes[categoryId] = [
              totalHeight,
              React.createElement(
                "div",
                {
                  key: categoryName,
                  "data-category-name": categoryName,
                  className: "emoji-category-container",
                  style: {
                    position: "absolute",
                    top: posTop
                  }
                },
                emojis.length > 0
                  ? React.createElement("div", {
                      className: "clear"
                    })
                  : null,
                React.createElement(
                  "div",
                  {
                    className: "emoji-type-txt"
                  },
                  self.categoryLabels[categoryName] ? self.categoryLabels[categoryName] : categoryName
                ),
                React.createElement("div", {
                  className: "clear"
                }),
                emojis,
                React.createElement("div", {
                  className: "clear"
                })
              )
            ]);
          } else {
            return (self._cachedNodes[categoryId] = undefined);
          }
        }
        _isVisible(scrollTop, scrollBottom, elTop, elBottom) {
          var visibleTop = elTop < scrollTop ? scrollTop : elTop;
          var visibleBottom = elBottom > scrollBottom ? scrollBottom : elBottom;
          return visibleBottom - visibleTop > 0;
        }
        _onScrollChanged(scrollPositionY, stateObj) {
          var self = this;
          if (!self.data_categoriesWithCustomOrder) {
            return;
          }
          if (scrollPositionY === false) {
            scrollPositionY = self.scrollableArea.getScrollPositionY();
          }
          if (!stateObj) {
            stateObj = self.state;
          }
          var visibleStart = scrollPositionY;
          var visibleEnd = visibleStart + self.heightDefs.containerHeight;
          var currentPos = 0;
          var visibleCategories = [];
          self._emojiReactElements = [];
          self.data_categoryPositions = {};
          self.data_categoriesWithCustomOrder.forEach(function (k) {
            var categoryDivMeta = self.generateEmojiElementsByCategory(k, currentPos, stateObj);
            if (categoryDivMeta) {
              var startPos = currentPos;
              currentPos += categoryDivMeta[0];
              var endPos = currentPos;
              self.data_categoryPositions[k] = startPos;
              if (self._isVisible(visibleStart, visibleEnd, startPos, endPos)) {
                visibleCategories.push(k);
                self._emojiReactElements.push(categoryDivMeta[1]);
              }
            }
          });
          if (self._emojiReactElements.length === 0) {
            const emojisNotFound = React.createElement(
              "span",
              {
                className: "emojis-not-found",
                key: "emojis-not-found"
              },
              l[20920]
            );
            self._emojiReactElements.push(emojisNotFound);
          }
          visibleCategories = visibleCategories.join(",");
          self.setState({
            totalScrollHeight: currentPos,
            visibleCategories: visibleCategories
          });
        }
        _renderEmojiPickerPopup() {
          var self = this;
          var preview;
          if (self.state.previewEmoji) {
            var meta = self.state.previewEmoji;
            preview = React.createElement(
              "div",
              {
                className: "emoji-preview"
              },
              self._generateEmoji(meta),
              React.createElement(
                "div",
                {
                  className: "emoji title"
                },
                ":" + meta.n + ":"
              )
            );
          }
          var categoryIcons = {
            frequently_used: "icon-emoji-type-frequent",
            people: "icon-emoji-type-people",
            nature: "icon-emoji-type-nature",
            food: "icon-emoji-type-food",
            activity: "icon-emoji-type-activity",
            travel: "icon-emoji-type-travel",
            objects: "icon-emoji-type-objects",
            symbols: "icon-emoji-type-symbol",
            flags: "icon-emoji-type-flag"
          };
          var categoryButtons = [];
          var activeCategoryName = false;
          if (!self.state.searchValue) {
            var firstActive = self.state.visibleCategories.split(",")[0];
            if (firstActive) {
              activeCategoryName = self.data_categories[firstActive];
            }
          }
          self.customCategoriesOrder.forEach((categoryName) => {
            categoryButtons.push(
              React.createElement(
                "div",
                {
                  visiblecategories: this.state.visibleCategories,
                  className: `
                        button square-button emoji
                        ${activeCategoryName === categoryName ? "active" : ""}
                    `,
                  key: categoryIcons[categoryName],
                  onClick: (e) => {
                    var _this$emojiSearchFiel;
                    e.stopPropagation();
                    e.preventDefault();
                    this.setState({
                      browsingCategory: categoryName,
                      searchValue: ""
                    });
                    this._cachedNodes = {};
                    const categoryPosition = this.data_categoryPositions[this.data_categories.indexOf(categoryName)] + 10;
                    this.scrollableArea.scrollToY(categoryPosition);
                    this._onScrollChanged(categoryPosition);
                    (_this$emojiSearchFiel = this.emojiSearchField) == null || _this$emojiSearchFiel.current.focus();
                  }
                },
                React.createElement("i", {
                  className: `sprite-fm-mono ${categoryIcons[categoryName]}`
                })
              )
            );
          });
          return React.createElement(
            React.Fragment,
            null,
            React.createElement(
              "div",
              {
                className: "popup-header emoji"
              },
              preview ||
                React.createElement(
                  "div",
                  {
                    className: "search-block emoji"
                  },
                  React.createElement("i", {
                    className: "sprite-fm-mono icon-preview-reveal"
                  }),
                  React.createElement("input", {
                    ref: this.emojiSearchField,
                    type: "search",
                    placeholder: l[102],
                    onChange: this.onSearchChange,
                    autoFocus: true,
                    value: this.state.searchValue
                  })
                )
            ),
            React.createElement(
              PerfectScrollbar,
              {
                className: "popup-scroll-area emoji perfectScrollbarContainer",
                searchValue: this.state.searchValue,
                onUserScroll: this.onUserScroll,
                visibleCategories: this.state.visibleCategories,
                ref: (ref) => {
                  this.scrollableArea = ref;
                }
              },
              React.createElement(
                "div",
                {
                  className: "popup-scroll-content emoji"
                },
                React.createElement(
                  "div",
                  {
                    style: {
                      height: this.state.totalScrollHeight
                    }
                  },
                  this._emojiReactElements
                )
              )
            ),
            React.createElement(
              "div",
              {
                className: "popup-footer emoji"
              },
              categoryButtons
            )
          );
        }
        render() {
          var self = this;
          var popupContents = null;
          if (self.state.isActive === true) {
            if (self.state.loadFailed === true) {
              popupContents = React.createElement(
                "div",
                {
                  className: "loading"
                },
                l[1514]
              );
            } else if (self.state.isLoading === true && !self.data_emojiByCategory) {
              popupContents = React.createElement(
                "div",
                {
                  className: "loading"
                },
                l[5533]
              );
            } else {
              popupContents = self._renderEmojiPickerPopup();
            }
          } else {
            popupContents = null;
          }
          return React.createElement(
            DropdownsUI.Dropdown,
            (0, _extends1__.Z)(
              {
                className: "popup emoji"
              },
              self.props,
              {
                ref: "dropdown",
                isLoading: self.state.isLoading,
                loadFailed: self.state.loadFailed,
                visibleCategories: this.state.visibleCategories,
                forceShowWhenEmpty: true,
                onActiveChange: (newValue) => {
                  if (newValue === false) {
                    self.setState(self.getInitialState());
                    self._cachedNodes = {};
                    self._onScrollChanged(0);
                  } else {
                    self.setState({
                      isActive: true
                    });
                  }
                  if (self.props.onActiveChange) {
                    self.props.onActiveChange(newValue);
                  }
                },
                searchValue: self.state.searchValue,
                browsingCategory: self.state.browsingCategory,
                previewEmoji: self.state.previewEmoji
              }
            ),
            popupContents
          );
        }
      }
      DropdownEmojiSelector.defaultProps = {
        requiresUpdateOnResize: true,
        hideable: true
      };

      /***/
    },

    /***/ 309: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, {
        Z: () => FMView
      });

      // EXTERNAL MODULE: external "React"
      var external_React_ = __webpack_require__(363);
      var external_React_default = __webpack_require__.n(external_React_);
      // EXTERNAL MODULE: ./js/chat/mixins.js
      var mixins = __webpack_require__(503);
      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
      var esm_extends = __webpack_require__(462);
      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js
      var applyDecoratedDescriptor = __webpack_require__(229);
      // EXTERNAL MODULE: ./js/ui/perfectScrollbar.jsx
      var perfectScrollbar = __webpack_require__(285); // CONCATENATED MODULE: ./js/ui/jsx/megaList/megaList2.jsx
      var _dec, _class;

      let MegaList2 =
        ((_dec = (0, mixins.M9)(30, true)),
        ((_class = class MegaList2 extends mixins.wl {
          constructor(props) {
            super(props);
            this._calculated = false;
            this._firstRender = true;
            this.customIsEventuallyVisible = true;
            this.requiresUpdateOnResize = true;
            this.adapterChangedDoRepaint = false;
            assert(props.listAdapter, "missing `listAdapter` for MegaList2");
            assert(props.nodeAdapter, "missing `nodeAdapter` for MegaList2");
            assert(props.entries, "missing `entries` for MegaList2");
            this.options = {
              extraRows: 8,
              batchPages: 0,
              perfectScrollOptions: {
                handlers: ["click-rail", "drag-scrollbar", "wheel", "touch"],
                minScrollbarLength: 20
              }
            };
            this.onPsUserScroll = this.onPsUserScroll.bind(this);
            this.thumbsLoadingHandlers = new MapSet();
            this.thumbsThatRequireLoading = new MapSet();
            this.requestThumbnailCb = this.requestThumbnailCb.bind(this);
          }
          specShouldComponentUpdate(nextProps) {
            let invalidate = false;
            if (
              nextProps.listAdapter.prototype.constructor.name !== this.props.listAdapter.prototype.constructor.name ||
              nextProps.entries !== this.props.entries ||
              nextProps.viewMode !== this.props.viewMode
            ) {
              invalidate = true;
            }
            if (nextProps.sortBy !== this.props.sortBy || nextProps.currentlyViewedEntry !== this.props.currentlyViewedEntry) {
              invalidate = true;
              this.ps.scrollToY(0);
            }
            if (invalidate) {
              this._calculated = false;
              this.adapterChangedDoRepaint = true;
              return true;
            }
            return null;
          }
          _recalculate() {
            if (this._calculated) {
              return this._calculated;
            }
            var calculated = (this._calculated = Object.create(null));
            lazy(calculated, "scrollWidth", () => {
              return this.ps.getClientWidth();
            });
            lazy(calculated, "scrollHeight", () => this.ps.getClientHeight() - calculated.headerHeight);
            lazy(calculated, "itemWidth", () => {
              if (this.props.listAdapter.itemWidth === false) {
                return calculated.scrollWidth;
              }
              return this.props.listAdapter.itemWidth;
            });
            lazy(calculated, "itemHeight", () => {
              return this.props.itemHeight || this.props.listAdapter.itemHeight;
            });
            lazy(calculated, "headerHeight", () => this.props.headerHeight || 0);
            lazy(calculated, "contentWidth", () => {
              var contentWidth = this.ps.getContentWidth();
              if (contentWidth) {
                return contentWidth;
              }
              return calculated.itemWidth;
            });
            lazy(calculated, "itemsPerRow", () => {
              if (this.props.listAdapter.itemsPerRow) {
                return this.props.listAdapter.itemsPerRow;
              }
              return Math.max(1, Math.floor(calculated.contentWidth / calculated.itemWidth));
            });
            lazy(calculated, "contentHeight", () => {
              return Math.ceil(this.props.entries.length / calculated.itemsPerRow) * calculated.itemHeight;
            });
            lazy(calculated, "scrollLeft", () => {
              return this.ps.getScrollPositionX();
            });
            lazy(calculated, "scrollTop", () => {
              if (this.adapterChangedDoRepaint) {
                return 0;
              }
              return this.ps.getScrollPositionY();
            });
            lazy(calculated, "scrolledPercentX", () => {
              return (100 / calculated.scrollWidth) * calculated.scrollLeft;
            });
            lazy(calculated, "scrolledPercentY", () => {
              return (100 / calculated.scrollHeight) * calculated.scrollTop;
            });
            lazy(calculated, "isAtTop", () => {
              return calculated.scrollTop === 0;
            });
            lazy(calculated, "isAtBottom", () => {
              return calculated.scrollTop === calculated.scrollHeight;
            });
            lazy(calculated, "itemsPerPage", () => {
              return Math.ceil(calculated.scrollHeight / calculated.itemHeight) * calculated.itemsPerRow;
            });
            lazy(calculated, "visibleFirstItemNum", () => {
              var value = 0;
              value = Math.floor(Math.floor(calculated.scrollTop / calculated.itemHeight) * calculated.itemsPerRow);
              if (value > 0) {
                value = Math.max(0, value - this.options.extraRows * calculated.itemsPerRow);
              }
              return value;
            });
            lazy(calculated, "visibleLastItemNum", () => {
              var value = Math.min(
                this.props.entries.length,
                Math.ceil(Math.ceil(calculated.scrollTop / calculated.itemHeight) * calculated.itemsPerRow + calculated.itemsPerPage)
              );
              if (value < this.props.entries.length) {
                value = Math.min(this.props.entries.length, value + this.options.extraRows * calculated.itemsPerRow);
              }
              return value;
            });
            if (this.options.batchPages > 0) {
              var perPage = calculated.itemsPerPage;
              var visibleF = calculated.visibleFirstItemNum;
              calculated.visibleFirstItemNum = Math.max(
                0,
                ((visibleF - (visibleF % perPage)) / perPage - 1 - this.options.batchPages) * perPage
              );
              var visibleL = calculated.visibleLastItemNum;
              calculated.visibleLastItemNum = Math.min(
                this.props.entries.length,
                ((visibleL - (visibleL % perPage)) / perPage + 1 + this.options.batchPages) * perPage
              );
            }
            Object.defineProperty(M, "rmItemsInView", {
              get: () => {
                const c = (this.ps && this._calculated) || !1;
                return (c.itemsPerPage + c.itemsPerRow) | 0;
              },
              configurable: true
            });
          }
          _contentUpdated() {
            this._calculated = false;
            this._recalculate();
            if (this.listContent && this._lastContentHeight !== this._calculated.contentHeight) {
              this._lastContentHeight = this._calculated.contentHeight;
              this.listContent.style.height = this._calculated.contentHeight + "px";
            }
            if (this.ps && this._calculated.scrollHeight + this._calculated.scrollTop > this._calculated.contentHeight) {
              this.ps.scrollToY(this._calculated.contentHeight - this._calculated.scrollHeight);
            }
            if (this.listAdapterInstance && this.listAdapterInstance.onContentUpdated) {
              this.listAdapterInstance.onContentUpdated();
            }
          }
          _getCalcsThatTriggerChange() {
            return [
              this.props.entries.length,
              this._calculated.scrollHeight,
              this._calculated.itemWidth,
              this._calculated.itemHeight,
              this._calculated.contentWidth,
              this._calculated.itemsPerRow,
              this._calculated.contentHeight,
              this._calculated.visibleFirstItemNum,
              this._calculated.visibleLastItemNum
            ];
          }
          indexOfEntry(nodeHandle, prop) {
            prop = prop || "h";
            for (let i = 0; i < this.props.entries.length; i++) {
              let entry = this.props.entries[i];
              if (entry[prop] === nodeHandle) {
                return i;
              }
            }
            return -1;
          }
          scrollToItem(nodeHandle) {
            var elementIndex = this.indexOfEntry(nodeHandle);
            if (elementIndex === -1) {
              return false;
            }
            var shouldScroll = false;
            var itemOffsetTop = Math.floor(elementIndex / this._calculated.itemsPerRow) * this._calculated.itemHeight;
            var itemOffsetTopPlusHeight = itemOffsetTop + this._calculated.itemHeight;
            if (
              itemOffsetTop < this._calculated.scrollTop ||
              itemOffsetTopPlusHeight > this._calculated.scrollTop + this._calculated.scrollHeight
            ) {
              shouldScroll = true;
            }
            if (shouldScroll) {
              this.ps.scrollToY(itemOffsetTop);
              onIdle(() => {
                this.safeForceUpdate();
              });
              return true;
            }
            return false;
          }
          onPsUserScroll() {
            if (!this.isMounted()) {
              return;
            }
            let oldCalc = JSON.stringify(this._getCalcsThatTriggerChange());
            this._contentUpdated();
            let newCalc = JSON.stringify(this._getCalcsThatTriggerChange());
            if (oldCalc !== newCalc) {
              this.forceUpdate();
            }
          }
          onResizeDoUpdate() {
            super.onResizeDoUpdate();
            this._contentUpdated();
          }
          componentDidMount() {
            super.componentDidMount();
            this._contentUpdated();
            this.forceUpdate();
          }
          componentDidUpdate() {
            super.componentDidUpdate();
            this._contentUpdated();
            if (this.adapterChangedDoRepaint) {
              this.adapterChangedDoRepaint = false;
              this._calculated = false;
              this._recalculate();
            }
            if (this.thumbsThatRequireLoading.size) {
              delay("chat:mega-list2:thumb-loader", () => this.enqueueThumbnailRetrieval(), 20);
            }
            this._firstRender = this._firstRender || this.props.viewmode !== M.viewmode;
            if (this._firstRender && this.ps) {
              this._firstRender = false;
              Ps.update(this.ps.findDOMNode());
            }
          }
          enqueueThumbnailRetrieval() {
            const loaders = new Map(this.thumbsLoadingHandlers);
            const nodes = new Map(this.thumbsThatRequireLoading);
            const pending = [];
            const defaultCallback = (n, src, id) => {
              let img = document.getElementById(id || `chat_${n.h}`);
              if (img && (img = img.querySelector("img"))) {
                var _img$parentNode$paren;
                img.src = src;
                (_img$parentNode$paren = img.parentNode.parentNode) == null || _img$parentNode$paren.classList.add("thumb");
              }
            };
            const setSource = (n) => {
              if (thumbnails.has(n.fa)) {
                const src = thumbnails.get(n.fa);
                const batch = [...nodes.get(n.fa)];
                for (var i = batch.length; i--; ) {
                  const n = batch[i];
                  const handlers = [...loaders.get(n.h)];
                  for (let i = handlers.length; i--; ) {
                    let callback = handlers[i];
                    if (typeof callback !== "function") {
                      callback = defaultCallback;
                    }
                    tryCatch(() => {
                      const id = callback(n, src);
                      if (id) {
                        defaultCallback(n, src, id);
                      }
                    })();
                  }
                }
                return true;
              }
            };
            for (const [, [n]] of nodes) {
              if (!setSource(n)) {
                pending.push(n);
              }
            }
            if (pending.length) {
              fm_thumbnails("standalone", pending, setSource);
            }
            this.thumbsLoadingHandlers.clear();
            this.thumbsThatRequireLoading.clear();
          }
          requestThumbnailCb(node, immediate, callback) {
            if (node && node.fa) {
              if (typeof immediate === "function") {
                callback = immediate;
                immediate = 0;
              }
              node.seen = node.seen || -7;
              this.thumbsLoadingHandlers.set(node.h, callback);
              this.thumbsThatRequireLoading.set(node.fa, node);
              delay("chat:mega-list2:thumb-loader", () => this.enqueueThumbnailRetrieval(), immediate || 480);
            }
          }
          render() {
            if (this.isMounted() && !this._calculated) {
              this._recalculate();
            }
            let { listAdapter, listAdapterOpts, entries, nodeAdapterProps, viewMode, header, onContextMenu } = this.props;
            let className = listAdapter.containerClassName + " megaList megaList2";
            var first = this._calculated.visibleFirstItemNum;
            var last = this._calculated.visibleLastItemNum;
            let nodes = [];
            for (var i = first; i < last; i++) {
              let node = entries[i];
              nodes.push(
                external_React_default().createElement(
                  this.props.nodeAdapter,
                  (0, esm_extends.Z)(
                    {
                      key: i + "_" + node[this.props.keyProp],
                      h: node[this.props.keyProp],
                      index: i,
                      megaList: this,
                      listAdapter: listAdapter,
                      node: node,
                      calculated: this._calculated,
                      listAdapterOpts: listAdapterOpts,
                      onContextMenu: onContextMenu,
                      selected: this.props.selected ? this.props.selected.indexOf(node[this.props.keyProp]) > -1 : false,
                      highlighted: this.props.highlighted ? this.props.highlighted.indexOf(node[this.props.keyProp]) > -1 : false,
                      requestThumbnailCb: this.requestThumbnailCb,
                      keyProp: this.props.keyProp || "h"
                    },
                    nodeAdapterProps
                  )
                )
              );
            }
            let listAdapterName = listAdapter.prototype.constructor.name;
            return external_React_default().createElement(
              external_React_default().Fragment,
              null,
              external_React_default().createElement(
                perfectScrollbar.F,
                {
                  key: "ps_" + listAdapterName + "_" + viewMode,
                  options: this.options.perfectScrollOptions,
                  onUserScroll: this.onPsUserScroll,
                  className: className,
                  style: {
                    position: "relative"
                  },
                  ref: (instance) => {
                    this.ps = instance;
                  }
                },
                external_React_default().createElement(
                  this.props.listAdapter,
                  (0, esm_extends.Z)(
                    {
                      containerClassName: this.props.containerClassName,
                      key: "ps_" + listAdapterName + "_" + this.props.viewMode + "_la",
                      ref: (listAdapterInstance) => {
                        this.listAdapterInstance = listAdapterInstance;
                      },
                      listContentRef: (listContent) => {
                        this.listContent = listContent;
                      },
                      header: header,
                      megaList: this,
                      calculated: this._calculated
                    },
                    listAdapterOpts
                  ),
                  nodes
                )
              )
            );
          }
        }),
        (0, applyDecoratedDescriptor.Z)(
          _class.prototype,
          "onPsUserScroll",
          [_dec],
          Object.getOwnPropertyDescriptor(_class.prototype, "onPsUserScroll"),
          _class.prototype
        ),
        _class));
      // EXTERNAL MODULE: ./js/ui/jsx/fm/nodes/genericNodePropsComponent.jsx + 1 modules
      var genericNodePropsComponent = __webpack_require__(297); // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/genericGrid.jsx
      class GenericGrid extends genericNodePropsComponent.L {
        render() {
          let { node, calculated, index, listAdapter, className, keyProp } = this.props;
          let style = {};
          listAdapter.repositionItem(node, calculated, index, style);
          let image = null;
          let src = null;
          let isThumbClass = "";
          if (node.fa && (is_image2(node) || is_video(node))) {
            src = thumbnails.get(node.fa);
            if (!src) {
              this.props.requestThumbnailCb(node);
              src = window.noThumbURI || "";
            }
            image = src
              ? external_React_default().createElement("img", {
                  alt: "",
                  src: src
                })
              : external_React_default().createElement("img", {
                  alt: ""
                });
            isThumbClass = " thumb";
          } else {
            image = external_React_default().createElement("img", null);
          }
          let fileStatusClass = "";
          if (node.fav) {
            fileStatusClass += " icon-favourite-filled";
          }
          return external_React_default().createElement(
            "a",
            {
              className:
                "data-block-view megaListItem ui-droppable ui-draggable ui-draggable-handle " +
                this.nodeProps.classNames.join(" ") +
                ((className && className(node)) || ""),
              id: "chat_" + node[keyProp],
              onClick: (e) => {
                this.props.onClick(e, this.props.node);
              },
              onDoubleClick: (e) => {
                this.props.onDoubleClick(e, this.props.node);
              },
              title: this.nodeProps.title,
              style: style
            },
            external_React_default().createElement(
              "span",
              {
                className: "data-block-bg " + isThumbClass
              },
              external_React_default().createElement(
                "span",
                {
                  className: "data-block-indicators"
                },
                external_React_default().createElement("span", {
                  className: "file-status-icon indicator sprite-fm-mono" + fileStatusClass
                }),
                external_React_default().createElement(
                  "span",
                  {
                    className: "versioning-indicator"
                  },
                  external_React_default().createElement("i", {
                    className: "sprite-fm-mono icon-versions-previous"
                  })
                ),
                external_React_default().createElement("i", {
                  className: "sprite-fm-mono icon-link"
                })
              ),
              external_React_default().createElement(
                "span",
                {
                  className: "block-view-file-type " + this.nodeProps.icon
                },
                image
              ),
              external_React_default().createElement(
                "div",
                {
                  className: "video-thumb-details"
                },
                external_React_default().createElement("i", {
                  className: "small-icon small-play-icon"
                }),
                external_React_default().createElement("span", null, "00:00")
              )
            ),
            external_React_default().createElement(
              "span",
              {
                className: "file-block-title"
              },
              this.nodeProps.title
            )
          );
        }
      } // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/genericTable.jsx
      class GenericTableHeader extends mixins.wl {
        render() {
          let { sortBy, columns } = this.props;
          let columnsRendered = [];
          for (let i = 0; i < columns.length; i++) {
            var _colProps;
            let col = columns[i];
            let colProps;
            if (Array.isArray(col)) {
              colProps = col[1];
              col = col[0];
            }
            let sortable;
            if (col.sortable) {
              let classes = "";
              if (sortBy[0] === col.id) {
                const ordClass = sortBy[1] === "desc" ? "icon-arrow-down" : "icon-arrow-up";
                classes = `${classes} ${ordClass}`;
              }
              if (col.id === "fav") {
                classes += " hidden";
              }
              sortable = external_React_default().createElement("i", {
                className: `sprite-fm-mono ${col.id} ${classes}`
              });
            }
            columnsRendered.push(
              external_React_default().createElement(
                "th",
                {
                  megatype: col.megatype,
                  className: col.headerClassName || col.megatype || "",
                  key: col.id + "_" + i,
                  onClick: (e) => {
                    e.preventDefault();
                    if (col.sortable) {
                      this.props.onClick(col.id);
                    }
                  }
                },
                external_React_default().createElement(
                  "span",
                  null,
                  ((_colProps = colProps) == null ? void 0 : _colProps.label) || col.label
                ),
                col.icon &&
                  external_React_default().createElement("i", {
                    className: "sprite-fm-mono " + col.icon
                  }),
                sortable
              )
            );
          }
          return external_React_default().createElement("thead", null, external_React_default().createElement("tr", null, columnsRendered));
        }
      }
      class GenericTable extends genericNodePropsComponent.L {
        render() {
          var _this$nodeProps;
          let { node, index, listAdapterOpts, className, keyProp } = this.props;
          let columns = [];
          for (let i = 0; i < listAdapterOpts.columns.length; i++) {
            let customColumn = listAdapterOpts.columns[i];
            if (Array.isArray(customColumn)) {
              columns.push(
                external_React_default().createElement(customColumn[0], {
                  ...customColumn[1],
                  nodeAdapter: this,
                  h: node[keyProp],
                  node: node,
                  key: i + "_" + customColumn[0].prototype.constructor.name,
                  keyProp: keyProp
                })
              );
            } else {
              columns.push(
                external_React_default().createElement(customColumn, {
                  nodeAdapter: this,
                  h: node[keyProp],
                  node: node,
                  key: i + "_" + customColumn.prototype.constructor.name,
                  keyProp: keyProp
                })
              );
            }
          }
          let listClassName = listAdapterOpts.className;
          return external_React_default().createElement(
            "tr",
            {
              className:
                "node_" +
                node[keyProp] +
                " " +
                ((className && className(node)) || "") +
                " " +
                ((listClassName && listClassName(node)) || "") +
                " " +
                ((_this$nodeProps = this.nodeProps) == null ? void 0 : _this$nodeProps.classNames.join(" ")),
              id: node[keyProp],
              onContextMenu: (ev) => {
                if (this.props.onContextMenu) {
                  this.props.onContextMenu(ev, node[keyProp]);
                }
              },
              onClick: (e) => {
                this.props.onClick(e, this.props.node);
              },
              onDoubleClick: (e) => {
                this.props.onDoubleClick(e, this.props.node);
              },
              key: index + "_" + node[keyProp]
            },
            columns
          );
        }
      } // CONCATENATED MODULE: ./js/ui/jsx/megaList/adapters.jsx
      class GenericListAdapter extends mixins.wl {
        constructor(...args) {
          super(...args);
          this.customIsEventuallyVisible = true;
        }
      }
      class Grid extends GenericListAdapter {
        static repositionItem(node, calculated, index, style) {
          style.position = "absolute";
          style.top = calculated.itemHeight * Math.floor(index / calculated.itemsPerRow);
          if (calculated.itemsPerRow > 1) {
            style.left = (index % calculated.itemsPerRow) * calculated.itemWidth;
          }
        }
        render() {
          return external_React_default().createElement(
            "div",
            {
              className: "megaList-content",
              ref: this.props.listContentRef,
              style: {
                position: "relative"
              }
            },
            this.props.children
          );
        }
      }
      Grid.itemWidth = 212;
      Grid.itemHeight = 212;
      Grid.containerClassName = "file-block-scrolling megaListContainer";
      class Table extends GenericListAdapter {
        onContentUpdated() {
          let { calculated } = this.props;
          let pusherHeight = (calculated.visibleFirstItemNum * calculated.itemHeight) | 0;
          if (this.topPusher) {
            this.topPusher.style.height = pusherHeight + "px";
          }
          if (this.bottomPusher) {
            this.bottomPusher.style.height =
              ((calculated.contentHeight -
                pusherHeight -
                (calculated.visibleLastItemNum - calculated.visibleFirstItemNum) * calculated.itemHeight) |
                0) +
              "px";
          }
        }
        componentDidUpdate() {
          super.componentDidUpdate();
          this.onContentUpdated();
        }
        render() {
          return external_React_default().createElement(
            "table",
            {
              width: "100%",
              className: this.props.containerClassName || "grid-table table-hover fm-dialog-table"
            },
            this.props.header,
            external_React_default().createElement(
              "tbody",
              {
                ref: this.props.listContentRef
              },
              external_React_default().createElement("tr", {
                className: "megalist-pusher top",
                ref: (r) => {
                  this.topPusher = r;
                }
              }),
              this.props.children,
              external_React_default().createElement("tr", {
                className: "megalist-pusher bottom",
                ref: (r) => {
                  this.bottomPusher = r;
                }
              })
            )
          );
        }
      }
      Table.itemHeight = 32;
      Table.itemsPerRow = 1;
      Table.containerClassName = "grid-scrolling-table megaListContainer";
      // EXTERNAL MODULE: ./js/ui/jsx/fm/nodes/columns/columnFavIcon.jsx
      var columnFavIcon = __webpack_require__(310); // CONCATENATED MODULE: ./js/ui/tooltips.jsx
      var React = __webpack_require__(363);

      class Handler extends mixins.wl {
        render() {
          var classes = "tooltip-handler" + (this.props.className ? " " + this.props.className : "");
          return React.createElement(
            "span",
            {
              className: classes,
              onMouseOver: this.props.onMouseOver,
              onMouseOut: this.props.onMouseOut
            },
            this.props.children
          );
        }
      }
      Handler.defaultProps = {
        hideable: true
      };
      class Contents extends mixins.wl {
        render() {
          var className = "tooltip-contents dropdown body tooltip " + (this.props.className ? this.props.className : "");
          if (this.props.active) {
            className += " visible";
            return React.createElement(
              "div",
              {
                className: className
              },
              this.props.withArrow
                ? React.createElement("i", {
                    className: "dropdown-white-arrow"
                  })
                : null,
              this.props.children
            );
          } else {
            return null;
          }
        }
      }
      Contents.defaultProps = {
        hideable: true
      };
      class Tooltip extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            active: false
          };
        }
        componentDidUpdate(oldProps, oldState) {
          var self = this;
          if (oldState.active === true && this.state.active === false) {
            chatGlobalEventManager.removeEventListener("resize", "tooltip" + this.getUniqueId());
          }
          if (self.state.active === true) {
            self.repositionTooltip();
            chatGlobalEventManager.addEventListener("resize", "tooltip" + this.getUniqueId(), function () {
              self.repositionTooltip();
            });
            if (this.props.onShown) {
              this.props.onShown();
            }
          }
        }
        repositionTooltip() {
          var elLeftPos, elTopPos, elWidth, elHeight;
          var tooltipLeftPos, tooltipTopPos, tooltipWidth, tooltipHeight;
          var docHeight;
          var arrowClass;
          if (!this.isMounted()) {
            return;
          }
          var $container = $(this.findDOMNode());
          var $el = $(".tooltip-handler", $container);
          var $tooltip = $(".tooltip-contents", $container);
          var tooltipOffset = this.props.tooltipOffset;
          var arrow = this.props.withArrow;
          if ($el && $tooltip) {
            elWidth = $el.outerWidth();
            elHeight = $el.outerHeight();
            elLeftPos = $el.offset().left;
            elTopPos = $el.offset().top;
            tooltipWidth = $tooltip.outerWidth();
            tooltipHeight = $tooltip.outerHeight();
            docHeight = $(window).height();
            $tooltip.removeClass("dropdown-arrow left-arrow right-arrow up-arrow down-arrow").removeAttr("style");
            if (!tooltipOffset) {
              tooltipOffset = 7;
            }
            if (elTopPos - tooltipHeight - tooltipOffset > 10) {
              tooltipLeftPos = elLeftPos + elWidth / 2 - tooltipWidth / 2;
              tooltipTopPos = elTopPos - tooltipHeight - tooltipOffset;
              arrowClass = arrow ? "dropdown-arrow down-arrow" : "";
            } else if (docHeight - (elTopPos + elHeight + tooltipHeight + tooltipOffset) > 10) {
              tooltipLeftPos = elLeftPos + elWidth / 2 - tooltipWidth / 2;
              tooltipTopPos = elTopPos + elHeight + tooltipOffset;
              arrowClass = arrow ? "dropdown-arrow up-arrow" : "";
            } else if (elLeftPos - tooltipWidth - tooltipOffset > 10) {
              tooltipLeftPos = elLeftPos - tooltipWidth - tooltipOffset;
              tooltipTopPos = elTopPos + elHeight / 2 - tooltipHeight / 2;
              arrowClass = arrow ? "dropdown-arrow right-arrow" : "";
            } else {
              tooltipLeftPos = elLeftPos + elWidth + tooltipOffset;
              tooltipTopPos = elTopPos + elHeight / 2 - tooltipHeight / 2;
              arrowClass = arrow ? "dropdown-arrow left-arrow" : "";
            }
            $tooltip.css({
              left: tooltipLeftPos,
              top: tooltipTopPos - 5
            });
            $tooltip.addClass(arrowClass);
          }
        }
        onHandlerMouseOver() {
          this.setState({
            active: true
          });
        }
        onHandlerMouseOut() {
          this.setState({
            active: false
          });
        }
        render() {
          var self = this;
          var others = [];
          var handler = null;
          var contents = null;
          var x = 0;
          React.Children.forEach(this.props.children, function (child) {
            if (child.type.name === "Handler") {
              handler = React.cloneElement(child, {
                onMouseOver: function () {
                  self.onHandlerMouseOver();
                },
                onMouseOut: function () {
                  self.onHandlerMouseOut();
                }
              });
            } else if (child.type.name === "Contents") {
              contents = React.cloneElement(child, {
                active: self.state.active,
                withArrow: self.props.withArrow
              });
            } else {
              var tmp = React.cloneElement(child, {
                key: x++
              });
              others.push(tmp);
            }
          });
          return React.createElement(
            "span",
            {
              className: this.props.className || ""
            },
            handler,
            contents,
            others
          );
        }
      }
      Tooltip.defaultProps = {
        hideable: true
      };
      const tooltips = {
        Tooltip,
        Handler,
        Contents
      }; // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnNodeName.jsx
      class ColumnNodeName extends genericNodePropsComponent.L {
        constructor(...args) {
          super(...args);
          this.state = {
            src: null
          };
        }
        componentDidMount() {
          super.componentDidMount();
        }
        render() {
          const { nodeAdapter } = this.props;
          const { node, requestThumbnailCb } = nodeAdapter.props;
          const src = this.state.src || thumbnails.get(node.fa);
          return external_React_default().createElement(
            "td",
            {
              megatype: ColumnNodeName.megatype
            },
            src || is_image2(node) || is_video(node)
              ? external_React_default().createElement(
                  tooltips.Tooltip,
                  {
                    withArrow: true,
                    className: "tooltip-handler-container",
                    onShown: () => {
                      if (!src) {
                        requestThumbnailCb(node, true, (n, src) => {
                          this.setState({
                            src
                          });
                          return `preview_${n.h}`;
                        });
                      }
                    }
                  },
                  external_React_default().createElement(tooltips.Handler, {
                    className: `transfer-filetype-icon ${fileIcon(node)}`
                  }),
                  external_React_default().createElement(
                    tooltips.Contents,
                    {
                      className: "img-preview"
                    },
                    external_React_default().createElement(
                      "div",
                      {
                        className: "dropdown img-wrapper img-block",
                        id: `preview_${node.h}`
                      },
                      external_React_default().createElement("img", {
                        alt: "",
                        className: `thumbnail-placeholder ${node.h}`,
                        src: node.fa || src ? src || `${staticpath}/images/mega/ajax-loader-tiny.gif` : window.noThumbURI
                      })
                    )
                  )
                )
              : external_React_default().createElement("span", {
                  className: `
                            transfer-filetype-icon
                            ${nodeAdapter.nodeProps.isFolder ? "folder" : ""}
                            ${nodeAdapter.nodeProps.icon}
                            ${node.su ? "inbound-share" : ""}
                        `
                }),
            external_React_default().createElement(
              "span",
              {
                className: "tranfer-filetype-txt"
              },
              nodeAdapter.nodeProps.title
            )
          );
        }
      }
      ColumnNodeName.sortable = true;
      ColumnNodeName.id = "name";
      ColumnNodeName.label = l[86];
      ColumnNodeName.megatype = "fname"; // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnSize.jsx
      class ColumnSize extends genericNodePropsComponent.L {
        render() {
          let { nodeAdapter } = this.props;
          return external_React_default().createElement(
            "td",
            {
              megatype: ColumnSize.megatype,
              className: "size"
            },
            !nodeAdapter.nodeProps.isFolder ? nodeAdapter.nodeProps.size : ""
          );
        }
      }
      ColumnSize.sortable = true;
      ColumnSize.id = "size";
      ColumnSize.label = l[87];
      ColumnSize.megatype = "size"; // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnTimeAdded.jsx
      class ColumnTimeAdded extends genericNodePropsComponent.L {
        render() {
          let { nodeAdapter } = this.props;
          return external_React_default().createElement(
            "td",
            {
              megatype: ColumnTimeAdded.megatype,
              className: "time ad"
            },
            nodeAdapter.nodeProps.timestamp
          );
        }
      }
      ColumnTimeAdded.sortable = true;
      ColumnTimeAdded.id = "ts";
      ColumnTimeAdded.label = l[16169];
      ColumnTimeAdded.megatype = "timeAd"; // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/columns/columnExtras.jsx
      class ColumnExtras extends genericNodePropsComponent.L {
        render() {
          return external_React_default().createElement(
            "td",
            {
              megatype: ColumnExtras.megatype,
              className: "grid-url-field own-data extras-column"
            },
            external_React_default().createElement(
              "span",
              {
                className: "versioning-indicator"
              },
              external_React_default().createElement("i", {
                className: "sprite-fm-mono icon-versions-previous"
              })
            ),
            external_React_default().createElement("i", {
              className: "sprite-fm-mono icon-link"
            })
          );
        }
      }
      ColumnExtras.sortable = false;
      ColumnExtras.id = "extras";
      ColumnExtras.label = "";
      ColumnExtras.megatype = "extras";
      ColumnExtras.headerClassName = "grid-url-header"; // CONCATENATED MODULE: ./js/ui/jsx/fm/browserEntries.jsx
      class BrowserEntries extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            sortBy: props.sortBy || ["name", "asc"]
          };
          this.toggleSortBy = this.toggleSortBy.bind(this);
        }
        componentWillMount() {
          this.lastCharKeyPressed = false;
          this.lastCharKeyIndex = -1;
        }
        componentDidMount() {
          super.componentDidMount();
          this.bindEvents();
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          this.unbindEvents();
        }
        componentDidUpdate(oldProps) {
          if (oldProps.sortBy && (oldProps.sortBy[0] !== this.props.sortBy[0] || oldProps.sortBy[1] !== this.props.sortBy[1])) {
            this.setState({
              sortBy: this.props.sortBy
            });
          }
        }
        handleKeyNavigation(selectionManager, shiftKey, keyCode, viewMode) {
          let curr;
          const { folderSelectNotAllowed } = this.props;
          if (shiftKey && folderSelectNotAllowed) {
            curr = selectionManager.last_selected;
          }
          let KEYS = BrowserEntries.KEYS;
          if (viewMode) {
            if (keyCode === KEYS.LEFT) {
              selectionManager.select_prev(shiftKey, true);
            } else if (keyCode === KEYS.RIGHT) {
              selectionManager.select_next(shiftKey, true);
            } else if (keyCode === KEYS.UP) {
              selectionManager.select_grid_up(shiftKey, true);
            } else {
              selectionManager.select_grid_down(shiftKey, true);
            }
          } else if (keyCode === KEYS.UP) {
            selectionManager.select_prev(shiftKey, true);
          } else {
            selectionManager.select_next(shiftKey, true);
          }
          if (shiftKey && folderSelectNotAllowed && $.selected.length > 1) {
            const folderNodes = $.selected.filter((n) => !M.isFileNode(M.getNodeByHandle(n)));
            if (folderNodes.length > 1) {
              if (!M.isFileNode(M.getNodeByHandle(curr))) {
                array.remove(folderNodes, curr);
              }
              if (folderNodes.length) {
                const newCurr = selectionManager.last_selected;
                for (let i = 0; i < folderNodes.length; i++) {
                  selectionManager.remove_from_selection(folderNodes[i]);
                }
                if (M.isFileNode(M.getNodeByHandle(newCurr))) {
                  selectionManager.set_currently_selected(curr);
                } else if (curr && $.selected.includes(curr)) {
                  selectionManager.set_currently_selected(curr);
                } else if ($.selected.length) {
                  selectionManager.set_currently_selected($.selected[0]);
                }
              }
            }
          }
        }
        _invalidKeydownTarget(e) {
          return (
            e.target &&
            (e.target.tagName === "INPUT" ||
              e.target.tagName === "BUTTON" ||
              (e.target.tagName === "TEXTAREA" && !e.target.classList.contains("messages-textarea")) ||
              e.target.tagName === "SELECT")
          );
        }
        _isNavigationKeyDown(e, keyCode) {
          const { KEYS } = BrowserEntries;
          const { viewMode } = this.props;
          return (
            !e.metaKey &&
            ((!viewMode && (keyCode === KEYS.UP || keyCode === KEYS.DOWN)) ||
              (viewMode && (keyCode === KEYS.UP || keyCode === KEYS.DOWN || keyCode === KEYS.LEFT || keyCode === KEYS.RIGHT)))
          );
        }
        bindEvents() {
          const { KEYS } = BrowserEntries;
          $(document.body).rebind(`keydown.be${this.getUniqueId()}`, (e) => {
            let charTyped = false;
            const keyCode = e.which || e.keyCode;
            const $searchField = $("div.fm-files-search input");
            const $typingArea = $("textarea.messages-textarea");
            const { selectionManager, viewMode } = this.props;
            if (this._invalidKeydownTarget(e)) {
              return;
            }
            if ($searchField.is(":focus")) {
              return;
            }
            if ($typingArea.is(":focus")) {
              $typingArea.trigger("blur");
            }
            if (keyCode === KEYS.A && (e.ctrlKey || e.metaKey)) {
              this.handleSelectAll();
              e.preventDefault();
              e.stopPropagation();
            } else if ((e.metaKey && keyCode === KEYS.UP) || keyCode === KEYS.BACKSPACE) {
              this.handleKeyBack();
            } else if (this._isNavigationKeyDown(e, keyCode)) {
              this.handleKeyNavigation(selectionManager, e.shiftKey, keyCode, viewMode);
            } else if ((keyCode >= 48 && keyCode <= 57) || (keyCode >= 65 && keyCode <= 123) || keyCode > 255) {
              charTyped = String.fromCharCode(keyCode).toLowerCase();
              this.handleCharTyped(charTyped);
            } else if (keyCode === KEYS.ENTER || (e.metaKey && keyCode === KEYS.DOWN)) {
              this.handleAttach();
            }
            if (!charTyped) {
              this.lastCharKeyPressed = false;
              this.lastCharKeyIndex = -1;
            }
          });
        }
        handleSelectAll() {
          const { selectionManager, folderSelectNotAllowed, entries } = this.props;
          selectionManager.select_all();
          if (folderSelectNotAllowed) {
            const folders = entries.filter((h) => !M.isFileNode(M.getNodeByHandle(h)));
            for (let i = 0; i < folders.length; i++) {
              selectionManager.remove_from_selection(folders[i].h);
            }
          }
        }
        handleKeyBack() {
          const { viewMode, currentlyViewedEntry } = this.props;
          if (!viewMode) {
            const currentFolder = M.getNode(currentlyViewedEntry);
            if (currentFolder.p) {
              this.expandFolder(currentFolder.p);
            }
          }
        }
        handleCharTyped(charTyped) {
          const { entries, keyProp, selectionManager } = this.props;
          const foundMatchingNodes = entries.filter((node) => {
            return node.name && node.name.substring(0, 1).toLowerCase() === charTyped;
          });
          if (this.lastCharKeyPressed === charTyped) {
            this.lastCharKeyIndex++;
          }
          this.lastCharKeyPressed = charTyped;
          if (foundMatchingNodes.length > 0) {
            if (!foundMatchingNodes[this.lastCharKeyIndex]) {
              this.lastCharKeyIndex = 0;
            }
            const foundNode = foundMatchingNodes[this.lastCharKeyIndex];
            selectionManager.clear_selection();
            selectionManager.set_currently_selected(foundNode[keyProp], true);
          }
        }
        handleAttach() {
          const { highlighted, folderSelectNotAllowed, entries, keyProp, onAttachClicked } = this.props;
          let selectedNodes = highlighted;
          if (folderSelectNotAllowed) {
            selectedNodes = highlighted.filter((h) => {
              const node = entries.find((e) => e[keyProp] === h);
              return node && node.t === 0;
            });
            if (selectedNodes.length === 0) {
              const cursorNode = highlighted[0] && M.getNodeByHandle(highlighted[0]);
              if (cursorNode.t === 1) {
                this.expandFolder(cursorNode[keyProp]);
                return;
              } else if (highlighted.length > 0) {
                this.expandFolder(highlighted[0]);
                return;
              }
              return;
            }
          }
          onAttachClicked(selectedNodes);
        }
        unbindEvents() {
          $(document.body).off("keydown.be" + this.getUniqueId());
        }
        onEntryClick(e, node) {
          const { selectionManager, keyProp, folderSelectNotAllowed, highlighted = [] } = this.props;
          this.lastCharKeyPressed = false;
          this.lastCharKeyIndex = -1;
          e.stopPropagation();
          e.preventDefault();
          if (!e.shiftKey && !e.ctrlKey && !e.metaKey) {
            selectionManager.clear_selection();
            selectionManager.set_currently_selected(node[keyProp]);
          } else if (e.shiftKey) {
            if ($.selected && $.selected.length) {
              let selFolders;
              if (folderSelectNotAllowed) {
                selFolders = $.selected.filter((n) => !M.isFileNode(M.getNodeByHandle(n)));
              }
              selectionManager.shift_select_to(node[keyProp], false, true, false);
              if (folderSelectNotAllowed && $.selected.length > 1) {
                const folderNodes = $.selected.filter((n) => !M.isFileNode(M.getNodeByHandle(n)));
                if (folderNodes.length > 1) {
                  array.remove(folderNodes, selFolders[0] || folderNodes[0]);
                  for (let i = 0; i < folderNodes.length; i++) {
                    selectionManager.remove_from_selection(folderNodes[i]);
                  }
                }
              }
            } else {
              selectionManager.set_currently_selected(node[keyProp]);
            }
          } else if (e.ctrlKey || e.metaKey) {
            if (!highlighted || !highlighted.includes(node[keyProp])) {
              if (folderSelectNotAllowed) {
                if (node.t === 1 && highlighted.length > 0) {
                  return;
                } else if (
                  highlighted.some((nodeId) => {
                    const node = M.getNodeByHandle(nodeId);
                    return node && node.t === 1;
                  })
                ) {
                  selectionManager.clear_selection();
                }
              }
              selectionManager.add_to_selection(node[keyProp]);
            } else if (highlighted && highlighted.includes(node[keyProp])) {
              if (folderSelectNotAllowed) {
                if (node.t === 1) {
                  return;
                } else if (
                  highlighted.some((nodeId) => {
                    const node = M.getNodeByHandle(nodeId);
                    return node && node.t === 1;
                  })
                ) {
                  selectionManager.clear();
                }
              }
              selectionManager.remove_from_selection(node[keyProp]);
            }
          }
        }
        expandFolder(nodeId) {
          var self = this;
          var node = M.getNodeByHandle(nodeId);
          if (node) {
            self.lastCharKeyPressed = false;
            self.lastCharKeyIndex = -1;
            self.setState({
              selected: [],
              highlighted: [],
              cursor: false
            });
            self.props.onExpand(node);
            self.forceUpdate();
          }
        }
        onEntryDoubleClick(e, node) {
          var self = this;
          self.lastCharKeyPressed = false;
          self.lastCharKeyIndex = -1;
          e.stopPropagation();
          e.preventDefault();
          var share = M.getNodeShare(node);
          if (share && share.down) {
            return;
          }
          if (node.t) {
            self.props.onExpand(node);
            self.forceUpdate();
          } else {
            self.onEntryClick(e, node);
            self.props.onAttachClicked();
          }
        }
        customIsEventuallyVisible() {
          return true;
        }
        toggleSortBy(colId) {
          var newState = {};
          if (this.state.sortBy[0] === colId) {
            newState.sortBy = [colId, this.state.sortBy[1] === "asc" ? "desc" : "asc"];
          } else {
            newState.sortBy = [colId, "asc"];
          }
          this.setState(newState);
          this.props.onSortByChanged(newState.sortBy);
        }
        render() {
          var viewMode = this.props.viewMode;
          let listAdapterOpts = this.props.listAdapterOpts || {};
          if (!viewMode) {
            listAdapterOpts.columns = [columnFavIcon.l, ColumnNodeName, ColumnSize, ColumnTimeAdded, ColumnExtras];
          }
          if (this.props.listAdapterColumns) {
            listAdapterOpts.columns = this.props.listAdapterColumns;
          }
          if (this.props.isLoading) {
            return external_React_default().createElement(
              "div",
              {
                className: "dialog-empty-block active dialog-fm folder"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "dialog-empty-pad"
                },
                external_React_default().createElement("i", {
                  className: "sprite-fm-mono icon-cloud-drive"
                }),
                external_React_default().createElement(
                  "div",
                  {
                    className: "dialog-empty-header"
                  },
                  l[5533]
                )
              )
            );
          } else if (!this.props.entries.length && this.props.currentlyViewedEntry === "search") {
            return external_React_default().createElement(
              "div",
              {
                className: "dialog-empty-block active dialog-fm folder"
              },
              external_React_default().createElement(
                "div",
                {
                  className: "dialog-empty-pad"
                },
                external_React_default().createElement("i", {
                  className: "sprite-fm-mono icon-preview-reveal"
                }),
                external_React_default().createElement(
                  "div",
                  {
                    className: "dialog-empty-header"
                  },
                  l[978]
                )
              )
            );
          } else if (!this.props.entries.length) {
            const nilComp = this.props.NilComponent;
            return (
              (nilComp && (typeof nilComp === "function" ? nilComp() : nilComp)) ||
              external_React_default().createElement(
                "div",
                {
                  className: "dialog-empty-block active dialog-fm folder"
                },
                this.props.currentlyViewedEntry === "shares"
                  ? external_React_default().createElement(
                      "div",
                      {
                        className: "dialog-empty-pad"
                      },
                      external_React_default().createElement("i", {
                        className: "sprite-fm-mono icon-folder-incoming-share-filled"
                      }),
                      external_React_default().createElement(
                        "div",
                        {
                          className: "dialog-empty-header"
                        },
                        l[6871]
                      )
                    )
                  : external_React_default().createElement(
                      "div",
                      {
                        className: "dialog-empty-pad"
                      },
                      external_React_default().createElement("i", {
                        className: "sprite-fm-mono icon-folder-filled"
                      }),
                      external_React_default().createElement(
                        "div",
                        {
                          className: "dialog-empty-header"
                        },
                        this.props.currentlyViewedEntry === M.RootID ? l[1343] : M.u[this.props.currentlyViewedEntry] ? l[6787] : l[782]
                      )
                    )
              )
            );
          }
          return external_React_default().createElement(MegaList2, {
            viewMode: viewMode,
            sortBy: this.state.sortBy,
            currentlyViewedEntry: this.props.currentlyViewedEntry,
            selected: this.props.selected,
            highlighted: this.props.highlighted,
            containerClassName: this.props.containerClassName,
            nodeAdapterProps: {
              onClick: (e, node) => {
                this.onEntryClick(e, node);
              },
              onDoubleClick: (e, node) => {
                this.onEntryDoubleClick(e, node);
              },
              className: (node) => {
                return this.props.highlighted.indexOf(node[this.props.keyProp]) > -1 ? " ui-selected" : "";
              }
            },
            ref: (r) => {
              this.megaList = r;
            },
            listAdapter: viewMode ? Grid : Table,
            nodeAdapter: viewMode ? GenericGrid : GenericTable,
            listAdapterOpts: listAdapterOpts,
            entries: this.props.entries,
            itemHeight: this.props.megaListItemHeight,
            headerHeight: viewMode ? 0 : 36,
            header:
              !viewMode &&
              external_React_default().createElement(GenericTableHeader, {
                columns: listAdapterOpts.columns,
                sortBy: this.state.sortBy,
                onClick: this.toggleSortBy,
                headerContainerClassName: this.props.headerContainerClassName
              }),
            currentdirid: this.props.currentdirid,
            onContextMenu: this.props.onContextMenu,
            keyProp: this.props.keyProp
          });
        }
      }
      BrowserEntries.KEYS = {
        A: 65,
        UP: 38,
        DOWN: 40,
        LEFT: 37,
        RIGHT: 39,
        ENTER: 13,
        BACKSPACE: 8
      };
      BrowserEntries.defaultProps = {
        hideable: true,
        requiresUpdateOnResize: true
      }; // CONCATENATED MODULE: ./js/ui/jsx/fm/fmView.jsx
      class FMView extends mixins.wl {
        constructor(props) {
          var _this$dataSource;
          super(props);
          let initialSortBy = props.initialSortBy || ["name", "asc"];
          if (props.fmConfigSortEnabled) {
            var _fmconfig$sortmodes;
            const sortId = props.fmConfigSortId;
            assert(sortId, "missing fmConfigSortId");
            if (
              (_fmconfig$sortmodes = fmconfig.sortmodes) != null &&
              (_fmconfig$sortmodes = _fmconfig$sortmodes[sortId]) != null &&
              _fmconfig$sortmodes.n
            ) {
              var _fmconfig$sortmodes2;
              initialSortBy = this._translateFmConfigSortMode(
                (_fmconfig$sortmodes2 = fmconfig.sortmodes) == null ? void 0 : _fmconfig$sortmodes2[sortId]
              );
            }
          }
          this.state = {
            sortBy: initialSortBy,
            selected: [],
            highlighted: [],
            entries: null
          };
          if (this.props.dataSource) {
            this.dataSource = this.props.dataSource;
          } else {
            this.dataSource = M.d;
          }
          this.state.entries = this.getEntries();
          this.onAttachClicked = this.onAttachClicked.bind(this);
          this.onContextMenu = this.onContextMenu.bind(this);
          if ((_this$dataSource = this.dataSource) != null && _this$dataSource.addChangeListener) {
            this._listener = this.dataSource.addChangeListener(() => {
              if (!this.isMounted()) {
                return;
              }
              this.setState({
                entries: this.getEntries()
              });
            });
          }
          this.initSelectionManager();
        }
        _translateFmConfigSortMode(currentSortModes) {
          const sortId = this.props.fmConfigSortId;
          assert(sortId, "missing fmConfigSortId");
          const sortByArr = [];
          if (currentSortModes != null && currentSortModes.n) {
            sortByArr[0] = currentSortModes.n;
            const sortMap = this.props.fmConfigSortMap;
            const aliasKeys = (sortMap && Object.keys(sortMap)) || [];
            for (const alias of aliasKeys) {
              if (sortByArr[0] === sortMap[alias]) {
                sortByArr[0] = alias;
                break;
              }
            }
            sortByArr[1] = currentSortModes.d === 1 ? "asc" : "desc";
          }
          return sortByArr;
        }
        initSelectionManager(entries) {
          this.selectionManager = new SelectionManager2_React(
            entries || this.state.entries,
            this.props.currentdirid || "cloud-drive",
            () => {
              var _this$browserEntries;
              return (_this$browserEntries = this.browserEntries) == null ||
                (_this$browserEntries = _this$browserEntries.megaList) == null ||
                (_this$browserEntries = _this$browserEntries._calculated) == null
                ? void 0
                : _this$browserEntries.itemsPerRow;
            },
            (nodeHandle) => {
              if (this.browserEntries && this.browserEntries.megaList) {
                this.browserEntries.megaList.scrollToItem(nodeHandle);
              }
            },
            {
              onSelectedUpdated: (selectedList) => {
                this.onSelectionUpdated(selectedList);
              }
            }
          );
        }
        onSelectionUpdated(selectedList) {
          selectedList = [...selectedList];
          let highlighted = selectedList;
          if (this.props.folderSelectNotAllowed && !this.props.folderSelectable) {
            selectedList = selectedList.filter((nodeId) => this.dataSource[nodeId].t !== 1);
          }
          this.setState({
            selected: selectedList,
            highlighted: highlighted
          });
          this.props.onSelected(selectedList);
          this.props.onHighlighted(highlighted);
          $.selected = highlighted;
        }
        getEntries(newState) {
          var self = this;
          var sortBy = (newState && newState.sortBy) || self.state.sortBy;
          var order = sortBy[1] === "asc" ? 1 : -1;
          var entries = [];
          const minSearchLength = self.props.minSearchLength || 3;
          if (self.props.currentlyViewedEntry === "search" && self.props.searchValue && self.props.searchValue.length >= minSearchLength) {
            M.getFilterBy(M.getFilterBySearchFn(self.props.searchValue)).forEach(function (n) {
              if (!n.h || n.h.length === 11 || n.fv) {
                return;
              }
              if (self.props.customFilterFn && !self.props.customFilterFn(n)) {
                return;
              }
              entries.push(n);
            });
          } else {
            Object.keys(M.c[self.props.currentlyViewedEntry] || self.props.dataSource || {}).forEach((h) => {
              if (this.dataSource[h]) {
                if (self.props.customFilterFn) {
                  if (self.props.customFilterFn(this.dataSource[h])) {
                    entries.push(this.dataSource[h]);
                  }
                } else {
                  entries.push(this.dataSource[h]);
                }
              }
            });
          }
          var sortFunc;
          if (sortBy[0] === "name") {
            sortFunc = M.getSortByNameFn();
          } else if (sortBy[0] === "size") {
            sortFunc = M.getSortBySizeFn();
          } else if (sortBy[0] === "ts") {
            sortFunc = M.getSortByDateTimeFn();
          } else if (sortBy[0] === "rts") {
            sortFunc = M.getSortByRtsFn();
          } else if (sortBy[0] === "status") {
            sortFunc = M.getSortByStatusFn();
          } else if (sortBy[0] === "interaction") {
            sortFunc = M.getSortByInteractionFn();
          } else if (sortBy[0] === "verification") {
            sortFunc = M.getSortByVerificationFn();
          } else if (sortBy[0] === "email") {
            sortFunc = M.getSortByEmail();
          } else if (sortBy[0] === "access") {
            sortFunc = (a, b, o) => typeof a.r !== "undefined" && typeof b.r !== "undefined" && (a.r < b.r ? -1 : 1) * o;
          } else {
            sortFunc = M.sortByFavFn(order);
          }
          var folders = [];
          if (this.props.sortFoldersFirst) {
            for (var i = entries.length; i--; ) {
              if (entries[i] && entries[i].t) {
                folders.unshift(entries[i]);
                entries.splice(i, 1);
              }
            }
          }
          folders.sort(function (a, b) {
            return sortFunc(a, b, order);
          });
          entries.sort(function (a, b) {
            return sortFunc(a, b, order);
          });
          return folders.concat(entries);
        }
        onHighlighted(nodes) {
          this.setState({
            highlighted: nodes
          });
          if (this.props.onHighlighted) {
            this.props.onHighlighted(nodes);
          }
        }
        finishedLoading(newState) {
          newState.isLoading = false;
          newState.entries = this.getEntries();
          this.initSelectionManager(newState.entries);
          this.setState(newState);
        }
        addOrUpdRawListener() {
          if (this._rawListener) {
            mBroadcaster.removeListener(this._rawListener);
          }
          this._rawListener = mBroadcaster.addListener("fmViewUpdate:" + this.props.currentlyViewedEntry, () => {
            this.setState(
              {
                entries: this.getEntries()
              },
              () => {
                if (this.browserEntries.isMounted()) {
                  this.browserEntries.forceUpdate();
                }
              }
            );
          });
        }
        componentDidMount() {
          var _this$dataSource2;
          super.componentDidMount();
          if (!((_this$dataSource2 = this.dataSource) != null && _this$dataSource2.addChangeListener)) {
            this.addOrUpdRawListener();
          }
          if (this.props.fmConfigSortEnabled) {
            this._sortModeListener = mBroadcaster.addListener("fmconfig:sortmodes", (sortModes) => {
              this.onFmConfigSortModeChanged(sortModes);
            });
          }
        }
        componentDidUpdate(prevProps) {
          const { currentlyViewedEntry: currEntry, searchValue: currSearch } = this.props;
          const { currentlyViewedEntry: prevEntry, searchValue: prevSearch } = prevProps;
          if (prevEntry !== currEntry || currSearch !== prevSearch) {
            var _this$dataSource3;
            let newState = {
              selected: [],
              highlighted: []
            };
            if (!((_this$dataSource3 = this.dataSource) != null && _this$dataSource3.addChangeListener)) {
              this.addOrUpdRawListener();
            }
            const handle = currEntry;
            if (handle === "shares") {
              newState.isLoading = true;
              this.setState(newState);
              dbfetch.geta(Object.keys(M.c.shares || {})).always(() => {
                this.finishedLoading(newState);
              });
              return;
            }
            if (!this.dataSource[handle] || (this.dataSource[handle].t && !M.c[handle])) {
              this.setState({
                isLoading: true
              });
              dbfetch.get(handle).always(() => {
                this.finishedLoading(newState);
              });
              return;
            }
            let entries = this.getEntries();
            this.initSelectionManager(entries);
            this.setState({
              entries: entries
            });
          }
        }
        onAttachClicked() {
          this.props.onAttachClicked();
        }
        onContextMenu() {}
        componentWillUnmount() {
          super.componentWillUnmount();
          if (this._listener) {
            var _this$dataSource4;
            (_this$dataSource4 = this.dataSource) == null || _this$dataSource4.removeChangeListener(this._listener);
          }
          if (this._rawListener) {
            mBroadcaster.removeListener(this._rawListener);
          }
          if (this._sortModeListener) {
            mBroadcaster.removeListener(this._sortModeListener);
          }
          $.selected = [];
          this.selectionManager.destroy();
          this.selectionManager = undefined;
          $(".dropdown.body.files-menu.context").css("z-index", "");
        }
        onSortByChanged(newState) {
          if (newState[0] === this.state.sortBy[0] && newState[1] === this.state.sortBy[1]) {
            return;
          }
          const entries = this.getEntries({
            sortBy: newState
          });
          this.setState(
            {
              sortBy: newState,
              entries: entries,
              selected: [],
              highlighted: []
            },
            () => {
              if (this.props.onSortByChanged) {
                this.props.onSortByChanged(newState);
              }
              if (this.props.fmConfigSortEnabled) {
                const sortId = this.props.fmConfigSortId;
                assert(sortId, "fmConfigSortId missing");
                if (newState[0] === this.props.initialSortBy[0] && newState[1] === this.props.initialSortBy[1]) {
                  const sortModes = typeof fmconfig.sortmodes !== "undefined" ? fmconfig.sortmodes : Object.create(null);
                  delete sortModes[sortId];
                  mega.config.set("sortmodes", sortModes);
                  return;
                }
                const map = this.props.fmConfigSortMap || Object.create(null);
                const name = map[newState[0]] || newState[0];
                const direction = newState[1] === "asc" ? 1 : -1;
                fmsortmode(sortId, name, direction);
              }
            }
          );
          this.initSelectionManager(entries);
        }
        onFmConfigSortModeChanged(sortModes) {
          const currentSortMode = sortModes[this.props.fmConfigSortId];
          if (!currentSortMode) {
            this.onSortByChanged(this.props.initialSortBy || ["name", "asc"]);
          } else {
            const newSortMode = this._translateFmConfigSortMode(currentSortMode);
            if (this.state.sortBy[0] !== newSortMode[0] || this.state.sortBy[1] !== newSortMode[1]) {
              this.onSortByChanged(newSortMode);
            }
          }
        }
        render() {
          return external_React_default().createElement(
            "div",
            {
              className: "content-container",
              onClick: (ev) => {
                $.hideContextMenu(ev);
              }
            },
            external_React_default().createElement(BrowserEntries, {
              isLoading: this.state.isLoading || this.props.nodeLoading,
              currentlyViewedEntry: this.props.currentlyViewedEntry,
              entries: this.state.entries || [],
              onExpand: (node) => {
                this.setState({
                  selected: [],
                  highlighted: []
                });
                this.props.onExpand(node[this.props.keyProp || "h"]);
              },
              sortBy: this.state.sortBy,
              folderSelectNotAllowed: this.props.folderSelectNotAllowed,
              onAttachClicked: this.onAttachClicked,
              viewMode: this.props.viewMode,
              selected: this.state.selected,
              highlighted: this.state.highlighted,
              onContextMenu: this.props.onContextMenu ? this.props.onContextMenu : this.onContextMenu,
              selectionManager: this.selectionManager,
              ref: (browserEntries) => {
                this.browserEntries = browserEntries;
              },
              onSortByChanged: (newState) => {
                this.onSortByChanged(newState);
              },
              listAdapterColumns: this.props.listAdapterColumns,
              currentdirid: this.props.currentdirid,
              containerClassName: this.props.containerClassName,
              headerContainerClassName: this.props.headerContainerClassName,
              megaListItemHeight: this.props.megaListItemHeight,
              keyProp: this.props.keyProp || "h",
              NilComponent: this.props.NilComponent,
              listAdapterOpts: this.props.listAdapterOpts
            })
          );
        }
      }

      /***/
    },

    /***/ 310: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        l: () => ColumnFavIcon
      });
      var react0__ = __webpack_require__(363);
      var react0 = __webpack_require__.n(react0__);
      var _genericNodePropsComponent1__ = __webpack_require__(297);

      class ColumnFavIcon extends _genericNodePropsComponent1__.L {
        render() {
          let { nodeAdapter } = this.props;
          let { node } = nodeAdapter.props;
          let isFavouritable = node.r === 2;
          return react0().createElement(
            "td",
            {
              megatype: ColumnFavIcon.megatype,
              className: ColumnFavIcon.megatype
            },
            react0().createElement("span", {
              className:
                "grid-status-icon sprite-fm-mono " +
                (missingkeys[node.h] ? " icon-info" : nodeAdapter.nodeProps.fav ? " icon-favourite-filled" : " icon-dot") +
                ((!isFavouritable && " disabled") || ""),
              onClick: () => {
                if (isFavouritable) {
                  M.favourite([node.h], !node.fav);
                }
              }
            })
          );
        }
      }
      ColumnFavIcon.sortable = true;
      ColumnFavIcon.id = "fav";
      ColumnFavIcon.label = "";
      ColumnFavIcon.icon = "icon-favourite-filled";
      ColumnFavIcon.megatype = "fav";
      ColumnFavIcon.headerClassName = "grid-first-th fav";

      /***/
    },

    /***/ 297: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, {
        L: () => GenericNodePropsComponent
      });

      // EXTERNAL MODULE: ./js/chat/mixins.js
      var mixins = __webpack_require__(503); // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/nodeProperties.jsx
      class NodeProperties {
        static get(node, changeListener) {
          assert(node.h, "missing handle for node");
          if (NodeProperties._globalCleanupTimer) {
            NodeProperties._globalCleanupTimer.abort();
          }
          (NodeProperties._globalCleanupTimer = tSleep(120)).then(() => {
            NodeProperties.cleanup(0);
          });
          let nodeProps;
          if (!NodeProperties._cache.has(node.h)) {
            nodeProps = new NodeProperties(node, changeListener);
            NodeProperties._cache.set(node.h, nodeProps);
          }
          return nodeProps || NodeProperties._cache.get(node.h);
        }
        unuse(changeListener) {
          let node = this.node;
          if (!node) {
            if (d) {
              console.warn("This should not happen.");
            }
            return;
          }
          this.changeListeners.delete(changeListener);
          let usages = NodeProperties._usages.get(this);
          if (usages) {
            NodeProperties._usages.set(this, --usages);
            if (usages === 0 && NodeProperties._cache.size > NodeProperties.MAX_CACHE_SIZE) {
              delay("nodePropCleanup", NodeProperties.cleanup, 1000);
            }
          }
        }
        static cleanup(maxCacheSize) {
          maxCacheSize = typeof maxCacheSize === "undefined" ? NodeProperties.MAX_CACHE_SIZE : maxCacheSize;
          let len = NodeProperties._cache.size;
          let removed = 0;
          for (let entry of NodeProperties._cache) {
            let id = entry[0];
            let node = entry[1];
            let usage = NodeProperties._usages.get(node);
            if (usage === 0) {
              NodeProperties._usages.delete(node);
              node._cleanup();
              NodeProperties._cache.delete(id);
              removed++;
              if (len - removed < maxCacheSize) {
                return;
              }
            }
          }
        }
        constructor(node, changeListener) {
          this.node = node;
          this.changeListeners = new Set();
          if (changeListener) {
            this.changeListeners.add(changeListener);
          }
          let _onChange = () => {
            this.initProps();
            for (let listener of this.changeListeners) {
              listener();
            }
          };
          if (this.node.addChangeListener) {
            this._listener = this.node.addChangeListener(_onChange);
          } else {
            this._mbListener = mBroadcaster.addListener("nodeUpdated:" + node.h, _onChange);
          }
          this.initProps();
        }
        use(changeListener) {
          if (changeListener) {
            this.changeListeners.add(changeListener);
          }
          NodeProperties._usages.set(this, (NodeProperties._usages.get(this) | 0) + 1);
        }
        _cleanup() {
          if (this._listener) {
            this.node.removeChangeListener(this._listener);
          }
          if (this._mbListener) {
            mBroadcaster.removeListener(this._mbListener);
          }
          oDestroy(this);
        }
        initProps() {
          let node = this.node;
          lazy(this, "title", () => {
            return M.getNameByHandle(node.h);
          });
          lazy(this, "classNames", () => {
            let classNames = [];
            if (node.su) {
              classNames.push("inbound-share");
            }
            if (node.t) {
              classNames.push("folder");
            } else {
              classNames.push("file");
            }
            var share = this.shareData;
            if (missingkeys[node.h] || share.down) {
              if (share.down) {
                classNames.push("taken-down");
              }
              if (missingkeys[node.h]) {
                classNames.push("undecryptable");
              }
            }
            if (share) {
              classNames.push("linked");
            }
            if (node.lbl && !folderlink) {
              var colourLabel = M.getLabelClassFromId(node.lbl);
              classNames.push("colour-label");
              classNames.push(colourLabel);
            }
            return classNames;
          });
          lazy(this, "icon", () => {
            return fileIcon(node);
          });
          lazy(this, "isFolder", () => {
            return !!node.t;
          });
          lazy(this, "shareData", () => {
            return M.getNodeShare(node);
          });
          lazy(this, "isTakendown", () => {
            return this.shareData && !!this.shareData.down;
          });
          lazy(this, "fav", () => {
            return !!node.fav;
          });
          lazy(this, "size", () => {
            return bytesToSize(node.s);
          });
          lazy(this, "timestamp", () => {
            return time2date(node.ts);
          });
          lazy(this, "root", () => {
            return M.getNodeRoot(node.h);
          });
          lazy(this, "incomingShareData", () => {
            let result = {};
            if (node.r === 1) {
              result.accessLabel = l[56];
              result.accessIcon = "icon-permissions-write";
            } else if (node.r === 2) {
              result.accessLabel = l[57];
              result.accessIcon = "icon-star";
            } else {
              result.accessLabel = l[55];
              result.accessIcon = "icon-read-only";
            }
            return result;
          });
          lazy(this, "timestamp", () => {
            return time2date(node.ts);
          });
          lazy(this, "onlineStatus", () => {
            return M.onlineStatusClass(node.presence ? node.presence : "unavailable");
          });
        }
      }
      NodeProperties._cache = new Map();
      NodeProperties._usages = new WeakMap();
      NodeProperties._globalCleanupTimer = void 0;
      NodeProperties.MAX_CACHE_SIZE = 100;
      if (d) {
        window.NodeProperties = NodeProperties;
      } // CONCATENATED MODULE: ./js/ui/jsx/fm/nodes/genericNodePropsComponent.jsx
      class GenericNodePropsComponent extends mixins.wl {
        constructor(props) {
          super(props);
          if (this.props.node.h) {
            this.nodeProps = NodeProperties.get(this.props.node);
            this.changeListener = this.changeListener.bind(this);
          }
        }
        changeListener() {
          if (this.isMounted()) {
            this.safeForceUpdate();
          }
        }
        componentWillReceiveProps(nextProps) {
          if (nextProps.highlighted !== this.props.highlighted) {
            this.safeForceUpdate();
          }
        }
        componentWillMount() {
          var _this$nodeProps;
          if (super.componentWillMount) {
            super.componentWillMount();
          }
          (_this$nodeProps = this.nodeProps) == null || _this$nodeProps.use(this.changeListener);
        }
        componentWillUnmount() {
          var _this$nodeProps2;
          super.componentWillUnmount();
          (_this$nodeProps2 = this.nodeProps) == null || _this$nodeProps2.unuse(this.changeListener);
        }
      }

      /***/
    },

    /***/ 182: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";

      // EXPORTS
      __webpack_require__.d(__webpack_exports__, {
        Z: () => modalDialogs
      });

      // UNUSED EXPORTS: ExtraFooterElement

      // EXTERNAL MODULE: ./js/ui/utils.jsx
      var utils = __webpack_require__(79);
      // EXTERNAL MODULE: ./js/chat/mixins.js
      var mixins = __webpack_require__(503); // CONCATENATED MODULE: ./js/ui/forms.jsx
      var React = __webpack_require__(363);

      class Checkbox extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            checked: this.props.checked ? this.props.checked : false
          };
          this.onLabelClick = this.onLabelClick.bind(this);
          this.onChange = this.onChange.bind(this);
        }
        onLabelClick(e) {
          var state = !this.state.checked;
          this.setState({
            checked: state
          });
          if (this.props.onLabelClick) {
            this.props.onLabelClick(e, state);
          }
          this.onChange(e);
        }
        onChange(e) {
          if (this.props.onChange) {
            this.props.onChange(e, this.state.checked);
          }
        }
        render() {
          var className = this.state.checked ? "checkboxOn" : "checkboxOff";
          return React.createElement(
            "div",
            {
              className: "formsCheckbox"
            },
            React.createElement(
              "div",
              {
                className: "checkdiv " + className,
                onClick: this.onLabelClick
              },
              React.createElement("input", {
                type: "checkbox",
                name: this.props.name,
                id: this.props.id,
                className: className,
                checked: this.state.checked,
                onChange: this.onChange
              })
            ),
            React.createElement(
              "label",
              {
                htmlFor: this.props.id,
                className: "radio-txt"
              },
              this.props.children
            )
          );
        }
      }
      const ui_forms = {
        Checkbox
      }; // CONCATENATED MODULE: ./js/ui/modalDialogs.jsx
      var modalDialogs_React = __webpack_require__(363);

      var ContactsUI = __webpack_require__(13);
      class ExtraFooterElement extends mixins.wl {
        render() {
          return this.props.children;
        }
      }
      class ModalDialog extends mixins.wl {
        constructor(props) {
          super(props);
          this.onBlur = this.onBlur.bind(this);
          this.onCloseClicked = this.onCloseClicked.bind(this);
          this.onPopupDidMount = this.onPopupDidMount.bind(this);
        }
        componentDidMount() {
          super.componentDidMount();
          if (!this.props.hideOverlay) {
            $(document.body).addClass("overlayed");
            $(".fm-dialog-overlay").removeClass("hidden");
          }
          $("textarea:focus").trigger("blur");
          if (!this.props.noCloseOnClickOutside) {
            const convApp = document.querySelector(".conversationsApp");
            if (convApp) {
              convApp.removeEventListener("click", this.onBlur);
              convApp.addEventListener("click", this.onBlur);
            }
            $(".fm-modal-dialog").rebind("click.modalDialogOv" + this.getUniqueId(), ({ target }) => {
              if ($(target).is(".fm-modal-dialog")) {
                this.onBlur();
              }
            });
            $(".fm-dialog-overlay").rebind("click.modalDialog" + this.getUniqueId(), () => {
              if (this.props.closeDlgOnClickOverlay) {
                this.onBlur();
              }
              return false;
            });
          }
          $(document).rebind("keyup.modalDialog" + this.getUniqueId(), ({ keyCode }) => {
            if (!this.props.stopKeyPropagation && keyCode === 27) {
              this.onBlur();
            }
          });
        }
        onBlur(e) {
          var $element = $(this.findDOMNode());
          if (!e || !$(e.target).closest(".mega-dialog").is($element)) {
            var convApp = document.querySelector(".conversationsApp");
            if (convApp) {
              convApp.removeEventListener("click", this.onBlur);
            }
            this.onCloseClicked();
          }
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          if (!this.props.noCloseOnClickOutside) {
            var convApp = document.querySelector(".conversationsApp");
            if (convApp) {
              convApp.removeEventListener("click", this.onBlur);
            }
            $(".fm-dialog-overlay").off("click.modalDialog" + this.getUniqueId());
          }
          if (!this.props.hideOverlay) {
            $(document.body).removeClass("overlayed");
            $(".fm-dialog-overlay").addClass("hidden");
          }
          $(this.domNode).off("dialog-closed.modalDialog" + this.getUniqueId());
          $(document).off("keyup.modalDialog" + this.getUniqueId());
        }
        onCloseClicked() {
          var self = this;
          if (self.props.onClose) {
            self.props.onClose(self);
          }
        }
        onPopupDidMount(elem) {
          this.domNode = elem;
          $(elem).rebind("dialog-closed.modalDialog" + this.getUniqueId(), () => this.onCloseClicked());
          if (this.props.popupDidMount) {
            this.props.popupDidMount(elem);
          }
        }
        render() {
          var self = this;
          var classes = "mega-dialog";
          var selectedNumEle = null;
          var footer = null;
          var extraFooterElements = [];
          var otherElements = [];
          var x = 0;
          modalDialogs_React.Children.forEach(
            self.props.children,
            function (child) {
              if (!child) {
                return;
              }
              if (child.type.name === "ExtraFooterElement") {
                extraFooterElements.push(
                  modalDialogs_React.cloneElement(child, {
                    key: x++
                  })
                );
              } else {
                otherElements.push(
                  modalDialogs_React.cloneElement(child, {
                    key: x++
                  })
                );
              }
            }.bind(this)
          );
          if (self.props.className) {
            classes += ` ${self.props.className}`;
          }
          if (self.props.dialogType) {
            classes += ` dialog-template-${self.props.dialogType}`;
          }
          if (self.props.dialogName) {
            classes += ` ${self.props.dialogName}`;
          }
          if (self.props.showSelectedNum && self.props.selectedNum) {
            selectedNumEle = modalDialogs_React.createElement(
              "div",
              {
                className: "selected-num"
              },
              modalDialogs_React.createElement("span", null, self.props.selectedNum)
            );
          }
          var buttons;
          if (self.props.buttons) {
            buttons = [];
            self.props.buttons.forEach(function (v, i) {
              if (v) {
                buttons.push(
                  modalDialogs_React.createElement(
                    "button",
                    {
                      className:
                        (v.defaultClassname ? v.defaultClassname : "mega-button") +
                        (v.className ? " " + v.className : "") +
                        (self.props.dialogType === "action" ? "large" : ""),
                      onClick: (e) => {
                        if ($(e.target).is(".disabled")) {
                          return false;
                        }
                        if (v.onClick) {
                          v.onClick(e, self);
                        }
                      },
                      key: v.key + i
                    },
                    v.iconBefore
                      ? modalDialogs_React.createElement(
                          "div",
                          null,
                          modalDialogs_React.createElement("i", {
                            className: v.iconBefore
                          })
                        )
                      : null,
                    modalDialogs_React.createElement("span", null, v.label),
                    v.iconAfter
                      ? modalDialogs_React.createElement(
                          "div",
                          null,
                          modalDialogs_React.createElement("i", {
                            className: v.iconAfter
                          })
                        )
                      : null
                  )
                );
              }
            });
            if ((buttons && buttons.length > 0) || extraFooterElements.length > 0) {
              footer = modalDialogs_React.createElement(
                "footer",
                null,
                buttons && buttons.length > 0
                  ? modalDialogs_React.createElement(
                      "div",
                      {
                        className: "footer-container"
                      },
                      buttons
                    )
                  : null,
                extraFooterElements.length > 0 ? modalDialogs_React.createElement("aside", null, extraFooterElements) : null
              );
            }
          }
          return modalDialogs_React.createElement(
            utils.ZP.RenderTo,
            {
              element: document.body,
              className: "fm-modal-dialog",
              popupDidMount: this.onPopupDidMount
            },
            modalDialogs_React.createElement(
              "div",
              {
                id: self.props.id,
                className: classes,
                "aria-labelledby": self.props.dialogName ? self.props.dialogName + "-title" : null,
                role: "dialog",
                "aria-modal": "true",
                onClick: self.props.onClick
              },
              modalDialogs_React.createElement(
                "button",
                {
                  className: "close",
                  onClick: self.onCloseClicked
                },
                modalDialogs_React.createElement("i", {
                  className: "sprite-fm-mono icon-dialog-close"
                })
              ),
              self.props.title
                ? self.props.dialogType === "message"
                  ? modalDialogs_React.createElement(
                      "header",
                      null,
                      self.props.icon
                        ? modalDialogs_React.createElement("i", {
                            className: `graphic ${self.props.icon}`
                          })
                        : self.props.iconElement,
                      modalDialogs_React.createElement(
                        "div",
                        null,
                        modalDialogs_React.createElement(
                          "h3",
                          {
                            id: self.props.dialogName ? self.props.dialogName + "-title" : null
                          },
                          self.props.title,
                          selectedNumEle
                        ),
                        self.props.subtitle ? modalDialogs_React.createElement("p", null, self.props.subtitle) : null,
                        otherElements
                      )
                    )
                  : modalDialogs_React.createElement(
                      "header",
                      null,
                      self.props.icon
                        ? modalDialogs_React.createElement("i", {
                            className: `graphic ${self.props.icon}`
                          })
                        : self.props.iconElement,
                      modalDialogs_React.createElement(
                        "h2",
                        {
                          id: self.props.dialogName ? self.props.dialogName + "-title" : null
                        },
                        self.props.title,
                        selectedNumEle
                      ),
                      self.props.subtitle ? modalDialogs_React.createElement("p", null, self.props.subtitle) : null
                    )
                : null,
              self.props.dialogType !== "message" ? otherElements : null,
              buttons || extraFooterElements ? footer : null
            )
          );
        }
      }
      ModalDialog.defaultProps = {
        hideable: true,
        noCloseOnClickOutside: false,
        closeDlgOnClickOverlay: true,
        showSelectedNum: false,
        selectedNum: 0
      };
      class SelectContactDialog extends mixins.wl {
        constructor(props) {
          super(props);
          this.state = {
            selected: this.props.selected ? this.props.selected : []
          };
          this.onSelected = this.onSelected.bind(this);
        }
        onSelected(nodes) {
          this.setState({
            selected: nodes
          });
          if (this.props.onSelected) {
            this.props.onSelected(nodes);
          }
        }
        onSelectClicked() {
          this.props.onSelectClicked();
        }
        render() {
          var self = this;
          var classes = "send-contact contrast small-footer dialog-template-tool " + self.props.className;
          return modalDialogs_React.createElement(
            ModalDialog,
            {
              title: l.share_contact_title,
              className: classes,
              selected: self.state.selected,
              onClose: () => {
                self.props.onClose(self);
              },
              buttons: [
                {
                  label: self.props.cancelLabel,
                  key: "cancel",
                  onClick: function (e) {
                    self.props.onClose(self);
                    e.preventDefault();
                    e.stopPropagation();
                  }
                },
                {
                  label: self.props.selectLabel,
                  key: "select",
                  className: self.state.selected.length === 0 ? "positive disabled" : "positive",
                  onClick: function (e) {
                    if (self.state.selected.length > 0) {
                      if (self.props.onSelected) {
                        self.props.onSelected(self.state.selected);
                      }
                      self.props.onSelectClicked(self.state.selected);
                    }
                    e.preventDefault();
                    e.stopPropagation();
                  }
                }
              ]
            },
            modalDialogs_React.createElement(
              "section",
              {
                className: "content"
              },
              modalDialogs_React.createElement(
                "div",
                {
                  className: "content-block"
                },
                modalDialogs_React.createElement(ContactsUI.ContactPickerWidget, {
                  megaChat: self.props.megaChat,
                  exclude: self.props.exclude,
                  selectableContacts: "true",
                  onSelectDone: self.props.onSelectClicked,
                  onSelected: self.onSelected,
                  onClose: self.props.onClose,
                  selected: self.state.selected,
                  contacts: M.u,
                  headerClasses: "left-aligned",
                  multiple: true
                })
              )
            )
          );
        }
      }
      SelectContactDialog.clickTime = 0;
      SelectContactDialog.defaultProps = {
        selectLabel: l.share_contact_action,
        cancelLabel: l[82],
        hideable: true
      };
      class ConfirmDialog extends mixins.wl {
        static saveState(o) {
          let state = mega.config.get("xcod") >>> 0;
          mega.config.set("xcod", state | (1 << o.props.pref));
        }
        static clearState(o) {
          let state = mega.config.get("xcod") >>> 0;
          mega.config.set("xcod", state & ~(1 << o.props.pref));
        }
        static autoConfirm(o) {
          console.assert(o.props.pref > 0);
          let state = mega.config.get("xcod") >>> 0;
          return !!(state & (1 << o.props.pref));
        }
        constructor(props) {
          super(props);
          this._wasAutoConfirmed = undefined;
          this._keyUpEventName = "keyup.confirmDialog" + this.getUniqueId();
          lazy(
            this,
            "_autoConfirm",
            () => this.props.onConfirmClicked && this.props.dontShowAgainCheckbox && ConfirmDialog.autoConfirm(this)
          );
        }
        unbindEvents() {
          $(document).off(this._keyUpEventName);
        }
        componentDidMount() {
          super.componentDidMount();
          queueMicrotask(() => {
            if (!this.isMounted()) {
              return;
            }
            if (this._autoConfirm) {
              if (!this._wasAutoConfirmed) {
                this._wasAutoConfirmed = 1;
                queueMicrotask(() => {
                  this.onConfirmClicked();
                });
              }
              return;
            }
            $(document).rebind(this._keyUpEventName, (e) => {
              if (e.which === 13 || e.keyCode === 13) {
                if (!this.isMounted()) {
                  this.unbindEvents();
                  return;
                }
                this.onConfirmClicked();
                return false;
              }
            });
          });
        }
        componentWillUnmount() {
          super.componentWillUnmount();
          var self = this;
          self.unbindEvents();
          delete this._wasAutoConfirmed;
        }
        onConfirmClicked() {
          this.unbindEvents();
          if (this.props.onConfirmClicked) {
            this.props.onConfirmClicked();
          }
        }
        render() {
          var self = this;
          if (this._autoConfirm) {
            return null;
          }
          var classes =
            "delete-message" + (self.props.name ? ` ${self.props.name}` : "") + (self.props.className ? ` ${self.props.className}` : "");
          var dontShowCheckbox = null;
          if (self.props.dontShowAgainCheckbox) {
            dontShowCheckbox = modalDialogs_React.createElement(
              "div",
              {
                className: "footer-checkbox"
              },
              modalDialogs_React.createElement(
                ui_forms.Checkbox,
                {
                  name: "delete-confirm",
                  id: "delete-confirm",
                  onLabelClick: (e, state) => {
                    if (state === true) {
                      ConfirmDialog.saveState(self);
                    } else {
                      ConfirmDialog.clearState(self);
                    }
                  }
                },
                l[7039]
              )
            );
          }
          return modalDialogs_React.createElement(
            ModalDialog,
            {
              title: this.props.title,
              subtitle: this.props.subtitle,
              className: classes,
              dialogId: this.props.name,
              dialogType: this.props.dialogType,
              icon: this.props.icon,
              onClose: () => {
                self.props.onClose(self);
              },
              buttons: [
                {
                  label: self.props.cancelLabel,
                  key: "cancel",
                  onClick: function (e) {
                    ConfirmDialog.clearState(self);
                    self.props.onClose(self);
                    e.preventDefault();
                    e.stopPropagation();
                  }
                },
                {
                  label: self.props.confirmLabel,
                  key: "select",
                  className: "positive",
                  onClick: function (e) {
                    self.onConfirmClicked();
                    e.preventDefault();
                    e.stopPropagation();
                  }
                }
              ]
            },
            self.props.children,
            dontShowCheckbox ? modalDialogs_React.createElement(ExtraFooterElement, null, dontShowCheckbox) : null
          );
        }
      }
      ConfirmDialog.defaultProps = {
        confirmLabel: l[6826],
        cancelLabel: l[82],
        dontShowAgainCheckbox: true,
        hideable: true,
        dialogType: "message"
      };
      const modalDialogs = {
        ModalDialog,
        SelectContactDialog,
        ConfirmDialog
      };

      /***/
    },

    /***/ 285: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        F: () => PerfectScrollbar
      });
      var _applyDecoratedDescriptor1__ = __webpack_require__(229);
      var _chat_mixins0__ = __webpack_require__(503);

      var _dec, _dec2, _class, _class2;
      var React = __webpack_require__(363);

      let PerfectScrollbar =
        ((_dec = (0, _chat_mixins0__.M9)(30, true)),
        (_dec2 = (0, _chat_mixins0__.M9)(30, true)),
        ((_class =
          ((_class2 = class PerfectScrollbar extends _chat_mixins0__.wl {
            constructor(props) {
              super(props);
              this.isUserScroll = true;
              this.scrollEventIncId = 0;
            }
            get$Node() {
              if (!this.$Node) {
                this.$Node = $(this.findDOMNode());
              }
              return this.$Node;
            }
            doProgramaticScroll(newPos, forced, isX, skipReinitialised) {
              if (!this.isMounted()) {
                return;
              }
              var self = this;
              var $elem = self.get$Node();
              var animFrameInner = false;
              var prop = !isX ? "scrollTop" : "scrollLeft";
              var event = "scroll.progscroll" + self.scrollEventIncId++;
              $elem.rebind(event, () => {
                if (animFrameInner) {
                  cancelAnimationFrame(animFrameInner);
                  animFrameInner = false;
                }
                $elem.off(event);
                if (!skipReinitialised) {
                  self.reinitialised(true);
                } else if (typeof skipReinitialised === "function") {
                  onIdle(skipReinitialised);
                }
                self.isUserScroll = true;
              });
              self.isUserScroll = false;
              $elem[0][prop] = Math.round(newPos);
              Ps.update($elem[0]);
              animFrameInner = requestAnimationFrame(() => {
                animFrameInner = false;
                self.isUserScroll = true;
                $elem.off(event);
              });
              return true;
            }
            componentDidMount() {
              super.componentDidMount();
              var self = this;
              var $elem = self.get$Node();
              $elem.height("100%");
              var options = Object.assign(
                {},
                {
                  handlers: ["click-rail", "drag-scrollbar", "keyboard", "wheel", "touch", "selection"],
                  minScrollbarLength: 20
                },
                self.props.options
              );
              Ps.initialize($elem[0], options);
              if (self.props.onFirstInit) {
                self.props.onFirstInit(self, $elem);
              }
              $elem.rebind("ps-scroll-y.ps" + self.getUniqueId(), function (e) {
                if ($elem.attr("data-scroll-disabled") === "true") {
                  e.stopPropagation();
                  e.preventDefault();
                  e.originalEvent.stopPropagation();
                  e.originalEvent.preventDefault();
                  return false;
                }
                if (self.props.onUserScroll && self.isUserScroll === true && $elem.is(e.target)) {
                  self.props.onUserScroll(self, $elem, e);
                }
              });
              $elem.rebind("disable-scroll.ps" + self.getUniqueId(), function () {
                Ps.destroy($elem[0]);
              });
              $elem.rebind("enable-scroll.ps" + self.getUniqueId(), function () {
                Ps.initialize($elem[0], options);
              });
              $elem.rebind("forceResize.ps" + self.getUniqueId(), function (e, forced, scrollPositionYPerc, scrollToElement) {
                self.onResize(forced, scrollPositionYPerc, scrollToElement);
              });
              self.onResize();
              this.attachAnimationEvents();
            }
            componentWillUnmount() {
              super.componentWillUnmount();
              var $elem = this.get$Node();
              $elem.off("ps-scroll-y.ps" + this.getUniqueId());
              var ns = ".ps" + this.getUniqueId();
              $elem.parents(".have-animation").unbind("animationend" + ns + " webkitAnimationEnd" + ns + " oAnimationEnd" + ns);
            }
            attachAnimationEvents() {}
            eventuallyReinitialise(forced, scrollPositionYPerc, scrollToElement) {
              var self = this;
              if (!self.isComponentEventuallyVisible()) {
                return;
              }
              var $elem = self.get$Node();
              var h = self.getContentHeight();
              if (forced || self._currHeight !== h) {
                self._currHeight = h;
                self._doReinit(scrollPositionYPerc, scrollToElement, forced, $elem);
              }
            }
            _doReinit(scrollPositionYPerc, scrollToElement, forced, $elem) {
              var fired = false;
              if (this.props.onReinitialise) {
                fired = this.props.onReinitialise(this, $elem, forced, scrollPositionYPerc, scrollToElement);
              }
              if (fired === false) {
                if (scrollPositionYPerc) {
                  if (scrollPositionYPerc === -1) {
                    this.scrollToBottom(true);
                  } else {
                    this.scrollToPercentY(scrollPositionYPerc, true);
                  }
                } else if (scrollToElement) {
                  this.scrollToElement(scrollToElement, true);
                }
              }
            }
            scrollToBottom(skipReinitialised) {
              this.reinitialise(skipReinitialised, true);
            }
            reinitialise(skipReinitialised, bottom) {
              var $elem = this.findDOMNode();
              this.isUserScroll = false;
              if (bottom) {
                $elem.scrollTop = this.getScrollHeight();
              }
              Ps.update($elem);
              this.isUserScroll = true;
              if (!skipReinitialised) {
                this.reinitialised(true);
              }
            }
            getDOMRect(node) {
              return (node || this.findDOMNode()).getBoundingClientRect();
            }
            getScrollOffset(value) {
              var $elem = this.findDOMNode();
              return this.getDOMRect($elem.children[0])[value] - this.getDOMRect($elem)[value] || 0;
            }
            getScrollHeight() {
              var res = this.getScrollOffset("height");
              if (res < 1) {
                return this._lastKnownScrollHeight || 0;
              }
              this._lastKnownScrollHeight = res;
              return res;
            }
            getScrollWidth() {
              var res = this.getScrollOffset("width");
              if (res < 1) {
                return this._lastKnownScrollWidth || 0;
              }
              this._lastKnownScrollWidth = res;
              return res;
            }
            getContentHeight() {
              var $elem = this.get$Node();
              return $elem[0].scrollHeight;
            }
            getContentWidth() {
              var $elem = this.get$Node();
              return $elem[0].scrollWidth;
            }
            setCssContentHeight(h) {
              var $elem = this.get$Node();
              return $elem.css("height", h);
            }
            isAtTop() {
              return this.findDOMNode().scrollTop === 0;
            }
            isAtBottom() {
              return Math.round(this.getScrollPositionY()) === Math.round(this.getScrollHeight());
            }
            isCloseToBottom(minPixelsOff) {
              return this.getScrollHeight() - this.getScrollPositionY() <= minPixelsOff;
            }
            getScrolledPercentY() {
              return (100 / this.getScrollHeight()) * this.getScrollPositionY();
            }
            getScrollPositionY() {
              return this.findDOMNode().scrollTop;
            }
            getScrollPositionX() {
              return this.findDOMNode().scrollLeft;
            }
            getClientWidth() {
              return this.findDOMNode().clientWidth;
            }
            getClientHeight() {
              return this.findDOMNode().clientHeight;
            }
            scrollToPercentY(posPerc, skipReinitialised) {
              var $elem = this.get$Node();
              var targetPx = (this.getScrollHeight() / 100) * posPerc;
              if ($elem[0].scrollTop !== targetPx) {
                this.doProgramaticScroll(targetPx, 0, 0, skipReinitialised);
              }
            }
            scrollToPercentX(posPerc, skipReinitialised) {
              var $elem = this.get$Node();
              var targetPx = (this.getScrollWidth() / 100) * posPerc;
              if ($elem[0].scrollLeft !== targetPx) {
                this.doProgramaticScroll(targetPx, false, true, skipReinitialised);
              }
            }
            scrollToY(posY, skipReinitialised) {
              var $elem = this.get$Node();
              if ($elem[0].scrollTop !== posY) {
                this.doProgramaticScroll(posY, 0, 0, skipReinitialised);
              }
            }
            scrollToElement(element, skipReinitialised) {
              if (element && element.offsetParent) {
                this.doProgramaticScroll(element.offsetTop, 0, 0, skipReinitialised);
              }
            }
            disable() {
              if (this.isMounted()) {
                var $elem = this.get$Node();
                $elem.attr("data-scroll-disabled", true);
                $elem.addClass("ps-disabled");
                Ps.disable($elem[0]);
              }
            }
            enable() {
              if (this.isMounted()) {
                var $elem = this.get$Node();
                $elem.removeAttr("data-scroll-disabled");
                $elem.removeClass("ps-disabled");
                Ps.enable($elem[0]);
              }
            }
            reinitialised(forced) {
              if (this.props.onReinitialise) {
                this.props.onReinitialise(this, this.get$Node(), forced ? forced : false);
              }
            }
            onResize(forced, scrollPositionYPerc, scrollToElement) {
              if (forced && forced.originalEvent) {
                forced = true;
                scrollPositionYPerc = undefined;
              }
              this.eventuallyReinitialise(forced, scrollPositionYPerc, scrollToElement);
            }
            inViewport(domNode) {
              return verge.inViewport(domNode);
            }
            componentDidUpdate() {
              if (this.props.requiresUpdateOnResize || this.requiresUpdateOnResize) {
                this.onResize(true);
              }
              this.attachAnimationEvents();
            }
            customIsEventuallyVisible() {
              const chatRoom = this.props.chatRoom;
              return !chatRoom || chatRoom.isCurrentlyActive;
            }
            render() {
              var self = this;
              return React.createElement(
                "div",
                {
                  style: this.props.style,
                  className: this.props.className
                },
                self.props.children
              );
            }
          }),
          (_class2.defaultProps = {
            className: "perfectScrollbarContainer",
            requiresUpdateOnResize: true
          }),
          _class2)),
        ((0, _applyDecoratedDescriptor1__.Z)(
          _class.prototype,
          "eventuallyReinitialise",
          [_dec],
          Object.getOwnPropertyDescriptor(_class.prototype, "eventuallyReinitialise"),
          _class.prototype
        ),
        (0, _applyDecoratedDescriptor1__.Z)(
          _class.prototype,
          "onResize",
          [_dec2],
          Object.getOwnPropertyDescriptor(_class.prototype, "onResize"),
          _class.prototype
        )),
        _class));

      /***/
    },

    /***/ 79: /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        Cw: () => ParsedHTML,
        ZP: () => __WEBPACK_DEFAULT_EXPORT__,
        a0: () => OFlowEmoji,
        dy: () => Emoji,
        hV: () => reactStringWrap,
        nF: () => OFlowParsedHTML,
        pQ: () => withOverflowObserver
      });
      var _chat_mixins0__ = __webpack_require__(503);
      var React = __webpack_require__(363);
      var ReactDOM = __webpack_require__(533);

      class RenderTo extends React.Component {
        componentDidMount() {
          if (super.componentDidMount) {
            super.componentDidMount();
          }
          this.popup = document.createElement("div");
          this._setClassNames();
          if (this.props.style) {
            $(this.popup).css(this.props.style);
          }
          this.props.element.appendChild(this.popup);
          var self = this;
          this._renderLayer(function () {
            if (self.props.popupDidMount) {
              self.props.popupDidMount(self.popup);
            }
          });
        }
        componentDidUpdate() {
          this._setClassNames();
          this._renderLayer();
        }
        componentWillUnmount() {
          if (super.componentWillUnmount) {
            super.componentWillUnmount();
          }
          ReactDOM.unmountComponentAtNode(this.popup);
          if (this.props.popupWillUnmount) {
            this.props.popupWillUnmount(this.popup);
          }
          this.props.element.removeChild(this.popup);
        }
        _setClassNames() {
          this.popup.className = this.props.className ? this.props.className : "";
        }
        _renderLayer(cb) {
          ReactDOM.render(this.props.children, this.popup, cb);
        }
        render() {
          return null;
        }
      }
      const withOverflowObserver = (Component) =>
        class extends _chat_mixins0__._p {
          constructor(props) {
            super(props);
            this.displayName = "OverflowObserver";
            this.ref = React.createRef();
            this.state = {
              overflowed: false
            };
            this.handleMouseEnter = this.handleMouseEnter.bind(this);
          }
          handleMouseEnter() {
            const element = this.ref && this.ref.current;
            if (element) {
              this.setState({
                overflowed: element.scrollWidth > element.offsetWidth
              });
            }
          }
          shouldComponentUpdate(nextProps, nextState) {
            return (
              nextState.overflowed !== this.state.overflowed ||
              nextProps.children !== this.props.children ||
              nextProps.content !== this.props.content
            );
          }
          render() {
            const { simpletip } = this.props;
            return React.createElement(
              "div",
              {
                ref: this.ref,
                className: `
                        overflow-observer
                        ${this.state.overflowed ? "simpletip simpletip-tc" : ""}
                    `,
                "data-simpletipposition": (simpletip == null ? void 0 : simpletip.position) || "top",
                "data-simpletipoffset": simpletip == null ? void 0 : simpletip.offset,
                "data-simpletip-class": (simpletip == null ? void 0 : simpletip.className) || "medium-width center-align",
                onMouseEnter: this.handleMouseEnter
              },
              React.createElement(Component, this.props)
            );
          }
        };
      const Emoji = ({ children }) => {
        return React.createElement(ParsedHTML, {
          content: megaChat.html(children)
        });
      };
      class ParsedHTML extends React.Component {
        constructor(...args) {
          super(...args);
          this.ref = React.createRef();
        }
        updateInternalState() {
          const { children, content } = this.props;
          const ref = this.ref && this.ref.current;
          if (!children && !content) {
            return d > 1 && console.warn("Emoji: No content passed.");
          }
          if (ref) {
            if (ref.childNodes.length) {
              while (ref.firstChild) {
                ref.removeChild(ref.firstChild);
              }
            }
            ref.appendChild(parseHTML(children || content));
          }
        }
        shouldComponentUpdate(nextProps) {
          return nextProps && (nextProps.children !== this.props.children || nextProps.content !== this.props.content);
        }
        componentDidUpdate() {
          this.updateInternalState();
        }
        componentDidMount() {
          this.updateInternalState();
        }
        render() {
          const { className, onClick, tag } = this.props;
          return React.createElement(tag || "span", {
            ref: this.ref,
            className: className,
            onClick: onClick
          });
        }
      }
      const reactStringWrap = (src, find, WrapClass, wrapProps) => {
        const endTag = find.replace("[", "[/");
        return React.createElement(
          React.Fragment,
          null,
          src.split(find)[0],
          React.createElement(WrapClass, wrapProps, src.substring(src.indexOf(find) + find.length, src.indexOf(endTag))),
          src.split(endTag)[1]
        );
      };
      const OFlowEmoji = withOverflowObserver(Emoji);
      const OFlowParsedHTML = withOverflowObserver(ParsedHTML);
      const __WEBPACK_DEFAULT_EXPORT__ = {
        RenderTo,
        SoonFcWrap: _chat_mixins0__.M9,
        OFlowEmoji,
        OFlowParsedHTML
      };

      /***/
    },

    /***/ 363: /***/ (module) => {
      "use strict";
      module.exports = React;

      /***/
    },

    /***/ 533: /***/ (module) => {
      "use strict";
      module.exports = ReactDOM;

      /***/
    },

    /***/ 229: /***/ (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        Z: () => _applyDecoratedDescriptor
      });
      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ("value" in desc || desc.initializer) {
          desc.writable = true;
        }
        desc = decorators
          .slice()
          .reverse()
          .reduce(function (desc, decorator) {
            return decorator(target, property, desc) || desc;
          }, desc);
        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }
        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }
        return desc;
      }

      /***/
    },

    /***/ 462: /***/ (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        Z: () => _extends
      });
      function _extends() {
        _extends = Object.assign
          ? Object.assign.bind()
          : function (target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
        return _extends.apply(this, arguments);
      }

      /***/
    }

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/ function __webpack_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId];
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ // no module.id needed
      /******/ // no module.loaded needed
      /******/ exports: {}
      /******/
    });
    /******/
    /******/ // Execute the module function
    /******/ __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }
  /******/
  /************************************************************************/
  /******/
  /******/ (() => {
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/ __webpack_require__.n = (module) => {
      /******/ var getter = module && module.__esModule ? /******/ () => module["default"] : /******/ () => module;
      /******/ __webpack_require__.d(getter, { a: getter });
      /******/ return getter;
      /******/
    };
    /******/
  })();
  /******/
  /******/
  /******/ (() => {
    /******/ // define getter functions for harmony exports
    /******/ __webpack_require__.d = (exports, definition) => {
      /******/ for (var key in definition) {
        /******/ if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
          /******/ Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/
  /******/ (() => {
    /******/ __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    /******/
  })();
  /******/
  /******/
  /******/ (() => {
    /******/ // define __esModule on exports
    /******/ __webpack_require__.r = (exports) => {
      /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
        /******/
      }
      /******/ Object.defineProperty(exports, "__esModule", { value: true });
      /******/
    };
    /******/
  })();
  /******/
  /************************************************************************/
  /******/
  /******/ // startup
  /******/ // Load entry module and return exports
  /******/ __webpack_require__(51);
  /******/ // This entry module is referenced by other modules so it can't be inlined
  /******/ var __webpack_exports__ = __webpack_require__(978);
  /******/
  /******/
})();
