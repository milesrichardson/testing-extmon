var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.arrayIteratorImpl = function (a) {
  var b = 0;
  return function () {
    return b < a.length ? { done: !1, value: a[b++] } : { done: !0 };
  };
};
$jscomp.arrayIterator = function (a) {
  return { next: $jscomp.arrayIteratorImpl(a) };
};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.SIMPLE_FROUND_POLYFILL = !1;
$jscomp.ISOLATE_POLYFILLS = !1;
$jscomp.FORCE_POLYFILL_PROMISE = !1;
$jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = !1;
$jscomp.defineProperty =
  $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties
    ? Object.defineProperty
    : function (a, b, d) {
        if (a == Array.prototype || a == Object.prototype) return a;
        a[b] = d.value;
        return a;
      };
$jscomp.getGlobal = function (a) {
  a = [
    "object" == typeof globalThis && globalThis,
    a,
    "object" == typeof window && window,
    "object" == typeof self && self,
    "object" == typeof global && global
  ];
  for (var b = 0; b < a.length; ++b) {
    var d = a[b];
    if (d && d.Math == Math) return d;
  }
  throw Error("Cannot find global object");
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.IS_SYMBOL_NATIVE = "function" === typeof Symbol && "symbol" === typeof Symbol("x");
$jscomp.TRUST_ES6_POLYFILLS = !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE;
$jscomp.polyfills = {};
$jscomp.propertyToPolyfillSymbol = {};
$jscomp.POLYFILL_PREFIX = "$jscp$";
$jscomp.polyfill = function (a, b, d, c) {
  b && ($jscomp.ISOLATE_POLYFILLS ? $jscomp.polyfillIsolated(a, b, d, c) : $jscomp.polyfillUnisolated(a, b, d, c));
};
$jscomp.polyfillUnisolated = function (a, b) {
  var d = $jscomp.global;
  a = a.split(".");
  for (var c = 0; c < a.length - 1; c++) {
    var e = a[c];
    if (!(e in d)) return;
    d = d[e];
  }
  a = a[a.length - 1];
  c = d[a];
  b = b(c);
  b != c && null != b && $jscomp.defineProperty(d, a, { configurable: !0, writable: !0, value: b });
};
$jscomp.polyfillIsolated = function (a, b, d) {
  var c = a.split("."),
    e = 1 === c.length;
  a = c[0];
  a = !e && a in $jscomp.polyfills ? $jscomp.polyfills : $jscomp.global;
  for (var f = 0; f < c.length - 1; f++) {
    var g = c[f];
    if (!(g in a)) return;
    a = a[g];
  }
  c = c[c.length - 1];
  d = $jscomp.IS_SYMBOL_NATIVE && "es6" === d ? a[c] : null;
  b = b(d);
  null != b &&
    (e
      ? $jscomp.defineProperty($jscomp.polyfills, c, { configurable: !0, writable: !0, value: b })
      : b !== d &&
        (void 0 === $jscomp.propertyToPolyfillSymbol[c] &&
          ((e = (1e9 * Math.random()) >>> 0),
          ($jscomp.propertyToPolyfillSymbol[c] = $jscomp.IS_SYMBOL_NATIVE
            ? $jscomp.global.Symbol(c)
            : $jscomp.POLYFILL_PREFIX + e + "$" + c)),
        (e = $jscomp.propertyToPolyfillSymbol[c]),
        $jscomp.defineProperty(a, e, { configurable: !0, writable: !0, value: b })));
};
$jscomp.initSymbol = function () {};
$jscomp.polyfill(
  "Symbol",
  function (a) {
    if (a) return a;
    var b = function (f, g) {
      this.$jscomp$symbol$id_ = f;
      $jscomp.defineProperty(this, "description", { configurable: !0, writable: !0, value: g });
    };
    b.prototype.toString = function () {
      return this.$jscomp$symbol$id_;
    };
    a = (1e9 * Math.random()) >>> 0;
    var d = "jscomp_symbol_" + a + "_",
      c = 0,
      e = function (f) {
        if (this instanceof e) throw new TypeError("Symbol is not a constructor");
        return new b(d + (f || "") + "_" + c++, f);
      };
    return e;
  },
  "es6",
  "es3"
);
$jscomp.polyfill(
  "Symbol.iterator",
  function (a) {
    if (a) return a;
    a = Symbol("Symbol.iterator");
    for (
      var b = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(
          " "
        ),
        d = 0;
      d < b.length;
      d++
    ) {
      var c = $jscomp.global[b[d]];
      "function" === typeof c &&
        "function" != typeof c.prototype[a] &&
        $jscomp.defineProperty(c.prototype, a, {
          configurable: !0,
          writable: !0,
          value: function () {
            return $jscomp.iteratorPrototype($jscomp.arrayIteratorImpl(this));
          }
        });
    }
    return a;
  },
  "es6",
  "es3"
);
$jscomp.iteratorPrototype = function (a) {
  a = { next: a };
  a[Symbol.iterator] = function () {
    return this;
  };
  return a;
};
$jscomp.iteratorFromArray = function (a, b) {
  a instanceof String && (a += "");
  var d = 0,
    c = !1,
    e = {
      next: function () {
        if (!c && d < a.length) {
          var f = d++;
          return { value: b(f, a[f]), done: !1 };
        }
        c = !0;
        return { done: !0, value: void 0 };
      }
    };
  e[Symbol.iterator] = function () {
    return e;
  };
  return e;
};
$jscomp.polyfill(
  "Array.prototype.keys",
  function (a) {
    return a
      ? a
      : (a = function () {
          return $jscomp.iteratorFromArray(this, function (b) {
            return b;
          });
        });
  },
  "es6",
  "es3"
);
$jscomp.makeIterator = function (a) {
  var b = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
  if (b) return b.call(a);
  if ("number" == typeof a.length) return $jscomp.arrayIterator(a);
  throw Error(String(a) + " is not an iterable or ArrayLike");
};
$jscomp.polyfill(
  "Promise",
  function (a) {
    function b() {
      this.batch_ = null;
    }
    function d(h) {
      return h instanceof f
        ? h
        : new f(function (l) {
            l(h);
          });
    }
    if (
      a &&
      (!(
        $jscomp.FORCE_POLYFILL_PROMISE ||
        ($jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION && "undefined" === typeof $jscomp.global.PromiseRejectionEvent)
      ) ||
        !$jscomp.global.Promise ||
        -1 === $jscomp.global.Promise.toString().indexOf("[native code]"))
    )
      return a;
    b.prototype.asyncExecute = function (h) {
      if (null == this.batch_) {
        this.batch_ = [];
        var l = this;
        this.asyncExecuteFunction(function () {
          l.executeBatch_();
        });
      }
      this.batch_.push(h);
    };
    var c = $jscomp.global.setTimeout;
    b.prototype.asyncExecuteFunction = function (h) {
      c(h, 0);
    };
    b.prototype.executeBatch_ = function () {
      for (; this.batch_ && this.batch_.length; ) {
        var h = this.batch_;
        this.batch_ = [];
        for (var l = 0; l < h.length; ++l) {
          var m = h[l];
          h[l] = null;
          try {
            m();
          } catch (v) {
            this.asyncThrow_(v);
          }
        }
      }
      this.batch_ = null;
    };
    b.prototype.asyncThrow_ = function (h) {
      this.asyncExecuteFunction(function () {
        throw h;
      });
    };
    var e = { PENDING: 0, FULFILLED: 1, REJECTED: 2 },
      f = function (h) {
        this.state_ = e.PENDING;
        this.result_ = void 0;
        this.onSettledCallbacks_ = [];
        this.isRejectionHandled_ = !1;
        var l = this.createResolveAndReject_();
        try {
          h(l.resolve, l.reject);
        } catch (m) {
          l.reject(m);
        }
      };
    f.prototype.createResolveAndReject_ = function () {
      function h(v) {
        return function (n) {
          m || ((m = !0), v.call(l, n));
        };
      }
      var l = this,
        m = !1;
      return { resolve: h(this.resolveTo_), reject: h(this.reject_) };
    };
    f.prototype.resolveTo_ = function (h) {
      if (h === this) this.reject_(new TypeError("A Promise cannot resolve to itself"));
      else if (h instanceof f) this.settleSameAsPromise_(h);
      else {
        a: switch (typeof h) {
          case "object":
            var l = null != h;
            break a;
          case "function":
            l = !0;
            break a;
          default:
            l = !1;
        }
        l ? this.resolveToNonPromiseObj_(h) : this.fulfill_(h);
      }
    };
    f.prototype.resolveToNonPromiseObj_ = function (h) {
      var l = void 0;
      try {
        l = h.then;
      } catch (m) {
        this.reject_(m);
        return;
      }
      "function" == typeof l ? this.settleSameAsThenable_(l, h) : this.fulfill_(h);
    };
    f.prototype.reject_ = function (h) {
      this.settle_(e.REJECTED, h);
    };
    f.prototype.fulfill_ = function (h) {
      this.settle_(e.FULFILLED, h);
    };
    f.prototype.settle_ = function (h, l) {
      if (this.state_ != e.PENDING) throw Error("Cannot settle(" + h + ", " + l + "): Promise already settled in state" + this.state_);
      this.state_ = h;
      this.result_ = l;
      this.state_ === e.REJECTED && this.scheduleUnhandledRejectionCheck_();
      this.executeOnSettledCallbacks_();
    };
    f.prototype.scheduleUnhandledRejectionCheck_ = function () {
      var h = this;
      c(function () {
        if (h.notifyUnhandledRejection_()) {
          var l = $jscomp.global.console;
          "undefined" !== typeof l && l.error(h.result_);
        }
      }, 1);
    };
    f.prototype.notifyUnhandledRejection_ = function () {
      if (this.isRejectionHandled_) return !1;
      var h = $jscomp.global.CustomEvent,
        l = $jscomp.global.Event,
        m = $jscomp.global.dispatchEvent;
      if ("undefined" === typeof m) return !0;
      "function" === typeof h
        ? (h = new h("unhandledrejection", { cancelable: !0 }))
        : "function" === typeof l
        ? (h = new l("unhandledrejection", { cancelable: !0 }))
        : ((h = $jscomp.global.document.createEvent("CustomEvent")), h.initCustomEvent("unhandledrejection", !1, !0, h));
      h.promise = this;
      h.reason = this.result_;
      return m(h);
    };
    f.prototype.executeOnSettledCallbacks_ = function () {
      if (null != this.onSettledCallbacks_) {
        for (var h = 0; h < this.onSettledCallbacks_.length; ++h) g.asyncExecute(this.onSettledCallbacks_[h]);
        this.onSettledCallbacks_ = null;
      }
    };
    var g = new b();
    f.prototype.settleSameAsPromise_ = function (h) {
      var l = this.createResolveAndReject_();
      h.callWhenSettled_(l.resolve, l.reject);
    };
    f.prototype.settleSameAsThenable_ = function (h, l) {
      var m = this.createResolveAndReject_();
      try {
        h.call(l, m.resolve, m.reject);
      } catch (v) {
        m.reject(v);
      }
    };
    f.prototype.then = function (h, l) {
      function m(r, x) {
        return "function" == typeof r
          ? function (y) {
              try {
                v(r(y));
              } catch (k) {
                n(k);
              }
            }
          : x;
      }
      var v,
        n,
        q = new f(function (r, x) {
          v = r;
          n = x;
        });
      this.callWhenSettled_(m(h, v), m(l, n));
      return q;
    };
    f.prototype.catch = function (h) {
      return this.then(void 0, h);
    };
    f.prototype.callWhenSettled_ = function (h, l) {
      function m() {
        switch (v.state_) {
          case e.FULFILLED:
            h(v.result_);
            break;
          case e.REJECTED:
            l(v.result_);
            break;
          default:
            throw Error("Unexpected state: " + v.state_);
        }
      }
      var v = this;
      null == this.onSettledCallbacks_ ? g.asyncExecute(m) : this.onSettledCallbacks_.push(m);
      this.isRejectionHandled_ = !0;
    };
    f.resolve = d;
    f.reject = function (h) {
      return new f(function (l, m) {
        m(h);
      });
    };
    f.race = function (h) {
      return new f(function (l, m) {
        for (var v = $jscomp.makeIterator(h), n = v.next(); !n.done; n = v.next()) d(n.value).callWhenSettled_(l, m);
      });
    };
    f.all = function (h) {
      var l = $jscomp.makeIterator(h),
        m = l.next();
      return m.done
        ? d([])
        : new f(function (v, n) {
            function q(y) {
              return function (k) {
                r[y] = k;
                x--;
                0 == x && v(r);
              };
            }
            var r = [],
              x = 0;
            do r.push(void 0), x++, d(m.value).callWhenSettled_(q(r.length - 1), n), (m = l.next());
            while (!m.done);
          });
    };
    return f;
  },
  "es6",
  "es3"
);
$jscomp.polyfill(
  "Promise.prototype.finally",
  function (a) {
    return a
      ? a
      : (a = function (b) {
          return this.then(
            function (d) {
              var c = Promise.resolve(b());
              return c.then(function () {
                return d;
              });
            },
            function (d) {
              var c = Promise.resolve(b());
              return c.then(function () {
                throw d;
              });
            }
          );
        });
  },
  "es9",
  "es3"
);
$jscomp.findInternal = function (a, b, d) {
  a instanceof String && (a = String(a));
  for (var c = a.length, e = 0; e < c; e++) {
    var f = a[e];
    if (b.call(d, f, e, a)) return { i: e, v: f };
  }
  return { i: -1, v: void 0 };
};
$jscomp.polyfill(
  "Array.prototype.find",
  function (a) {
    return a
      ? a
      : (a = function (b, d) {
          return $jscomp.findInternal(this, b, d).v;
        });
  },
  "es6",
  "es3"
); /*

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/
var goog = goog || {};
goog.global = this || self;
goog.exportPath_ = function (a, b, d, c) {
  a = a.split(".");
  c = c || goog.global;
  a[0] in c || "undefined" == typeof c.execScript || c.execScript("var " + a[0]);
  for (var e; a.length && (e = a.shift()); )
    if (a.length || void 0 === b) c = c[e] && c[e] !== Object.prototype[e] ? c[e] : (c[e] = {});
    else if (!d && goog.isObject(b) && goog.isObject(c[e])) for (var f in b) b.hasOwnProperty(f) && (c[e][f] = b[f]);
    else c[e] = b;
};
goog.define = function (a, b) {
  return (a = b);
};
goog.FEATURESET_YEAR = 2012;
goog.DEBUG = !0;
goog.LOCALE = "en";
goog.TRUSTED_SITE = !0;
goog.DISALLOW_TEST_ONLY_CODE = !goog.DEBUG;
goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = !1;
goog.readFlagInternalDoNotUseOrElse = function (a, b) {
  var d = goog.getObjectByName(goog.FLAGS_OBJECT_);
  a = d && d[a];
  return null != a ? a : b;
};
goog.FLAGS_OBJECT_ = "CLOSURE_FLAGS";
goog.FLAGS_STAGING_DEFAULT = !0;
goog.readToggleInternalDoNotCallDirectly = function (a) {
  var b = "object" === typeof CLOSURE_TOGGLE_ORDINALS ? CLOSURE_TOGGLE_ORDINALS : void 0;
  a = b && b[a];
  return "number" !== typeof a ? !!a : !!(goog.TOGGLES_[Math.floor(a / 30)] & (1 << a % 30));
};
goog.TOGGLE_VAR_ = "_F_toggles";
goog.TOGGLES_ = goog.global[goog.TOGGLE_VAR_] || [];
goog.provide = function (a) {
  if (goog.isInModuleLoader_()) throw Error("goog.provide cannot be used within a module.");
  goog.constructNamespace_(a);
};
goog.constructNamespace_ = function (a, b, d) {
  goog.exportPath_(a, b, d);
};
goog.NONCE_PATTERN_ = /^[\w+/_-]+[=]{0,2}$/;
goog.getScriptNonce_ = function (a) {
  a = (a || goog.global).document;
  return (a = a.querySelector && a.querySelector("script[nonce]")) &&
    (a = a.nonce || a.getAttribute("nonce")) &&
    goog.NONCE_PATTERN_.test(a)
    ? a
    : "";
};
goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
goog.module = function (a) {
  if ("string" !== typeof a || !a || -1 == a.search(goog.VALID_MODULE_RE_)) throw Error("Invalid module identifier");
  if (!goog.isInGoogModuleLoader_())
    throw Error(
      "Module " +
        a +
        " has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide."
    );
  if (goog.moduleLoaderState_.moduleName) throw Error("goog.module may only be called once per module.");
  goog.moduleLoaderState_.moduleName = a;
};
goog.module.get = function (a) {
  return goog.module.getInternal_(a);
};
goog.module.getInternal_ = function () {
  return null;
};
goog.requireDynamic = function () {
  return null;
};
goog.importHandler_ = null;
goog.uncompiledChunkIdHandler_ = null;
goog.setImportHandlerInternalDoNotCallOrElse = function (a) {
  goog.importHandler_ = a;
};
goog.setUncompiledChunkIdHandlerInternalDoNotCallOrElse = function (a) {
  goog.uncompiledChunkIdHandler_ = a;
};
goog.maybeRequireFrameworkInternalOnlyDoNotCallOrElse = function () {};
goog.ModuleType = { ES6: "es6", GOOG: "goog" };
goog.moduleLoaderState_ = null;
goog.isInModuleLoader_ = function () {
  return goog.isInGoogModuleLoader_() || goog.isInEs6ModuleLoader_();
};
goog.isInGoogModuleLoader_ = function () {
  return !!goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.GOOG;
};
goog.isInEs6ModuleLoader_ = function () {
  var a = !!goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.ES6;
  return a ? !0 : (a = goog.global.$jscomp) ? ("function" != typeof a.getCurrentModulePath ? !1 : !!a.getCurrentModulePath()) : !1;
};
goog.module.declareLegacyNamespace = function () {
  goog.moduleLoaderState_.declareLegacyNamespace = !0;
};
goog.declareModuleId = function (a) {
  if (goog.moduleLoaderState_) goog.moduleLoaderState_.moduleName = a;
  else {
    var b = goog.global.$jscomp;
    if (!b || "function" != typeof b.getCurrentModulePath) throw Error('Module with namespace "' + a + '" has been loaded incorrectly.');
    b = b.require(b.getCurrentModulePath());
    goog.loadedModules_[a] = { exports: b, type: goog.ModuleType.ES6, moduleId: a };
  }
};
goog.setTestOnly = function (a) {
  if (goog.DISALLOW_TEST_ONLY_CODE)
    throw ((a = a || ""), Error("Importing test-only code into non-debug environment" + (a ? ": " + a : ".")));
};
goog.forwardDeclare = function () {};
goog.getObjectByName = function (a, b) {
  a = a.split(".");
  b = b || goog.global;
  for (var d = 0; d < a.length; d++) if (((b = b[a[d]]), null == b)) return null;
  return b;
};
goog.addDependency = function () {};
goog.ENABLE_DEBUG_LOADER = !1;
goog.logToConsole_ = function (a) {
  goog.global.console && goog.global.console.error(a);
};
goog.require = function () {};
goog.requireType = function () {
  return {};
};
goog.basePath = "";
goog.abstractMethod = function () {
  throw Error("unimplemented abstract method");
};
goog.addSingletonGetter = function (a) {
  a.instance_ = void 0;
  a.getInstance = function () {
    if (a.instance_) return a.instance_;
    goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);
    return (a.instance_ = new a());
  };
};
goog.instantiatedSingletons_ = [];
goog.LOAD_MODULE_USING_EVAL = !0;
goog.SEAL_MODULE_EXPORTS = goog.DEBUG;
goog.loadedModules_ = {};
goog.DEPENDENCIES_ENABLED = !1;
goog.TRANSPILE = "detect";
goog.ASSUME_ES_MODULES_TRANSPILED = !1;
goog.TRUSTED_TYPES_POLICY_NAME = "goog";
goog.hasBadLetScoping = null;
goog.loadModule = function (a) {
  var b = goog.moduleLoaderState_;
  try {
    goog.moduleLoaderState_ = { moduleName: "", declareLegacyNamespace: !1, type: goog.ModuleType.GOOG };
    var d = {},
      c = d;
    if ("function" === typeof a) c = a.call(void 0, c);
    else if ("string" === typeof a) c = goog.loadModuleFromSource_.call(void 0, c, a);
    else throw Error("Invalid module definition");
    var e = goog.moduleLoaderState_.moduleName;
    if ("string" === typeof e && e) {
      goog.moduleLoaderState_.declareLegacyNamespace
        ? ((a = d !== c), goog.constructNamespace_(e, c, a))
        : goog.SEAL_MODULE_EXPORTS && Object.seal && "object" == typeof c && null != c && Object.seal(c);
      var f = { exports: c, type: goog.ModuleType.GOOG, moduleId: goog.moduleLoaderState_.moduleName };
      goog.loadedModules_[e] = f;
    } else throw Error('Invalid module name "' + e + '"');
  } finally {
    goog.moduleLoaderState_ = b;
  }
};
goog.loadModuleFromSource_ = function (a, b) {
  eval(goog.CLOSURE_EVAL_PREFILTER_.createScript(b));
  return a;
};
goog.normalizePath_ = function (a) {
  a = a.split("/");
  for (var b = 0; b < a.length; ) "." == a[b] ? a.splice(b, 1) : b && ".." == a[b] && a[b - 1] && ".." != a[b - 1] ? a.splice(--b, 2) : b++;
  return a.join("/");
};
goog.loadFileSync_ = function (a) {
  if (goog.global.CLOSURE_LOAD_FILE_SYNC) return goog.global.CLOSURE_LOAD_FILE_SYNC(a);
  try {
    var b = new goog.global.XMLHttpRequest();
    b.open("get", a, !1);
    b.send();
    return 0 == b.status || 200 == b.status ? b.responseText : null;
  } catch (d) {
    return null;
  }
};
goog.typeOf = function (a) {
  var b = typeof a;
  return "object" != b ? b : a ? (Array.isArray(a) ? "array" : b) : "null";
};
goog.isArrayLike = function (a) {
  var b = goog.typeOf(a);
  return "array" == b || ("object" == b && "number" == typeof a.length);
};
goog.isDateLike = function (a) {
  return goog.isObject(a) && "function" == typeof a.getFullYear;
};
goog.isObject = function (a) {
  var b = typeof a;
  return ("object" == b && null != a) || "function" == b;
};
goog.getUid = function (a) {
  return (
    (Object.prototype.hasOwnProperty.call(a, goog.UID_PROPERTY_) && a[goog.UID_PROPERTY_]) || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_)
  );
};
goog.hasUid = function (a) {
  return !!a[goog.UID_PROPERTY_];
};
goog.removeUid = function (a) {
  null !== a && "removeAttribute" in a && a.removeAttribute(goog.UID_PROPERTY_);
  try {
    delete a[goog.UID_PROPERTY_];
  } catch (b) {}
};
goog.UID_PROPERTY_ = "closure_uid_" + ((1e9 * Math.random()) >>> 0);
goog.uidCounter_ = 0;
goog.cloneObject = function (a) {
  var b = goog.typeOf(a);
  if ("object" == b || "array" == b) {
    if ("function" === typeof a.clone) return a.clone();
    if ("undefined" !== typeof Map && a instanceof Map) return new Map(a);
    if ("undefined" !== typeof Set && a instanceof Set) return new Set(a);
    b = "array" == b ? [] : {};
    for (var d in a) b[d] = goog.cloneObject(a[d]);
    return b;
  }
  return a;
};
goog.bindNative_ = function (a, b, d) {
  return a.call.apply(a.bind, arguments);
};
goog.bindJs_ = function (a, b, d) {
  if (!a) throw Error();
  if (2 < arguments.length) {
    var c = Array.prototype.slice.call(arguments, 2);
    return function () {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, c);
      return a.apply(b, e);
    };
  }
  return function () {
    return a.apply(b, arguments);
  };
};
goog.bind = function (a, b, d) {
  Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code")
    ? (goog.bind = goog.bindNative_)
    : (goog.bind = goog.bindJs_);
  return goog.bind.apply(null, arguments);
};
goog.partial = function (a, b) {
  var d = Array.prototype.slice.call(arguments, 1);
  return function () {
    var c = d.slice();
    c.push.apply(c, arguments);
    return a.apply(this, c);
  };
};
goog.now = function () {
  return Date.now();
};
goog.globalEval = function (a) {
  (0, eval)(a);
};
goog.getCssName = function (a, b) {
  if ("." == String(a).charAt(0)) throw Error('className passed in goog.getCssName must not start with ".". You passed: ' + a);
  var d = function (e) {
      return goog.cssNameMapping_[e] || e;
    },
    c = function (e) {
      e = e.split("-");
      for (var f = [], g = 0; g < e.length; g++) f.push(d(e[g]));
      return f.join("-");
    };
  c = goog.cssNameMapping_
    ? "BY_WHOLE" == goog.cssNameMappingStyle_
      ? d
      : c
    : function (e) {
        return e;
      };
  a = b ? a + "-" + c(b) : c(a);
  return goog.global.CLOSURE_CSS_NAME_MAP_FN ? goog.global.CLOSURE_CSS_NAME_MAP_FN(a) : a;
};
goog.setCssNameMapping = function (a, b) {
  goog.cssNameMapping_ = a;
  goog.cssNameMappingStyle_ = b;
};
goog.GetMsgOptions = function () {};
goog.getMsg = function (a, b, d) {
  d && d.html && (a = a.replace(/</g, "&lt;"));
  d &&
    d.unescapeHtmlEntities &&
    (a = a
      .replace(/&lt;/g, "<")
      .replace(/&gt;/g, ">")
      .replace(/&apos;/g, "'")
      .replace(/&quot;/g, '"')
      .replace(/&amp;/g, "&"));
  b &&
    (a = a.replace(/\{\$([^}]+)}/g, function (c, e) {
      return null != b && e in b ? b[e] : c;
    }));
  return a;
};
goog.getMsgWithFallback = function (a) {
  return a;
};
goog.exportSymbol = function (a, b, d) {
  goog.exportPath_(a, b, !0, d);
};
goog.exportProperty = function (a, b, d) {
  a[b] = d;
};
goog.inherits = function (a, b) {
  function d() {}
  d.prototype = b.prototype;
  a.superClass_ = b.prototype;
  a.prototype = new d();
  a.prototype.constructor = a;
  a.base = function (c, e, f) {
    for (var g = Array(arguments.length - 2), h = 2; h < arguments.length; h++) g[h - 2] = arguments[h];
    return b.prototype[e].apply(c, g);
  };
};
goog.scope = function (a) {
  if (goog.isInModuleLoader_()) throw Error("goog.scope is not supported within a module.");
  a.call(goog.global);
};
goog.defineClass = function (a, b) {
  var d = b.constructor,
    c = b.statics;
  (d && d != Object.prototype.constructor) ||
    (d = function () {
      throw Error("cannot instantiate an interface (no constructor defined).");
    });
  d = goog.defineClass.createSealingConstructor_(d, a);
  a && goog.inherits(d, a);
  delete b.constructor;
  delete b.statics;
  goog.defineClass.applyProperties_(d.prototype, b);
  null != c && (c instanceof Function ? c(d) : goog.defineClass.applyProperties_(d, c));
  return d;
};
goog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG;
goog.defineClass.createSealingConstructor_ = function (a) {
  if (!goog.defineClass.SEAL_CLASS_INSTANCES) return a;
  var b = function () {
    var d = a.apply(this, arguments) || this;
    d[goog.UID_PROPERTY_] = d[goog.UID_PROPERTY_];
    return d;
  };
  return b;
};
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ =
  "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
goog.defineClass.applyProperties_ = function (a, b) {
  for (var d in b) Object.prototype.hasOwnProperty.call(b, d) && (a[d] = b[d]);
  for (var c = 0; c < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; c++)
    (d = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[c]), Object.prototype.hasOwnProperty.call(b, d) && (a[d] = b[d]);
};
goog.identity_ = function (a) {
  return a;
};
goog.createTrustedTypesPolicy = function (a) {
  var b = null,
    d = goog.global.trustedTypes;
  if (!d || !d.createPolicy) return b;
  try {
    b = d.createPolicy(a, { createHTML: goog.identity_, createScript: goog.identity_, createScriptURL: goog.identity_ });
  } catch (c) {
    goog.logToConsole_(c.message);
  }
  return b;
}; /*
 AngularJS Material Design
 https://github.com/angular/material
 @license MIT
 v1.1.20
*/
var ngmaterial = {};
DetectNgTouch.$inject = ["$log", "$injector"];
MdCoreConfigure.$inject = ["$provide", "$mdThemingProvider"];
rAFDecorator.$inject = ["$delegate"];
qDecorator.$inject = ["$delegate"];
angular
  .module(
    "material.core",
    "ngAnimate material.core.animate material.core.layout material.core.interaction material.core.gestures material.core.theming".split(" ")
  )
  .config(MdCoreConfigure)
  .run(DetectNgTouch);
function DetectNgTouch(a, b) {
  b.has("$swipe") &&
    a.warn(
      "You are using the ngTouch module. \nAngularJS Material already has mobile click, tap, and swipe support... \nngTouch is not supported with AngularJS Material!"
    );
}
function MdCoreConfigure(a, b) {
  a.decorator("$$rAF", ["$delegate", rAFDecorator]);
  a.decorator("$q", ["$delegate", qDecorator]);
  b.theme("default").primaryPalette("indigo").accentPalette("pink").warnPalette("deep-orange").backgroundPalette("grey");
}
function rAFDecorator(a) {
  a.throttle = function (b) {
    var d, c, e, f;
    return function () {
      d = arguments;
      f = this;
      e = b;
      c ||
        ((c = !0),
        a(function () {
          e.apply(f, Array.prototype.slice.call(d));
          c = !1;
        }));
    };
  };
  return a;
}
function qDecorator(a) {
  a.resolve || (a.resolve = a.when);
  return a;
}
MdAutofocusDirective.$inject = ["$parse"];
angular
  .module("material.core")
  .directive("mdAutofocus", MdAutofocusDirective)
  .directive("mdAutoFocus", MdAutofocusDirective)
  .directive("mdSidenavFocus", MdAutofocusDirective);
function MdAutofocusDirective(a) {
  function b(d, c, e) {
    function f(g) {
      angular.isUndefined(g) && (g = !0);
      c.toggleClass("md-autofocus", !!g);
    }
    e = e.mdAutoFocus || e.mdAutofocus || e.mdSidenavFocus;
    f(a(e)(d));
    e && d.$watch(e, f);
  }
  return { restrict: "A", link: { pre: b } };
}
angular.module("material.core").factory("$mdColorUtil", ColorUtilFactory);
function ColorUtilFactory() {
  function a(e) {
    var f = "#" === e[0] ? e.substr(1) : e;
    e = f.length / 3;
    var g = f.substr(0, e),
      h = f.substr(e, e);
    f = f.substr(2 * e);
    1 === e && ((g += g), (h += h), (f += f));
    return "rgba(" + parseInt(g, 16) + "," + parseInt(h, 16) + "," + parseInt(f, 16) + ",0.1)";
  }
  function b(e) {
    e =
      (e = e.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === e.length
        ? "#" +
          ("0" + parseInt(e[1], 10).toString(16)).slice(-2) +
          ("0" + parseInt(e[2], 10).toString(16)).slice(-2) +
          ("0" + parseInt(e[3], 10).toString(16)).slice(-2)
        : "";
    return e.toUpperCase();
  }
  function d(e) {
    return e.replace(")", ", 0.1)").replace("(", "a(");
  }
  function c(e) {
    return e ? e.replace("rgba", "rgb").replace(/,[^),]+\)/, ")") : "rgb(0,0,0)";
  }
  return { rgbaToHex: b, hexToRgba: a, rgbToRgba: d, rgbaToRgb: c };
}
angular.module("material.core").factory("$mdConstant", MdConstantFactory);
function MdConstantFactory() {
  function a(l) {
    var m = e + "-" + l;
    m = b(m);
    var v = m.charAt(0).toLowerCase() + m.substring(1);
    return angular.isDefined(c.style[l]) ? l : angular.isDefined(c.style[m]) ? m : angular.isDefined(c.style[v]) ? v : l;
  }
  function b(l) {
    return l.replace(g, function (m, v, n, q) {
      return q ? n.toUpperCase() : n;
    });
  }
  function d(l) {
    var m,
      v = /^(Moz|webkit|ms)(?=[A-Z])/;
    for (m in l.style) if ((l = v.exec(m))) return l[0];
  }
  var c = document.createElement("div"),
    e = d(c),
    f = /webkit/i.test(e),
    g = /([:\-_]+(.))/g,
    h = {
      isInputKey: function (l) {
        return 31 <= l.keyCode && 90 >= l.keyCode;
      },
      isNumPadKey: function (l) {
        return 3 === l.location && 97 <= l.keyCode && 105 >= l.keyCode;
      },
      isMetaKey: function (l) {
        return 91 <= l.keyCode && 93 >= l.keyCode;
      },
      isFnLockKey: function (l) {
        return 112 <= l.keyCode && 145 >= l.keyCode;
      },
      isNavigationKey: function (l) {
        var m = h.KEY_CODE;
        m = [m.SPACE, m.ENTER, m.UP_ARROW, m.DOWN_ARROW];
        return -1 != m.indexOf(l.keyCode);
      },
      hasModifierKey: function (l) {
        return l.ctrlKey || l.metaKey || l.altKey;
      },
      ELEMENT_MAX_PIXELS: 1533917,
      BEFORE_NG_ARIA: 210,
      KEY_CODE: {
        COMMA: 188,
        SEMICOLON: 186,
        ENTER: 13,
        ESCAPE: 27,
        SPACE: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT_ARROW: 37,
        UP_ARROW: 38,
        RIGHT_ARROW: 39,
        DOWN_ARROW: 40,
        TAB: 9,
        BACKSPACE: 8,
        DELETE: 46
      },
      CSS: {
        TRANSITIONEND: "transitionend" + (f ? " webkitTransitionEnd" : ""),
        ANIMATIONEND: "animationend" + (f ? " webkitAnimationEnd" : ""),
        TRANSFORM: a("transform"),
        TRANSFORM_ORIGIN: a("transformOrigin"),
        TRANSITION: a("transition"),
        TRANSITION_DURATION: a("transitionDuration"),
        ANIMATION_PLAY_STATE: a("animationPlayState"),
        ANIMATION_DURATION: a("animationDuration"),
        ANIMATION_NAME: a("animationName"),
        ANIMATION_TIMING: a("animationTimingFunction"),
        ANIMATION_DIRECTION: a("animationDirection")
      },
      MEDIA: {
        xs: "(max-width: 599px)",
        "gt-xs": "(min-width: 600px)",
        sm: "(min-width: 600px) and (max-width: 959px)",
        "gt-sm": "(min-width: 960px)",
        md: "(min-width: 960px) and (max-width: 1279px)",
        "gt-md": "(min-width: 1280px)",
        lg: "(min-width: 1280px) and (max-width: 1919px)",
        "gt-lg": "(min-width: 1920px)",
        xl: "(min-width: 1920px)",
        landscape: "(orientation: landscape)",
        portrait: "(orientation: portrait)",
        print: "print"
      },
      MEDIA_PRIORITY: "xl gt-lg lg gt-md md gt-sm sm gt-xs xs landscape portrait print".split(" ")
    };
  return h;
}
angular.module("material.core").config([
  "$provide",
  function (a) {
    a.decorator("$mdUtil", [
      "$delegate",
      function (b) {
        b.iterator = MdIterator;
        return b;
      }
    ]);
  }
]);
function MdIterator(a, b) {
  function d() {
    return [].concat(p);
  }
  function c() {
    return p.length;
  }
  function e(t) {
    return p.length && -1 < t && t < p.length;
  }
  function f(t) {
    return t ? e(n(t) + 1) : !1;
  }
  function g(t) {
    return t ? e(n(t) - 1) : !1;
  }
  function h(t) {
    return e(t) ? p[t] : null;
  }
  function l(t, H) {
    return p.filter(function (A) {
      return A[t] === H;
    });
  }
  function m(t, H) {
    if (!t) return -1;
    angular.isNumber(H) || (H = p.length);
    p.splice(H, 0, t);
    return n(t);
  }
  function v(t) {
    q(t) && p.splice(n(t), 1);
  }
  function n(t) {
    return p.indexOf(t);
  }
  function q(t) {
    return t && -1 < n(t);
  }
  function r() {
    return p.length ? p[0] : null;
  }
  function x() {
    return p.length ? p[p.length - 1] : null;
  }
  function y(t, H, A, w) {
    A = A || k;
    for (H = n(H); ; ) {
      if (!e(H)) return null;
      H += t ? -1 : 1;
      var B = null;
      e(H) ? (B = p[H]) : b && ((B = t ? x() : r()), (H = n(B)));
      if (null === B || H === w) return null;
      if (A(B)) return B;
      angular.isUndefined(w) && (w = H);
    }
  }
  var k = function () {
    return !0;
  };
  a && !angular.isArray(a) && (a = Array.prototype.slice.call(a));
  b = !!b;
  var p = a || [];
  return {
    items: d,
    count: c,
    inRange: e,
    contains: q,
    indexOf: n,
    itemAt: h,
    findBy: l,
    add: m,
    remove: v,
    first: r,
    last: x,
    next: angular.bind(null, y, !1),
    previous: angular.bind(null, y, !0),
    hasPrevious: g,
    hasNext: f
  };
}
mdMediaFactory.$inject = ["$mdConstant", "$rootScope", "$window"];
angular.module("material.core").factory("$mdMedia", mdMediaFactory);
function mdMediaFactory(a, b, d) {
  function c(r) {
    var x = m[r];
    angular.isUndefined(x) && ((x = r), (x = a.MEDIA[x] || ("(" !== x.charAt(0) ? "(" + x + ")" : x)), (x = m[r] = x));
    r = n[x];
    angular.isUndefined(r) && ((r = v[x]) || (r = v[x] = d.matchMedia(x)), r.addListener(e), (r = n[r.media] = !!r.matches));
    return r;
  }
  function e(r) {
    b.$evalAsync(function () {
      n[r.media] = !!r.matches;
    });
  }
  function f(r) {
    return v[r];
  }
  function g(r, x) {
    for (var y = 0; y < a.MEDIA_PRIORITY.length; y++) {
      var k = a.MEDIA_PRIORITY[y];
      if (v[m[k]].matches && ((k = l(r, x + "-" + k)), r[k])) return r[k];
    }
    return r[l(r, x)];
  }
  function h(r, x, y) {
    var k = [];
    r.forEach(function (p) {
      var t = l(x, p);
      angular.isDefined(x[t]) && k.push(x.$observe(t, angular.bind(void 0, y, null)));
      for (var H in a.MEDIA) (t = l(x, p + "-" + H)), angular.isDefined(x[t]) && k.push(x.$observe(t, angular.bind(void 0, y, H)));
    });
    return function () {
      k.forEach(function (p) {
        p();
      });
    };
  }
  function l(r, x) {
    return q[x] || (q[x] = r.$normalize(x));
  }
  var m = {},
    v = {},
    n = {},
    q = {};
  c.getResponsiveAttribute = g;
  c.getQuery = f;
  c.watchResponsiveAttributes = h;
  return c;
}
angular.module("material.core").config([
  "$provide",
  function (a) {
    a.decorator("$mdUtil", [
      "$delegate",
      function (b) {
        b.prefixer = MdPrefixer;
        return b;
      }
    ]);
  }
]);
function MdPrefixer(a, b) {
  function d(l) {
    l = angular.isArray(l) ? l : [l];
    l.forEach(function (m) {
      h.forEach(function (v) {
        l.push(v + "-" + m);
      });
    });
    return l;
  }
  function c(l) {
    l = angular.isArray(l) ? l : [l];
    return d(l)
      .map(function (m) {
        return "[" + m + "]";
      })
      .join(",");
  }
  function e(l, m) {
    l = g(l);
    if (!l) return !1;
    m = d(m);
    for (var v = 0; v < m.length; v++) if (l.hasAttribute(m[v])) return !0;
    return !1;
  }
  function f(l, m) {
    (l = g(l)) &&
      d(m).forEach(function (v) {
        l.removeAttribute(v);
      });
  }
  function g(l) {
    l = l[0] || l;
    if (l.nodeType) return l;
  }
  var h = ["data", "x"];
  return a ? (b ? c(a) : d(a)) : { buildList: d, buildSelector: c, hasAttribute: e, removeAttribute: f };
}
UtilFactory.$inject = "$document $timeout $compile $rootScope $$mdAnimate $interpolate $log $rootElement $window $$rAF".split(" ");
var nextUniqueId = 0,
  isIos,
  isAndroid;
if (window.navigator) {
  var userAgent = window.navigator.userAgent || window.navigator.vendor || window.opera;
  isIos = userAgent.match(/ipad|iphone|ipod/i);
  isAndroid = userAgent.match(/android/i);
}
angular.module("material.core").factory("$mdUtil", UtilFactory);
function UtilFactory(a, b, d, c, e, f, g, h, l, m) {
  function v(k) {
    return k ? (-1 < String(k).indexOf("px") || -1 < String(k).indexOf("%") ? k : k + "px") : "0";
  }
  var n = f.startSymbol(),
    q = f.endSymbol(),
    r = "{{" === n && "}}" === q;
  document.contains ||
    (document.contains = function (k) {
      return document.body.contains(k);
    });
  var x = function (k, p, t) {
      var H = !1;
      k && k.length && ((k = l.getComputedStyle(k[0])), (H = angular.isDefined(k[p]) && (t ? k[p] == t : !0)));
      return H;
    },
    y = {
      dom: {},
      isIos: isIos,
      isAndroid: isAndroid,
      now:
        window.performance && window.performance.now
          ? angular.bind(window.performance, window.performance.now)
          : Date.now ||
            function () {
              return new Date().getTime();
            },
      getModelOption: function (k, p) {
        if (k.$options) return (k = k.$options), k.getOption ? k.getOption(p) : k[p];
      },
      isRtl: function (k) {
        k = angular.isDefined(k) && k.hasOwnProperty("dir") && k.dir;
        switch (k) {
          case "ltr":
            return !1;
          case "rtl":
            return !0;
        }
        return "rtl" === a[0].dir || "rtl" === a[0].body.dir;
      },
      bidi: function (k, p, t, H) {
        var A = !this.isRtl();
        if (0 == arguments.length) return A ? "ltr" : "rtl";
        var w = angular.element(k);
        A && angular.isDefined(t) ? w.css(p, v(t)) : !A && angular.isDefined(H) && w.css(p, v(H));
      },
      bidiProperty: function (k, p, t, H) {
        var A = !this.isRtl();
        k = angular.element(k);
        A && angular.isDefined(p) ? (k.css(p, v(H)), k.css(t, "")) : !A && angular.isDefined(t) && (k.css(t, v(H)), k.css(p, ""));
      },
      clientRect: function (k, p, t) {
        k = k[0] || k;
        p = p || k.offsetParent || document.body;
        p = p[0] || p;
        k = k.getBoundingClientRect();
        t = t ? p.getBoundingClientRect() : { left: 0, top: 0, width: 0, height: 0 };
        return { left: k.left - t.left, top: k.top - t.top, width: k.width, height: k.height };
      },
      offsetRect: function (k, p) {
        return y.clientRect(k, p, !0);
      },
      nodesToArray: function (k) {
        k = k || [];
        for (var p = [], t = 0; t < k.length; ++t) p.push(k.item(t));
        return p;
      },
      getViewportTop: function () {
        return y.disableScrollAround._count && y.disableScrollAround._viewPortTop
          ? y.disableScrollAround._viewPortTop
          : l.scrollY || l.pageYOffset || 0;
      },
      findFocusTarget: function (k, p) {
        function t(w, B) {
          var u;
          (w = w[0].querySelectorAll(B)) &&
            w.length &&
            w.length &&
            angular.forEach(w, function (z) {
              z = angular.element(z);
              var D = z.hasClass("md-autofocus");
              D && (u = z);
            });
          return u;
        }
        var H = this.prefixer("md-autofocus", !0);
        var A = t(k, p || H);
        A || p == H || (A = t(k, this.prefixer("md-auto-focus", !0))) || (A = t(k, H));
        return A;
      },
      disableScrollAround: function (k, p, t) {
        function H(z, D) {
          function G(C) {
            C.preventDefault();
          }
          z = angular.element(z || w);
          if (D.disableScrollMask) var N = z;
          else (N = angular.element('<div class="md-scroll-mask">  <div class="md-scroll-mask-bar"></div></div>')), z.append(N);
          N.on("wheel touchmove", G);
          return function () {
            N.off("wheel touchmove", G);
            !D.disableScrollMask && N[0].parentNode && N[0].parentNode.removeChild(N[0]);
          };
        }
        function A() {
          var z = a[0].documentElement,
            D = z.style.cssText || "",
            G = w.style.cssText || "",
            N = y.getViewportTop();
          y.disableScrollAround._viewPortTop = N;
          var C = w.clientWidth,
            F = w.scrollHeight > w.clientHeight + 1,
            O = 0 < z.scrollTop ? z : w;
          F && angular.element(w).css({ position: "fixed", width: "100%", top: -N + "px" });
          w.clientWidth < C && (w.style.overflow = "hidden");
          return function () {
            w.style.cssText = G;
            z.style.cssText = D;
            O.scrollTop = N;
          };
        }
        t = t || {};
        y.disableScrollAround._count = Math.max(0, y.disableScrollAround._count || 0);
        y.disableScrollAround._count++;
        if (y.disableScrollAround._restoreScroll) return y.disableScrollAround._restoreScroll;
        var w = a[0].body,
          B = A(),
          u = H(p, t);
        return (y.disableScrollAround._restoreScroll = function () {
          0 >= --y.disableScrollAround._count &&
            (delete y.disableScrollAround._viewPortTop, B(), u(), delete y.disableScrollAround._restoreScroll);
        });
      },
      enableScrolling: function () {
        var k = this.disableScrollAround._restoreScroll;
        k && k();
      },
      floatingScrollbars: function () {
        if (void 0 === this.floatingScrollbars.cached) {
          var k = angular
            .element("<div><div></div></div>")
            .css({ width: "100%", "z-index": -1, position: "absolute", height: "35px", "overflow-y": "scroll" });
          k.children().css("height", "60px");
          a[0].body.appendChild(k[0]);
          this.floatingScrollbars.cached = k[0].offsetWidth == k[0].childNodes[0].offsetWidth;
          k.remove();
        }
        return this.floatingScrollbars.cached;
      },
      forceFocus: function (k) {
        var p = k[0] || k;
        document.addEventListener(
          "click",
          function A(H) {
            H.target === p && H.$focus && (p.focus(), H.stopImmediatePropagation(), H.preventDefault(), p.removeEventListener("click", A));
          },
          !0
        );
        k = document.createEvent("MouseEvents");
        k.initMouseEvent("click", !1, !0, window, {}, 0, 0, 0, 0, !1, !1, !1, !1, 0, null);
        k.$material = !0;
        k.$focus = !0;
        p.dispatchEvent(k);
      },
      createBackdrop: function (k, p) {
        return d(y.supplant('<md-backdrop class="{0}">', [p]))(k);
      },
      supplant: function (k, p, t) {
        t = t || /\{([^{}]*)\}/g;
        return k.replace(t, function (H, A) {
          A = A.split(".");
          var w = p;
          try {
            for (var B in A) A.hasOwnProperty(B) && (w = w[A[B]]);
          } catch (u) {
            w = H;
          }
          return "string" === typeof w || "number" === typeof w ? w : H;
        });
      },
      fakeNgModel: function () {
        return {
          $fake: !0,
          $setTouched: angular.noop,
          $setViewValue: function (k) {
            this.$viewValue = k;
            this.$render(k);
            this.$viewChangeListeners.forEach(function (p) {
              p();
            });
          },
          $isEmpty: function (k) {
            return 0 === ("" + k).length;
          },
          $parsers: [],
          $formatters: [],
          $viewChangeListeners: [],
          $render: angular.noop
        };
      },
      debounce: function (k, p, t, H) {
        var A;
        return function () {
          var w = t,
            B = Array.prototype.slice.call(arguments);
          b.cancel(A);
          A = b(
            function () {
              A = void 0;
              k.apply(w, B);
            },
            p || 10,
            H
          );
        };
      },
      throttle: function (k, p) {
        var t;
        return function () {
          var H = this,
            A = arguments,
            w = y.now();
          if (!t || w - t > p) k.apply(H, A), (t = w);
        };
      },
      time: function (k) {
        var p = y.now();
        k();
        return y.now() - p;
      },
      valueOnUse: function (k, p, t) {
        var H = null,
          A = Array.prototype.slice.call(arguments),
          w = 3 < A.length ? A.slice(3) : [];
        Object.defineProperty(k, p, {
          get: function () {
            null === H && (H = t.apply(k, w));
            return H;
          }
        });
      },
      nextUid: function () {
        return "" + nextUniqueId++;
      },
      disconnectScope: function (k) {
        if (k && k.$root !== k && !k.$$destroyed) {
          var p = k.$parent;
          k.$$disconnected = !0;
          p.$$childHead === k && (p.$$childHead = k.$$nextSibling);
          p.$$childTail === k && (p.$$childTail = k.$$prevSibling);
          k.$$prevSibling && (k.$$prevSibling.$$nextSibling = k.$$nextSibling);
          k.$$nextSibling && (k.$$nextSibling.$$prevSibling = k.$$prevSibling);
          k.$$nextSibling = k.$$prevSibling = null;
        }
      },
      reconnectScope: function (k) {
        if (k && k.$root !== k && k.$$disconnected) {
          var p = k.$parent;
          k.$$disconnected = !1;
          k.$$prevSibling = p.$$childTail;
          p.$$childHead ? ((p.$$childTail.$$nextSibling = k), (p.$$childTail = k)) : (p.$$childHead = p.$$childTail = k);
        }
      },
      getClosest: function (k, p, t) {
        if (angular.isString(p)) {
          var H = p.toUpperCase();
          p = function (A) {
            return A.nodeName.toUpperCase() === H;
          };
        }
        k instanceof angular.element && (k = k[0]);
        t && (k = k.parentNode);
        if (!k) return null;
        do if (p(k)) return k;
        while ((k = k.parentNode));
        return null;
      },
      elementContains: function (k, p) {
        var t = window.Node && window.Node.prototype && Node.prototype.contains;
        t = t
          ? angular.bind(k, k.contains)
          : angular.bind(k, function (H) {
              return k === p || !!(this.compareDocumentPosition(H) & 16);
            });
        return t(p);
      },
      extractElementByName: function (k, p, t, H) {
        function A(B) {
          var u;
          a: {
            if ((u = B))
              for (var z = 0, D = u.length; z < D; z++)
                if (u[z].nodeName.toLowerCase() === p) {
                  u = u[z];
                  break a;
                }
            u = null;
          }
          if (!u) {
            if (t) {
              if (B)
                for (u = 0, z = B.length; u < z; u++)
                  if (((D = B[u]), !C)) for (var G = 0, N = D.childNodes.length; G < N; G++) var C = C || A([D.childNodes[G]]);
            } else C = null;
            u = C;
          }
          return u;
        }
        var w = A(k);
        !w && H && g.warn(y.supplant("Unable to find node '{0}' in element '{1}'.", [p, k[0].outerHTML]));
        return angular.element(w || k);
      },
      initOptionalProperties: function (k, p, t) {
        t = t || {};
        angular.forEach(k.$$isolateBindings, function (H, A) {
          H.optional && angular.isUndefined(k[A]) && ((H = angular.isDefined(p[H.attrName])), (k[A] = angular.isDefined(t[A]) ? t[A] : H));
        });
      },
      nextTick: function (k, p, t) {
        function H() {
          var u = A.queue,
            z = A.digest;
          A.queue = [];
          A.timeout = null;
          A.digest = !1;
          u.forEach(function (D) {
            var G = D.scope && D.scope.$$destroyed;
            G || D.callback();
          });
          z && c.$digest();
        }
        var A = y.nextTick,
          w = A.timeout,
          B = A.queue || [];
        B.push({ scope: t, callback: k });
        null == p && (p = !0);
        A.digest = A.digest || p;
        A.queue = B;
        return w || (A.timeout = b(H, 0, !1));
      },
      processTemplate: function (k) {
        return r ? k : k && angular.isString(k) ? k.replace(/\{\{/g, n).replace(/}}/g, q) : k;
      },
      getParentWithPointerEvents: function (k) {
        for (k = k.parent(); x(k, "pointer-events", "none"); ) k = k.parent();
        return k;
      },
      getNearestContentElement: function (k) {
        for (k = k.parent()[0]; k && k !== h[0] && k !== document.body && "MD-CONTENT" !== k.nodeName.toUpperCase(); ) k = k.parentNode;
        return k;
      },
      checkStickySupport: function () {
        var k = angular.element("<div>");
        a[0].body.appendChild(k[0]);
        for (var p = ["sticky", "-webkit-sticky"], t = 0; t < p.length; ++t)
          if ((k.css({ position: p[t], top: 0, "z-index": 2 }), k.css("position") == p[t])) {
            var H = p[t];
            break;
          }
        k.remove();
        return H;
      },
      parseAttributeBoolean: function (k, p) {
        return "" === k || (!!k && (!1 === p || ("false" !== k && "0" !== k)));
      },
      hasComputedStyle: x,
      isParentFormSubmitted: function (k) {
        return (k = (k = y.getClosest(k, "form")) ? angular.element(k).controller("form") : null) ? k.$submitted : !1;
      },
      animateScrollTo: function (k, p, t) {
        function H() {
          var z = t || 1e3;
          var D = y.now() - u;
          D > z ? (z = A + w) : ((z = (D /= z) * D), (D *= z), (z = A + w * (-2 * D + 3 * z)));
          k.scrollTop = z;
          (B ? z < p : z > p) && m(H);
        }
        var A = k.scrollTop,
          w = p - A,
          B = A < p,
          u = y.now();
        m(H);
      },
      uniq: function (k) {
        if (k)
          return k.filter(function (p, t, H) {
            return H.indexOf(p) === t;
          });
      },
      getInnerHTML: function (k) {
        var p = new XMLSerializer();
        return Array.prototype.map
          .call(k.childNodes, function (t) {
            return p.serializeToString(t);
          })
          .join("");
      },
      getOuterHTML: function (k) {
        var p = new XMLSerializer();
        return p.serializeToString(k);
      },
      msie: window.document.documentMode
    };
  y.dom.animator = e(y);
  return y;
}
angular.element.prototype.focus =
  angular.element.prototype.focus ||
  function () {
    this.length && this[0].focus();
    return this;
  };
angular.element.prototype.blur =
  angular.element.prototype.blur ||
  function () {
    this.length && this[0].blur();
    return this;
  };
MdAriaService.$inject = ["$$rAF", "$log", "$window", "$interpolate"];
angular.module("material.core").provider("$mdAria", MdAriaProvider);
function MdAriaProvider() {
  function a() {
    b.showWarnings = !1;
  }
  var b = { showWarnings: !0 };
  return {
    disableWarnings: a,
    $get: [
      "$$rAF",
      "$log",
      "$window",
      "$interpolate",
      function (d, c, e, f) {
        return MdAriaService.apply(b, arguments);
      }
    ]
  };
}
function MdAriaService(a, b, d, c) {
  function e(q, r, x) {
    var y = angular.element(q)[0] || q,
      k;
    if ((k = y)) {
      if (!(k = y.hasAttribute(r) && 0 !== y.getAttribute(r).length)) {
        var p = y;
        k = r;
        var t = p.hasChildNodes(),
          H = !1;
        if (t)
          for (p = p.childNodes, t = 0; t < p.length; t++) {
            var A = p[t];
            1 === A.nodeType &&
              A.hasAttribute(k) &&
              ((A = A.currentStyle ? A.currentStyle : d.getComputedStyle(A)), (A = "none" === A.display) || (H = !0));
          }
        k = H;
      }
      k = !k;
    }
    k &&
      ((x = angular.isString(x) ? x.trim() : ""),
      x.length ? q.attr(r, x) : n && b.warn('ARIA: Attribute "', r, '", required for accessibility, is missing on node:', y));
  }
  function f(q, r, x) {
    a(function () {
      e(q, r, x());
    });
  }
  function g(q, r) {
    var x = l(q) || "",
      y = -1 < x.indexOf(c.startSymbol());
    y
      ? f(q, r, function () {
          return l(q);
        })
      : e(q, r, x);
  }
  function h(q, r) {
    var x = l(q),
      y = -1 < x.indexOf(c.startSymbol());
    y || x || e(q, r, x);
  }
  function l(q) {
    q = q[0] || q;
    for (var r = document.createTreeWalker(q, NodeFilter.SHOW_TEXT, null, !1), x = "", y; (y = r.nextNode()); ) {
      var k;
      a: {
        for (k = y; k.parentNode && (k = k.parentNode) !== q; )
          if (k.getAttribute && "true" === k.getAttribute("aria-hidden")) {
            k = !0;
            break a;
          }
        k = void 0;
      }
      k || (x += y.textContent);
    }
    return x.trim() || "";
  }
  function m(q) {
    q = angular.element(q)[0] || q;
    return q.hasAttribute ? q.hasAttribute("aria-label") || q.hasAttribute("aria-labelledby") || q.hasAttribute("aria-describedby") : !1;
  }
  function v(q, r) {
    function x(y) {
      if (!m(y)) return !1;
      if (y.hasAttribute("role"))
        switch (y.getAttribute("role").toLowerCase()) {
          case "command":
          case "definition":
          case "directory":
          case "grid":
          case "list":
          case "listitem":
          case "log":
          case "marquee":
          case "menu":
          case "menubar":
          case "note":
          case "presentation":
          case "separator":
          case "scrollbar":
          case "status":
          case "tablist":
            return !1;
        }
      switch (y.tagName.toLowerCase()) {
        case "abbr":
        case "acronym":
        case "address":
        case "applet":
        case "audio":
        case "b":
        case "bdi":
        case "bdo":
        case "big":
        case "blockquote":
        case "br":
        case "canvas":
        case "caption":
        case "center":
        case "cite":
        case "code":
        case "col":
        case "data":
        case "dd":
        case "del":
        case "dfn":
        case "dir":
        case "div":
        case "dl":
        case "em":
        case "embed":
        case "fieldset":
        case "figcaption":
        case "font":
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
        case "hgroup":
        case "html":
        case "i":
        case "ins":
        case "isindex":
        case "kbd":
        case "keygen":
        case "label":
        case "legend":
        case "li":
        case "map":
        case "mark":
        case "menu":
        case "object":
        case "ol":
        case "output":
        case "pre":
        case "presentation":
        case "q":
        case "rt":
        case "ruby":
        case "samp":
        case "small":
        case "source":
        case "span":
        case "status":
        case "strike":
        case "strong":
        case "sub":
        case "sup":
        case "svg":
        case "tbody":
        case "td":
        case "th":
        case "thead":
        case "time":
        case "tr":
        case "track":
        case "tt":
        case "ul":
        case "var":
          return !1;
      }
      return !0;
    }
    r = r || 1;
    q = angular.element(q)[0] || q;
    if (!q.parentNode) return !1;
    if (x(q.parentNode)) return !0;
    r--;
    return r ? v(q.parentNode, r) : !1;
  }
  var n = this.showWarnings;
  return { expect: e, expectAsync: f, expectWithText: g, expectWithoutText: h, getText: l, hasAriaLabel: m, parentHasAriaLabel: v };
}
angular.module("material.core").provider("$mdCompiler", MdCompilerProvider);
MdCompilerProvider.$inject = ["$compileProvider"];
function MdCompilerProvider(a) {
  function b(c, e, f, g, h) {
    this.$q = c;
    this.$templateRequest = e;
    this.$injector = f;
    this.$compile = g;
    this.$controller = h;
  }
  var d = !1;
  this.respectPreAssignBindingsEnabled = function (c) {
    return angular.isDefined(c) ? ((d = c), this) : d;
  };
  this.$get = [
    "$q",
    "$templateRequest",
    "$injector",
    "$compile",
    "$controller",
    function (c, e, f, g, h) {
      return new b(c, e, f, g, h);
    }
  ];
  b.prototype.compile = function (c) {
    return c.contentElement ? this._prepareContentElement(c) : this._compileTemplate(c);
  };
  b.prototype._prepareContentElement = function (c) {
    var e = this._fetchContentElement(c);
    return this.$q.resolve({
      element: e.element,
      cleanup: e.restore,
      locals: {},
      link: function () {
        return e.element;
      }
    });
  };
  b.prototype._compileTemplate = function (c) {
    var e = this,
      f = c.templateUrl,
      g = c.template || "",
      h = angular.extend({}, c.resolve),
      l = angular.extend({}, c.locals),
      m = c.transformTemplate || angular.identity;
    angular.forEach(h, function (v, n) {
      angular.isString(v) ? (h[n] = e.$injector.get(v)) : (h[n] = e.$injector.invoke(v));
    });
    angular.extend(h, l);
    h.$$ngTemplate = f ? this.$templateRequest(f) : this.$q.when(g);
    return this.$q.all(h).then(function (v) {
      var n = m(v.$$ngTemplate, c);
      n = c.element || angular.element("<div>").html(n.trim()).contents();
      return e._compileElement(v, n, c);
    });
  };
  b.prototype._compileElement = function (c, e, f) {
    function g(v) {
      c.$scope = v;
      if (f.controller) {
        var n = angular.extend({}, c, { $element: e });
        n = h._createController(f, n, c);
        e.data("$ngControllerController", n);
        e.children().data("$ngControllerController", n);
        m.controller = n;
      }
      return l(v);
    }
    var h = this,
      l = this.$compile(e),
      m = { element: e, cleanup: e.remove.bind(e), locals: c, link: g };
    return m;
  };
  b.prototype._createController = function (c, e, f) {
    var g;
    (g = d
      ? "function" === typeof a.preAssignBindingsEnabled
        ? a.preAssignBindingsEnabled()
        : 1 === angular.version.major && 6 > angular.version.minor
        ? !0
        : !1
      : !0)
      ? ((g = this.$controller(c.controller, e, !0)), c.bindToController && angular.extend(g.instance, f), (g = g()))
      : ((g = this.$controller(c.controller, e)), c.bindToController && angular.extend(g, f));
    c.controllerAs && (e.$scope[c.controllerAs] = g);
    angular.isFunction(g.$onInit) && g.$onInit();
    return g;
  };
  b.prototype._fetchContentElement = function (c) {
    function e(g) {
      var h = g.parentNode,
        l = g.nextElementSibling;
      return function () {
        l ? h.insertBefore(g, l) : h.appendChild(g);
      };
    }
    var f = c.contentElement;
    c = null;
    angular.isString(f)
      ? ((f = document.querySelector(f)), (c = e(f)))
      : ((f = f[0] || f),
        (c = document.contains(f)
          ? e(f)
          : function () {
              f.parentNode && f.parentNode.removeChild(f);
            }));
    return { element: angular.element(f), restore: c };
  };
}
MdGesture.$inject = ["$$MdGestureHandler", "$$rAF", "$timeout", "$mdUtil"];
attachToDocument.$inject = ["$mdGesture", "$$MdGestureHandler", "$mdUtil"];
var HANDLERS = {},
  pointer,
  lastPointer,
  maxClickDistance = 6,
  forceSkipClickHijack = !1,
  disableAllGestures = !1,
  lastLabelClickPos = null,
  isInitialized = !1;
angular
  .module("material.core.gestures", [])
  .provider("$mdGesture", MdGestureProvider)
  .factory("$$MdGestureHandler", MdGestureHandler)
  .run(attachToDocument);
function MdGestureProvider() {}
MdGestureProvider.prototype = {
  disableAll: function () {
    disableAllGestures = !0;
  },
  skipClickHijack: function () {
    return (forceSkipClickHijack = !0);
  },
  setMaxClickDistance: function (a) {
    maxClickDistance = parseInt(a);
  },
  $get: [
    "$$MdGestureHandler",
    "$$rAF",
    "$timeout",
    "$mdUtil",
    function (a, b, d, c) {
      return new MdGesture(a, b, d, c);
    }
  ]
};
function MdGesture(a, b, d, c) {
  function e(n) {
    return function (q, r) {
      r.distance < this.state.options.maxDistance && this.dispatchEvent(q, n, r);
    };
  }
  function f(n, q, r) {
    var x = HANDLERS[q.replace(/^\$md./, "")];
    if (!x) throw Error("Failed to register element with handler " + q + ". Available handlers: " + Object.keys(HANDLERS).join(", "));
    return x.registerElement(n, r);
  }
  function g(n, q) {
    var r = new a(n);
    angular.extend(r, q);
    HANDLERS[n] = r;
    return v;
  }
  function h() {
    for (var n = document.createElement("div"), q = " webkit Moz MS ms o".split(" "), r = 0; r < q.length; r++) {
      var x = q[r];
      x = x ? x + "TouchAction" : "touchAction";
      if (angular.isDefined(n.style[x])) return x;
    }
  }
  var l = h(),
    m = "undefined" !== typeof window.jQuery && angular.element === window.jQuery,
    v = {
      handler: g,
      register: f,
      isAndroid: c.isAndroid,
      isIos: c.isIos,
      isHijackingClicks: (c.isIos || c.isAndroid) && !m && !forceSkipClickHijack
    };
  v.isHijackingClicks &&
    (v.handler("click", { options: { maxDistance: maxClickDistance }, onEnd: e("click") }),
    v.handler("focus", {
      options: { maxDistance: maxClickDistance },
      onEnd: function (n, q) {
        q.distance < this.state.options.maxDistance && canFocus(n.target) && (this.dispatchEvent(n, "focus", q), n.target.focus());
      }
    }),
    v.handler("mouseup", { options: { maxDistance: maxClickDistance }, onEnd: e("mouseup") }),
    v.handler("mousedown", {
      onStart: function (n) {
        this.dispatchEvent(n, "mousedown");
      }
    }));
  return v
    .handler("press", {
      onStart: function (n) {
        this.dispatchEvent(n, "$md.pressdown");
      },
      onEnd: function (n) {
        this.dispatchEvent(n, "$md.pressup");
      }
    })
    .handler("hold", {
      options: { maxDistance: 6, delay: 500 },
      onCancel: function () {
        d.cancel(this.state.timeout);
      },
      onStart: function (n, q) {
        if (!this.state.registeredParent) return this.cancel();
        this.state.pos = { x: q.x, y: q.y };
        this.state.timeout = d(
          angular.bind(this, function () {
            this.dispatchEvent(n, "$md.hold");
            this.cancel();
          }),
          this.state.options.delay,
          !1
        );
      },
      onMove: function (n, q) {
        l || "touchmove" !== n.type || n.preventDefault();
        n = this.state.pos.x - q.x;
        q = this.state.pos.y - q.y;
        Math.sqrt(n * n + q * q) > this.options.maxDistance && this.cancel();
      },
      onEnd: function () {
        this.onCancel();
      }
    })
    .handler("drag", {
      options: { minDistance: 6, horizontal: !0, cancelMultiplier: 1.5 },
      onSetup: function (n, q) {
        l && ((this.oldTouchAction = n[0].style[l]), (n[0].style[l] = q.horizontal ? "pan-y" : "pan-x"));
      },
      onCleanup: function (n) {
        this.oldTouchAction && (n[0].style[l] = this.oldTouchAction);
      },
      onStart: function () {
        this.state.registeredParent || this.cancel();
      },
      onMove: function (n, q) {
        l || "touchmove" !== n.type || n.preventDefault();
        if (this.state.dragPointer) this.dispatchDragMove(n);
        else {
          if (this.state.options.horizontal) {
            var r = Math.abs(q.distanceX) > this.state.options.minDistance;
            q = Math.abs(q.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier;
          } else
            (r = Math.abs(q.distanceY) > this.state.options.minDistance),
              (q = Math.abs(q.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier);
          r
            ? ((this.state.dragPointer = makeStartPointer(n)),
              updatePointerState(n, this.state.dragPointer),
              this.dispatchEvent(n, "$md.dragstart", this.state.dragPointer))
            : q && this.cancel();
        }
      },
      dispatchDragMove: b.throttle(function (n) {
        this.state.isRunning && (updatePointerState(n, this.state.dragPointer), this.dispatchEvent(n, "$md.drag", this.state.dragPointer));
      }),
      onEnd: function (n) {
        this.state.dragPointer &&
          (updatePointerState(n, this.state.dragPointer), this.dispatchEvent(n, "$md.dragend", this.state.dragPointer));
      }
    })
    .handler("swipe", {
      options: { minVelocity: 0.65, minDistance: 10 },
      onEnd: function (n, q) {
        Math.abs(q.velocityX) > this.state.options.minVelocity && Math.abs(q.distanceX) > this.state.options.minDistance
          ? ((q = "left" == q.directionX ? "$md.swipeleft" : "$md.swiperight"), this.dispatchEvent(n, q))
          : Math.abs(q.velocityY) > this.state.options.minVelocity &&
            Math.abs(q.distanceY) > this.state.options.minDistance &&
            ((q = "up" == q.directionY ? "$md.swipeup" : "$md.swipedown"), this.dispatchEvent(n, q));
      }
    });
}
function GestureHandler(a) {
  this.name = a;
  this.state = {};
}
function MdGestureHandler() {
  function a(c, e, f) {
    f = f || pointer;
    e = new angular.element.Event(e);
    e.$material = !0;
    e.pointer = f;
    e.srcEvent = c;
    angular.extend(e, {
      clientX: f.x,
      clientY: f.y,
      screenX: f.x,
      screenY: f.y,
      pageX: f.x,
      pageY: f.y,
      ctrlKey: c.ctrlKey,
      altKey: c.altKey,
      shiftKey: c.shiftKey,
      metaKey: c.metaKey
    });
    angular.element(f.target).trigger(e);
  }
  function b(c, e, f) {
    f = f || pointer;
    if ("click" === e || "mouseup" === e || "mousedown" === e)
      if ("function" === typeof window.MouseEvent)
        var g = new MouseEvent(e, {
          bubbles: !0,
          cancelable: !0,
          screenX: Number(c.screenX),
          screenY: Number(c.screenY),
          clientX: Number(f.x),
          clientY: Number(f.y),
          ctrlKey: c.ctrlKey,
          altKey: c.altKey,
          shiftKey: c.shiftKey,
          metaKey: c.metaKey,
          button: c.button,
          buttons: c.buttons,
          relatedTarget: c.relatedTarget || null
        });
      else
        (g = document.createEvent("MouseEvents")),
          g.initMouseEvent(
            e,
            !0,
            !0,
            window,
            c.detail,
            f.x,
            f.y,
            f.x,
            f.y,
            c.ctrlKey,
            c.altKey,
            c.shiftKey,
            c.metaKey,
            c.button,
            c.relatedTarget || null
          );
    else
      "function" === typeof window.CustomEvent
        ? (g = new CustomEvent(e, { bubbles: !0, cancelable: !0, detail: {} }))
        : ((g = document.createEvent("CustomEvent")), g.initCustomEvent(e, !0, !0, {}));
    g.$material = !0;
    g.pointer = f;
    g.srcEvent = c;
    f.target.dispatchEvent(g);
  }
  var d = "undefined" !== typeof window.jQuery && angular.element === window.jQuery;
  GestureHandler.prototype = {
    options: {},
    dispatchEvent: d ? a : b,
    onSetup: angular.noop,
    onCleanup: angular.noop,
    onStart: angular.noop,
    onMove: angular.noop,
    onEnd: angular.noop,
    onCancel: angular.noop,
    start: function (c, e) {
      if (!this.state.isRunning) {
        var f = this.getNearestParent(c.target),
          g = (f && f.$mdGesture[this.name]) || {};
        this.state = { isRunning: !0, options: angular.extend({}, this.options, g), registeredParent: f };
        this.onStart(c, e);
      }
    },
    move: function (c, e) {
      if (this.state.isRunning) this.onMove(c, e);
    },
    end: function (c, e) {
      this.state.isRunning && ((this.state.isRunning = !1), this.onEnd(c, e));
    },
    cancel: function (c, e) {
      this.onCancel(c, e);
      this.state = {};
    },
    getNearestParent: function (c) {
      for (; c; ) {
        if ((c.$mdGesture || {})[this.name]) return c;
        c = c.parentNode;
      }
      return null;
    },
    registerElement: function (c, e) {
      function f() {
        delete c[0].$mdGesture[g.name];
        c.off("$destroy", f);
        g.onCleanup(c, e || {});
      }
      var g = this;
      c[0].$mdGesture = c[0].$mdGesture || {};
      c[0].$mdGesture[this.name] = e || {};
      c.on("$destroy", f);
      g.onSetup(c, e || {});
      return f;
    }
  };
  return GestureHandler;
}
function attachToDocument(a, b, d) {
  function c(m) {
    var v = !m.clientX && !m.clientY;
    v ||
      m.$material ||
      m.isIonicTap ||
      (lastLabelClickPos && lastLabelClickPos.x === m.x && lastLabelClickPos.y === m.y) ||
      ("mousedown" === m.type && (canFocus(m.target) || canFocus(document.activeElement))) ||
      (m.preventDefault(), m.stopPropagation());
  }
  function e(m) {
    var v;
    (v = d.isIos ? angular.isDefined(m.webkitForce) && 0 === m.webkitForce : 0 === m.clientX && 0 === m.clientY) ||
    m.$material ||
    m.isIonicTap ||
    (lastLabelClickPos && lastLabelClickPos.x === m.x && lastLabelClickPos.y === m.y)
      ? ((lastLabelClickPos = null), "label" === m.target.tagName.toLowerCase() && (lastLabelClickPos = { x: m.x, y: m.y }))
      : (m.preventDefault(), m.stopPropagation(), (lastLabelClickPos = null));
  }
  function f(m, v) {
    var n;
    for (n in HANDLERS) {
      var q = HANDLERS[n];
      q instanceof b && ("start" === m && q.cancel(), q[m](v, pointer));
    }
  }
  function g(m) {
    if (!pointer) {
      var v = +Date.now();
      (lastPointer && !typesMatch(m, lastPointer) && 1500 > v - lastPointer.endTime) || ((pointer = makeStartPointer(m)), f("start", m));
    }
  }
  function h(m) {
    pointer && typesMatch(m, pointer) && (updatePointerState(m, pointer), f("move", m));
  }
  function l(m) {
    pointer &&
      typesMatch(m, pointer) &&
      (updatePointerState(m, pointer),
      (pointer.endTime = +Date.now()),
      "pointercancel" !== m.type && f("end", m),
      (lastPointer = pointer),
      (pointer = null));
  }
  disableAllGestures ||
    (!isInitialized &&
      a.isHijackingClicks &&
      (document.addEventListener("click", e, !0),
      document.addEventListener("mouseup", c, !0),
      document.addEventListener("mousedown", c, !0),
      document.addEventListener("focus", c, !0),
      (isInitialized = !0)),
    angular
      .element(document)
      .on("mousedown touchstart pointerdown", g)
      .on("mousemove touchmove pointermove", h)
      .on("mouseup mouseleave touchend touchcancel pointerup pointercancel", l)
      .on("$$mdGestureReset", function () {
        lastPointer = pointer = null;
      }));
}
function makeStartPointer(a) {
  var b = getEventPoint(a);
  a = { startTime: +Date.now(), target: a.target, type: a.type.charAt(0) };
  a.startX = a.x = b.pageX;
  a.startY = a.y = b.pageY;
  return a;
}
function typesMatch(a, b) {
  return a && b && a.type.charAt(0) === b.type;
}
function updatePointerState(a, b) {
  var d = getEventPoint(a);
  a = b.x = d.pageX;
  d = b.y = d.pageY;
  b.distanceX = a - b.startX;
  b.distanceY = d - b.startY;
  b.distance = Math.sqrt(b.distanceX * b.distanceX + b.distanceY * b.distanceY);
  b.directionX = 0 < b.distanceX ? "right" : 0 > b.distanceX ? "left" : "";
  b.directionY = 0 < b.distanceY ? "down" : 0 > b.distanceY ? "up" : "";
  b.duration = +Date.now() - b.startTime;
  b.velocityX = b.distanceX / b.duration;
  b.velocityY = b.distanceY / b.duration;
}
function getEventPoint(a) {
  a = a.originalEvent || a;
  return (a.touches && a.touches[0]) || (a.changedTouches && a.changedTouches[0]) || a;
}
function canFocus(a) {
  return (
    !!a &&
    "-1" !== a.getAttribute("tabindex") &&
    !a.hasAttribute("disabled") &&
    (a.hasAttribute("tabindex") ||
      a.hasAttribute("href") ||
      a.isContentEditable ||
      -1 !== "INPUT SELECT BUTTON TEXTAREA VIDEO AUDIO".split(" ").indexOf(a.nodeName))
  );
}
MdInteractionService.$inject = ["$timeout", "$mdUtil", "$rootScope"];
angular.module("material.core.interaction", []).service("$mdInteraction", MdInteractionService);
function MdInteractionService(a, b, d) {
  this.$timeout = a;
  this.$mdUtil = b;
  this.$rootScope = d;
  this.pointerEvent = "MSPointerEvent" in window ? "MSPointerDown" : "PointerEvent" in window ? "pointerdown" : null;
  this.bodyElement = angular.element(document.body);
  this.isBuffering = !1;
  this.lastInteractionTime = this.lastInteractionType = this.bufferTimeout = null;
  this.inputHandler = this.onInputEvent.bind(this);
  this.bufferedInputHandler = this.onBufferInputEvent.bind(this);
  this.inputEventMap = {
    keydown: "keyboard",
    mousedown: "mouse",
    mouseenter: "mouse",
    touchstart: "touch",
    pointerdown: "pointer",
    MSPointerDown: "pointer"
  };
  this.iePointerMap = { 2: "touch", 3: "touch", 4: "mouse" };
  this.initializeEvents();
  this.$rootScope.$on("$destroy", this.deregister.bind(this));
}
MdInteractionService.prototype.deregister = function () {
  this.bodyElement.off("keydown mousedown", this.inputHandler);
  "ontouchstart" in document.documentElement && this.bodyElement.off("touchstart", this.bufferedInputHandler);
  this.pointerEvent && this.bodyElement.off(this.pointerEvent, this.inputHandler);
};
MdInteractionService.prototype.initializeEvents = function () {
  this.bodyElement.on("keydown mousedown", this.inputHandler);
  if ("ontouchstart" in document.documentElement) this.bodyElement.on("touchstart", this.bufferedInputHandler);
  if (this.pointerEvent) this.bodyElement.on(this.pointerEvent, this.inputHandler);
};
MdInteractionService.prototype.onInputEvent = function (a) {
  if (!this.isBuffering) {
    var b = this.inputEventMap[a.type];
    "pointer" === b && (b = this.iePointerMap[a.pointerType] || a.pointerType);
    this.lastInteractionType = b;
    this.lastInteractionTime = this.$mdUtil.now();
  }
};
MdInteractionService.prototype.onBufferInputEvent = function (a) {
  this.$timeout.cancel(this.bufferTimeout);
  this.onInputEvent(a);
  this.isBuffering = !0;
  this.bufferTimeout = this.$timeout(
    function () {
      this.isBuffering = !1;
    }.bind(this),
    650,
    !1
  );
};
MdInteractionService.prototype.getLastInteractionType = function () {
  return this.lastInteractionType;
};
MdInteractionService.prototype.isUserInvoked = function (a) {
  a = angular.isNumber(a) ? a : 15;
  return this.lastInteractionTime >= this.$mdUtil.now() - a;
};
angular.module("material.core").provider("$$interimElement", InterimElementProvider);
function InterimElementProvider() {
  function a(d) {
    function c(n) {
      m.optionsFactory = n.options;
      m.methods = (n.methods || []).concat(h);
      return v;
    }
    function e(n, q) {
      l[n] = q;
      return v;
    }
    function f(n, q) {
      q = q || {};
      q.methods = q.methods || [];
      q.options =
        q.options ||
        function () {
          return {};
        };
      if (/^cancel|hide|show$/.test(n)) throw Error("Preset '" + n + "' in " + d + " is reserved!");
      if (-1 < q.methods.indexOf("_options")) throw Error("Method '_options' in " + d + " is reserved!");
      m.presets[n] = { methods: q.methods.concat(h), optionsFactory: q.options, argOption: q.argOption };
      return v;
    }
    function g(n, q) {
      function r(A) {
        A = A || {};
        A._options && (A = A._options);
        return k.show(angular.extend({}, H, A));
      }
      function x(A) {
        return k.destroy(A);
      }
      function y(A, w) {
        var B = {};
        B[d] = p;
        return q.invoke(
          A ||
            function () {
              return w;
            },
          {},
          B
        );
      }
      var k = n(),
        p = { hide: k.hide, cancel: k.cancel, show: r, destroy: x };
      var t = m.methods || [];
      var H = y(m.optionsFactory, {});
      angular.forEach(l, function (A, w) {
        p[w] = A;
      });
      angular.forEach(m.presets, function (A, w) {
        function B(D) {
          this._options = angular.extend({}, u, D);
        }
        var u = y(A.optionsFactory, {}),
          z = (A.methods || []).concat(t);
        angular.extend(u, { $type: w });
        angular.forEach(z, function (D) {
          B.prototype[D] = function (G) {
            this._options[D] = G;
            return this;
          };
        });
        A.argOption &&
          ((z = "show" + w.charAt(0).toUpperCase() + w.slice(1)),
          (p[z] = function (D) {
            D = p[w](D);
            return p.show(D);
          }));
        p[w] = function (D) {
          return arguments.length && A.argOption && !angular.isObject(D) && !angular.isArray(D) ? new B()[A.argOption](D) : new B(D);
        };
      });
      return p;
    }
    g.$inject = ["$$interimElement", "$injector"];
    var h = ["onHide", "onShow", "onRemove"],
      l = {},
      m = { presets: {} },
      v = { setDefaults: c, addPreset: f, addMethod: e, $get: g };
    v.addPreset("build", {
      methods: "controller controllerAs resolve multiple template templateUrl themable transformTemplate parent contentElement".split(" ")
    });
    return v;
  }
  function b(d, c, e, f, g, h, l, m, v, n, q) {
    return function () {
      function r(u) {
        u = u || {};
        var z = new t(u || {}),
          D = u.multiple ? c.resolve() : c.all(A);
        u.multiple ||
          (D = D.then(function () {
            var N = w.concat(B.map(H.cancel));
            return c.all(N);
          }));
        var G = D.then(function () {
          return z
            .show()
            .then(function () {
              B.push(z);
            })
            .catch(function (N) {
              return N;
            })
            .finally(function () {
              A.splice(A.indexOf(G), 1);
            });
        });
        A.push(G);
        z.deferred.promise.catch(function (N) {
          N instanceof Error && q(N);
          return N;
        });
        return z.deferred.promise;
      }
      function x(u, z) {
        function D(G) {
          if (!G) return c.when(u);
          var N = G.remove(u, !1, z || {})
            .catch(function (C) {
              return C;
            })
            .finally(function () {
              w.splice(w.indexOf(N), 1);
            });
          B.splice(B.indexOf(G), 1);
          w.push(N);
          return G.deferred.promise;
        }
        z = z || {};
        return z.closeAll
          ? c.all(B.slice().reverse().map(D))
          : void 0 !== z.closeTo
          ? c.all(B.slice(z.closeTo).map(D))
          : D(B[B.length - 1]);
      }
      function y(u, z) {
        var D = B.pop();
        if (!D) return c.when(u);
        var G = D.remove(u, !0, z || {})
          .catch(function (N) {
            return N;
          })
          .finally(function () {
            w.splice(w.indexOf(G), 1);
          });
        w.push(G);
        return D.deferred.promise.catch(angular.noop);
      }
      function k(u) {
        return function () {
          var z = arguments;
          return B.length
            ? u.apply(H, z)
            : A.length
            ? A[0].finally(function () {
                return u.apply(H, z);
              })
            : c.when("No interim elements currently showing up.");
        };
      }
      function p(u) {
        var z = u ? null : B.shift(),
          D = angular.element(u).length && angular.element(u)[0].parentNode;
        D &&
          ((u = B.filter(function (G) {
            return G.options.element[0] === D;
          })),
          u.length && ((z = u[0]), B.splice(B.indexOf(z), 1)));
        return z ? z.remove(!1, !1, { $destroy: !0 }) : c.when(!1);
      }
      function t(u) {
        function z() {
          return c(function (I, J) {
            function Q(T) {
              S.deferred.reject(T);
              J(T);
            }
            u.onCompiling && u.onCompiling(u);
            N(u)
              .then(function (T) {
                var Y = T,
                  R = u;
                angular.extend(Y.locals, R);
                Y = Y.link(R.scope);
                R.element = Y;
                var U = R;
                var X = Y,
                  aa = R,
                  ha = aa.parent;
                ha = angular.isFunction(ha)
                  ? ha(aa.scope, X, aa)
                  : angular.isString(ha)
                  ? angular.element(d[0].querySelector(ha))
                  : angular.element(ha);
                if ((ha || {}).length) var fa = ha;
                else
                  g[0] && g[0].querySelector && (fa = g[0].querySelector(":not(svg) > body")),
                    fa || (fa = g[0]),
                    "#comment" == fa.nodeName && (fa = d[0].body),
                    (fa = angular.element(fa));
                U.parent = fa;
                R.themable && v(Y);
                K = Y;
                u.cleanupElement = T.cleanup;
                M = F(K, u, T.controller).then(I, Q);
              })
              .catch(Q);
          });
        }
        function D(I, J, Q) {
          function T(Y) {
            S.deferred.reject(Y);
          }
          if (!K) return c.when(!1);
          u = angular.extend(u || {}, Q || {});
          u.cancelAutoHide && u.cancelAutoHide();
          u.element.triggerHandler("$mdInterimElementRemove");
          if (!0 === u.$destroy)
            return O(u.element, u).then(function () {
              (J && T(I)) || S.deferred.resolve(I);
            });
          c.when(M).finally(function () {
            O(u.element, u).then(function () {
              J ? T(I) : S.deferred.resolve(I);
            }, T);
          });
          return S.deferred.promise;
        }
        function G(I) {
          I = I || {};
          I.template && (I.template = l.processTemplate(I.template));
          return angular.extend(
            {
              preserveScope: !1,
              cancelAutoHide: angular.noop,
              scope: I.scope || e.$new(I.isolateScope),
              onShow: function (J, Q, T) {
                return h.enter(Q, T.parent);
              },
              onRemove: function (J, Q) {
                return (Q && h.leave(Q)) || c.when();
              }
            },
            I
          );
        }
        function N(I) {
          var J = I.skipCompile ? null : m.compile(I);
          return (
            J ||
            c(function (Q) {
              Q({
                locals: {},
                link: function () {
                  return I.element;
                }
              });
            })
          );
        }
        function C() {
          var I = angular.noop;
          if (u.hideDelay) {
            var J = f(H.hide, u.hideDelay);
            I = function () {
              f.cancel(J);
            };
          }
          u.cancelAutoHide = function () {
            I();
            u.cancelAutoHide = void 0;
          };
        }
        function F(I, J, Q) {
          var T = J.onShowing || angular.noop,
            Y = J.onComplete || angular.noop;
          try {
            T(J.scope, I, J, Q);
          } catch (R) {
            return c.reject(R);
          }
          return c(function (R, U) {
            try {
              c.when(J.onShow(J.scope, I, J, Q)).then(function () {
                Y(J.scope, I, J);
                C();
                R(I);
              }, U);
            } catch (X) {
              U(X.message);
            }
          });
        }
        function O(I, J) {
          var Q = J.onRemoving || angular.noop;
          return c(function (T, Y) {
            try {
              var R = c.when(J.onRemove(J.scope, I, J) || !0);
              Q(I, R);
              J.$destroy
                ? (T(I),
                  !J.preserveScope &&
                    J.scope &&
                    R.then(function () {
                      J.scope.$destroy();
                    }))
                : R.then(function () {
                    !J.preserveScope && J.scope && J.scope.$destroy();
                    T(I);
                  }, Y);
            } catch (U) {
              Y(U.message);
            }
          });
        }
        var S,
          K,
          M = c.when(!0);
        u = G(u);
        return (S = { options: u, deferred: c.defer(), show: z, remove: D });
      }
      var H,
        A = [],
        w = [],
        B = [];
      return (H = { show: r, hide: k(x), cancel: k(y), destroy: p, $injector_: n });
    };
  }
  b.$inject = "$document $q $rootScope $timeout $rootElement $animate $mdUtil $mdCompiler $mdTheming $injector $exceptionHandler".split(
    " "
  );
  a.$get = b;
  return a;
}
MdLiveAnnouncer.$inject = ["$timeout"];
angular.module("material.core").service("$mdLiveAnnouncer", MdLiveAnnouncer);
function MdLiveAnnouncer(a) {
  this._$timeout = a;
  this._liveElement = this._createLiveElement();
  this._announceTimeout = 100;
}
MdLiveAnnouncer.prototype.announce = function (a, b) {
  b || (b = "polite");
  var d = this;
  d._liveElement.textContent = "";
  d._liveElement.setAttribute("aria-live", b);
  d._$timeout(
    function () {
      d._liveElement.textContent = a;
    },
    d._announceTimeout,
    !1
  );
};
MdLiveAnnouncer.prototype._createLiveElement = function () {
  var a = document.createElement("div");
  a.classList.add("md-visually-hidden");
  a.setAttribute("role", "status");
  a.setAttribute("aria-atomic", "true");
  a.setAttribute("aria-live", "polite");
  document.body.appendChild(a);
  return a;
};
angular.module("material.core.meta", []).provider("$$mdMeta", function () {
  function a(g) {
    if (e[g]) return !0;
    var h = document.getElementsByName(g)[0];
    if (!h) return !1;
    e[g] = angular.element(h);
    return !0;
  }
  function b(g, h) {
    a(g);
    e[g] ? e[g].attr("content", h) : ((h = angular.element('<meta name="' + g + '" content="' + h + '"/>')), c.append(h), (e[g] = h));
    return function () {
      e[g].attr("content", "");
      e[g].remove();
      delete e[g];
    };
  }
  function d(g) {
    if (!a(g)) throw Error("$$mdMeta: could not find a meta tag with the name '" + g + "'");
    return e[g].attr("content");
  }
  var c = angular.element(document.head),
    e = {},
    f = { setMeta: b, getMeta: d };
  return angular.extend({}, f, {
    $get: function () {
      return f;
    }
  });
});
(function () {
  function a(u) {
    function z(O) {
      return O.replace(D, "").replace(G, function (S, K, M, I) {
        return I ? M.toUpperCase() : M;
      });
    }
    var D = /^((?:x|data)[:\-_])/i,
      G = /([:\-_]+(.))/g,
      N = " xs gt-xs sm gt-sm md gt-md lg gt-lg xl print".split(" "),
      C = ["layout", "flex", "flex-order", "flex-offset", "layout-align"],
      F = ["show", "hide", "layout-padding", "layout-margin"];
    angular.forEach(N, function (O) {
      angular.forEach(C, function (S) {
        S = O ? S + "-" + O : S;
        u.directive(z(S), e(S));
      });
      angular.forEach(F, function (S) {
        S = O ? S + "-" + O : S;
        u.directive(z(S), f(S));
      });
    });
    u.provider("$$mdLayout", function () {
      return {
        $get: angular.noop,
        validateAttributeValue: m,
        validateAttributeUsage: l,
        disableLayouts: function (O) {
          B.enabled = !0 !== O;
        }
      };
    })
      .directive("mdLayoutCss", d)
      .directive("ngCloak", c("ng-cloak"))
      .directive("layoutWrap", f("layout-wrap"))
      .directive("layoutNowrap", f("layout-nowrap"))
      .directive("layoutNoWrap", f("layout-no-wrap"))
      .directive("layoutFill", f("layout-fill"))
      .directive("layoutLtMd", h("layout-lt-md", !0))
      .directive("layoutLtLg", h("layout-lt-lg", !0))
      .directive("flexLtMd", h("flex-lt-md", !0))
      .directive("flexLtLg", h("flex-lt-lg", !0))
      .directive("layoutAlignLtMd", h("layout-align-lt-md"))
      .directive("layoutAlignLtLg", h("layout-align-lt-lg"))
      .directive("flexOrderLtMd", h("flex-order-lt-md"))
      .directive("flexOrderLtLg", h("flex-order-lt-lg"))
      .directive("offsetLtMd", h("flex-offset-lt-md"))
      .directive("offsetLtLg", h("flex-offset-lt-lg"))
      .directive("hideLtMd", h("hide-lt-md"))
      .directive("hideLtLg", h("hide-lt-lg"))
      .directive("showLtMd", h("show-lt-md"))
      .directive("showLtLg", h("show-lt-lg"))
      .config(b);
  }
  function b() {
    var u = !!document.querySelector("[md-layouts-disabled]");
    B.enabled = !u;
  }
  function d() {
    B.enabled = !1;
    return { restrict: "A", priority: "900" };
  }
  function c(u) {
    return [
      "$timeout",
      function (z) {
        return {
          restrict: "A",
          priority: -10,
          compile: function (D) {
            if (!B.enabled) return angular.noop;
            D.addClass(u);
            return function (G, N) {
              z(
                function () {
                  N.removeClass(u);
                },
                10,
                !1
              );
            };
          }
        };
      }
    ];
  }
  function e(u) {
    function z(D, G, N) {
      G = g(G, u, N);
      var C = N.$observe(N.$normalize(u), G);
      G(n(u, N, ""));
      D.$on("$destroy", function () {
        C();
      });
    }
    return [
      "$mdUtil",
      "$interpolate",
      "$log",
      function (D, G, N) {
        r = D;
        x = G;
        y = N;
        return {
          restrict: "A",
          compile: function (C, F) {
            if (B.enabled) {
              l(u, F, C, y);
              m(u, n(u, F, ""), v(C, u, F));
              var O = z;
            }
            return O || angular.noop;
          }
        };
      }
    ];
  }
  function f(u) {
    function z(D, G) {
      G.addClass(u);
    }
    return [
      "$mdUtil",
      "$interpolate",
      "$log",
      function (D, G, N) {
        r = D;
        x = G;
        y = N;
        return {
          restrict: "A",
          compile: function (C, F) {
            if (B.enabled) {
              m(u, n(u, F, ""), v(C, u, F));
              C.addClass(u);
              var O = z;
            }
            return O || angular.noop;
          }
        };
      }
    ];
  }
  function g(u, z) {
    var D;
    return function (G) {
      G = m(z, G || "");
      angular.isDefined(G) && (D && u.removeClass(D), (D = G ? z + "-" + G.trim().replace(p, "-") : z), u.addClass(D));
    };
  }
  function h(u) {
    var z = u.split("-");
    return [
      "$log",
      function (D) {
        D.warn(u + "has been deprecated. Please use a `" + z[0] + "-gt-<xxx>` variant.");
        return angular.noop;
      }
    ];
  }
  function l(u, z, D, G) {
    z = D[0].nodeName.toLowerCase();
    switch (u.replace(k, "")) {
      case "flex":
        if ("md-button" == z || "fieldset" == z)
          (z = "<" + z + " " + u + "></" + z + ">"),
            (D = "https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers"),
            (u = "Markup '{0}' may not work as expected in IE Browsers. Consult '{1}' for details."),
            G.warn(r.supplant(u, [z, D]));
    }
  }
  function m(u, z, D) {
    var G;
    if (!(-1 < (z || "").indexOf(x.startSymbol()))) {
      switch (u.replace(k, "")) {
        case "layout":
          q(z, H) || (z = H[0]);
          break;
        case "flex":
          q(z, t) || (isNaN(z) && (z = ""));
          break;
        case "flex-offset":
        case "flex-order":
          if (!z || isNaN(+z)) z = "0";
          break;
        case "layout-align":
          u = { main: "start", cross: "stretch" };
          z = z || "";
          if (0 === z.indexOf("-") || 0 === z.indexOf(" ")) z = "none" + z;
          z = z.toLowerCase().trim().replace(p, "-").split("-");
          z.length && "space" === z[0] && (z = [z[0] + "-" + z[1], z[2]]);
          0 < z.length && (u.main = z[0] || u.main);
          1 < z.length && (u.cross = z[1] || u.cross);
          0 > A.indexOf(u.main) && (u.main = "start");
          0 > w.indexOf(u.cross) && (u.cross = "stretch");
          z = r.supplant("{main}-{cross}", u);
          break;
        case "layout-padding":
        case "layout-margin":
        case "layout-fill":
        case "layout-wrap":
        case "layout-nowrap":
          z = "";
      }
      z != G && (D || angular.noop)(z);
    }
    return z ? z.trim() : "";
  }
  function v(u, z, D) {
    return function (G) {
      -1 < (G || "").indexOf(x.startSymbol()) || (D[D.$normalize(z)] = G);
    };
  }
  function n(u, z, D) {
    u = z.$normalize(u);
    return z[u] ? z[u].trim().replace(p, "-") : D || null;
  }
  function q(u, z, D) {
    u = D && u ? u.replace(p, D) : u;
    var G = !1;
    u &&
      z.forEach(function (N) {
        N = D ? N.replace(p, D) : N;
        G = G || N === u;
      });
    return G;
  }
  var r,
    x,
    y,
    k = /(-gt)?-(sm|md|lg|print)/g,
    p = /\s+/g,
    t = "grow initial auto none noshrink nogrow".split(" "),
    H = ["row", "column"],
    A = " start center end stretch space-around space-between".split(" "),
    w = ["", "start", "center", "end", "stretch"],
    B = { enabled: !0, breakpoints: [] };
  a(angular.module("material.core.layout", ["ng"]));
})();
ComponentRegistry.$inject = ["$log", "$q"];
angular.module("material.core").factory("$mdComponentRegistry", ComponentRegistry);
function ComponentRegistry(a, b) {
  var d,
    c = [],
    e = {};
  return (d = {
    notFoundError: function (f, g) {
      a.error((g || "") + "No instance found for handle", f);
    },
    getInstances: function () {
      return c;
    },
    get: function (f) {
      if (!f || "" === f) return null;
      var g;
      var h = 0;
      for (g = c.length; h < g; h++) {
        var l = c[h];
        if (l.$$mdHandle === f) return l;
      }
      return null;
    },
    register: function (f, g) {
      function h() {
        var m = c.indexOf(f);
        -1 !== m && c.splice(m, 1);
      }
      function l() {
        var m = e[g];
        m &&
          (m.forEach(function (v) {
            v.resolve(f);
          }),
          delete e[g]);
      }
      if (!g) return angular.noop;
      f.$$mdHandle = g;
      c.push(f);
      l();
      return h;
    },
    when: function (f) {
      if (f && "" !== f) {
        var g = b.defer(),
          h = d.get(f);
        h ? g.resolve(h) : (void 0 === e[f] && (e[f] = []), e[f].push(g));
        return g.promise;
      }
      return b.reject("Invalid `md-component-id` value.");
    }
  });
}
angular
  .module("material.core.theming.palette", [])
  .constant("$mdColorPalette", {
    red: {
      50: "#ffebee",
      100: "#ffcdd2",
      200: "#ef9a9a",
      300: "#e57373",
      400: "#ef5350",
      500: "#f44336",
      600: "#e53935",
      700: "#d32f2f",
      800: "#c62828",
      900: "#b71c1c",
      A100: "#ff8a80",
      A200: "#ff5252",
      A400: "#ff1744",
      A700: "#d50000",
      contrastDefaultColor: "light",
      contrastDarkColors: "50 100 200 300 A100",
      contrastStrongLightColors: "400 500 600 700 A200 A400 A700"
    },
    pink: {
      50: "#fce4ec",
      100: "#f8bbd0",
      200: "#f48fb1",
      300: "#f06292",
      400: "#ec407a",
      500: "#e91e63",
      600: "#d81b60",
      700: "#c2185b",
      800: "#ad1457",
      900: "#880e4f",
      A100: "#ff80ab",
      A200: "#ff4081",
      A400: "#f50057",
      A700: "#c51162",
      contrastDefaultColor: "light",
      contrastDarkColors: "50 100 200 A100",
      contrastStrongLightColors: "500 600 A200 A400 A700"
    },
    purple: {
      50: "#f3e5f5",
      100: "#e1bee7",
      200: "#ce93d8",
      300: "#ba68c8",
      400: "#ab47bc",
      500: "#9c27b0",
      600: "#8e24aa",
      700: "#7b1fa2",
      800: "#6a1b9a",
      900: "#4a148c",
      A100: "#ea80fc",
      A200: "#e040fb",
      A400: "#d500f9",
      A700: "#aa00ff",
      contrastDefaultColor: "light",
      contrastDarkColors: "50 100 200 A100",
      contrastStrongLightColors: "300 400 A200 A400 A700"
    },
    "deep-purple": {
      50: "#ede7f6",
      100: "#d1c4e9",
      200: "#b39ddb",
      300: "#9575cd",
      400: "#7e57c2",
      500: "#673ab7",
      600: "#5e35b1",
      700: "#512da8",
      800: "#4527a0",
      900: "#311b92",
      A100: "#b388ff",
      A200: "#7c4dff",
      A400: "#651fff",
      A700: "#6200ea",
      contrastDefaultColor: "light",
      contrastDarkColors: "50 100 200 A100",
      contrastStrongLightColors: "300 400 A200"
    },
    indigo: {
      50: "#e8eaf6",
      100: "#c5cae9",
      200: "#9fa8da",
      300: "#7986cb",
      400: "#5c6bc0",
      500: "#3f51b5",
      600: "#3949ab",
      700: "#303f9f",
      800: "#283593",
      900: "#1a237e",
      A100: "#8c9eff",
      A200: "#536dfe",
      A400: "#3d5afe",
      A700: "#304ffe",
      contrastDefaultColor: "light",
      contrastDarkColors: "50 100 200 A100",
      contrastStrongLightColors: "300 400 A200 A400"
    },
    blue: {
      50: "#e3f2fd",
      100: "#bbdefb",
      200: "#90caf9",
      300: "#64b5f6",
      400: "#42a5f5",
      500: "#2196f3",
      600: "#1e88e5",
      700: "#1976d2",
      800: "#1565c0",
      900: "#0d47a1",
      A100: "#82b1ff",
      A200: "#448aff",
      A400: "#2979ff",
      A700: "#2962ff",
      contrastDefaultColor: "light",
      contrastDarkColors: "50 100 200 300 400 A100",
      contrastStrongLightColors: "500 600 700 A200 A400 A700"
    },
    "light-blue": {
      50: "#e1f5fe",
      100: "#b3e5fc",
      200: "#81d4fa",
      300: "#4fc3f7",
      400: "#29b6f6",
      500: "#03a9f4",
      600: "#039be5",
      700: "#0288d1",
      800: "#0277bd",
      900: "#01579b",
      A100: "#80d8ff",
      A200: "#40c4ff",
      A400: "#00b0ff",
      A700: "#0091ea",
      contrastDefaultColor: "dark",
      contrastLightColors: "600 700 800 900 A700",
      contrastStrongLightColors: "600 700 800 A700"
    },
    cyan: {
      50: "#e0f7fa",
      100: "#b2ebf2",
      200: "#80deea",
      300: "#4dd0e1",
      400: "#26c6da",
      500: "#00bcd4",
      600: "#00acc1",
      700: "#0097a7",
      800: "#00838f",
      900: "#006064",
      A100: "#84ffff",
      A200: "#18ffff",
      A400: "#00e5ff",
      A700: "#00b8d4",
      contrastDefaultColor: "dark",
      contrastLightColors: "700 800 900",
      contrastStrongLightColors: "700 800 900"
    },
    teal: {
      50: "#e0f2f1",
      100: "#b2dfdb",
      200: "#80cbc4",
      300: "#4db6ac",
      400: "#26a69a",
      500: "#009688",
      600: "#00897b",
      700: "#00796b",
      800: "#00695c",
      900: "#004d40",
      A100: "#a7ffeb",
      A200: "#64ffda",
      A400: "#1de9b6",
      A700: "#00bfa5",
      contrastDefaultColor: "dark",
      contrastLightColors: "500 600 700 800 900",
      contrastStrongLightColors: "500 600 700"
    },
    green: {
      50: "#e8f5e9",
      100: "#c8e6c9",
      200: "#a5d6a7",
      300: "#81c784",
      400: "#66bb6a",
      500: "#4caf50",
      600: "#43a047",
      700: "#388e3c",
      800: "#2e7d32",
      900: "#1b5e20",
      A100: "#b9f6ca",
      A200: "#69f0ae",
      A400: "#00e676",
      A700: "#00c853",
      contrastDefaultColor: "dark",
      contrastLightColors: "500 600 700 800 900",
      contrastStrongLightColors: "500 600 700"
    },
    "light-green": {
      50: "#f1f8e9",
      100: "#dcedc8",
      200: "#c5e1a5",
      300: "#aed581",
      400: "#9ccc65",
      500: "#8bc34a",
      600: "#7cb342",
      700: "#689f38",
      800: "#558b2f",
      900: "#33691e",
      A100: "#ccff90",
      A200: "#b2ff59",
      A400: "#76ff03",
      A700: "#64dd17",
      contrastDefaultColor: "dark",
      contrastLightColors: "700 800 900",
      contrastStrongLightColors: "700 800 900"
    },
    lime: {
      50: "#f9fbe7",
      100: "#f0f4c3",
      200: "#e6ee9c",
      300: "#dce775",
      400: "#d4e157",
      500: "#cddc39",
      600: "#c0ca33",
      700: "#afb42b",
      800: "#9e9d24",
      900: "#827717",
      A100: "#f4ff81",
      A200: "#eeff41",
      A400: "#c6ff00",
      A700: "#aeea00",
      contrastDefaultColor: "dark",
      contrastLightColors: "900",
      contrastStrongLightColors: "900"
    },
    yellow: {
      50: "#fffde7",
      100: "#fff9c4",
      200: "#fff59d",
      300: "#fff176",
      400: "#ffee58",
      500: "#ffeb3b",
      600: "#fdd835",
      700: "#fbc02d",
      800: "#f9a825",
      900: "#f57f17",
      A100: "#ffff8d",
      A200: "#ffff00",
      A400: "#ffea00",
      A700: "#ffd600",
      contrastDefaultColor: "dark"
    },
    amber: {
      50: "#fff8e1",
      100: "#ffecb3",
      200: "#ffe082",
      300: "#ffd54f",
      400: "#ffca28",
      500: "#ffc107",
      600: "#ffb300",
      700: "#ffa000",
      800: "#ff8f00",
      900: "#ff6f00",
      A100: "#ffe57f",
      A200: "#ffd740",
      A400: "#ffc400",
      A700: "#ffab00",
      contrastDefaultColor: "dark"
    },
    orange: {
      50: "#fff3e0",
      100: "#ffe0b2",
      200: "#ffcc80",
      300: "#ffb74d",
      400: "#ffa726",
      500: "#ff9800",
      600: "#fb8c00",
      700: "#f57c00",
      800: "#ef6c00",
      900: "#e65100",
      A100: "#ffd180",
      A200: "#ffab40",
      A400: "#ff9100",
      A700: "#ff6d00",
      contrastDefaultColor: "dark",
      contrastLightColors: "800 900",
      contrastStrongLightColors: "800 900"
    },
    "deep-orange": {
      50: "#fbe9e7",
      100: "#ffccbc",
      200: "#ffab91",
      300: "#ff8a65",
      400: "#ff7043",
      500: "#ff5722",
      600: "#f4511e",
      700: "#e64a19",
      800: "#d84315",
      900: "#bf360c",
      A100: "#ff9e80",
      A200: "#ff6e40",
      A400: "#ff3d00",
      A700: "#dd2c00",
      contrastDefaultColor: "light",
      contrastDarkColors: "50 100 200 300 400 A100 A200",
      contrastStrongLightColors: "500 600 700 800 900 A400 A700"
    },
    brown: {
      50: "#efebe9",
      100: "#d7ccc8",
      200: "#bcaaa4",
      300: "#a1887f",
      400: "#8d6e63",
      500: "#795548",
      600: "#6d4c41",
      700: "#5d4037",
      800: "#4e342e",
      900: "#3e2723",
      A100: "#d7ccc8",
      A200: "#bcaaa4",
      A400: "#8d6e63",
      A700: "#5d4037",
      contrastDefaultColor: "light",
      contrastDarkColors: "50 100 200 A100 A200",
      contrastStrongLightColors: "300 400"
    },
    grey: {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#eeeeee",
      300: "#e0e0e0",
      400: "#bdbdbd",
      500: "#9e9e9e",
      600: "#757575",
      700: "#616161",
      800: "#424242",
      900: "#212121",
      A100: "#ffffff",
      A200: "#000000",
      A400: "#303030",
      A700: "#616161",
      contrastDefaultColor: "dark",
      contrastLightColors: "600 700 800 900 A200 A400 A700"
    },
    "blue-grey": {
      50: "#eceff1",
      100: "#cfd8dc",
      200: "#b0bec5",
      300: "#90a4ae",
      400: "#78909c",
      500: "#607d8b",
      600: "#546e7a",
      700: "#455a64",
      800: "#37474f",
      900: "#263238",
      A100: "#cfd8dc",
      A200: "#b0bec5",
      A400: "#78909c",
      A700: "#455a64",
      contrastDefaultColor: "light",
      contrastDarkColors: "50 100 200 300 A100 A200",
      contrastStrongLightColors: "400 500 700"
    }
  });
(function (a) {
  function b(D) {
    var G = !!document.querySelector("[md-themes-disabled]");
    D.disableTheming(G);
  }
  function d(D, G) {
    function N(R, U) {
      U = U || {};
      r[R] = F(R, U);
      return I;
    }
    function C(R, U) {
      return F(R, a.extend({}, r[R] || {}, U));
    }
    function F(R, U) {
      var X = B.filter(function (aa) {
        return !U[aa];
      });
      if (X.length) throw Error("Missing colors %1 in palette %2!".replace("%1", X.join(", ")).replace("%2", R));
      return U;
    }
    function O(R, U) {
      if (M[R]) return M[R];
      U = U || "default";
      U = "string" === typeof U ? M[U] : U;
      var X = new S(R);
      U &&
        a.forEach(U.colors, function (aa, ha) {
          X.colors[ha] = { name: aa.name, hues: a.extend({}, aa.hues) };
        });
      return (M[R] = X);
    }
    function S(R) {
      function U(aa) {
        aa = 0 === arguments.length ? !0 : !!aa;
        if (aa !== X.isDark) {
          X.isDark = aa;
          X.foregroundPalette = X.isDark ? y : x;
          X.foregroundShadow = X.isDark ? "1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)" : "";
          var ha = X.isDark ? w : A,
            fa = X.isDark ? A : w;
          a.forEach(ha, function (ea, ca) {
            var da = X.colors[ca];
            ca = fa[ca];
            if (da) for (var la in da.hues) da.hues[la] === ca[la] && (da.hues[la] = ea[la]);
          });
          return X;
        }
      }
      var X = this;
      X.name = R;
      X.colors = {};
      X.dark = U;
      U(!1);
      H.forEach(function (aa) {
        var ha = (X.isDark ? w : A)[aa];
        X[aa + "Palette"] = function (fa, ea) {
          var ca = (X.colors[aa] = { name: fa, hues: a.extend({}, ha, ea) });
          Object.keys(ca.hues).forEach(function (da) {
            if (!ha[da])
              throw Error(
                "Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4"
                  .replace("%1", da)
                  .replace("%2", X.name)
                  .replace("%3", fa)
                  .replace("%4", Object.keys(ha).join(", "))
              );
          });
          Object.keys(ca.hues)
            .map(function (da) {
              return ca.hues[da];
            })
            .forEach(function (da) {
              if (-1 == B.indexOf(da))
                throw Error(
                  "Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5"
                    .replace("%1", da)
                    .replace("%2", X.name)
                    .replace("%3", aa)
                    .replace("%4", fa)
                    .replace("%5", B.join(", "))
                );
            });
          return X;
        };
        X[aa + "Color"] = function () {
          var fa = Array.prototype.slice.call(arguments);
          console.warn(
            "$mdThemingProviderTheme." + aa + "Color() has been deprecated. Use $mdThemingProviderTheme." + aa + "Palette() instead."
          );
          return X[aa + "Palette"].apply(X, fa);
        };
      });
    }
    function K(R, U, X, aa) {
      function ha(ca) {
        return void 0 === ca || "" === ca ? !0 : void 0 !== ea.THEMES[ca];
      }
      function fa(ca, da) {
        function la(ma) {
          if (ma) {
            ha(ma) || aa.warn("Attempted to use unregistered theme '" + ma + "'. Register it with $mdThemingProvider.theme().");
            var za = ca.data("$mdThemeName");
            za && ca.removeClass("md-" + za + "-theme");
            ca.addClass("md-" + ma + "-theme");
            ca.data("$mdThemeName", ma);
            pa && ca.data("$mdThemeController", pa);
          }
        }
        var pa = da.controller("mdTheme") || ca.data("$mdThemeController");
        da = ca.scope();
        la((pa && pa.$mdTheme) || ("default" === Q ? "" : Q));
        if (pa) {
          var Ga = J || pa.$shouldWatch || U.parseAttributeBoolean(ca.attr("md-theme-watch"));
          if (Ga || pa.isAsyncTheme) {
            var wa = function () {
                Aa && (Aa(), (Aa = void 0));
              },
              Aa = pa.registerChanges(function (ma) {
                la(ma);
                Ga || wa();
              });
            if (da) da.$on("$destroy", wa);
            else ca.on("$destroy", wa);
          }
        }
      }
      var ea = function (ca, da) {
        void 0 === da && (da = ca);
        ea.inherit(da, da);
      };
      Object.defineProperty(ea, "THEMES", {
        get: function () {
          return a.extend({}, M);
        }
      });
      Object.defineProperty(ea, "PALETTES", {
        get: function () {
          return a.extend({}, r);
        }
      });
      Object.defineProperty(ea, "ALWAYS_WATCH", {
        get: function () {
          return J;
        }
      });
      ea.inherit = fa;
      ea.registered = ha;
      ea.defaultTheme = function () {
        return Q;
      };
      ea.generateTheme = function (ca) {
        l(M[ca], ca, u.nonce);
      };
      ea.defineTheme = function (ca, da) {
        da = da || {};
        var la = O(ca);
        da.primary && la.primaryPalette(da.primary, da.primaryHues);
        da.accent && la.accentPalette(da.accent, da.accentHues);
        da.warn && la.warnPalette(da.warn, da.warnHues);
        da.background && la.backgroundPalette(da.background, da.backgroundHues);
        da.dark && la.dark();
        this.generateTheme(ca);
        return X.resolve(ca);
      };
      ea.setBrowserColor = Y;
      return ea;
    }
    K.$inject = ["$rootScope", "$mdUtil", "$q", "$log"];
    r = {};
    var M = {},
      I,
      J = !1,
      Q = "default";
    a.extend(r, D);
    var T = function (R) {
        var U = G.setMeta("theme-color", R),
          X = G.setMeta("msapplication-navbutton-color", R);
        return function () {
          U();
          X();
        };
      },
      Y = function (R) {
        R = a.isObject(R) ? R : {};
        var U = R.theme || "default",
          X = R.hue || "800";
        R = r[R.palette] || r[M[U].colors[R.palette || "primary"].name];
        X = a.isObject(R[X]) ? R[X].hex : R[X];
        "#" !== X.substr(0, 1) && (X = "#" + X);
        return T(X);
      };
    return (I = {
      definePalette: N,
      extendPalette: C,
      theme: O,
      configuration: function () {
        return a.extend({}, u, { defaultTheme: Q, alwaysWatchTheme: J, registeredStyles: [].concat(u.registeredStyles) });
      },
      disableTheming: function (R) {
        u.disableTheming = a.isUndefined(R) || !!R;
      },
      registerStyles: function (R) {
        u.registeredStyles.push(R);
      },
      setNonce: function (R) {
        u.nonce = R;
      },
      generateThemesOnDemand: function (R) {
        u.generateOnDemand = R;
      },
      setDefaultTheme: function (R) {
        Q = R;
      },
      alwaysWatchTheme: function (R) {
        J = R;
      },
      enableBrowserColor: Y,
      $get: K,
      _LIGHT_DEFAULT_HUES: A,
      _DARK_DEFAULT_HUES: w,
      _PALETTES: r,
      _THEMES: M,
      _parseRules: g,
      _rgba: n
    });
  }
  function c(D, G, N, C, F, O) {
    return {
      priority: 101,
      link: {
        pre: function (S, K, M) {
          var I = [],
            J = G.startSymbol(),
            Q = G.endSymbol(),
            T = M.mdTheme.trim();
          T = T.substr(0, J.length) === J && T.lastIndexOf(Q) === T.length - Q.length;
          J = "::" === M.mdTheme.split(J).join("").split(Q).join("").trim().substr(0, 2);
          Q = function () {
            var X = G(M.mdTheme)(S);
            return N(X)(S) || X;
          };
          var Y = {
            isAsyncTheme: a.isFunction(Q()) || a.isFunction(Q().then),
            registerChanges: function (X, aa) {
              aa && (X = a.bind(aa, X));
              I.push(X);
              return function () {
                var ha = I.indexOf(X);
                -1 < ha && I.splice(ha, 1);
              };
            },
            $setTheme: function (X) {
              D.registered(X) || O.warn("attempted to use unregistered theme '" + X + "'");
              Y.$mdTheme = X;
              for (var aa = I.length; aa--; ) I[aa](X);
            },
            $shouldWatch: C.parseAttributeBoolean(K.attr("md-theme-watch")) || D.ALWAYS_WATCH || (T && !J)
          };
          K.data("$mdThemeController", Y);
          var R = function (X) {
            if ("string" === typeof X) return Y.$setTheme(X);
            F.when(a.isFunction(X) ? X() : X).then(function (aa) {
              Y.$setTheme(aa);
            });
          };
          R(Q());
          var U = S.$watch(Q, function (X) {
            X && (R(X), Y.$shouldWatch || U());
          });
        }
      }
    };
  }
  function e() {
    u.disableTheming = !0;
    return { restrict: "A", priority: "900" };
  }
  function f(D) {
    return D;
  }
  function g(D, G, N) {
    m(D, G);
    N = N.replace(/THEME_NAME/g, D.name);
    var C = new RegExp("\\.md-" + D.name + "-theme", "g");
    G = /'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue-[0-3]|shadow|default)-?(\d\.?\d*)?(contrast)?\s*\}\}'?"?/g;
    N = N.replace(G, function (S, K, M, I, J) {
      if ("foreground" === K) return "shadow" == M ? D.foregroundShadow : D.foregroundPalette[M] || D.foregroundPalette["1"];
      if (0 === M.indexOf("hue") || "default" === M) M = D.colors[K].hues[M];
      return n((r[D.colors[K].name][M] || "")[J ? "contrast" : "value"], I);
    });
    var F = RegExp("('|\")?{{\\s*([a-zA-Z]+)-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\"|')?", "g"),
      O = [];
    a.forEach(["default", "hue-1", "hue-2", "hue-3"], function (S) {
      var K = N.replace(F, function (I, J, Q, T, Y) {
        Q = D.colors[Q];
        I = r[Q.name];
        Q = Q.hues[S];
        return n(I[Q]["color" === T ? "value" : "contrast"], Y);
      });
      "default" !== S && (K = K.replace(C, ".md-" + D.name + "-theme.md-" + S));
      if ("default" == D.name) {
        var M = /((?:\s|>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)\.md-default-theme((?:\s|>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)/g;
        K = K.replace(M, function (I, J, Q) {
          return I + ", " + J + Q;
        });
      }
      O.push(K);
    });
    return O;
  }
  function h(D, G) {
    function N(F) {
      var O = F.contrastDefaultColor,
        S = F.contrastLightColors || [],
        K = F.contrastStrongLightColors || [],
        M = F.contrastDarkColors || [];
      "string" === typeof S && (S = S.split(" "));
      "string" === typeof K && (K = K.split(" "));
      "string" === typeof M && (M = M.split(" "));
      delete F.contrastDefaultColor;
      delete F.contrastLightColors;
      delete F.contrastStrongLightColors;
      delete F.contrastDarkColors;
      a.forEach(F, function (I, J) {
        if (!a.isObject(I)) {
          var Q = v(I);
          if (!Q)
            throw Error(
              "Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected."
                .replace("%1", I)
                .replace("%2", F.name)
                .replace("%3", J)
            );
          F[J] = {
            hex: F[J],
            value: Q,
            contrast:
              "light" === O ? (-1 < M.indexOf(J) ? k : -1 < K.indexOf(J) ? t : p) : -1 < S.indexOf(J) ? (-1 < K.indexOf(J) ? t : p) : k
          };
        }
      });
    }
    var C = document.head;
    C = C ? C.firstElementChild : null;
    D = !u.disableTheming && D.has("$MD_THEME_CSS") ? D.get("$MD_THEME_CSS") : "";
    D += u.registeredStyles.join("");
    C &&
      0 !== D.length &&
      (a.forEach(r, N),
      (D = D.split(/\}(?!(\}|'|"|;))/)
        .filter(function (F) {
          return F && F.trim().length;
        })
        .map(function (F) {
          return F.trim() + "}";
        })),
      H.forEach(function (F) {
        z[F] = "";
      }),
      D.forEach(function (F) {
        for (var O = 0, S; (S = H[O]); O++) if (-1 < F.indexOf(".md-" + S)) return (z[S] += F);
        for (O = 0; (S = H[O]); O++) if (-1 < F.indexOf(S)) return (z[S] += F);
        return (z.primary += F);
      }),
      u.generateOnDemand ||
        a.forEach(G.THEMES, function (F) {
          q[F.name] || ("default" !== G.defaultTheme() && "default" === F.name) || l(F, F.name, u.nonce);
        }));
  }
  function l(D, G, N) {
    var C = document.head,
      F = C ? C.firstElementChild : null;
    q[G] ||
      (H.forEach(function (O) {
        for (O = g(D, O, z[O]); O.length; ) {
          var S = O.shift();
          if (S) {
            var K = document.createElement("style");
            K.setAttribute("md-theme-style", "");
            N && K.setAttribute("nonce", N);
            K.appendChild(document.createTextNode(S));
            C.insertBefore(K, F);
          }
        }
      }),
      (q[D.name] = !0));
  }
  function m(D, G) {
    if (!r[(D.colors[G] || {}).name])
      throw Error(
        "You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3"
          .replace("%1", D.name)
          .replace("%2", G)
          .replace("%3", Object.keys(r).join(", "))
      );
  }
  function v(D) {
    if (a.isArray(D) && 3 == D.length) return D;
    if (/^rgb/.test(D))
      return D.replace(/(^\s*rgba?\(|\)\s*$)/g, "")
        .split(",")
        .map(function (F, O) {
          return 3 == O ? parseFloat(F, 10) : parseInt(F, 10);
        });
    "#" == D.charAt(0) && (D = D.substring(1));
    if (/^([a-fA-F0-9]{3}){1,2}$/g.test(D)) {
      var G = D.length / 3,
        N = D.substr(0, G),
        C = D.substr(G, G);
      D = D.substr(2 * G);
      1 === G && ((N += N), (C += C), (D += D));
      return [parseInt(N, 16), parseInt(C, 16), parseInt(D, 16)];
    }
  }
  function n(D, G) {
    if (!D) return "rgb('0,0,0')";
    4 == D.length && ((D = a.copy(D)), G ? D.pop() : (G = D.pop()));
    return G && ("number" == typeof G || ("string" == typeof G && G.length))
      ? "rgba(" + D.join(",") + "," + G + ")"
      : "rgb(" + D.join(",") + ")";
  }
  b.$inject = ["$mdThemingProvider"];
  c.$inject = "$mdTheming $interpolate $parse $mdUtil $q $log".split(" ");
  f.$inject = ["$mdTheming"];
  d.$inject = ["$mdColorPalette", "$$mdMetaProvider"];
  h.$inject = ["$injector", "$mdTheming"];
  a.module("material.core.theming", ["material.core.theming.palette", "material.core.meta"])
    .directive("mdTheme", c)
    .directive("mdThemable", f)
    .directive("mdThemesDisabled", e)
    .provider("$mdTheming", d)
    .config(b)
    .run(h);
  var q = {},
    r,
    x = { name: "dark", 1: "rgba(0,0,0,0.87)", 2: "rgba(0,0,0,0.54)", 3: "rgba(0,0,0,0.38)", 4: "rgba(0,0,0,0.12)" },
    y = { name: "light", 1: "rgba(255,255,255,1.0)", 2: "rgba(255,255,255,0.7)", 3: "rgba(255,255,255,0.5)", 4: "rgba(255,255,255,0.12)" },
    k = v("rgba(0,0,0,0.87)"),
    p = v("rgba(255,255,255,0.87)"),
    t = v("rgb(255,255,255)"),
    H = ["primary", "accent", "warn", "background"],
    A = {
      accent: { default: "A200", "hue-1": "A100", "hue-2": "A400", "hue-3": "A700" },
      background: { default: "50", "hue-1": "A100", "hue-2": "100", "hue-3": "300" }
    },
    w = { background: { default: "A400", "hue-1": "800", "hue-2": "900", "hue-3": "A200" } };
  H.forEach(function (D) {
    var G = { default: "500", "hue-1": "300", "hue-2": "800", "hue-3": "A100" };
    A[D] || (A[D] = G);
    w[D] || (w[D] = G);
  });
  var B = "50 100 200 300 400 500 600 700 800 900 A100 A200 A400 A700".split(" "),
    u = { disableTheming: !1, generateOnDemand: !1, registeredStyles: [], nonce: null },
    z = {};
})(window.angular);
(function () {
  function a(b) {
    return {
      attach: function (d, c, e) {
        var f = angular,
          g = f.extend;
        var h = c;
        h = h.hasClass("md-icon-button")
          ? { isMenuItem: h.hasClass("md-menu-item"), fitRipple: !0, center: !0 }
          : { isMenuItem: h.hasClass("md-menu-item"), dimBackground: !0 };
        e = g.call(f, h, e);
        return b.attach(d, c, e);
      }
    };
  }
  a.$inject = ["$mdInkRipple"];
  angular.module("material.core").factory("$mdButtonInkRipple", a);
})();
(function () {
  function a(b) {
    function d(c, e, f) {
      return b.attach(c, e, angular.extend({ center: !0, dimBackground: !1, fitRipple: !0 }, f));
    }
    return { attach: d };
  }
  a.$inject = ["$mdInkRipple"];
  angular.module("material.core").factory("$mdCheckboxInkRipple", a);
})();
(function () {
  function a(b) {
    function d(c, e, f) {
      return b.attach(c, e, angular.extend({ center: !1, dimBackground: !0, outline: !1, rippleSize: "full" }, f));
    }
    return { attach: d };
  }
  a.$inject = ["$mdInkRipple"];
  angular.module("material.core").factory("$mdListInkRipple", a);
})();
InkRippleCtrl.$inject = "$scope $element rippleOptions $window $timeout $mdUtil $mdColorUtil".split(" ");
InkRippleDirective.$inject = ["$mdButtonInkRipple", "$mdCheckboxInkRipple"];
angular
  .module("material.core")
  .provider("$mdInkRipple", InkRippleProvider)
  .directive("mdInkRipple", InkRippleDirective)
  .directive("mdNoInk", attrNoDirective)
  .directive("mdNoBar", attrNoDirective)
  .directive("mdNoStretch", attrNoDirective);
function InkRippleDirective(a, b) {
  return {
    controller: angular.noop,
    link: function (d, c, e) {
      e.hasOwnProperty("mdInkRippleCheckbox") ? b.attach(d, c) : a.attach(d, c);
    }
  };
}
function InkRippleProvider() {
  function a() {
    b = !0;
  }
  var b = !1;
  return {
    disableInkRipple: a,
    $get: [
      "$injector",
      function (d) {
        function c(e, f, g) {
          return b || f.controller("mdNoInk") ? angular.noop : d.instantiate(InkRippleCtrl, { $scope: e, $element: f, rippleOptions: g });
        }
        return { attach: c };
      }
    ]
  };
}
function InkRippleCtrl(a, b, d, c, e, f, g) {
  this.$window = c;
  this.$timeout = e;
  this.$mdUtil = f;
  this.$mdColorUtil = g;
  this.$scope = a;
  this.$element = b;
  this.options = d;
  this.mousedown = !1;
  this.ripples = [];
  this.lastRipple = this.timeout = null;
  f.valueOnUse(this, "container", this.createContainer);
  this.$element.addClass("md-ink-ripple");
  (b.controller("mdInkRipple") || {}).createRipple = angular.bind(this, this.createRipple);
  (b.controller("mdInkRipple") || {}).setColor = angular.bind(this, this.color);
  this.bindEvents();
}
function autoCleanup(a, b) {
  if (a.mousedown || a.lastRipple) (a.mousedown = !1), a.$mdUtil.nextTick(angular.bind(a, b), !1);
}
InkRippleCtrl.prototype.color = function (a) {
  var b = this;
  angular.isDefined(a) && (b._color = b._parseColor(a));
  if (!(a = b._color || b._parseColor(b.inkRipple()))) {
    a = b;
    var d = a._parseColor,
      c = b.options && b.options.colorElement ? b.options.colorElement : [];
    b = (c = c.length ? c[0] : b.$element[0]) ? b.$window.getComputedStyle(c).color : "rgb(0,0,0)";
    a = d.call(a, b);
  }
  return a;
};
InkRippleCtrl.prototype.calculateColor = function () {
  return this.color();
};
InkRippleCtrl.prototype._parseColor = function (a, b) {
  b = b || 1;
  var d = this.$mdColorUtil;
  if (a) {
    if (0 === a.indexOf("rgba")) return a.replace(/\d?\.?\d*\s*\)\s*$/, (0.1 * b).toString() + ")");
    if (0 === a.indexOf("rgb")) return d.rgbToRgba(a);
    if (0 === a.indexOf("#")) return d.hexToRgba(a);
  }
};
InkRippleCtrl.prototype.bindEvents = function () {
  this.$element.on("mousedown", angular.bind(this, this.handleMousedown));
  this.$element.on("mouseup touchend", angular.bind(this, this.handleMouseup));
  this.$element.on("mouseleave", angular.bind(this, this.handleMouseup));
  this.$element.on("touchmove", angular.bind(this, this.handleTouchmove));
};
InkRippleCtrl.prototype.handleMousedown = function (a) {
  if (!this.mousedown)
    if ((a.hasOwnProperty("originalEvent") && (a = a.originalEvent), (this.mousedown = !0), this.options.center))
      this.createRipple(this.container.prop("clientWidth") / 2, this.container.prop("clientWidth") / 2);
    else if (a.srcElement !== this.$element[0]) {
      var b = this.$element[0].getBoundingClientRect(),
        d = a.clientX - b.left;
      a = a.clientY - b.top;
      this.createRipple(d, a);
    } else this.createRipple(a.offsetX, a.offsetY);
};
InkRippleCtrl.prototype.handleMouseup = function () {
  this.$timeout(
    function () {
      autoCleanup(this, this.clearRipples);
    }.bind(this)
  );
};
InkRippleCtrl.prototype.handleTouchmove = function () {
  autoCleanup(this, this.deleteRipples);
};
InkRippleCtrl.prototype.deleteRipples = function () {
  for (var a = 0; a < this.ripples.length; a++) this.ripples[a].remove();
};
InkRippleCtrl.prototype.clearRipples = function () {
  for (var a = 0; a < this.ripples.length; a++) this.fadeInComplete(this.ripples[a]);
};
InkRippleCtrl.prototype.createContainer = function () {
  var a = angular.element('<div class="md-ripple-container"></div>');
  this.$element.append(a);
  return a;
};
InkRippleCtrl.prototype.clearTimeout = function () {
  this.timeout && (this.$timeout.cancel(this.timeout), (this.timeout = null));
};
InkRippleCtrl.prototype.isRippleAllowed = function () {
  var a = this.$element[0];
  do {
    if (!a.tagName || "BODY" === a.tagName) break;
    if (a && angular.isFunction(a.hasAttribute) && (a.hasAttribute("disabled") || "false" === this.inkRipple() || "0" === this.inkRipple()))
      return !1;
  } while ((a = a.parentNode));
  return !0;
};
InkRippleCtrl.prototype.inkRipple = function () {
  return this.$element.attr("md-ink-ripple");
};
InkRippleCtrl.prototype.createRipple = function (a, b) {
  if (this.isRippleAllowed()) {
    var d = this,
      c = d.$mdColorUtil,
      e = angular.element('<div class="md-ripple"></div>'),
      f = this.$element.prop("clientWidth"),
      g = this.$element.prop("clientHeight");
    f = 2 * Math.max(Math.abs(f - a), a);
    g = 2 * Math.max(Math.abs(g - b), b);
    g = this.options.fitRipple ? Math.max(f, g) : Math.sqrt(Math.pow(f, 2) + Math.pow(g, 2));
    f = this.calculateColor();
    e.css({
      left: a + "px",
      top: b + "px",
      background: "black",
      width: g + "px",
      height: g + "px",
      backgroundColor: c.rgbaToRgb(f),
      borderColor: c.rgbaToRgb(f)
    });
    this.lastRipple = e;
    this.clearTimeout();
    this.timeout = this.$timeout(
      function () {
        d.clearTimeout();
        d.mousedown || d.fadeInComplete(e);
      },
      157.5,
      !1
    );
    this.options.dimBackground && this.container.css({ backgroundColor: f });
    this.container.append(e);
    this.ripples.push(e);
    e.addClass("md-ripple-placed");
    this.$mdUtil.nextTick(function () {
      e.addClass("md-ripple-scaled md-ripple-active");
      d.$timeout(
        function () {
          d.clearRipples();
        },
        450,
        !1
      );
    }, !1);
  }
};
InkRippleCtrl.prototype.fadeInComplete = function (a) {
  this.lastRipple === a ? this.timeout || this.mousedown || this.removeRipple(a) : this.removeRipple(a);
};
InkRippleCtrl.prototype.removeRipple = function (a) {
  var b = this,
    d = this.ripples.indexOf(a);
  0 > d ||
    (this.ripples.splice(this.ripples.indexOf(a), 1),
    a.removeClass("md-ripple-active"),
    a.addClass("md-ripple-remove"),
    0 === this.ripples.length && this.container.css({ backgroundColor: "" }),
    this.$timeout(
      function () {
        b.fadeOutComplete(a);
      },
      450,
      !1
    ));
};
InkRippleCtrl.prototype.fadeOutComplete = function (a) {
  a.remove();
  this.lastRipple = null;
};
function attrNoDirective() {
  return { controller: angular.noop };
}
(function () {
  function a(b) {
    function d(c, e, f) {
      return b.attach(c, e, angular.extend({ center: !1, dimBackground: !0, outline: !1, rippleSize: "full" }, f));
    }
    return { attach: d };
  }
  a.$inject = ["$mdInkRipple"];
  angular.module("material.core").factory("$mdTabInkRipple", a);
})();
angular.module("material.core").factory("$$mdAnimate", [
  "$q",
  "$timeout",
  "$mdConstant",
  "$animateCss",
  function (a, b, d, c) {
    return function (e) {
      return AnimateDomUtils(e, a, b, d, c);
    };
  }
]);
function AnimateDomUtils(a, b, d, c, e) {
  var f;
  return (f = {
    translate3d: function (g, h, l, m) {
      function v(n) {
        return e(g, { to: n || h, addClass: m.transitionOutClass, removeClass: m.transitionInClass, duration: m.duration }).start();
      }
      return e(g, { from: h, to: l, addClass: m.transitionInClass, removeClass: m.transitionOutClass, duration: m.duration })
        .start()
        .then(function () {
          return v;
        });
    },
    waitTransitionEnd: function (g, h) {
      var l = 3e3;
      return b(function (m) {
        function v(r) {
          (r && r.target !== g[0]) || (r && d.cancel(q), g.off(c.CSS.TRANSITIONEND, v), m());
        }
        function n(r) {
          r = r || window.getComputedStyle(g[0]);
          return "0s" == r.transitionDuration || (!r.transition && !r.transitionProperty);
        }
        h = h || {};
        n(h.cachedTransitionStyles) && (l = 0);
        var q = d(v, h.timeout || l);
        g.on(c.CSS.TRANSITIONEND, v);
      });
    },
    calculateTransformValues: function (g, h) {
      var l = h.element;
      h = h.bounds;
      if (l || h) {
        l
          ? (l = f.clientRect(l)) || (l = (l = (l = g ? g.parent() : null) ? l.parent() : null) ? f.clientRect(l) : null)
          : (l = f.copyRect(h));
        g = f.copyRect(g[0].getBoundingClientRect());
        h = f.centerPointFor(g);
        var m = f.centerPointFor(l);
        return {
          centerX: m.x - h.x,
          centerY: m.y - h.y,
          scaleX: Math.round(100 * Math.min(0.5, l.width / g.width)) / 100,
          scaleY: Math.round(100 * Math.min(0.5, l.height / g.height)) / 100
        };
      }
      return { centerX: 0, centerY: 0, scaleX: 0.5, scaleY: 0.5 };
    },
    calculateZoomToOrigin: function (g, h) {
      var l = angular.bind(null, a.supplant, "translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )");
      return l(f.calculateTransformValues(g, h));
    },
    calculateSlideToOrigin: function (g, h) {
      var l = angular.bind(null, a.supplant, "translate3d( {centerX}px, {centerY}px, 0 )");
      return l(f.calculateTransformValues(g, h));
    },
    toCss: function (g) {
      function h(m, v, n) {
        angular.forEach(v.split(" "), function (q) {
          l[q] = n;
        });
      }
      var l = {};
      angular.forEach(g, function (m, v) {
        if (!angular.isUndefined(m))
          if (0 <= "left top right bottom width height x y min-width min-height max-width max-height".indexOf(v)) l[v] = m + "px";
          else
            switch (v) {
              case "transition":
                h(v, c.CSS.TRANSITION, m);
                break;
              case "transform":
                h(v, c.CSS.TRANSFORM, m);
                break;
              case "transformOrigin":
                h(v, c.CSS.TRANSFORM_ORIGIN, m);
                break;
              case "font-size":
                l["font-size"] = m;
            }
      });
      return l;
    },
    toTransformCss: function (g, h, l) {
      var m = {};
      angular.forEach(c.CSS.TRANSFORM.split(" "), function (v) {
        m[v] = g;
      });
      h && ((l = l || "all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important"), (m.transition = l));
      return m;
    },
    copyRect: function (g, h) {
      if (!g) return null;
      h = h || {};
      angular.forEach("left top right bottom width height".split(" "), function (l) {
        h[l] = Math.round(g[l]);
      });
      h.width = h.width || h.right - h.left;
      h.height = h.height || h.bottom - h.top;
      return h;
    },
    clientRect: function (g) {
      return (g = angular.element(g)[0].getBoundingClientRect()) && 0 < g.width && 0 < g.height ? f.copyRect(g) : null;
    },
    centerPointFor: function (g) {
      return g ? { x: Math.round(g.left + g.width / 2), y: Math.round(g.top + g.height / 2) } : { x: 0, y: 0 };
    }
  });
}
4 <= angular.version.minor
  ? angular.module("material.core.animate", [])
  : (function () {
      function a(m) {
        return m.replace(/-[a-z]/g, function (v) {
          return v.charAt(1).toUpperCase();
        });
      }
      var b = angular.forEach,
        d = angular.isDefined(document.documentElement.style.WebkitAppearance),
        c = d ? "-webkit-" : "",
        e = (d ? "webkitTransitionEnd " : "") + "transitionend",
        f = (d ? "webkitAnimationEnd " : "") + "animationend",
        g = [
          "$document",
          function (m) {
            return function () {
              return m[0].body.clientWidth + 1;
            };
          }
        ],
        h = [
          "$$rAF",
          function (m) {
            return function () {
              var v = !1;
              m(function () {
                v = !0;
              });
              return function (n) {
                v ? n() : m(n);
              };
            };
          }
        ],
        l = [
          "$q",
          "$$rAFMutex",
          function (m, v) {
            function n(q) {
              this.setHost(q);
              this._doneCallbacks = [];
              this._runInAnimationFrame = v();
              this._state = 0;
            }
            n.prototype = {
              setHost: function (q) {
                this.host = q || {};
              },
              done: function (q) {
                2 === this._state ? q() : this._doneCallbacks.push(q);
              },
              progress: angular.noop,
              getPromise: function () {
                if (!this.promise) {
                  var q = this;
                  this.promise = m(function (r, x) {
                    q.done(function (y) {
                      !1 === y ? x() : r();
                    });
                  });
                }
                return this.promise;
              },
              then: function (q, r) {
                return this.getPromise().then(q, r);
              },
              catch: function (q) {
                return this.getPromise()["catch"](q);
              },
              finally: function (q) {
                return this.getPromise()["finally"](q);
              },
              pause: function () {
                this.host.pause && this.host.pause();
              },
              resume: function () {
                this.host.resume && this.host.resume();
              },
              end: function () {
                this.host.end && this.host.end();
                this._resolve(!0);
              },
              cancel: function () {
                this.host.cancel && this.host.cancel();
                this._resolve(!1);
              },
              complete: function (q) {
                var r = this;
                0 === r._state &&
                  ((r._state = 1),
                  r._runInAnimationFrame(function () {
                    r._resolve(q);
                  }));
              },
              _resolve: function (q) {
                2 !== this._state &&
                  (b(this._doneCallbacks, function (r) {
                    r(q);
                  }),
                  (this._doneCallbacks.length = 0),
                  (this._state = 2));
              }
            };
            n.all = function (q, r) {
              function x(p) {
                k = k && p;
                ++y === q.length && r(k);
              }
              var y = 0,
                k = !0;
              b(q, function (p) {
                p.done(x);
              });
            };
            return n;
          }
        ];
      angular
        .module("material.core.animate", [])
        .factory("$$forceReflow", g)
        .factory("$$AnimateRunner", l)
        .factory("$$rAFMutex", h)
        .factory("$animateCss", [
          "$window",
          "$$rAF",
          "$$AnimateRunner",
          "$$forceReflow",
          "$$jqLite",
          "$timeout",
          "$animate",
          function (m, v, n, q, r, x, y) {
            function k(C, F) {
              var O = [],
                S = z(C),
                K = S && y.enabled(),
                M = !1,
                I = !1;
              K &&
                (F.transitionStyle && O.push([c + "transition", F.transitionStyle]),
                F.keyframeStyle && O.push([c + "animation", F.keyframeStyle]),
                F.delay && O.push([c + "transition-delay", F.delay + "s"]),
                F.duration && O.push([c + "transition-duration", F.duration + "s"]),
                (M = F.keyframeStyle || (F.to && (0 < F.duration || F.transitionStyle))),
                (I = !!F.addClass || !!F.removeClass),
                D(C, !0));
              var J = K && (M || I);
              B(C, F);
              var Q = !1,
                T,
                Y;
              return {
                close: m.close,
                start: function () {
                  function R() {
                    if (!Q)
                      return (
                        (Q = !0),
                        T && Y && C.off(T, Y),
                        p(C, F),
                        w(C, F),
                        b(O, function (X) {
                          S.style[a(X[0])] = "";
                        }),
                        U.complete(!0),
                        U
                      );
                  }
                  var U = new n();
                  A(function () {
                    D(C, !1);
                    if (!J) return R();
                    b(O, function (ca) {
                      var da = ca[0];
                      ca = ca[1];
                      S.style[a(da)] = ca;
                    });
                    p(C, F);
                    var X = t(C);
                    if (0 === X.duration) return R();
                    var aa = [];
                    F.easing &&
                      (X.transitionDuration && aa.push([c + "transition-timing-function", F.easing]),
                      X.animationDuration && aa.push([c + "animation-timing-function", F.easing]));
                    F.delay && X.animationDelay && aa.push([c + "animation-delay", F.delay + "s"]);
                    F.duration && X.animationDuration && aa.push([c + "animation-duration", F.duration + "s"]);
                    b(aa, function (ca) {
                      var da = ca[0],
                        la = ca[1];
                      S.style[a(da)] = la;
                      O.push(ca);
                    });
                    aa = X.delay;
                    var ha = 1e3 * aa,
                      fa = X.duration;
                    aa = 1e3 * fa;
                    var ea = Date.now();
                    T = [];
                    X.transitionDuration && T.push(e);
                    X.animationDuration && T.push(f);
                    T = T.join(" ");
                    Y = function (ca) {
                      ca.stopPropagation();
                      var da = ca.originalEvent || ca;
                      ca = da.timeStamp || Date.now();
                      da = parseFloat(da.elapsedTime.toFixed(3));
                      Math.max(ca - ea, 0) >= ha && da >= fa && R();
                    };
                    C.on(T, Y);
                    u(C, F);
                    x(R, ha + 1.5 * aa, !1);
                  });
                  return U;
                }
              };
            }
            function p(C, F) {
              F.addClass && (r.addClass(C, F.addClass), (F.addClass = null));
              F.removeClass && (r.removeClass(C, F.removeClass), (F.removeClass = null));
            }
            function t(C) {
              function F(J) {
                return d ? "Webkit" + J.charAt(0).toUpperCase() + J.substr(1) : J;
              }
              C = z(C);
              var O = m.getComputedStyle(C);
              C = H(O[F("transitionDuration")]);
              var S = H(O[F("animationDuration")]),
                K = H(O[F("transitionDelay")]),
                M = H(O[F("animationDelay")]);
              S *= parseInt(O[F("animationIterationCount")], 10) || 1;
              O = Math.max(S, C);
              var I = Math.max(M, K);
              return { duration: O, delay: I, animationDuration: S, transitionDuration: C, animationDelay: M, transitionDelay: K };
            }
            function H(C) {
              var F = 0;
              C = (C || "").split(/\s*,\s*/);
              b(C, function (O) {
                "s" == O.charAt(O.length - 1) && (O = O.substring(0, O.length - 1));
                O = parseFloat(O) || 0;
                F = F ? Math.max(O, F) : O;
              });
              return F;
            }
            function A(C) {
              G && G();
              N.push(C);
              G = v(function () {
                G = null;
                for (var F = q(), O = 0; O < N.length; O++) N[O](F);
                N.length = 0;
              });
            }
            function w(C, F) {
              B(C, F);
              u(C, F);
            }
            function B(C, F) {
              F.from && (C.css(F.from), (F.from = null));
            }
            function u(C, F) {
              F.to && (C.css(F.to), (F.to = null));
            }
            function z(C) {
              for (var F = 0; F < C.length; F++) if (1 === C[F].nodeType) return C[F];
            }
            function D(C, F) {
              C = z(C);
              var O = a(c + "transition-delay");
              C.style[O] = F ? "-9999s" : "";
            }
            var G,
              N = [];
            return k;
          }
        ]);
    })();
angular
  .module("material.core")
  .constant(
    "$MD_THEME_CSS",
    'md-autocomplete.md-THEME_NAME-theme{background:"{{background-hue-1}}"}md-autocomplete.md-THEME_NAME-theme[disabled]:not([md-floating-label]){background:"{{background-hue-2}}"}md-autocomplete.md-THEME_NAME-theme button md-icon path{fill:"{{background-600}}"}md-autocomplete.md-THEME_NAME-theme button:after{background:"{{background-600-0.3}}"}md-autocomplete.md-THEME_NAME-theme input{color:"{{foreground-1}}"}md-autocomplete.md-THEME_NAME-theme.md-accent md-input-container.md-input-focused .md-input{border-color:"{{accent-color}}"}md-autocomplete.md-THEME_NAME-theme.md-accent md-input-container.md-input-focused label,md-autocomplete.md-THEME_NAME-theme.md-accent md-input-container.md-input-focused md-icon{color:"{{accent-color}}"}md-autocomplete.md-THEME_NAME-theme.md-accent md-progress-linear .md-container{background-color:"{{accent-100}}"}md-autocomplete.md-THEME_NAME-theme.md-accent md-progress-linear .md-bar{background-color:"{{accent-color}}"}md-autocomplete.md-THEME_NAME-theme.md-warn md-input-container.md-input-focused .md-input{border-color:"{{warn-A700}}"}md-autocomplete.md-THEME_NAME-theme.md-warn md-input-container.md-input-focused label,md-autocomplete.md-THEME_NAME-theme.md-warn md-input-container.md-input-focused md-icon{color:"{{warn-A700}}"}md-autocomplete.md-THEME_NAME-theme.md-warn md-progress-linear .md-container{background-color:"{{warn-100}}"}md-autocomplete.md-THEME_NAME-theme.md-warn md-progress-linear .md-bar{background-color:"{{warn-color}}"}.md-autocomplete-standard-list-container.md-THEME_NAME-theme,.md-autocomplete-suggestions-container.md-THEME_NAME-theme{background:"{{background-hue-1}}"}.md-autocomplete-standard-list-container.md-THEME_NAME-theme .md-autocomplete-suggestion,.md-autocomplete-suggestions-container.md-THEME_NAME-theme .md-autocomplete-suggestion{color:"{{foreground-1}}"}.md-autocomplete-standard-list-container.md-THEME_NAME-theme .md-autocomplete-suggestion.selected,.md-autocomplete-standard-list-container.md-THEME_NAME-theme .md-autocomplete-suggestion:hover,.md-autocomplete-suggestions-container.md-THEME_NAME-theme .md-autocomplete-suggestion.selected,.md-autocomplete-suggestions-container.md-THEME_NAME-theme .md-autocomplete-suggestion:hover{background:"{{background-500-0.18}}"}md-backdrop{background-color:"{{background-900-0.0}}"}md-backdrop.md-opaque.md-THEME_NAME-theme{background-color:"{{background-900-1.0}}"}md-bottom-sheet.md-THEME_NAME-theme{background-color:"{{background-color}}";border-top-color:"{{background-hue-3}}"}md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item{color:"{{foreground-1}}"}md-bottom-sheet.md-THEME_NAME-theme .md-subheader{background-color:"{{background-color}}";color:"{{foreground-1}}"}.md-button.md-THEME_NAME-theme:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme:not([disabled]):hover{background-color:"{{background-500-0.2}}"}.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover{background-color:transparent}.md-button.md-THEME_NAME-theme.md-fab md-icon{color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-primary{color:"{{primary-color}}"}.md-button.md-THEME_NAME-theme.md-primary.md-fab,.md-button.md-THEME_NAME-theme.md-primary.md-raised{color:"{{primary-contrast}}";background-color:"{{primary-color}}"}.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon{color:"{{primary-contrast}}"}.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover{background-color:"{{primary-600}}"}.md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon{color:"{{primary-color}}"}.md-button.md-THEME_NAME-theme.md-fab{background-color:"{{accent-color}}";color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon{color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover{background-color:"{{accent-A700}}"}.md-button.md-THEME_NAME-theme.md-raised{color:"{{background-900}}";background-color:"{{background-50}}"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon{color:"{{background-900}}"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover{background-color:"{{background-50}}"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused{background-color:"{{background-200}}"}.md-button.md-THEME_NAME-theme.md-warn{color:"{{warn-color}}"}.md-button.md-THEME_NAME-theme.md-warn.md-fab,.md-button.md-THEME_NAME-theme.md-warn.md-raised{color:"{{warn-contrast}}";background-color:"{{warn-color}}"}.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon{color:"{{warn-contrast}}"}.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover{background-color:"{{warn-600}}"}.md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon{color:"{{warn-color}}"}.md-button.md-THEME_NAME-theme.md-accent{color:"{{accent-color}}"}.md-button.md-THEME_NAME-theme.md-accent.md-fab,.md-button.md-THEME_NAME-theme.md-accent.md-raised{color:"{{accent-contrast}}";background-color:"{{accent-color}}"}.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon{color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover{background-color:"{{accent-A700}}"}.md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon{color:"{{accent-color}}"}.md-button.md-THEME_NAME-theme.md-accent[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-warn[disabled],.md-button.md-THEME_NAME-theme[disabled]{color:"{{foreground-3}}";cursor:default}.md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon,.md-button.md-THEME_NAME-theme[disabled] md-icon{color:"{{foreground-3}}"}.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled]{background-color:"{{foreground-4}}"}.md-button.md-THEME_NAME-theme[disabled]{background-color:transparent}._md a.md-THEME_NAME-theme:not(.md-button).md-primary{color:"{{primary-color}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-primary:hover{color:"{{primary-700}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-accent{color:"{{accent-color}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-accent:hover{color:"{{accent-A700}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-warn{color:"{{warn-color}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-warn:hover{color:"{{warn-700}}"}md-card.md-THEME_NAME-theme{color:"{{foreground-1}}";background-color:"{{background-hue-1}}";border-radius:2px}md-card.md-THEME_NAME-theme .md-card-image{border-radius:2px 2px 0 0}md-card.md-THEME_NAME-theme md-card-header md-card-avatar md-icon{color:"{{background-color}}";background-color:"{{foreground-3}}"}md-card.md-THEME_NAME-theme md-card-header md-card-header-text .md-subhead,md-card.md-THEME_NAME-theme md-card-title md-card-title-text:not(:only-child) .md-subhead{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme .md-ripple{color:"{{accent-A700}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple{color:"{{background-600}}"}md-checkbox.md-THEME_NAME-theme.md-checked.md-focused .md-container:before{background-color:"{{accent-color-0.26}}"}md-checkbox.md-THEME_NAME-theme .md-ink-ripple{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-ink-ripple{color:"{{accent-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-icon{background-color:"{{accent-color-0.87}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after{border-color:"{{accent-contrast-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple{color:"{{primary-600}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple{color:"{{background-600}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ink-ripple{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple{color:"{{primary-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon{background-color:"{{primary-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused .md-container:before{background-color:"{{primary-color-0.26}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after{border-color:"{{primary-contrast-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-indeterminate[disabled] .md-container{color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple{color:"{{warn-600}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ink-ripple{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple{color:"{{warn-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon{background-color:"{{warn-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) .md-container:before{background-color:"{{warn-color-0.26}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after{border-color:"{{background-200}}"}md-checkbox.md-THEME_NAME-theme[disabled]:not(.md-checked) .md-icon{border-color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon{background-color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon:after{border-color:"{{background-200}}"}md-checkbox.md-THEME_NAME-theme[disabled] .md-icon:after{border-color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme[disabled] .md-label{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme .md-chips{box-shadow:0 1px "{{foreground-4}}"}md-chips.md-THEME_NAME-theme .md-chips.md-focused{box-shadow:0 2px "{{primary-color}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input{color:"{{foreground-1}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input::-webkit-input-placeholder{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input:-ms-input-placeholder,md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input::-ms-input-placeholder{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input::placeholder{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input:-moz-placeholder,md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input::-moz-placeholder{color:"{{foreground-3}}";opacity:1}md-chips.md-THEME_NAME-theme md-chip{background:"{{background-300}}";color:"{{background-800}}"}md-chips.md-THEME_NAME-theme md-chip md-icon{color:"{{background-700}}"}md-chips.md-THEME_NAME-theme md-chip.md-focused{background:"{{primary-color}}";color:"{{primary-contrast}}"}md-chips.md-THEME_NAME-theme md-chip.md-focused md-icon{color:"{{primary-contrast}}"}md-chips.md-THEME_NAME-theme md-chip._md-chip-editing{background:transparent;color:"{{background-800}}"}md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path{fill:"{{background-500}}"}.md-contact-suggestion span.md-contact-email{color:"{{background-400}}"}md-content.md-THEME_NAME-theme{color:"{{foreground-1}}";background-color:"{{background-default}}"}.md-THEME_NAME-theme .md-calendar{background:"{{background-hue-1}}";color:"{{foreground-1-0.87}}"}.md-THEME_NAME-theme .md-calendar tr:last-child td{border-bottom-color:"{{background-hue-2}}"}.md-THEME_NAME-theme .md-calendar-day-header{background:"{{background-500-0.32}}";color:"{{foreground-1-0.87}}"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today .md-calendar-date-selection-indicator{border:1px solid "{{primary-500}}"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today.md-calendar-date-disabled{color:"{{primary-500-0.6}}"}.md-calendar-date.md-focus .md-THEME_NAME-theme .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date-selection-indicator:hover{background:"{{background-500-0.32}}"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-selected-date .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date.md-focus.md-calendar-selected-date .md-calendar-date-selection-indicator{background:"{{primary-500}}";color:"{{primary-500-contrast}}";border-color:transparent}.md-THEME_NAME-theme .md-calendar-date-disabled,.md-THEME_NAME-theme .md-calendar-month-label-disabled{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-calendar-month-label md-icon,.md-THEME_NAME-theme .md-datepicker-input{color:"{{foreground-1}}"}.md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-datepicker-input:-ms-input-placeholder,.md-THEME_NAME-theme .md-datepicker-input::-ms-input-placeholder{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-datepicker-input::placeholder{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-datepicker-input:-moz-placeholder,.md-THEME_NAME-theme .md-datepicker-input::-moz-placeholder{color:"{{foreground-3}}";opacity:1}.md-THEME_NAME-theme .md-datepicker-input-container{border-bottom-color:"{{foreground-4}}"}.md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:"{{primary-color}}"}.md-accent .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:"{{accent-color}}"}.md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-invalid,.md-warn .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:"{{warn-A700}}"}.md-THEME_NAME-theme .md-datepicker-calendar-pane{border-color:"{{background-hue-1}}"}.md-THEME_NAME-theme .md-datepicker-triangle-button .md-datepicker-expand-triangle{border-top-color:"{{foreground-2}}"}.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon{color:"{{primary-color}}"}.md-accent .md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon,.md-THEME_NAME-theme .md-datepicker-open.md-accent .md-datepicker-calendar-icon{color:"{{accent-color}}"}.md-THEME_NAME-theme .md-datepicker-open.md-warn .md-datepicker-calendar-icon,.md-warn .md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon{color:"{{warn-A700}}"}.md-THEME_NAME-theme .md-datepicker-calendar{background:"{{background-hue-1}}"}.md-THEME_NAME-theme .md-datepicker-input-mask-opaque{box-shadow:0 0 0 9999px "{{background-hue-1}}"}.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-input-container{background:"{{background-hue-1}}"}md-dialog.md-THEME_NAME-theme{border-radius:4px;background-color:"{{background-hue-1}}";color:"{{foreground-1}}"}md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions,md-dialog.md-THEME_NAME-theme.md-content-overflow md-dialog-actions,md-divider.md-THEME_NAME-theme{border-top-color:"{{foreground-4}}"}.layout-gt-lg-row>md-divider.md-THEME_NAME-theme,.layout-gt-md-row>md-divider.md-THEME_NAME-theme,.layout-gt-sm-row>md-divider.md-THEME_NAME-theme,.layout-gt-xs-row>md-divider.md-THEME_NAME-theme,.layout-lg-row>md-divider.md-THEME_NAME-theme,.layout-md-row>md-divider.md-THEME_NAME-theme,.layout-row>md-divider.md-THEME_NAME-theme,.layout-sm-row>md-divider.md-THEME_NAME-theme,.layout-xl-row>md-divider.md-THEME_NAME-theme,.layout-xs-row>md-divider.md-THEME_NAME-theme{border-right-color:"{{foreground-4}}"}md-icon.md-THEME_NAME-theme{color:"{{foreground-2}}"}md-icon.md-THEME_NAME-theme.md-primary{color:"{{primary-color}}"}md-icon.md-THEME_NAME-theme.md-accent{color:"{{accent-color}}"}md-icon.md-THEME_NAME-theme.md-warn{color:"{{warn-color}}"}md-input-container.md-THEME_NAME-theme .md-input{color:"{{foreground-1}}";border-color:"{{foreground-4}}"}md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder,md-input-container.md-THEME_NAME-theme .md-input::-ms-input-placeholder{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme .md-input::placeholder{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder,md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder{color:"{{foreground-2}}";opacity:1}md-input-container.md-THEME_NAME-theme>md-icon{color:"{{foreground-1}}"}md-input-container.md-THEME_NAME-theme .md-placeholder,md-input-container.md-THEME_NAME-theme label{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme label.md-required:after{color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-focused):not(.md-input-invalid) label.md-required:after{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme .md-input-message-animation,md-input-container.md-THEME_NAME-theme .md-input-messages-animation{color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme .md-input-message-animation .md-char-counter,md-input-container.md-THEME_NAME-theme .md-input-messages-animation .md-char-counter{color:"{{foreground-1}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input::-webkit-input-placeholder{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input:-ms-input-placeholder,md-input-container.md-THEME_NAME-theme.md-input-focused .md-input::-ms-input-placeholder{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input::placeholder{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input:-moz-placeholder,md-input-container.md-THEME_NAME-theme.md-input-focused .md-input::-moz-placeholder{color:"{{foreground-2}}";opacity:1}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-resized .md-input{border-color:"{{primary-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon{color:"{{primary-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input{border-color:"{{accent-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent md-icon{color:"{{accent-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input{border-color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn md-icon{color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input{border-color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter,md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input-message-animation,md-input-container.md-THEME_NAME-theme.md-input-invalid label{color:"{{warn-A700}}"}[disabled] md-input-container.md-THEME_NAME-theme .md-input,md-input-container.md-THEME_NAME-theme .md-input[disabled]{border-bottom-color:transparent;color:"{{foreground-3}}";background-image:linear-gradient(90deg,"{{foreground-3}}" 0,"{{foreground-3}}" 33%,transparent 0);background-image:-ms-linear-gradient(left,transparent 0,"{{foreground-3}}" 100%)}md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4{color:"{{foreground-1}}"}md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p{color:"{{foreground-2}}"}md-list.md-THEME_NAME-theme .md-proxy-focus.md-focused div.md-no-style{background-color:"{{background-100}}"}md-list.md-THEME_NAME-theme md-list-item .md-avatar-icon{background-color:"{{foreground-3}}";color:"{{background-color}}"}md-list.md-THEME_NAME-theme md-list-item>md-icon{color:"{{foreground-2}}"}md-list.md-THEME_NAME-theme md-list-item>md-icon.md-highlight{color:"{{primary-color}}"}md-list.md-THEME_NAME-theme md-list-item>md-icon.md-highlight.md-accent{color:"{{accent-color}}"}md-menu-content.md-THEME_NAME-theme{background-color:"{{background-hue-1}}"}md-menu-content.md-THEME_NAME-theme md-menu-item{color:"{{foreground-1}}"}md-menu-content.md-THEME_NAME-theme md-menu-item md-icon{color:"{{foreground-2}}"}md-menu-content.md-THEME_NAME-theme md-menu-item .md-button[disabled],md-menu-content.md-THEME_NAME-theme md-menu-item .md-button[disabled] md-icon{color:"{{foreground-3}}"}md-menu-content.md-THEME_NAME-theme md-menu-divider{background-color:"{{foreground-4}}"}md-menu-bar.md-THEME_NAME-theme>button.md-button{color:"{{foreground-1}}";border-radius:2px}md-menu-bar.md-THEME_NAME-theme md-menu>button{color:"{{foreground-1}}"}md-menu-bar.md-THEME_NAME-theme md-menu.md-open>button,md-menu-bar.md-THEME_NAME-theme md-menu>button:focus{outline:none;background-color:"{{ background-500-0.18}}"}md-menu-bar.md-THEME_NAME-theme.md-open:not(.md-keyboard-mode) md-menu:hover>button{background-color:"{{ background-500-0.18}}"}md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:focus,md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:hover{background:transparent}md-menu-content.md-THEME_NAME-theme .md-menu>.md-button:after{color:"{{foreground-2}}"}md-menu-content.md-THEME_NAME-theme .md-menu.md-open>.md-button{background-color:"{{ background-500-0.18}}"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar{background-color:"{{background-hue-1}}";color:"{{foreground-1}}"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler{background-color:"{{primary-color}}";color:"{{primary-contrast}}"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler md-icon{color:"{{primary-contrast}}"}md-nav-bar.md-THEME_NAME-theme .md-nav-bar{background-color:transparent;border-color:"{{foreground-4}}"}md-nav-bar.md-THEME_NAME-theme .md-button._md-nav-button.md-unselected{color:"{{foreground-2}}"}md-nav-bar.md-THEME_NAME-theme .md-button._md-nav-button[disabled]{color:"{{foreground-3}}"}md-nav-bar.md-THEME_NAME-theme md-nav-ink-bar{color:"{{accent-color}}";background:"{{accent-color}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar{background-color:"{{accent-color}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button{color:"{{accent-A100}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{accent-contrast}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{accent-contrast-0.1}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar md-nav-ink-bar{color:"{{primary-600-1}}";background:"{{primary-600-1}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar{background-color:"{{warn-color}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button{color:"{{warn-100}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{warn-contrast}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{warn-contrast-0.1}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar{background-color:"{{primary-color}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button{color:"{{primary-100}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{primary-contrast}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{primary-contrast-0.1}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:"{{primary-color}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:"{{primary-100}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{primary-contrast}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{primary-contrast-0.1}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:"{{accent-color}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:"{{accent-A100}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{accent-contrast}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{accent-contrast-0.1}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar md-nav-ink-bar{color:"{{primary-600-1}}";background:"{{primary-600-1}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:"{{warn-color}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:"{{warn-100}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{warn-contrast}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{warn-contrast-0.1}}"}._md-panel-backdrop.md-THEME_NAME-theme{background-color:"{{background-900-1.0}}"}md-progress-circular.md-THEME_NAME-theme path{stroke:"{{primary-color}}"}md-progress-circular.md-THEME_NAME-theme.md-warn path{stroke:"{{warn-color}}"}md-progress-circular.md-THEME_NAME-theme.md-accent path{stroke:"{{accent-color}}"}md-progress-linear.md-THEME_NAME-theme .md-container{background-color:"{{primary-100}}"}md-progress-linear.md-THEME_NAME-theme .md-bar{background-color:"{{primary-color}}"}md-progress-linear.md-THEME_NAME-theme.md-warn .md-container{background-color:"{{warn-100}}"}md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar{background-color:"{{warn-color}}"}md-progress-linear.md-THEME_NAME-theme.md-accent .md-container{background-color:"{{accent-100}}"}md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar{background-color:"{{accent-color}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-primary .md-bar1{background-color:"{{primary-100}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-primary .md-dashed:before{background:radial-gradient("{{primary-100}}" 0,"{{primary-100}}" 16%,transparent 42%)}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1{background-color:"{{warn-100}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before{background:radial-gradient("{{warn-100}}" 0,"{{warn-100}}" 16%,transparent 42%)}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1{background-color:"{{accent-100}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before{background:radial-gradient("{{accent-100}}" 0,"{{accent-100}}" 16%,transparent 42%)}md-radio-button.md-THEME_NAME-theme .md-off{border-color:"{{foreground-2}}"}md-radio-button.md-THEME_NAME-theme .md-on{background-color:"{{accent-color-0.87}}"}md-radio-button.md-THEME_NAME-theme.md-checked .md-off{border-color:"{{accent-color-0.87}}"}md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple{color:"{{accent-color-0.87}}"}md-radio-button.md-THEME_NAME-theme .md-container .md-ripple{color:"{{accent-A700}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on{background-color:"{{primary-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off{border-color:"{{primary-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple{color:"{{primary-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple{color:"{{primary-600}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on{background-color:"{{warn-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off{border-color:"{{warn-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple{color:"{{warn-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple{color:"{{warn-600}}"}md-radio-button.md-THEME_NAME-theme[disabled],md-radio-group.md-THEME_NAME-theme[disabled]{color:"{{foreground-3}}"}md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off,md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on,md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-off,md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-on{border-color:"{{foreground-3}}"}md-radio-group.md-THEME_NAME-theme .md-checked .md-ink-ripple{color:"{{accent-color-0.26}}"}md-radio-group.md-THEME_NAME-theme .md-checked:not([disabled]).md-primary .md-ink-ripple,md-radio-group.md-THEME_NAME-theme.md-primary .md-checked:not([disabled]) .md-ink-ripple{color:"{{primary-color-0.26}}"}md-radio-group.md-THEME_NAME-theme.md-focused.ng-empty>md-radio-button:first-child .md-container:before{background-color:"{{foreground-3-0.26}}"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked .md-container:before{background-color:"{{accent-color-0.26}}"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-primary .md-checked .md-container:before{background-color:"{{primary-color-0.26}}"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-warn .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-warn .md-checked .md-container:before{background-color:"{{warn-color-0.26}}"}md-input-container md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:"{{warn-A700}}"}md-input-container:not(.md-input-focused):not(.md-input-invalid) md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:"{{foreground-3}}"}md-input-container.md-input-focused:not(.md-input-has-value) md-select.md-THEME_NAME-theme .md-select-value,md-input-container.md-input-focused:not(.md-input-has-value) md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder{color:"{{primary-color}}"}md-input-container.md-input-invalid md-select.md-THEME_NAME-theme .md-select-value{color:"{{warn-A700}}"!important;border-bottom-color:"{{warn-A700}}"!important}md-input-container.md-input-invalid md-select.md-THEME_NAME-theme.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-input-container:not(.md-input-invalid).md-input-focused.md-accent .md-select-value{border-color:"{{accent-color}}"}md-input-container:not(.md-input-invalid).md-input-focused.md-accent .md-select-value span{color:"{{accent-color}}"}md-input-container:not(.md-input-invalid).md-input-focused.md-warn .md-select-value{border-color:"{{warn-A700}}"}md-input-container:not(.md-input-invalid).md-input-focused.md-warn .md-select-value span{color:"{{warn-A700}}"}md-select.md-THEME_NAME-theme[disabled] .md-select-value{border-bottom-color:transparent;background-image:linear-gradient(90deg,"{{foreground-3}}" 0,"{{foreground-3}}" 33%,transparent 0);background-image:-ms-linear-gradient(left,transparent 0,"{{foreground-3}}" 100%)}md-select.md-THEME_NAME-theme .md-select-value{border-bottom-color:"{{foreground-4}}"}md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder{color:"{{foreground-3}}"}md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:"{{warn-A700}}"}md-select.md-THEME_NAME-theme.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme.ng-invalid.ng-touched .md-select-value{color:"{{warn-A700}}"!important;border-bottom-color:"{{warn-A700}}"!important}md-select.md-THEME_NAME-theme.ng-invalid.ng-touched.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value{border-bottom-color:"{{primary-color}}";color:"{{ foreground-1 }}"}md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value.md-select-placeholder{color:"{{ foreground-1 }}"}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-value{border-bottom-color:"{{accent-color}}"}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-value{border-bottom-color:"{{warn-color}}"}md-select.md-THEME_NAME-theme[disabled] .md-select-icon,md-select.md-THEME_NAME-theme[disabled] .md-select-value,md-select.md-THEME_NAME-theme[disabled] .md-select-value.md-select-placeholder{color:"{{foreground-3}}"}md-select.md-THEME_NAME-theme .md-select-icon{color:"{{foreground-2}}"}md-select-menu.md-THEME_NAME-theme md-content{background-color:"{{background-hue-1}}"}md-select-menu.md-THEME_NAME-theme md-content md-optgroup{color:"{{foreground-2}}"}md-select-menu.md-THEME_NAME-theme md-content md-option{color:"{{foreground-1}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[disabled] .md-text{color:"{{foreground-3}}"}md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]):focus,md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]):hover{background-color:"{{background-500-0.18}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected]{color:"{{primary-500}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected]:focus{color:"{{primary-600}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent{color:"{{accent-color}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent:focus{color:"{{accent-A700}}"}.md-checkbox-enabled.md-THEME_NAME-theme .md-ripple{color:"{{primary-600}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ripple{color:"{{background-600}}"}.md-checkbox-enabled.md-THEME_NAME-theme .md-ink-ripple{color:"{{foreground-2}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ink-ripple{color:"{{primary-color-0.87}}"}.md-checkbox-enabled.md-THEME_NAME-theme:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-icon{background-color:"{{primary-color-0.87}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected].md-focused .md-container:before{background-color:"{{primary-color-0.26}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-icon:after{border-color:"{{primary-contrast-0.87}}"}.md-checkbox-enabled.md-THEME_NAME-theme .md-indeterminate[disabled] .md-container{color:"{{foreground-3}}"}.md-checkbox-enabled.md-THEME_NAME-theme md-option .md-text{color:"{{foreground-1}}"}md-sidenav.md-THEME_NAME-theme,md-sidenav.md-THEME_NAME-theme md-content{background-color:"{{background-hue-1}}"}md-slider.md-THEME_NAME-theme .md-track{background-color:"{{foreground-3}}"}md-slider.md-THEME_NAME-theme .md-track-ticks{color:"{{background-contrast}}"}md-slider.md-THEME_NAME-theme .md-focus-ring{background-color:"{{accent-A200-0.2}}"}md-slider.md-THEME_NAME-theme .md-disabled-thumb{border-color:"{{background-color}}";background-color:"{{background-color}}"}md-slider.md-THEME_NAME-theme.md-min .md-thumb:after{background-color:"{{background-color}}";border-color:"{{foreground-3}}"}md-slider.md-THEME_NAME-theme.md-min .md-focus-ring{background-color:"{{foreground-3-0.38}}"}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-thumb:after{background-color:"{{background-contrast}}";border-color:transparent}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-sign{background-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-sign:after{border-top-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme.md-min[md-discrete][md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme .md-track.md-track-fill{background-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-thumb:after{border-color:"{{accent-color}}";background-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-sign{background-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-sign:after{border-top-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme[md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-thumb-text{color:"{{accent-contrast}}"}md-slider.md-THEME_NAME-theme.md-warn .md-focus-ring{background-color:"{{warn-200-0.38}}"}md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill{background-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after{border-color:"{{warn-color}}";background-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-sign{background-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-sign:after{border-top-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn[md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text{color:"{{warn-contrast}}"}md-slider.md-THEME_NAME-theme.md-primary .md-focus-ring{background-color:"{{primary-200-0.38}}"}md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill{background-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after{border-color:"{{primary-color}}";background-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-sign{background-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-sign:after{border-top-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary[md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text{color:"{{primary-contrast}}"}md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after{border-color:transparent}md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after,md-slider.md-THEME_NAME-theme[disabled][md-discrete] .md-thumb:after{background-color:"{{foreground-3}}";border-color:transparent}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-sign{background-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-sign:after{border-top-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme[disabled][readonly][md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-disabled-thumb{border-color:transparent;background-color:transparent}md-slider-container[disabled]>:first-child:not(md-slider),md-slider-container[disabled]>:last-child:not(md-slider){color:"{{foreground-3}}"}.md-subheader.md-THEME_NAME-theme{color:"{{ foreground-2-0.23 }}";background-color:"{{background-default}}"}.md-subheader.md-THEME_NAME-theme.md-primary{color:"{{primary-color}}"}.md-subheader.md-THEME_NAME-theme.md-accent{color:"{{accent-color}}"}.md-subheader.md-THEME_NAME-theme.md-warn{color:"{{warn-color}}"}md-switch.md-THEME_NAME-theme .md-ink-ripple{color:"{{background-500}}"}md-switch.md-THEME_NAME-theme .md-thumb{background-color:"{{background-50}}"}md-switch.md-THEME_NAME-theme .md-bar{background-color:"{{background-500}}"}md-switch.md-THEME_NAME-theme.md-focused:not(.md-checked) .md-thumb:before,md-switch.md-THEME_NAME-theme.md-focused[disabled] .md-thumb:before{background-color:"{{foreground-4}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]) .md-ink-ripple{color:"{{accent-color}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]) .md-thumb{background-color:"{{accent-color}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]) .md-bar{background-color:"{{accent-color-0.5}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-focused .md-thumb:before{background-color:"{{accent-color-0.26}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-primary .md-ink-ripple{color:"{{primary-color}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-primary .md-thumb{background-color:"{{primary-color}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-primary .md-bar{background-color:"{{primary-color-0.5}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-primary.md-focused .md-thumb:before{background-color:"{{primary-color-0.26}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-warn .md-ink-ripple{color:"{{warn-color}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-warn .md-thumb{background-color:"{{warn-color}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-warn .md-bar{background-color:"{{warn-color-0.5}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-warn.md-focused .md-thumb:before{background-color:"{{warn-color-0.26}}"}md-switch.md-THEME_NAME-theme[disabled] .md-thumb{background-color:"{{background-400}}"}md-switch.md-THEME_NAME-theme[disabled] .md-bar{background-color:"{{foreground-4}}"}md-tabs.md-THEME_NAME-theme md-tabs-wrapper{background-color:transparent;border-color:"{{foreground-4}}"}md-tabs.md-THEME_NAME-theme .md-paginator md-icon{color:"{{primary-color}}"}md-tabs.md-THEME_NAME-theme md-ink-bar{color:"{{accent-color}}";background:"{{accent-color}}"}md-tabs.md-THEME_NAME-theme .md-tab{color:"{{foreground-2}}"}md-tabs.md-THEME_NAME-theme .md-tab[disabled],md-tabs.md-THEME_NAME-theme .md-tab[disabled] md-icon{color:"{{foreground-3}}"}md-tabs.md-THEME_NAME-theme .md-tab.md-active,md-tabs.md-THEME_NAME-theme .md-tab.md-active md-icon,md-tabs.md-THEME_NAME-theme .md-tab.md-focused,md-tabs.md-THEME_NAME-theme .md-tab.md-focused md-icon{color:"{{primary-color}}"}md-tabs.md-THEME_NAME-theme .md-tab.md-focused{background:"{{primary-color-0.1}}"}md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container{color:"{{accent-A100}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper{background-color:"{{accent-color}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{accent-A100}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{accent-contrast}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{accent-contrast-0.1}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{color:"{{primary-600-1}}";background:"{{primary-600-1}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper{background-color:"{{primary-color}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{primary-100}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{primary-contrast}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{primary-contrast-0.1}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper{background-color:"{{warn-color}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{warn-100}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{warn-contrast}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{warn-contrast-0.1}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:"{{primary-color}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{primary-100}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{primary-contrast}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{primary-contrast-0.1}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:"{{accent-color}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{accent-A100}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{accent-contrast}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{accent-contrast-0.1}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{color:"{{primary-600-1}}";background:"{{primary-600-1}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:"{{warn-color}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{warn-100}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{warn-contrast}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{warn-contrast-0.1}}"}md-toast.md-THEME_NAME-theme .md-toast-content{background-color:#323232;color:"{{background-50}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button{color:"{{background-50}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight{color:"{{accent-color}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-primary{color:"{{primary-color}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-warn{color:"{{warn-color}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar){background-color:"{{primary-color}}";color:"{{primary-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-icon{color:"{{primary-contrast}}";fill:"{{primary-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) .md-button[disabled] md-icon{color:"{{primary-contrast-0.26}}";fill:"{{primary-contrast-0.26}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent{background-color:"{{accent-color}}";color:"{{accent-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent .md-ink-ripple{color:"{{accent-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-icon{color:"{{accent-contrast}}";fill:"{{accent-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent .md-button[disabled] md-icon{color:"{{accent-contrast-0.26}}";fill:"{{accent-contrast-0.26}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn{background-color:"{{warn-color}}";color:"{{warn-contrast}}"}.md-panel.md-tooltip.md-THEME_NAME-theme{color:"{{background-700-contrast}}";background-color:"{{background-700}}"}body.md-THEME_NAME-theme,html.md-THEME_NAME-theme{color:"{{foreground-1}}";background-color:"{{background-color}}"}'
  );
ngmaterial.core = angular.module("material.core");
ngmaterial.components = {};
angular.module("material.components.icon", ["material.core"]);
angular.module("material.components.icon").directive("mdIcon", ["$mdIcon", "$mdTheming", "$mdAria", "$sce", mdIconDirective]);
function mdIconDirective(a, b, d) {
  function c(e, f, g) {
    function h() {
      if (!g.mdSvgIcon && !g.mdSvgSrc) {
        g.mdFontIcon && (f.removeClass(l), f.addClass(g.mdFontIcon), (l = g.mdFontIcon));
        var n = a.fontSet(g.mdFontSet);
        m !== n && (f.removeClass(m), f.addClass(n), (m = n));
      }
    }
    b(f);
    var l = g.mdFontIcon,
      m = a.fontSet(g.mdFontSet);
    g.mdSvgIcon || g.mdSvgSrc || (g.mdFontIcon && f.addClass("md-font " + g.mdFontIcon), f.addClass(m));
    g.$observe("mdFontIcon", h);
    g.$observe("mdFontSet", h);
    f[0].getAttribute(g.$attr.mdSvgSrc);
    e = g.$normalize(g.$attr.mdSvgIcon || g.$attr.mdSvgSrc || "");
    g.role || (d.expect(f, "role", "img"), (g.role = "img"));
    if ("img" === g.role && !g.ariaHidden && !d.hasAriaLabel(f)) {
      var v;
      g.alt
        ? d.expect(f, "aria-label", g.alt)
        : d.parentHasAriaLabel(f, 2)
        ? d.expect(f, "aria-hidden", "true")
        : (v = g.mdFontIcon || g.mdSvgIcon || f.text())
        ? d.expect(f, "aria-label", v)
        : d.expect(f, "aria-hidden", "true");
    }
    e &&
      g.$observe(e, function (n) {
        f.empty();
        n &&
          a(n).then(function (q) {
            f.empty();
            f.append(q);
          });
      });
  }
  return { restrict: "E", link: c };
}
MdIconService.$inject = "config $templateRequest $q $log $mdUtil $sce".split(" ");
angular
  .module("material.components.icon")
  .constant("$$mdSvgRegistry", {
    mdTabsArrow:
      "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwb2x5Z29uIHBvaW50cz0iMTUuNCw3LjQgMTQsNiA4LDEyIDE0LDE4IDE1LjQsMTYuNiAxMC44LDEyICIvPjwvZz48L3N2Zz4=",
    mdClose:
      "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik0xOSA2LjQxbC0xLjQxLTEuNDEtNS41OSA1LjU5LTUuNTktNS41OS0xLjQxIDEuNDEgNS41OSA1LjU5LTUuNTkgNS41OSAxLjQxIDEuNDEgNS41OS01LjU5IDUuNTkgNS41OSAxLjQxLTEuNDEtNS41OS01LjU5eiIvPjwvZz48L3N2Zz4=",
    mdCancel:
      "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik0xMiAyYy01LjUzIDAtMTAgNC40Ny0xMCAxMHM0LjQ3IDEwIDEwIDEwIDEwLTQuNDcgMTAtMTAtNC40Ny0xMC0xMC0xMHptNSAxMy41OWwtMS40MSAxLjQxLTMuNTktMy41OS0zLjU5IDMuNTktMS40MS0xLjQxIDMuNTktMy41OS0zLjU5LTMuNTkgMS40MS0xLjQxIDMuNTkgMy41OSAzLjU5LTMuNTkgMS40MSAxLjQxLTMuNTkgMy41OSAzLjU5IDMuNTl6Ii8+PC9nPjwvc3ZnPg==",
    mdMenu:
      "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0zLDZIMjFWOEgzVjZNMywxMUgyMVYxM0gzVjExTTMsMTZIMjFWMThIM1YxNloiIC8+PC9zdmc+",
    mdToggleArrow:
      "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgNDggNDgiPjxwYXRoIGQ9Ik0yNCAxNmwtMTIgMTIgMi44MyAyLjgzIDkuMTctOS4xNyA5LjE3IDkuMTcgMi44My0yLjgzeiIvPjxwYXRoIGQ9Ik0wIDBoNDh2NDhoLTQ4eiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==",
    mdCalendar:
      "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgM2gtMVYxaC0ydjJIOFYxSDZ2Mkg1Yy0xLjExIDAtMS45OS45LTEuOTkgMkwzIDE5YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bTAgMTZINVY4aDE0djExek03IDEwaDV2NUg3eiIvPjwvc3ZnPg==",
    mdChecked:
      "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik05IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtMS40MXoiLz48L2c+PC9zdmc+"
  })
  .provider("$mdIcon", MdIconProvider);
var config = { defaultViewBoxSize: 24, defaultFontSet: "material-icons", fontSets: [] };
function MdIconProvider() {}
MdIconProvider.prototype = {
  icon: function (a, b, d) {
    -1 == a.indexOf(":") && (a = "$default:" + a);
    config[a] = new ConfigurationItem(b, d);
    return this;
  },
  iconSet: function (a, b, d) {
    config[a] = new ConfigurationItem(b, d);
    return this;
  },
  defaultIconSet: function (a, b) {
    config.$default || (config.$default = new ConfigurationItem(a, b));
    config.$default.viewBoxSize = b || config.defaultViewBoxSize;
    return this;
  },
  defaultViewBoxSize: function (a) {
    config.defaultViewBoxSize = a;
    return this;
  },
  fontSet: function (a, b) {
    config.fontSets.push({ alias: a, fontSet: b || a });
    return this;
  },
  defaultFontSet: function (a) {
    config.defaultFontSet = a ? a : "";
    return this;
  },
  defaultIconSize: function (a) {
    config.defaultIconSize = a;
    return this;
  },
  $get: [
    "$templateRequest",
    "$q",
    "$log",
    "$mdUtil",
    "$sce",
    function (a, b, d, c, e) {
      return MdIconService(config, a, b, d, c, e);
    }
  ]
};
function ConfigurationItem(a, b) {
  this.url = a;
  this.viewBoxSize = b || config.defaultViewBoxSize;
}
function MdIconService(a, b, d, c, e, f) {
  function g(w) {
    w = w || "";
    angular.isString(w) || (w = f.getTrustedUrl(w));
    if (p[w]) return d.when(l(p[w]));
    if (H.test(w) || A.test(w)) return r(w).then(v(w));
    -1 === w.indexOf(":") && (w = "$default:" + w);
    var B = a[w] ? n : q;
    return B(w).then(v(w));
  }
  function h(w) {
    var B = angular.isUndefined(w) || !(w && w.length);
    if (B) return a.defaultFontSet;
    var u = w;
    angular.forEach(a.fontSets, function (z) {
      z.alias === w && (u = z.fontSet || u);
    });
    return u;
  }
  function l(w) {
    var B = w.clone(),
      u = e.nextUid(),
      z,
      D,
      G,
      N = "clip-path color-profile cursor fill filter href marker-start marker-mid marker-end mask stroke style vector-effect".split(" "),
      C = void 0 === B.innerHTML;
    if (!isFinite(Number(u))) throw Error("Unsafe and unexpected non-number result from $mdUtil.nextUid().");
    var F = "_cache" + u;
    B.id && (B.id += F);
    angular.forEach(B.querySelectorAll("[id]"), function (O) {
      z = "";
      for (D = 0; D < N.length; D++) (z += "[" + N[D] + '="url(#' + O.id + ')"]'), D + 1 < N.length && (z += ", ");
      angular.forEach(B.querySelectorAll(z), function (S) {
        m(O, S, C, u);
      });
      angular.forEach(B.querySelectorAll("style"), function (S) {
        m(O, S, C, u);
      });
      angular.forEach(B.querySelectorAll("[*|href]:not([href])"), function (S) {
        if ((G = S.getAttribute("xlink:href"))) (G = G.replace("#" + O.id, "#" + O.id + F)), S.setAttribute("xlink:href", G);
      });
      O.id += F;
    });
    return B;
  }
  function m(w, B, u, z) {
    if (!isFinite(Number(z))) throw Error("Unsafe and unexpected non-number result for newUid.");
    z = "_cache" + z;
    u
      ? ((u = e.getOuterHTML(B)),
        (u = u.replace("url(#" + w.id + ")", "url(#" + w.id + z + ")")),
        (B.textContent = angular.element(u)[0].innerHTML))
      : (B.outerHTML = B.outerHTML.replace("url(#" + w.id + ")", "url(#" + w.id + z + ")"));
  }
  function v(w) {
    return function (B) {
      var u = B;
      u = angular.isDefined(u.element) && angular.isDefined(u.config);
      p[w] = u ? B : new x(B, a[w]);
      return l(p[w]);
    };
  }
  function n(w) {
    var B = a[w];
    return r(B.url).then(function (u) {
      return new x(u, B);
    });
  }
  function q(w) {
    function B(G) {
      var N = w.slice(w.lastIndexOf(":") + 1);
      return (G = G.querySelector("#" + N)) ? new x(G, D) : u(w);
    }
    function u(G) {
      var N = "icon " + G + " not found";
      c.warn(N);
      return d.reject(N || G);
    }
    var z = w.substring(0, w.lastIndexOf(":")) || "$default",
      D = a[z];
    return D ? r(D.url).then(B) : u(w);
  }
  function r(w) {
    function B(z) {
      var D = A.exec(z);
      D = (z = /base64/i.test(z)) ? window.atob(D[2]) : D[2];
      return d.when(angular.element(D)[0]);
    }
    function u(z) {
      return d(function (D, G) {
        var N = function (F) {
            var O = angular.isString(F) ? F : F.message || F.data || F.statusText;
            c.warn(O);
            G(F);
          },
          C = function (F) {
            t[z] || (t[z] = angular.element("<div>").append(F)[0].querySelector("svg"));
            D(t[z]);
          };
        b(z, !0).then(C, N);
      });
    }
    return A.test(w) ? B(w) : u(w);
  }
  function x(w, B) {
    if (w && "symbol" === w.tagName.toLowerCase()) {
      var u = w.getAttribute("viewBox");
      w = w.innerHTML
        ? angular.element('<svg xmlns="http://www.w3.org/2000/svg">').html(w.innerHTML)[0]
        : angular.element('<svg xmlns="http://www.w3.org/2000/svg">').append(e.getInnerHTML(w))[0];
      u && w.setAttribute("viewBox", u);
    }
    w && "svg" !== w.tagName.toLowerCase() && (w = angular.element('<svg xmlns="http://www.w3.org/2000/svg">').append(w.cloneNode(!0))[0]);
    w.getAttribute("xmlns") || w.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    this.element = w;
    this.config = B;
    this.prepare();
  }
  function y() {
    var w = this.config ? this.config.viewBoxSize : a.defaultViewBoxSize;
    angular.forEach(
      {
        fit: "",
        height: "100%",
        width: "100%",
        preserveAspectRatio: "xMidYMid meet",
        viewBox: this.element.getAttribute("viewBox") || "0 0 " + w + " " + w,
        focusable: !1
      },
      function (B, u) {
        this.element.setAttribute(u, B);
      },
      this
    );
  }
  function k() {
    return this.element.cloneNode(!0);
  }
  var p = {},
    t = {},
    H = /[-\w@:%+.~#?&//=]{2,}\.[a-z]{2,4}\b(\/[-\w@:%+.~#?&//=]*)?/i,
    A = /^data:image\/svg\+xml[\s*;\w\-=]*?(base64)?,(.*)$/i;
  x.prototype = { clone: k, prepare: y };
  g.fontSet = h;
  return g;
}
ngmaterial.components.icon = angular.module("material.components.icon");
angular
  .module("material.components.showHide", ["material.core"])
  .directive("ngShow", createDirective("ngShow", !0))
  .directive("ngHide", createDirective("ngHide", !1));
function createDirective(a, b) {
  return [
    "$mdUtil",
    "$window",
    function (d, c) {
      return {
        restrict: "A",
        multiElement: !0,
        link: function (e, f, g) {
          var h = e.$on("$md-resize-enable", function () {
            h();
            var l = f[0],
              m = l.nodeType === c.Node.ELEMENT_NODE ? c.getComputedStyle(l) : {};
            e.$watch(g[a], function (v) {
              !!v === b &&
                (d.nextTick(function () {
                  e.$broadcast("$md-resize");
                }),
                (v = { cachedTransitionStyles: m }),
                d.dom.animator.waitTransitionEnd(f, v).then(function () {
                  e.$broadcast("$md-resize");
                }));
            });
          });
        }
      };
    }
  ];
}
ngmaterial.components.showHide = angular.module("material.components.showHide");
VirtualRepeatContainerController.$inject = "$$rAF $mdUtil $mdConstant $parse $rootScope $window $scope $element $attrs".split(" ");
VirtualRepeatController.$inject = "$scope $element $attrs $browser $document $rootScope $$rAF $mdUtil".split(" ");
VirtualRepeatDirective.$inject = ["$parse"];
angular
  .module("material.components.virtualRepeat", ["material.core", "material.components.showHide"])
  .directive("mdVirtualRepeatContainer", VirtualRepeatContainerDirective)
  .directive("mdVirtualRepeat", VirtualRepeatDirective)
  .directive("mdForceHeight", ForceHeightDirective);
function VirtualRepeatContainerDirective() {
  return {
    controller: VirtualRepeatContainerController,
    template: virtualRepeatContainerTemplate,
    compile: function (a, b) {
      a.addClass("md-virtual-repeat-container").addClass(
        b.hasOwnProperty("mdOrientHorizontal") ? "md-orient-horizontal" : "md-orient-vertical"
      );
    }
  };
}
function virtualRepeatContainerTemplate(a) {
  return (
    '<div class="md-virtual-repeat-scroller" role="presentation"><div class="md-virtual-repeat-sizer" role="presentation"></div><div class="md-virtual-repeat-offsetter" role="presentation">' +
    a[0].innerHTML +
    "</div></div>"
  );
}
function VirtualRepeatContainerController(a, b, d, c, e, f, g, h, l) {
  this.$rootScope = e;
  this.$scope = g;
  this.$element = h;
  this.$attrs = l;
  this.scrollOffset = this.scrollSize = this.size = 0;
  this.horizontal = this.$attrs.hasOwnProperty("mdOrientHorizontal");
  this.repeater = null;
  this.autoShrink = this.$attrs.hasOwnProperty("mdAutoShrink");
  this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0;
  this.originalSize = null;
  this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0;
  this.oldElementSize = null;
  this.maxElementPixels = d.ELEMENT_MAX_PIXELS;
  this.ltr = !b.isRtl(this.$attrs);
  this.$attrs.mdTopIndex
    ? ((this.bindTopIndex = c(this.$attrs.mdTopIndex)),
      (this.topIndex = this.bindTopIndex(this.$scope)),
      angular.isDefined(this.topIndex) || ((this.topIndex = 0), this.bindTopIndex.assign(this.$scope, 0)),
      this.$scope.$watch(
        this.bindTopIndex,
        angular.bind(this, function (v) {
          v !== this.topIndex && this.scrollToIndex(v);
        })
      ))
    : (this.topIndex = 0);
  this.scroller = h[0].querySelector(".md-virtual-repeat-scroller");
  this.sizer = this.scroller.querySelector(".md-virtual-repeat-sizer");
  this.offsetter = this.scroller.querySelector(".md-virtual-repeat-offsetter");
  var m = angular.bind(this, this.updateSize);
  a(
    angular.bind(this, function () {
      m();
      var v = b.debounce(m, 10, null, !1),
        n = angular.element(f);
      this.size || v();
      n.on("resize", v);
      g.$on("$destroy", function () {
        n.off("resize", v);
      });
      g.$emit("$md-resize-enable");
      g.$on("$md-resize", m);
    })
  );
}
VirtualRepeatContainerController.prototype.register = function (a) {
  this.repeater = a;
  angular.element(this.scroller).on("scroll wheel touchmove touchend", angular.bind(this, this.handleScroll_));
};
VirtualRepeatContainerController.prototype.isHorizontal = function () {
  return this.horizontal;
};
VirtualRepeatContainerController.prototype.getSize = function () {
  return this.size;
};
VirtualRepeatContainerController.prototype.setSize_ = function (a) {
  var b = this.getDimensionName_();
  this.size = a;
  this.$element[0].style[b] = a + "px";
};
VirtualRepeatContainerController.prototype.unsetSize_ = function () {
  this.$element[0].style[this.getDimensionName_()] = this.oldElementSize;
  this.oldElementSize = null;
};
VirtualRepeatContainerController.prototype.updateSize = function () {
  if (!this.originalSize) {
    var a = this.isHorizontal() ? this.$element[0].clientWidth : this.$element[0].clientHeight;
    a && (this.size = a);
    this.handleScroll_();
    this.repeater && this.repeater.containerUpdated();
  }
};
VirtualRepeatContainerController.prototype.getScrollSize = function () {
  return this.scrollSize;
};
VirtualRepeatContainerController.prototype.getDimensionName_ = function () {
  return this.isHorizontal() ? "width" : "height";
};
VirtualRepeatContainerController.prototype.sizeScroller_ = function (a) {
  var b = this.getDimensionName_(),
    d = this.isHorizontal() ? "height" : "width";
  this.sizer.innerHTML = "";
  if (a < this.maxElementPixels) this.sizer.style[b] = a + "px";
  else {
    this.sizer.style[b] = "auto";
    this.sizer.style[d] = "auto";
    var c = Math.floor(a / this.maxElementPixels),
      e = document.createElement("div");
    e.style[b] = this.maxElementPixels + "px";
    e.style[d] = "1px";
    for (d = 0; d < c; d++) this.sizer.appendChild(e.cloneNode(!1));
    e.style[b] = a - c * this.maxElementPixels + "px";
    this.sizer.appendChild(e);
  }
};
VirtualRepeatContainerController.prototype.autoShrink_ = function (a) {
  a = Math.max(a, this.autoShrinkMin * this.repeater.getItemSize());
  if (this.autoShrink && a !== this.size) {
    null === this.oldElementSize && (this.oldElementSize = this.$element[0].style[this.getDimensionName_()]);
    var b = this.originalSize || this.size;
    if (!b || a < b) this.originalSize || (this.originalSize = this.size), this.setSize_(a);
    else if (null !== this.originalSize) {
      this.unsetSize_();
      var d = this.originalSize;
      this.originalSize = null;
      d || this.updateSize();
      this.setSize_(d || this.size);
    }
    this.repeater.containerUpdated();
  }
};
VirtualRepeatContainerController.prototype.setScrollSize = function (a) {
  a += this.offsetSize;
  this.scrollSize !== a && (this.sizeScroller_(a), this.autoShrink_(a), (this.scrollSize = a));
};
VirtualRepeatContainerController.prototype.getScrollOffset = function () {
  return this.scrollOffset;
};
VirtualRepeatContainerController.prototype.scrollTo = function (a) {
  this.scroller[this.isHorizontal() ? "scrollLeft" : "scrollTop"] = a;
  this.handleScroll_();
};
VirtualRepeatContainerController.prototype.scrollToIndex = function (a) {
  var b = this.repeater.getItemSize(),
    d = this.repeater.itemsLength;
  a > d && (a = d - 1);
  this.scrollTo(b * a);
};
VirtualRepeatContainerController.prototype.resetScroll = function () {
  this.scrollTo(0);
};
VirtualRepeatContainerController.prototype.handleScroll_ = function () {
  this.ltr || this.maxSize || ((this.scroller.scrollLeft = this.scrollSize), (this.maxSize = this.scroller.scrollLeft));
  var a = this.isHorizontal() ? (this.ltr ? this.scroller.scrollLeft : this.maxSize - this.scroller.scrollLeft) : this.scroller.scrollTop;
  if (!(this.scrollSize < this.size) && (a > this.scrollSize - this.size && (a = this.scrollSize - this.size), a !== this.scrollOffset)) {
    var b = this.repeater.getItemSize();
    if (b) {
      var d = Math.max(0, Math.floor(a / b) - 3);
      d = (this.isHorizontal() ? "translateX(" : "translateY(") + (!this.isHorizontal() || this.ltr ? d * b : -(d * b)) + "px)";
      this.scrollOffset = a;
      this.offsetter.style.webkitTransform = d;
      this.offsetter.style.transform = d;
      this.bindTopIndex &&
        ((a = Math.floor(a / b)),
        a !== this.topIndex &&
          a < this.repeater.getItemCount() &&
          ((this.topIndex = a), this.bindTopIndex.assign(this.$scope, a), this.$rootScope.$$phase || this.$scope.$digest()));
      this.repeater.containerUpdated();
    }
  }
};
function VirtualRepeatDirective(a) {
  return {
    controller: VirtualRepeatController,
    priority: 1e3,
    require: ["mdVirtualRepeat", "^^mdVirtualRepeatContainer"],
    restrict: "A",
    terminal: !0,
    transclude: "element",
    compile: function (b, d) {
      b = d.mdVirtualRepeat;
      b = b.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/);
      var c = b[1],
        e = a(b[2]),
        f = d.mdExtraName && a(d.mdExtraName);
      return function (g, h, l, m, v) {
        m[0].link_(m[1], v, c, e, f);
      };
    }
  };
}
function VirtualRepeatController(a, b, d, c, e, f, g, h) {
  this.$scope = a;
  this.$element = b;
  this.$attrs = d;
  this.$browser = c;
  this.$document = e;
  this.$mdUtil = h;
  this.$rootScope = f;
  this.$$rAF = g;
  this.onDemand = h.parseAttributeBoolean(d.mdOnDemand);
  this.browserCheckUrlChange = c.$$checkUrlChange;
  this.endIndex = this.startIndex = this.newVisibleEnd = this.newEndIndex = this.newStartIndex = 0;
  this.itemSize = a.$eval(d.mdItemSize) || null;
  this.isFirstRender = !0;
  this.isVirtualRepeatUpdating_ = !1;
  this.itemsLength = 0;
  this.unwatchItemSize_ = angular.noop;
  this.blocks = {};
  this.pooledBlocks = [];
  a.$on("$destroy", angular.bind(this, this.cleanupBlocks_));
}
VirtualRepeatController.prototype.link_ = function (a, b, d, c, e) {
  this.container = a;
  this.transclude = b;
  this.repeatName = d;
  this.rawRepeatListExpression = c;
  this.extraName = e;
  this.sized = !1;
  this.repeatListExpression = angular.bind(this, this.repeatListExpression_);
  this.container.register(this);
};
VirtualRepeatController.prototype.cleanupBlocks_ = function () {
  angular.forEach(this.pooledBlocks, function (a) {
    a.element.remove();
  });
};
VirtualRepeatController.prototype.readItemSize_ = function () {
  if (!this.itemSize) {
    this.items = this.repeatListExpression(this.$scope);
    this.parentNode = this.$element[0].parentNode;
    var a = this.getBlock_(0);
    a.element[0].parentNode || this.parentNode.appendChild(a.element[0]);
    this.itemSize = a.element[0][this.container.isHorizontal() ? "offsetWidth" : "offsetHeight"] || null;
    this.blocks[0] = a;
    this.poolBlock_(0);
    this.itemSize && this.containerUpdated();
  }
};
VirtualRepeatController.prototype.repeatListExpression_ = function (a) {
  a = this.rawRepeatListExpression(a);
  return this.onDemand && a ? ((a = new VirtualRepeatModelArrayLike(a)), a.$$includeIndexes(this.newStartIndex, this.newVisibleEnd), a) : a;
};
VirtualRepeatController.prototype.containerUpdated = function () {
  if (this.itemSize) {
    if (
      (this.sized || (this.items = this.repeatListExpression(this.$scope)),
      this.sized ||
        (this.unwatchItemSize_(),
        (this.sized = !0),
        this.$scope.$watchCollection(
          this.repeatListExpression,
          angular.bind(this, function (a, b) {
            this.isVirtualRepeatUpdating_ || this.virtualRepeatUpdate_(a, b);
          })
        )),
      this.updateIndexes_(),
      this.newStartIndex !== this.startIndex ||
        this.newEndIndex !== this.endIndex ||
        this.container.getScrollOffset() > this.container.getScrollSize())
    )
      this.items instanceof VirtualRepeatModelArrayLike && this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex),
        this.virtualRepeatUpdate_(this.items, this.items);
  } else
    this.unwatchItemSize_ && this.unwatchItemSize_ !== angular.noop && this.unwatchItemSize_(),
      (this.unwatchItemSize_ = this.$scope.$watchCollection(
        this.repeatListExpression,
        angular.bind(this, function (a) {
          a && a.length && this.readItemSize_();
        })
      )),
      this.$rootScope.$$phase || this.$scope.$digest();
};
VirtualRepeatController.prototype.getItemSize = function () {
  return this.itemSize;
};
VirtualRepeatController.prototype.getItemCount = function () {
  return this.itemsLength;
};
VirtualRepeatController.prototype.virtualRepeatUpdate_ = function (a, b) {
  this.isVirtualRepeatUpdating_ = !0;
  var d = (a && a.length) || 0,
    c = !1;
  if (this.items && d < this.items.length && 0 !== this.container.getScrollOffset()) {
    this.items = a;
    var e = this.container.getScrollOffset();
    this.container.resetScroll();
    this.container.scrollTo(e);
  }
  d !== this.itemsLength && ((c = !0), (this.itemsLength = d));
  this.items = a;
  (a !== b || c) && this.updateIndexes_();
  this.parentNode = this.$element[0].parentNode;
  c && this.container.setScrollSize(d * this.itemSize);
  Object.keys(this.blocks).forEach(function (g) {
    g = parseInt(g, 10);
    (g < this.newStartIndex || g >= this.newEndIndex) && this.poolBlock_(g);
  }, this);
  this.$browser.$$checkUrlChange = angular.noop;
  d = [];
  c = [];
  for (a = this.newStartIndex; a < this.newEndIndex && null == this.blocks[a]; a++)
    (b = this.getBlock_(a)), this.updateBlock_(b, a), d.push(b);
  for (; null != this.blocks[a]; a++) this.updateBlock_(this.blocks[a], a);
  for (e = a - 1; a < this.newEndIndex; a++) (b = this.getBlock_(a)), this.updateBlock_(b, a), c.push(b);
  d.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(d), this.$element[0].nextSibling);
  c.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(c), this.blocks[e] && this.blocks[e].element[0].nextSibling);
  this.$browser.$$checkUrlChange = this.browserCheckUrlChange;
  this.startIndex = this.newStartIndex;
  this.endIndex = this.newEndIndex;
  if (this.isFirstRender) {
    this.isFirstRender = !1;
    var f = this.$attrs.mdStartIndex ? this.$scope.$eval(this.$attrs.mdStartIndex) : this.container.topIndex;
    this.$mdUtil.nextTick(
      function () {
        this.container.scrollToIndex(f);
      }.bind(this)
    );
  }
  this.isVirtualRepeatUpdating_ = !1;
};
VirtualRepeatController.prototype.getBlock_ = function (a) {
  if (this.pooledBlocks.length) return this.pooledBlocks.pop();
  var b;
  this.transclude(
    angular.bind(this, function (d, c) {
      b = { element: d, new: !0, scope: c };
      this.updateScope_(c, a);
      this.parentNode.appendChild(d[0]);
    })
  );
  return b;
};
VirtualRepeatController.prototype.updateBlock_ = function (a, b) {
  this.blocks[b] = a;
  if (a.new || a.scope.$index !== b || a.scope[this.repeatName] !== this.items[b])
    (a.new = !1), this.updateScope_(a.scope, b), this.$rootScope.$$phase || a.scope.$digest();
};
VirtualRepeatController.prototype.updateScope_ = function (a, b) {
  a.$index = b;
  a[this.repeatName] = this.items && this.items[b];
  this.extraName && (a[this.extraName(this.$scope)] = this.items[b]);
};
VirtualRepeatController.prototype.poolBlock_ = function (a) {
  this.pooledBlocks.push(this.blocks[a]);
  this.parentNode.removeChild(this.blocks[a].element[0]);
  delete this.blocks[a];
};
VirtualRepeatController.prototype.domFragmentFromBlocks_ = function (a) {
  var b = this.$document[0].createDocumentFragment();
  a.forEach(function (d) {
    b.appendChild(d.element[0]);
  });
  return b;
};
VirtualRepeatController.prototype.updateIndexes_ = function () {
  var a = this.items ? this.items.length : 0,
    b = Math.ceil(this.container.getSize() / this.itemSize);
  this.newStartIndex = Math.max(0, Math.min(a - b, Math.floor(this.container.getScrollOffset() / this.itemSize)));
  this.newVisibleEnd = this.newStartIndex + b + 3;
  this.newEndIndex = Math.min(a, this.newVisibleEnd);
  this.newStartIndex = Math.max(0, this.newStartIndex - 3);
};
function VirtualRepeatModelArrayLike(a) {
  if (!angular.isFunction(a.getItemAtIndex) || !angular.isFunction(a.getLength))
    throw Error(
      "When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement functions getItemAtIndex() and getLength()."
    );
  this.model = a;
}
VirtualRepeatModelArrayLike.prototype.$$includeIndexes = function (a, b) {
  for (; a < b; a++) this.hasOwnProperty(a) || (this[a] = this.model.getItemAtIndex(a));
  this.length = this.model.getLength();
};
function ForceHeightDirective() {
  return {
    restrict: "A",
    link: function (a, b, d) {
      (a = a.$eval(d.mdForceHeight) || null) && b && (b[0].style.height = a);
    }
  };
}
ForceHeightDirective.$inject = ["$mdUtil"];
ngmaterial.components.virtualRepeat = angular.module("material.components.virtualRepeat");
angular.module("material.components.autocomplete", ["material.core", "material.components.icon", "material.components.virtualRepeat"]);
MdAutocompleteCtrl.$inject =
  "$scope $element $mdUtil $mdConstant $mdTheming $window $animate $rootElement $attrs $q $log $mdLiveAnnouncer".split(" ");
angular.module("material.components.autocomplete").controller("MdAutocompleteCtrl", MdAutocompleteCtrl);
function MdAutocompleteCtrl(a, b, d, c, e, f, g, h, l, m, v, n) {
  function q() {
    d.initOptionalProperties(a, l, { searchText: "", selectedItem: null, clearButton: !1, disableVirtualRepeat: !1 });
    e(b);
    p();
    d.nextTick(function () {
      var V;
      for (V = b; V.length; V = V.parent()) {
        var ba = V.attr("md-autocomplete-snap");
        if (angular.isDefined(ba)) break;
      }
      V.length
        ? (V = { snap: V[0], wrap: "width" === ba.toLowerCase() ? V[0] : b.find("md-autocomplete-wrap")[0] })
        : ((V = b.find("md-autocomplete-wrap")[0]), (V = { snap: V, wrap: V }));
      L = {
        main: b[0],
        scrollContainer: b[0].querySelector(".md-virtual-repeat-container, .md-standard-list-container"),
        scroller: b[0].querySelector(".md-virtual-repeat-scroller, .md-standard-list-scroller"),
        ul: b.find("ul")[0],
        input: b.find("input")[0],
        wrap: V.wrap,
        snap: V.snap,
        root: document.body
      };
      L.li = L.ul.getElementsByTagName("li");
      V = L;
      ba = L;
      var ia = {};
      for (ka in ba) ba.hasOwnProperty(ka) && (ia[ka] = angular.element(ba[ka]));
      var ka = ia;
      V.$ = ka;
      na = L.scrollContainer.classList.contains("md-standard-list-container") ? "standard" : "virtual";
      Z = L.$.input.controller("ngModel");
      L.$.root.length &&
        (e(L.$.scrollContainer),
        L.$.scrollContainer.detach(),
        L.$.root.append(L.$.scrollContainer),
        g.pin && g.pin(L.$.scrollContainer, h));
      b.on("touchstart", y);
      if (a.autofocus) b.on("focus", y);
      a.inputAriaDescribedBy && L.input.setAttribute("aria-describedby", a.inputAriaDescribedBy);
      a.floatingLabel ||
        (a.inputAriaLabel
          ? L.input.setAttribute("aria-label", a.inputAriaLabel)
          : a.inputAriaLabelledBy
          ? L.input.setAttribute("aria-labelledby", a.inputAriaLabelledBy)
          : a.placeholder && L.input.setAttribute("aria-label", a.placeholder));
    });
  }
  function r() {
    a.requireMatch && Z && Z.$setValidity("md-require-match", !!a.selectedItem || !a.searchText);
  }
  function x() {
    function V() {
      var Ha = 0,
        Ja = b.find("md-input-container");
      if (Ja.length) {
        var Na = Ja.find("input");
        Ha = Ja.prop("offsetHeight");
        Ha -= Na.prop("offsetTop");
        Ha -= Na.prop("offsetHeight");
        Ha += Ja.prop("offsetTop");
      }
      return Ha;
    }
    function ba() {
      var Ha = L.scrollContainer.getBoundingClientRect(),
        Ja = {};
      Ha.right > Ca.right && (Ja.left = ka.right - Ha.width + "px");
      L.$.scrollContainer.css(Ja);
    }
    if (!L) return d.nextTick(x, !1, a);
    var ia = 48 * (a.dropdownItems || 5),
      ka = L.wrap.getBoundingClientRect(),
      ra = L.snap.getBoundingClientRect(),
      Ca = L.root.getBoundingClientRect(),
      Ma = ra.bottom - Ca.top,
      Ea = Ca.bottom - ra.top,
      Da = ka.left - Ca.left,
      Oa = ka.width,
      Pa = V(),
      Ka = a.dropdownPosition,
      La = Ca.bottom - ra.bottom - 8 + d.getViewportTop();
    ra = ra.top - 8;
    if (!Ka) {
      var Qa = ra > ia;
      Ka = (Ka = La > ia) ? "bottom" : Qa ? "top" : ra > La ? "top" : "bottom";
    }
    l.mdFloatingLabel && ((Da += 2), (Oa -= 4));
    Da = { left: Da + "px", minWidth: Oa + "px", maxWidth: Math.max(ka.right - Ca.left, Ca.right - ka.left) - 8 + "px" };
    "top" === Ka
      ? ((Da.top = "auto"), (Da.bottom = Ea + "px"), (Da.maxHeight = Math.min(ia, ra) + "px"))
      : ((La = Ca.bottom - ka.bottom - 8 + d.getViewportTop()),
        (Da.top = Ma - Pa + "px"),
        (Da.bottom = "auto"),
        (Da.maxHeight = Math.min(ia, La) + "px"));
    L.$.scrollContainer.css(Da);
    d.nextTick(ba, !1, a);
  }
  function y() {
    L.input.focus();
  }
  function k() {
    var V = L.scroller.querySelector(".selected");
    W.activeOption = V ? V.id : null;
  }
  function p() {
    var V = parseInt(a.delay, 10) || 0;
    l.$observe("disabled", function (ba) {
      W.isDisabled = d.parseAttributeBoolean(ba, !1);
    });
    l.$observe("required", function (ba) {
      W.isRequired = d.parseAttributeBoolean(ba, !1);
    });
    l.$observe("readonly", function (ba) {
      W.isReadonly = d.parseAttributeBoolean(ba, !1);
    });
    a.$watch("searchText", V ? d.debounce(S, V) : S);
    a.$watch("selectedItem", N);
    angular.element(f).on("resize", ja);
    a.$on("$destroy", t);
  }
  function t() {
    W.hidden || d.enableScrolling();
    angular.element(f).off("resize", ja);
    if (L) {
      var V = ["ul", "scroller", "scrollContainer", "input"];
      angular.forEach(V, function (ba) {
        L.$[ba].remove();
      });
    }
  }
  function H() {
    W.hidden || x();
  }
  function A(V) {
    V.preventDefault();
  }
  function w(V) {
    V.stopPropagation();
  }
  function B(V, ba) {
    var ia;
    L && (ia = angular.element(L.scrollContainer));
    if (!V && ba) {
      if ((x(), wa(!0, Ba.Count | Ba.Selected), L)) {
        d.disableScrollAround(L.scrollContainer);
        P = z(L.wrap);
        if (d.isIos && (W.documentElement.on("touchend", u), ia)) ia.on("touchstart touchmove touchend", w);
        d.nextTick(k);
      }
    } else
      V &&
        !ba &&
        (d.isIos && (W.documentElement.off("touchend", u), ia && ia.off("touchstart touchmove touchend", w)),
        d.enableScrolling(),
        P && (P(), (P = null)));
  }
  function u() {
    W.hidden = !0;
    sa = qa = !1;
    L.input.blur();
  }
  function z(V) {
    var ba = angular.element(V);
    ba.on("wheel touchmove", A);
    return function () {
      ba.off("wheel touchmove", A);
    };
  }
  function D() {
    qa = !0;
  }
  function G() {
    sa || W.hidden || L.input.focus();
    qa = !1;
    W.hidden = !U();
  }
  function N(V, ba) {
    r();
    V
      ? J(V).then(function (ia) {
          a.searchText = ia;
          C(V, ba);
        })
      : ba &&
        a.searchText &&
        J(ba).then(function (ia) {
          angular.isString(a.searchText) && ia.toString().toLowerCase() === a.searchText.toLowerCase() && (a.searchText = "");
        });
    V !== ba && angular.isFunction(a.itemChange) && a.itemChange(Q(a.selectedItem));
  }
  function C(V, ba) {
    ta.forEach(function (ia) {
      ia(V, ba);
    });
  }
  function F(V) {
    -1 === ta.indexOf(V) && ta.push(V);
  }
  function O(V) {
    V = ta.indexOf(V);
    -1 !== V && ta.splice(V, 1);
  }
  function S(V, ba) {
    W.index = a.autoselect ? 0 : -1;
    V !== ba &&
      (r(),
      J(a.selectedItem).then(function (ia) {
        V !== ia &&
          ((a.selectedItem = null),
          V !== ba && angular.isFunction(a.textChange) && a.textChange(),
          fa() ? Ia() : ((W.matches = []), T(!1), wa(!0, Ba.Count)));
      }));
  }
  function K(V) {
    sa = !1;
    if (!qa) {
      W.hidden = !U();
      var ba = "ngBlur";
      V = { $event: V };
      l[ba] && a.$parent.$eval(l[ba], V || {});
    }
  }
  function M(V) {
    sa = !0;
    Y() && fa() && Ia();
    W.hidden = !U();
    var ba = "ngFocus";
    V = { $event: V };
    l[ba] && a.$parent.$eval(l[ba], V || {});
  }
  function I(V) {
    switch (V.keyCode) {
      case c.KEY_CODE.DOWN_ARROW:
        if (W.loading || X()) break;
        V.stopPropagation();
        V.preventDefault();
        W.index = Math.min(W.index + 1, W.matches.length - 1);
        d.nextTick(k);
        ma();
        break;
      case c.KEY_CODE.UP_ARROW:
        if (W.loading || X()) break;
        V.stopPropagation();
        V.preventDefault();
        W.index = 0 > W.index ? W.matches.length - 1 : Math.max(0, W.index - 1);
        d.nextTick(k);
        ma();
        break;
      case c.KEY_CODE.TAB:
        G();
        if (W.hidden || W.loading || 0 > W.index || 1 > W.matches.length) break;
        ca(W.index);
        break;
      case c.KEY_CODE.ENTER:
        if (W.hidden || W.loading || 0 > W.index || 1 > W.matches.length) break;
        if (X()) break;
        V.stopImmediatePropagation();
        V.preventDefault();
        ca(W.index);
        break;
      case c.KEY_CODE.ESCAPE:
        if ((V.preventDefault(), R("blur") || !W.hidden || W.loading || (R("clear") && a.searchText)))
          V.stopPropagation(), la(), a.searchText && R("clear") && pa(), (W.hidden = !0), R("blur") && ((sa = qa = !1), L.input.blur());
    }
  }
  function J(V) {
    return m.when((V && a.itemText ? a.itemText(Q(V)) : null) || V).then(function (ba) {
      ba &&
        !angular.isString(ba) &&
        v.warn("md-autocomplete: Could not resolve display value to a string. Please check the `md-item-text` attribute.");
      return ba;
    });
  }
  function Q(V) {
    if (V) {
      var ba = {};
      W.itemName && (ba[W.itemName] = V);
      return ba;
    }
  }
  function T(V) {
    W.loading !== V && (W.loading = V);
    W.hidden = !U();
  }
  function Y() {
    return (W.loading && !W.matches.length) || X() || !sa ? !1 : !0;
  }
  function R(V) {
    return !a.escapeOptions || -1 !== a.escapeOptions.toLowerCase().indexOf(V);
  }
  function U() {
    return W.isReadonly || !Y() ? !1 : (fa() && (W.matches.length ? !0 : !1)) || oa();
  }
  function X() {
    return W.scope.selectedItem ? !0 : !1;
  }
  function aa() {
    return W.loading && !X();
  }
  function ha() {
    return J(W.matches[W.index]);
  }
  function fa() {
    return (a.searchText || "").length >= (angular.isNumber(a.minLength) ? a.minLength : 1);
  }
  function ea(V, ba, ia) {
    Object.defineProperty(W, V, {
      get: function () {
        return ia;
      },
      set: function (ka) {
        var ra = ia;
        ia = ka;
        ba(ka, ra);
      }
    });
  }
  function ca(V) {
    d.nextTick(function () {
      J(W.matches[V])
        .then(function (ba) {
          var ia = L.$.input.controller("ngModel");
          n.announce(ba + " " + W.selectedMessage, "assertive");
          ia.$setViewValue(ba);
          ia.$render();
        })
        .finally(function () {
          a.selectedItem = W.matches[V];
          T(!1);
        });
    }, !1);
  }
  function da(V) {
    V && V.stopPropagation();
    la();
    pa();
  }
  function la() {
    W.index = -1;
    d.nextTick(k);
    W.matches = [];
  }
  function pa() {
    T(!0);
    a.searchText = "";
    var V = document.createEvent("CustomEvent");
    V.initCustomEvent("change", !0, !0, { value: "" });
    L.input.dispatchEvent(V);
    L.input.blur();
    a.searchText = "";
    L.input.focus();
  }
  function Ga(V) {
    function ba(Ea) {
      Ea &&
        ((Ea = m.when(Ea)),
        E++,
        T(!0),
        d.nextTick(
          function () {
            Ea.then(ia).finally(function () {
              0 === --E && T(!1);
            });
          },
          !0,
          a
        ));
    }
    function ia(Ea) {
      ua[ra] = Ea;
      (V || "") === (a.searchText || "") && xa(Ea);
    }
    var ka = a.$parent.$eval(va),
      ra = V.toLowerCase(),
      Ca = angular.isArray(ka),
      Ma = !!ka.then;
    Ca ? ia(ka) : Ma && ba(ka);
  }
  function wa(V, ba) {
    var ia = V ? "polite" : "assertive";
    V = [];
    ba & Ba.Selected && -1 !== W.index && V.push(ha());
    ba & Ba.Count && V.push(m.resolve(Aa()));
    m.all(V).then(function (ka) {
      n.announce(ka.join(" "), ia);
    });
  }
  function Aa() {
    switch (W.matches.length) {
      case 0:
        return "There are no matches available.";
      case 1:
        return "There is 1 match available.";
      default:
        return "There are " + W.matches.length + " matches available.";
    }
  }
  function ma() {
    if (L.li[0])
      if ("standard" === na) {
        var V = L.li[Math.max(0, W.index)],
          ba = L.scrollContainer.offsetHeight,
          ia = (V && V.offsetTop) || 0;
        V = ia + V.clientHeight;
        var ka = L.scrollContainer.scrollTop;
        ia < ka ? za(ia) : V > ka + ba && za(V - ba);
      } else
        (ia = L.li[0].offsetHeight),
          (ba = ia * Math.max(0, W.index)),
          (ia = ba + ia),
          (V = L.scroller.clientHeight),
          (ka = L.scroller.scrollTop),
          ba < ka ? za(ba) : ia > ka + V && za(ia - V);
  }
  function za(V) {
    "standard" === na ? (L.scrollContainer.scrollTop = V) : L.$.scrollContainer.controller("mdVirtualRepeatContainer").scrollTo(V);
  }
  function oa() {
    var V = (W.scope.searchText || "").length;
    return (
      W.hasNotFound &&
      !W.matches.length &&
      (!W.loading || 0 !== E) &&
      V >= (angular.isNumber(a.minLength) ? a.minLength : 1) &&
      (sa || qa) &&
      !X()
    );
  }
  function Ia() {
    var V = a.searchText || "",
      ba = V.toLowerCase();
    !a.noCache && ua[ba] ? xa(ua[ba]) : Ga(V);
    W.hidden = !U();
  }
  function xa(V) {
    W.matches = V;
    W.hidden = !U();
    W.loading && T(!1);
    a.selectOnMatch && Fa();
    x();
    wa(!0, Ba.Count);
  }
  function Fa() {
    var V = a.searchText,
      ba = W.matches,
      ia = ba[0];
    1 === ba.length &&
      J(ia).then(function (ka) {
        var ra = V === ka;
        a.matchInsensitive && !ra && (ra = V.toLowerCase() === ka.toLowerCase());
        ra && ca(0);
      });
  }
  var W = this,
    ya = a.itemsExpr.split(/ in /i),
    va = ya[1],
    L = null,
    ua = {},
    qa = !1,
    ta = [],
    sa = !1,
    E = 0,
    P = null,
    Z = null,
    ja = d.debounce(H),
    na = "virtual";
  W.documentElement = angular.element(document.documentElement);
  ea("hidden", B, !0);
  W.scope = a;
  W.parent = a.$parent;
  W.itemName = ya[0];
  W.matches = [];
  W.loading = !1;
  W.hidden = !0;
  W.index = -1;
  W.activeOption = null;
  W.id = d.nextUid();
  W.isDisabled = null;
  W.isRequired = null;
  W.isReadonly = null;
  W.hasNotFound = !1;
  W.selectedMessage = a.selectedMessage || "selected";
  W.keydown = I;
  W.blur = K;
  W.focus = M;
  W.clear = da;
  W.select = ca;
  W.listEnter = D;
  W.listLeave = G;
  W.focusInput = y;
  W.getCurrentDisplayValue = ha;
  W.registerSelectedItemWatcher = F;
  W.unregisterSelectedItemWatcher = O;
  W.notFoundVisible = oa;
  W.loadingIsVisible = aa;
  W.positionDropdown = x;
  var Ba = { Count: 1, Selected: 2 };
  return q();
}
MdAutocomplete.$inject = ["$$mdSvgRegistry"];
angular.module("material.components.autocomplete").directive("mdAutocomplete", MdAutocomplete);
function MdAutocomplete(a) {
  function b(c) {
    if (!c) return "virtual";
    c = c.toLowerCase();
    return -1 < d.indexOf(c) ? c : "virtual";
  }
  var d = ["standard", "virtual"];
  return {
    controller: "MdAutocompleteCtrl",
    controllerAs: "$mdAutocompleteCtrl",
    scope: {
      inputName: "@mdInputName",
      inputMinlength: "@mdInputMinlength",
      inputMaxlength: "@mdInputMaxlength",
      searchText: "=?mdSearchText",
      selectedItem: "=?mdSelectedItem",
      itemsExpr: "@mdItems",
      itemText: "&mdItemText",
      placeholder: "@placeholder",
      inputAriaDescribedBy: "@?inputAriaDescribedby",
      inputAriaLabelledBy: "@?inputAriaLabelledby",
      inputAriaLabel: "@?inputAriaLabel",
      noCache: "=?mdNoCache",
      requireMatch: "=?mdRequireMatch",
      selectOnMatch: "=?mdSelectOnMatch",
      matchInsensitive: "=?mdMatchCaseInsensitive",
      itemChange: "&?mdSelectedItemChange",
      textChange: "&?mdSearchTextChange",
      minLength: "=?mdMinLength",
      delay: "=?mdDelay",
      autofocus: "=?mdAutofocus",
      floatingLabel: "@?mdFloatingLabel",
      autoselect: "=?mdAutoselect",
      menuClass: "@?mdMenuClass",
      menuContainerClass: "@?mdMenuContainerClass",
      inputClass: "@?mdInputClass",
      inputId: "@?mdInputId",
      escapeOptions: "@?mdEscapeOptions",
      dropdownItems: "=?mdDropdownItems",
      dropdownPosition: "@?mdDropdownPosition",
      clearButton: "=?mdClearButton",
      selectedMessage: "@?mdSelectedMessage",
      mdMode: "=?mdMode"
    },
    compile: function (c, e) {
      var f = ["md-select-on-focus", "md-no-asterisk", "ng-trim", "ng-pattern"],
        g = c.find("input");
      f.forEach(function (h) {
        var l = e[e.$normalize(h)];
        null !== l && g.attr(h, l);
      });
      return function (h, l, m, v) {
        v.hasNotFound = !!l.attr("md-has-not-found");
        angular.isDefined(m.mdClearButton) || h.floatingLabel || (h.clearButton = !0);
        h.mdMode = b(m.mdMode);
        l.on("click touchstart touchend", function (n) {
          n.stopPropagation();
        });
      };
    },
    template: function (c, e) {
      function f() {
        var r = c.find("md-item-template").detach(),
          x = r.length ? r.html() : c.html();
        r.length || c.empty();
        return "<md-autocomplete-parent-scope md-autocomplete-replace>" + x + "</md-autocomplete-parent-scope>";
      }
      function g() {
        var r = c.find("md-not-found").detach();
        return (r = r.length ? r.html() : "")
          ? '<li ng-if="$mdAutocompleteCtrl.notFoundVisible()"                         md-autocomplete-parent-scope>' + r + "</li>"
          : "";
      }
      function h(r, x) {
        r = r ? " " + r : "";
        return l(x)
          ? '            <div                 ng-hide="$mdAutocompleteCtrl.hidden"                class="md-standard-list-container md-autocomplete-suggestions-container md-whiteframe-z1' +
              r +
              '"                ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"                role="presentation">              <div class="md-standard-list-scroller" role="presentation">'
          : '          <md-virtual-repeat-container              md-auto-shrink              md-auto-shrink-min="1"              ng-hide="$mdAutocompleteCtrl.hidden"              class="md-virtual-repeat-container md-autocomplete-suggestions-container md-whiteframe-z1' +
              r +
              '"              ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"              role="presentation">';
      }
      function l(r) {
        r = b(r);
        return "virtual" !== r;
      }
      var m = g(),
        v = f(),
        n = c.html(),
        q = e.tabindex;
      m && c.attr("md-has-not-found", !0);
      c.attr("tabindex", "-1");
      n = e.mdFloatingLabel
        ? '            <md-input-container ng-if="floatingLabel">              <label>{{floatingLabel}}</label>              <input type="text"                ' +
          (null != q ? 'tabindex="' + q + '"' : "") +
          '                id="{{inputId || \'fl-input-\' + $mdAutocompleteCtrl.id}}"                name="{{inputName || \'fl-input-\' + $mdAutocompleteCtrl.id }}"                ng-class="::inputClass"                autocomplete="off"                ng-required="$mdAutocompleteCtrl.isRequired"                ng-readonly="$mdAutocompleteCtrl.isReadonly"                ng-minlength="inputMinlength"                ng-maxlength="inputMaxlength"                ng-disabled="$mdAutocompleteCtrl.isDisabled"                ng-model="$mdAutocompleteCtrl.scope.searchText"                ng-model-options="{ allowInvalid: true }"                ng-mousedown="$mdAutocompleteCtrl.focusInput()"                ng-keydown="$mdAutocompleteCtrl.keydown($event)"                ng-blur="$mdAutocompleteCtrl.blur($event)"                ng-focus="$mdAutocompleteCtrl.focus($event)"                aria-label="{{floatingLabel}}"                ng-attr-aria-autocomplete="{{$mdAutocompleteCtrl.isDisabled ? undefined : \'list\'}}"                ng-attr-role="{{$mdAutocompleteCtrl.isDisabled ? undefined : \'combobox\'}}"                aria-haspopup="{{!$mdAutocompleteCtrl.isDisabled}}"                aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"                ng-attr-aria-owns="{{$mdAutocompleteCtrl.hidden || $mdAutocompleteCtrl.isDisabled ? undefined : \'ul-\' + $mdAutocompleteCtrl.id}}"                ng-attr-aria-activedescendant="{{!$mdAutocompleteCtrl.hidden && $mdAutocompleteCtrl.activeOption ? $mdAutocompleteCtrl.activeOption : undefined}}">              <div md-autocomplete-parent-scope md-autocomplete-replace>' +
          n +
          "</div>            </md-input-container>"
        : '            <input type="text"              ' +
          (null != q ? 'tabindex="' + q + '"' : "") +
          '              id="{{inputId || \'input-\' + $mdAutocompleteCtrl.id}}"              name="{{inputName || \'input-\' + $mdAutocompleteCtrl.id }}"              ng-class="::inputClass"              ng-if="!floatingLabel"              autocomplete="off"              ng-required="$mdAutocompleteCtrl.isRequired"              ng-disabled="$mdAutocompleteCtrl.isDisabled"              ng-readonly="$mdAutocompleteCtrl.isReadonly"              ng-minlength="inputMinlength"              ng-maxlength="inputMaxlength"              ng-model="$mdAutocompleteCtrl.scope.searchText"              ng-mousedown="$mdAutocompleteCtrl.focusInput()"              ng-keydown="$mdAutocompleteCtrl.keydown($event)"              ng-blur="$mdAutocompleteCtrl.blur($event)"              ng-focus="$mdAutocompleteCtrl.focus($event)"              placeholder="{{placeholder}}"              aria-label="{{placeholder}}"              ng-attr-aria-autocomplete="{{$mdAutocompleteCtrl.isDisabled ? undefined : \'list\'}}"              ng-attr-role="{{$mdAutocompleteCtrl.isDisabled ? undefined : \'combobox\'}}"              aria-haspopup="{{!$mdAutocompleteCtrl.isDisabled}}"              aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"              ng-attr-aria-owns="{{$mdAutocompleteCtrl.hidden || $mdAutocompleteCtrl.isDisabled ? undefined : \'ul-\' + $mdAutocompleteCtrl.id}}"              ng-attr-aria-activedescendant="{{!$mdAutocompleteCtrl.hidden && $mdAutocompleteCtrl.activeOption ? $mdAutocompleteCtrl.activeOption : undefined}}">';
      return (
        "        <md-autocomplete-wrap            ng-class=\"{ 'md-whiteframe-z1': !floatingLabel,                         'md-menu-showing': !$mdAutocompleteCtrl.hidden,                         'md-show-clear-button': !!clearButton }\">          " +
        n +
        '          <button type="button" aria-label="Clear Input" tabindex="0" ng-if="clearButton && $mdAutocompleteCtrl.scope.searchText" ng-click="$mdAutocompleteCtrl.clear($event)"><md-icon md-svg-src="' +
        (a.mdClose + '"></md-icon></button>          <md-progress-linear              class="') +
        (e.mdFloatingLabel ? "md-inline" : "") +
        '"              ng-if="$mdAutocompleteCtrl.loadingIsVisible()"              md-mode="indeterminate"></md-progress-linear>          ' +
        h(e.mdMenuContainerClass, e.mdMode) +
        '            <ul class="md-autocomplete-suggestions"                ng-class="::menuClass"                id="ul-{{$mdAutocompleteCtrl.id}}"                ng-mouseenter="$mdAutocompleteCtrl.listEnter()"                ng-mouseleave="$mdAutocompleteCtrl.listLeave()"                ng-mouseup="$mdAutocompleteCtrl.focusInput()"                role="listbox">              <li class="md-autocomplete-suggestion" ' +
        (l(e.mdMode) ? "ng-repeat" : "md-virtual-repeat") +
        ' ="item in $mdAutocompleteCtrl.matches"                  ng-class="{ selected: $index === $mdAutocompleteCtrl.index }"                  ng-attr-id="{{\'md-option-\' + $mdAutocompleteCtrl.id + \'-\' + $index}}"                  ng-click="$mdAutocompleteCtrl.select($index)"                  role="option"                  aria-setsize="{{$mdAutocompleteCtrl.matches.length}}"                  aria-posinset="{{$index+1}}"                  aria-selected="{{$index === $mdAutocompleteCtrl.index ? true : false}}"                   md-extra-name="$mdAutocompleteCtrl.itemName">                  ' +
        v +
        "                  </li>" +
        m +
        "            </ul>          " +
        (l(e.mdMode) ? "   </div>              </div>            </div>" : "</md-virtual-repeat-container>") +
        "        </md-autocomplete-wrap>"
      );
    }
  };
}
MdAutocompleteItemScopeDirective.$inject = ["$compile", "$mdUtil"];
angular.module("material.components.autocomplete").directive("mdAutocompleteParentScope", MdAutocompleteItemScopeDirective);
function MdAutocompleteItemScopeDirective(a, b) {
  function d(c, e, f) {
    return function (g, h) {
      function l(q, r) {
        n[r] = g[q];
        g.$watch(q, function (x) {
          b.nextTick(function () {
            n[r] = x;
          });
        });
      }
      function m() {
        var q = !1,
          r = !1;
        g.$watch(function () {
          r ||
            q ||
            ((q = !0),
            g.$$postDigest(function () {
              r || n.$digest();
              q = r = !1;
            }));
        });
        n.$watch(function () {
          r = !0;
        });
      }
      var v = g.$mdAutocompleteCtrl,
        n = v.parent.$new();
      v = v.itemName;
      l("$index", "$index");
      l("item", v);
      m();
      f(n, function (q) {
        h.after(q);
      });
    };
  }
  return { restrict: "AE", compile: d, terminal: !0, transclude: "element" };
}
MdHighlightCtrl.$inject = ["$scope", "$element", "$attrs"];
angular.module("material.components.autocomplete").controller("MdHighlightCtrl", MdHighlightCtrl);
function MdHighlightCtrl(a, b, d) {
  this.$scope = a;
  this.$element = b;
  this.$attrs = d;
  this.regex = null;
}
MdHighlightCtrl.prototype.init = function (a, b) {
  this.flags = this.$attrs.mdHighlightFlags || "";
  this.unregisterFn = this.$scope.$watch(
    function (d) {
      return { term: a(d), contentText: b(d) };
    }.bind(this),
    this.onRender.bind(this),
    !0
  );
  this.$element.on("$destroy", this.unregisterFn);
};
MdHighlightCtrl.prototype.onRender = function (a, b) {
  var d = a.contentText;
  if (null === this.regex || a.term !== b.term) this.regex = this.createRegex(a.term, this.flags);
  a.term ? this.applyRegex(d) : this.$element.text(d);
};
MdHighlightCtrl.prototype.applyRegex = function (a) {
  a = this.resolveTokens(a);
  this.$element.empty();
  a.forEach(
    function (b) {
      b.isMatch
        ? ((b = angular.element('<span class="highlight">').text(b.text)), this.$element.append(b))
        : this.$element.append(document.createTextNode(b));
    }.bind(this)
  );
};
MdHighlightCtrl.prototype.resolveTokens = function (a) {
  function b(e, f) {
    (e = a.slice(e, f)) && d.push(e);
  }
  var d = [],
    c = 0;
  a.replace(this.regex, function (e, f) {
    b(c, f);
    d.push({ text: e, isMatch: !0 });
    c = f + e.length;
  });
  b(c);
  return d;
};
MdHighlightCtrl.prototype.createRegex = function (a, b) {
  var d = "",
    c = "";
  a = this.sanitizeRegex(a);
  0 <= b.indexOf("^") && (d = "^");
  0 <= b.indexOf("$") && (c = "$");
  return new RegExp(d + a + c, b.replace(/[$^]/g, ""));
};
MdHighlightCtrl.prototype.sanitizeRegex = function (a) {
  return a && a.toString().replace(/[\\^$*+?.()|{}[\]]/g, "\\$&");
};
MdHighlight.$inject = ["$interpolate", "$parse"];
angular.module("material.components.autocomplete").directive("mdHighlightText", MdHighlight);
function MdHighlight(a, b) {
  return {
    terminal: !0,
    controller: "MdHighlightCtrl",
    compile: function (d, c) {
      var e = b(c.mdHighlightText),
        f = a(d.html());
      return function (g, h, l, m) {
        m.init(e, f);
      };
    }
  };
}
ngmaterial.components.autocomplete = angular.module("material.components.autocomplete");
angular.module("material.components.backdrop", ["material.core"]).directive("mdBackdrop", [
  "$mdTheming",
  "$mdUtil",
  "$animate",
  "$rootElement",
  "$window",
  "$log",
  "$$rAF",
  "$document",
  function (a, b, d, c, e, f, g, h) {
    function l(m, v) {
      function n() {
        var r = parseInt(q.height, 10) + Math.abs(parseInt(q.top, 10));
        v.css("height", r + "px");
      }
      d.pin && d.pin(v, c);
      var q;
      g(function () {
        q = e.getComputedStyle(h[0].body);
        if ("fixed" === q.position) {
          var r = b.debounce(
            function () {
              q = e.getComputedStyle(h[0].body);
              n();
            },
            60,
            null,
            !1
          );
          n();
          angular.element(e).on("resize", r);
          m.$on("$destroy", function () {
            angular.element(e).off("resize", r);
          });
        }
        var x = v.parent();
        if (x.length) {
          "BODY" === x[0].nodeName && v.css("position", "fixed");
          var y = e.getComputedStyle(x[0]);
          "static" === y.position && f.warn("<md-backdrop> may not work properly in a scrolled, static-positioned parent container.");
          a.inherit(v, x);
        }
      });
    }
    return { restrict: "E", link: l };
  }
]);
ngmaterial.components.backdrop = angular.module("material.components.backdrop");
MdBottomSheetDirective.$inject = ["$mdBottomSheet"];
MdBottomSheetProvider.$inject = ["$$interimElementProvider"];
angular
  .module("material.components.bottomSheet", ["material.core", "material.components.backdrop"])
  .directive("mdBottomSheet", MdBottomSheetDirective)
  .provider("$mdBottomSheet", MdBottomSheetProvider);
function MdBottomSheetDirective(a) {
  return {
    restrict: "E",
    link: function (b, d) {
      d.addClass("_md");
      b.$on("$destroy", function () {
        a.destroy();
      });
    }
  };
}
function MdBottomSheetProvider(a) {
  function b(d, c, e, f, g, h, l, m) {
    function v(x, y, k) {
      y = e.extractElementByName(y, "md-bottom-sheet");
      y.attr("tabindex", "-1");
      y.hasClass("ng-cloak") &&
        m.warn("$mdBottomSheet: using `<md-bottom-sheet ng-cloak>` will affect the bottom-sheet opening animations.", y[0]);
      k.isLockedOpen ? ((k.clickOutsideToClose = !1), (k.escapeToClose = !1)) : (k.cleanupGestures = q(y, k.parent));
      if (!k.disableBackdrop) {
        r = e.createBackdrop(x, "md-bottom-sheet-backdrop md-opaque");
        r[0].tabIndex = -1;
        if (k.clickOutsideToClose)
          r.on("click", function () {
            e.nextTick(g.cancel, !0);
          });
        f.inherit(r, k.parent);
        d.enter(r, k.parent, null);
      }
      f.inherit(y, k.parent);
      k.disableParentScroll && (k.restoreScroll = e.disableScrollAround(y, k.parent));
      return d.enter(y, k.parent, r).then(function () {
        var p =
          e.findFocusTarget(y) ||
          angular.element(y[0].querySelector("button") || y[0].querySelector("a") || y[0].querySelector(e.prefixer("ng-click", !0))) ||
          r;
        k.escapeToClose &&
          ((k.rootElementKeyupCallback = function (t) {
            t.keyCode === c.KEY_CODE.ESCAPE && e.nextTick(g.cancel, !0);
          }),
          h.on("keyup", k.rootElementKeyupCallback),
          p && p.focus());
      });
    }
    function n(x, y, k) {
      k.disableBackdrop || d.leave(r);
      return d.leave(y).then(function () {
        k.disableParentScroll && (k.restoreScroll(), delete k.restoreScroll);
        k.cleanupGestures && k.cleanupGestures();
      });
    }
    function q(x, y) {
      function k() {
        x.css(c.CSS.TRANSITION_DURATION, "0ms");
      }
      function p(A) {
        A = A.pointer.distanceY;
        5 > A && (A = Math.max(-80, A / 2));
        x.css(c.CSS.TRANSFORM, "translate3d(0," + (80 + A) + "px,0)");
      }
      function t(A) {
        if (0 < A.pointer.distanceY && (20 < A.pointer.distanceY || 0.5 < Math.abs(A.pointer.velocityY))) {
          var w = x.prop("offsetHeight") - A.pointer.distanceY;
          A = Math.min((w / A.pointer.velocityY) * 0.75, 500);
          x.css(c.CSS.TRANSITION_DURATION, A + "ms");
          e.nextTick(g.cancel, !0);
        } else x.css(c.CSS.TRANSITION_DURATION, ""), x.css(c.CSS.TRANSFORM, "");
      }
      var H = l.register(y, "drag", { horizontal: !1 });
      y.on("$md.dragstart", k).on("$md.drag", p).on("$md.dragend", t);
      return function () {
        H();
        y.off("$md.dragstart", k);
        y.off("$md.drag", p);
        y.off("$md.dragend", t);
      };
    }
    var r;
    return {
      themable: !0,
      onShow: v,
      onRemove: n,
      disableBackdrop: !1,
      escapeToClose: !0,
      clickOutsideToClose: !0,
      disableParentScroll: !0,
      isLockedOpen: !1
    };
  }
  b.$inject = "$animate $mdConstant $mdUtil $mdTheming $mdBottomSheet $rootElement $mdGesture $log".split(" ");
  return a("$mdBottomSheet").setDefaults({ methods: ["disableParentScroll", "escapeToClose", "clickOutsideToClose"], options: b });
}
ngmaterial.components.bottomSheet = angular.module("material.components.bottomSheet");
MdButtonDirective.$inject = ["$mdButtonInkRipple", "$mdTheming", "$mdAria", "$mdInteraction"];
MdAnchorDirective.$inject = ["$mdTheming"];
angular.module("material.components.button", ["material.core"]).directive("mdButton", MdButtonDirective).directive("a", MdAnchorDirective);
function MdAnchorDirective(a) {
  return {
    restrict: "E",
    link: function (b, d) {
      a(d);
    }
  };
}
function MdButtonDirective(a, b, d, c) {
  function e(h) {
    return angular.isDefined(h.href) || angular.isDefined(h.ngHref) || angular.isDefined(h.ngLink) || angular.isDefined(h.uiSref);
  }
  function f(h, l) {
    if (e(l)) return '<a class="md-button" ng-transclude></a>';
    h = "undefined" === typeof l.type ? "button" : l.type;
    return '<button class="md-button" type="' + h + '" ng-transclude></button>';
  }
  function g(h, l, m) {
    b(l);
    a.attach(h, l);
    d.expectWithoutText(l, "aria-label");
    e(m) &&
      angular.isDefined(m.ngDisabled) &&
      !l.hasClass("_md-nav-button") &&
      h.$watch(m.ngDisabled, function (v) {
        l.attr("tabindex", v ? -1 : 0);
      });
    l.on("click", function (v) {
      !0 === m.disabled && (v.preventDefault(), v.stopImmediatePropagation());
    });
    l.hasClass("md-no-focus") ||
      (l.on("focus", function () {
        (c.isUserInvoked() && "keyboard" !== c.getLastInteractionType()) || l.addClass("md-focused");
      }),
      l.on("blur", function () {
        l.removeClass("md-focused");
      }));
  }
  return { restrict: "EA", replace: !0, transclude: !0, template: f, link: g };
}
ngmaterial.components.button = angular.module("material.components.button");
mdCardDirective.$inject = ["$mdTheming"];
angular.module("material.components.card", ["material.core"]).directive("mdCard", mdCardDirective);
function mdCardDirective(a) {
  return {
    restrict: "E",
    link: function (b, d) {
      d.addClass("_md");
      a(d);
    }
  };
}
ngmaterial.components.card = angular.module("material.components.card");
MdCheckboxDirective.$inject = "inputDirective $mdAria $mdConstant $mdTheming $mdUtil $mdInteraction".split(" ");
angular.module("material.components.checkbox", ["material.core"]).directive("mdCheckbox", MdCheckboxDirective);
function MdCheckboxDirective(a, b, d, c, e, f) {
  function g(h, l) {
    function m(v, n, q, r) {
      function x(u, z, D) {
        q[u] &&
          v.$watch(q[u], function (G) {
            D[G] && n.attr(z, D[G]);
          });
      }
      function y(u) {
        var z = u.which || u.keyCode;
        u.preventDefault();
        switch (z) {
          case d.KEY_CODE.SPACE:
            n.addClass("md-focused");
            k(u);
            break;
          case d.KEY_CODE.ENTER:
            (u = e.getClosest(u.target, "form")) &&
              (u = u.querySelector('button[type="submit"]:enabled, input[type="submit"]:enabled')) &&
              u.click();
        }
      }
      function k(u) {
        n[0].hasAttribute("disabled") ||
          v.skipToggle ||
          v.$apply(function () {
            var z = q.ngChecked && q.ngClick ? q.checked : !w.$viewValue;
            w.$setViewValue(z, u && u.type);
            w.$render();
          });
      }
      function p() {
        n.toggleClass("md-checked", !!w.$viewValue && !H);
      }
      function t(u) {
        (H = !1 !== u) && n.attr("aria-checked", "mixed");
        n.toggleClass("md-indeterminate", H);
      }
      var H,
        A = r[0],
        w = r[1] || e.fakeNgModel(),
        B = r[2];
      A &&
        ((r =
          A.isErrorGetter ||
          function () {
            return w.$invalid && (w.$touched || (B && B.$submitted));
          }),
        (A.input = n),
        v.$watch(r, A.setInvalid));
      c(n);
      n.children().on("focus", function () {
        n.focus();
      });
      e.parseAttributeBoolean(q.mdIndeterminate) && (t(), v.$watch(q.mdIndeterminate, t));
      q.ngChecked &&
        v.$watch(v.$eval.bind(v, q.ngChecked), function (u) {
          w.$setViewValue(u);
          w.$render();
        });
      x("ngDisabled", "tabindex", { true: "-1", false: q.tabindex });
      b.expectWithText(n, "aria-label");
      a.link.pre(v, { on: angular.noop, 0: {} }, q, [w]);
      n.on("click", k)
        .on("keypress", y)
        .on("focus", function () {
          "keyboard" === f.getLastInteractionType() && n.addClass("md-focused");
        })
        .on("blur", function () {
          n.removeClass("md-focused");
        });
      w.$render = p;
    }
    l.$set("tabindex", l.tabindex || "0");
    l.$set("type", "checkbox");
    l.$set("role", l.type);
    return {
      pre: function (v, n) {
        n.on("click", function (q) {
          this.hasAttribute("disabled") && q.stopImmediatePropagation();
        });
      },
      post: m
    };
  }
  a = a[0];
  return {
    restrict: "E",
    transclude: !0,
    require: ["^?mdInputContainer", "?ngModel", "?^form"],
    priority: d.BEFORE_NG_ARIA,
    template:
      '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox><div class="md-icon"></div></div><div ng-transclude class="md-label"></div>',
    compile: g
  };
}
ngmaterial.components.checkbox = angular.module("material.components.checkbox");
angular.module("material.components.chips", ["material.core", "material.components.autocomplete"]);
MdChipCtrl.$inject = ["$scope", "$element", "$mdConstant", "$timeout", "$mdUtil"];
angular.module("material.components.chips").controller("MdChipCtrl", MdChipCtrl);
function MdChipCtrl(a, b, d, c, e) {
  this.$scope = a;
  this.$element = b;
  this.$mdConstant = d;
  this.$timeout = c;
  this.$mdUtil = e;
  this.isEditing = !1;
  this.parentController = void 0;
  this.enableChipEdit = !1;
}
MdChipCtrl.prototype.init = function (a) {
  this.parentController = a;
  if ((this.enableChipEdit = this.parentController.enableChipEdit))
    this.$element.on("keydown", this.chipKeyDown.bind(this)),
      this.$element.on("dblclick", this.chipMouseDoubleClick.bind(this)),
      this.getChipContent().addClass("_md-chip-content-edit-is-enabled");
};
MdChipCtrl.prototype.getChipContent = function () {
  var a = this.$element[0].getElementsByClassName("md-chip-content");
  return angular.element(a[0]);
};
MdChipCtrl.prototype.getContentElement = function () {
  var a = angular.element(this.getChipContent().children()[0]);
  (a && 0 !== a.length) || (a = angular.element(this.getChipContent().contents()[0]));
  return a;
};
MdChipCtrl.prototype.getChipIndex = function () {
  return parseInt(this.$element.attr("index"));
};
MdChipCtrl.prototype.goOutOfEditMode = function () {
  if (this.isEditing) {
    this.isEditing = !1;
    this.$element.removeClass("_md-chip-editing");
    this.getChipContent()[0].contentEditable = "false";
    var a = this.getChipIndex(),
      b = this.getContentElement().text();
    b
      ? (this.parentController.updateChipContents(a, b),
        this.$mdUtil.nextTick(
          function () {
            this.parentController.selectedChip === a && this.parentController.focusChip(a);
          }.bind(this)
        ))
      : this.parentController.removeChipAndFocusInput(a);
  }
};
MdChipCtrl.prototype.selectNodeContents = function (a) {
  if (document.body.createTextRange) {
    var b = document.body.createTextRange();
    b.moveToElementText(a);
    b.select();
  } else if (window.getSelection) {
    var d = window.getSelection();
    b = document.createRange();
    b.selectNodeContents(a);
    d.removeAllRanges();
    d.addRange(b);
  }
};
MdChipCtrl.prototype.goInEditMode = function () {
  this.isEditing = !0;
  this.$element.addClass("_md-chip-editing");
  this.getChipContent()[0].contentEditable = "true";
  this.getChipContent().on(
    "blur",
    function () {
      this.goOutOfEditMode();
    }.bind(this)
  );
  this.selectNodeContents(this.getChipContent()[0]);
};
MdChipCtrl.prototype.chipKeyDown = function (a) {
  this.isEditing || (a.keyCode !== this.$mdConstant.KEY_CODE.ENTER && a.keyCode !== this.$mdConstant.KEY_CODE.SPACE)
    ? this.isEditing && a.keyCode === this.$mdConstant.KEY_CODE.ENTER && (a.preventDefault(), this.goOutOfEditMode())
    : (a.preventDefault(), this.goInEditMode());
};
MdChipCtrl.prototype.chipMouseDoubleClick = function () {
  this.enableChipEdit && !this.isEditing && this.goInEditMode();
};
MdChip.$inject = ["$mdTheming", "$mdUtil", "$compile", "$timeout"];
angular.module("material.components.chips").directive("mdChip", MdChip);
function MdChip(a, b, d, c) {
  function e(f, g, h, l) {
    var m = l.shift();
    f = l.shift();
    h = angular.element(g[0].querySelector(".md-chip-content"));
    a(g);
    m &&
      (f.init(m),
      h.on("blur", function () {
        m.resetSelectedChip();
        m.$scope.$applyAsync();
      }));
    c(function () {
      m && m.shouldFocusLastChip && m.focusLastChipThenInput();
    });
  }
  return { restrict: "E", require: ["^?mdChips", "mdChip"], link: e, controller: "MdChipCtrl" };
}
MdChipRemove.$inject = ["$timeout"];
angular.module("material.components.chips").directive("mdChipRemove", MdChipRemove);
function MdChipRemove(a) {
  function b(d, c, e, f) {
    c.on("click", function () {
      d.$apply(function () {
        f.removeChip(d.$$replacedScope.$index);
      });
    });
    a(function () {
      c.attr({ tabindex: "-1", "aria-hidden": "true" });
      c.find("button").attr("tabindex", "-1");
    });
  }
  return { restrict: "A", require: "^mdChips", scope: !1, link: b };
}
MdChipTransclude.$inject = ["$compile"];
angular.module("material.components.chips").directive("mdChipTransclude", MdChipTransclude);
function MdChipTransclude(a) {
  function b(d, c, e) {
    var f = d.$parent.$mdChipsCtrl,
      g = f.parent.$new(!1, f.parent);
    g.$$replacedScope = d;
    g.$chip = d.$chip;
    g.$index = d.$index;
    g.$mdChipsCtrl = f;
    d = f.$scope.$eval(e.mdChipTransclude);
    c.html(d);
    a(c.contents())(g);
  }
  return { restrict: "EA", terminal: !0, link: b, scope: !1 };
}
MdChipsCtrl.$inject = "$scope $attrs $mdConstant $log $element $timeout $mdUtil $mdLiveAnnouncer $exceptionHandler".split(" ");
angular.module("material.components.chips").controller("MdChipsCtrl", MdChipsCtrl);
function MdChipsCtrl(a, b, d, c, e, f, g, h, l) {
  this.$timeout = f;
  this.$mdConstant = d;
  this.$scope = a;
  this.parent = a.$parent;
  this.$mdUtil = g;
  this.$log = c;
  this.$mdLiveAnnouncer = h;
  this.$exceptionHandler = l;
  this.$element = e;
  this.$attrs = b;
  this.userInputElement = this.autocompleteCtrl = this.userInputNgModelCtrl = this.ngModelCtrl = null;
  this.items = [];
  this.selectedChip = -1;
  this.enableChipEdit = g.parseAttributeBoolean(b.mdEnableChipEdit);
  this.addOnBlur = g.parseAttributeBoolean(b.mdAddOnBlur);
  this.inputAriaLabel = "Chips input.";
  this.containerHint = "Chips container. Use arrow keys to select chips.";
  this.containerEmptyHint = "Chips container. Enter the text area, then type text, and press enter to add a chip.";
  this.deleteHint = "Press delete to remove this chip.";
  this.deleteButtonLabel = "Remove";
  this.chipBuffer = "";
  this.useOnRemove = this.useOnAdd = this.useTransformChip = !1;
  this.wrapperId = "";
  this.contentIds = [];
  this.ariaTabIndex = null;
  this.chipAppendDelay = 300;
  this.deRegister = [];
  this.addedMessage = "added";
  this.removedMessage = "removed";
  this.init();
}
MdChipsCtrl.prototype.init = function () {
  var a = this;
  this.wrapperId = "_md-chips-wrapper-" + this.$mdUtil.nextUid();
  this.$element.attr("ng-model") || this.setupStaticChips();
  this.deRegister.push(
    this.$scope.$watchCollection("$mdChipsCtrl.items", function () {
      a.setupInputAria();
      a.setupWrapperAria();
    })
  );
  this.deRegister.push(
    this.$attrs.$observe("mdChipAppendDelay", function (b) {
      a.chipAppendDelay = parseInt(b) || 300;
    })
  );
};
MdChipsCtrl.prototype.$onDestroy = function () {
  for (var a; (a = this.deRegister.pop()); ) a.call(this);
};
MdChipsCtrl.prototype.setupInputAria = function () {
  var a = this.$element.find("input");
  a &&
    (a.attr("role", "textbox"),
    a.attr("aria-multiline", !0),
    this.inputAriaDescribedBy && a.attr("aria-describedby", this.inputAriaDescribedBy),
    this.inputAriaLabelledBy
      ? (a.attr("aria-labelledby", this.inputAriaLabelledBy), a.removeAttr("aria-label"))
      : a.attr("aria-label", this.inputAriaLabel));
};
MdChipsCtrl.prototype.setupWrapperAria = function () {
  var a = this,
    b = this.$element.find("md-chips-wrap");
  this.items && this.items.length
    ? (b.attr("role", "listbox"),
      (this.contentIds = this.items.map(function () {
        return a.wrapperId + "-chip-" + a.$mdUtil.nextUid();
      })),
      b.attr("aria-owns", this.contentIds.join(" ")),
      b.attr("aria-label", this.containerHint))
    : (b.removeAttr("role"), b.removeAttr("aria-owns"), b.attr("aria-label", this.containerEmptyHint));
};
MdChipsCtrl.prototype.setupStaticChips = function () {
  var a = this,
    b,
    d,
    c = this.$element.find("md-chips-wrap");
  this.$timeout(function () {
    c.attr("role", "list");
    d = c[0].children;
    for (b = 0; b < d.length; b++) d[b].setAttribute("role", "listitem"), d[b].setAttribute("aria-setsize", d.length);
    a.inputAriaDescribedBy && c.attr("aria-describedby", a.inputAriaDescribedBy);
    a.inputAriaLabelledBy
      ? (c.attr("aria-labelledby", a.inputAriaLabelledBy), c.removeAttr("aria-label"))
      : c.attr("aria-label", a.inputAriaLabel);
  }, 10);
};
MdChipsCtrl.prototype.inputKeydown = function (a) {
  var b = this.getChipBuffer();
  if (!(this.autocompleteCtrl && a.isDefaultPrevented && a.isDefaultPrevented()))
    if (a.keyCode === this.$mdConstant.KEY_CODE.BACKSPACE)
      0 === this.getCursorPosition(a.target) &&
        (a.preventDefault(), a.stopPropagation(), this.items.length && this.selectAndFocusChipSafe(this.items.length - 1));
    else {
      if (!this.separatorKeys || 1 > this.separatorKeys.length) this.separatorKeys = [this.$mdConstant.KEY_CODE.ENTER];
      if (
        !(
          -1 === this.separatorKeys.indexOf(a.keyCode) ||
          (this.autocompleteCtrl && this.requireMatch) ||
          !b ||
          (a.preventDefault(), this.hasMaxChipsReached())
        )
      )
        return this.appendChip(b.trim()), this.resetChipBuffer(), !1;
    }
};
MdChipsCtrl.prototype.getCursorPosition = function (a) {
  try {
    if (a.selectionStart === a.selectionEnd) return a.selectionStart;
  } catch (b) {
    if (!a.value) return 0;
  }
};
MdChipsCtrl.prototype.updateChipContents = function (a, b) {
  0 <= a && a < this.items.length && ((this.items[a] = b), this.updateNgModel(!0));
};
MdChipsCtrl.prototype.isEditingChip = function () {
  return !!this.$element[0].querySelector("._md-chip-editing");
};
MdChipsCtrl.prototype._isChipObject = function (a) {
  return angular.isObject(a);
};
MdChipsCtrl.prototype.isRemovable = function () {
  return this.ngModelCtrl ? (this.readonly ? this.removable : angular.isDefined(this.removable) ? this.removable : !0) : !1;
};
MdChipsCtrl.prototype.chipKeydown = function (a) {
  if (!this.getChipBuffer() && !this.isEditingChip())
    switch (a.keyCode) {
      case this.$mdConstant.KEY_CODE.BACKSPACE:
      case this.$mdConstant.KEY_CODE.DELETE:
        if (0 > this.selectedChip) break;
        a.preventDefault();
        if (!this.isRemovable()) break;
        this.removeAndSelectAdjacentChip(this.selectedChip, a);
        break;
      case this.$mdConstant.KEY_CODE.LEFT_ARROW:
        a.preventDefault();
        if (0 > this.selectedChip || (this.readonly && 0 === this.selectedChip)) this.selectedChip = this.items.length;
        this.items.length && this.selectAndFocusChipSafe(this.selectedChip - 1);
        break;
      case this.$mdConstant.KEY_CODE.RIGHT_ARROW:
        a.preventDefault();
        this.selectAndFocusChipSafe(this.selectedChip + 1);
        break;
      case this.$mdConstant.KEY_CODE.ESCAPE:
      case this.$mdConstant.KEY_CODE.TAB:
        0 > this.selectedChip || (a.preventDefault(), this.onFocus());
    }
};
MdChipsCtrl.prototype.getPlaceholder = function () {
  var a = this.items && this.items.length && ("" === this.secondaryPlaceholder || this.secondaryPlaceholder);
  return a ? this.secondaryPlaceholder : this.placeholder;
};
MdChipsCtrl.prototype.removeAndSelectAdjacentChip = function (a, b) {
  var d = this,
    c = d.getAdjacentChipIndex(a);
  this.$element[0].querySelector("md-chips-wrap");
  this.$element[0].querySelector('md-chip[index="' + a + '"]');
  d.removeChip(a, b);
  d.$timeout(function () {
    d.$timeout(function () {
      d.selectAndFocusChipSafe(c);
    });
  });
};
MdChipsCtrl.prototype.resetSelectedChip = function () {
  this.selectedChip = -1;
  this.ariaTabIndex = null;
};
MdChipsCtrl.prototype.getAdjacentChipIndex = function (a) {
  var b = this.items.length - 1;
  return 0 === b ? -1 : a === b ? a - 1 : a;
};
MdChipsCtrl.prototype.appendChip = function (a) {
  this.shouldFocusLastChip = !this.addOnBlur;
  if (this.useTransformChip && this.transformChip) {
    var b = this.transformChip({ $chip: a });
    angular.isDefined(b) && (a = b);
  }
  if (
    angular.isObject(a) &&
    (b = this.items.some(function (c) {
      return angular.equals(a, c);
    }))
  )
    return;
  if (!(null == a || this.items.indexOf(a) + 1)) {
    b = this.items.push(a);
    --b;
    this.updateNgModel();
    var d = angular.isObject(a) ? "" : a;
    this.$mdLiveAnnouncer.announce(d + " " + this.addedMessage, "assertive");
    if (this.useOnAdd && this.onAdd) this.onAdd({ $chip: a, $index: b });
  }
};
MdChipsCtrl.prototype.useTransformChipExpression = function () {
  this.useTransformChip = !0;
};
MdChipsCtrl.prototype.useOnAddExpression = function () {
  this.useOnAdd = !0;
};
MdChipsCtrl.prototype.useOnRemoveExpression = function () {
  this.useOnRemove = !0;
};
MdChipsCtrl.prototype.useOnSelectExpression = function () {
  this.useOnSelect = !0;
};
MdChipsCtrl.prototype.getChipBuffer = function () {
  var a = this.userInputElement
    ? this.userInputNgModelCtrl
      ? this.userInputNgModelCtrl.$viewValue
      : this.userInputElement[0].value
    : this.chipBuffer;
  return angular.isString(a) ? a : "";
};
MdChipsCtrl.prototype.resetChipBuffer = function () {
  this.userInputElement
    ? this.userInputNgModelCtrl
      ? (this.userInputNgModelCtrl.$setViewValue(""), this.userInputNgModelCtrl.$render())
      : (this.userInputElement[0].value = "")
    : (this.chipBuffer = "");
};
MdChipsCtrl.prototype.hasMaxChipsReached = function () {
  angular.isString(this.maxChips) && (this.maxChips = parseInt(this.maxChips, 10) || 0);
  return 0 < this.maxChips && this.items.length >= this.maxChips;
};
MdChipsCtrl.prototype.validateModel = function () {
  this.ngModelCtrl.$setValidity("md-max-chips", !this.hasMaxChipsReached());
  this.ngModelCtrl.$validate();
};
MdChipsCtrl.prototype.updateNgModel = function (a) {
  a || this.validateModel();
  angular.forEach(this.ngModelCtrl.$viewChangeListeners, function (b) {
    try {
      b();
    } catch (d) {
      this.$exceptionHandler(d);
    }
  });
};
MdChipsCtrl.prototype.removeChip = function (a, b) {
  var d = this.items.splice(a, 1);
  this.updateNgModel();
  this.ngModelCtrl.$setDirty();
  var c = angular.isObject(d[0]) ? "" : d[0];
  this.$mdLiveAnnouncer.announce(c + " " + this.removedMessage, "assertive");
  if (d && d.length && this.useOnRemove && this.onRemove) this.onRemove({ $chip: d[0], $index: a, $event: b });
};
MdChipsCtrl.prototype.removeChipAndFocusInput = function (a, b) {
  this.removeChip(a, b);
  if (this.autocompleteCtrl) (this.autocompleteCtrl.hidden = !0), this.$mdUtil.nextTick(this.onFocus.bind(this));
  else this.onFocus();
};
MdChipsCtrl.prototype.selectAndFocusChipSafe = function (a) {
  if (!this.items.length || -1 === a) return this.focusInput();
  if (a >= this.items.length)
    if (this.readonly) a = 0;
    else return this.onFocus();
  a = Math.max(a, 0);
  a = Math.min(a, this.items.length - 1);
  this.selectChip(a);
  this.focusChip(a);
};
MdChipsCtrl.prototype.focusLastChipThenInput = function () {
  var a = this;
  a.shouldFocusLastChip = !1;
  a.focusChip(this.items.length - 1);
  a.$timeout(function () {
    a.focusInput();
  }, a.chipAppendDelay);
};
MdChipsCtrl.prototype.focusInput = function () {
  this.selectChip(-1);
  this.onFocus();
};
MdChipsCtrl.prototype.selectChip = function (a) {
  if (-1 <= a && a <= this.items.length) {
    if (((this.selectedChip = a), this.useOnSelect && this.onSelect)) this.onSelect({ $chip: this.items[a] });
  } else this.$log.warn("Selected Chip index out of bounds; ignoring.");
};
MdChipsCtrl.prototype.selectAndFocusChip = function (a) {
  this.selectChip(a);
  -1 !== a && this.focusChip(a);
};
MdChipsCtrl.prototype.focusChip = function (a) {
  var b = this.$element[0].querySelector('md-chip[index="' + a + '"] .md-chip-content');
  this.ariaTabIndex = a;
  b.focus();
};
MdChipsCtrl.prototype.configureNgModel = function (a) {
  this.ngModelCtrl = a;
  var b = this;
  a.$isEmpty = function (d) {
    return !d || 0 === d.length;
  };
  a.$render = function () {
    b.items = b.ngModelCtrl.$viewValue;
  };
};
MdChipsCtrl.prototype.onFocus = function () {
  var a = this.$element[0].querySelector("input");
  a && a.focus();
  this.resetSelectedChip();
};
MdChipsCtrl.prototype.onInputFocus = function () {
  this.inputHasFocus = !0;
  this.setupInputAria();
  this.resetSelectedChip();
};
MdChipsCtrl.prototype.onInputBlur = function () {
  this.inputHasFocus = !1;
  this.shouldAddOnBlur() && (this.appendChip(this.getChipBuffer().trim()), this.resetChipBuffer());
};
MdChipsCtrl.prototype.configureInput = function (a) {
  var b = a.controller("ngModel"),
    d = this;
  b &&
    (this.deRegister.push(
      this.$scope.$watch(
        function () {
          return b.$touched;
        },
        function (c) {
          c && d.ngModelCtrl.$setTouched();
        }
      )
    ),
    this.deRegister.push(
      this.$scope.$watch(
        function () {
          return b.$dirty;
        },
        function (c) {
          c && d.ngModelCtrl.$setDirty();
        }
      )
    ));
};
MdChipsCtrl.prototype.configureUserInput = function (a) {
  this.userInputElement = a;
  var b = a.controller("ngModel");
  b !== this.ngModelCtrl && (this.userInputNgModelCtrl = b);
  var d = this.$scope,
    c = this;
  a.attr({ tabindex: 0 })
    .on("keydown", function (e) {
      d.$evalAsync(angular.bind(c, c.inputKeydown, e));
    })
    .on("focus", function (e) {
      d.$evalAsync(angular.bind(c, c.onInputFocus, e));
    })
    .on("blur", function (e) {
      d.$evalAsync(angular.bind(c, c.onInputBlur, e));
    });
};
MdChipsCtrl.prototype.configureAutocomplete = function (a) {
  a &&
    ((this.autocompleteCtrl = a),
    this.$element.attr("container-empty-hint") ||
      ((this.containerEmptyHint =
        "Chips container with autocompletion. Enter the text area, type text to search, and then use the up and down arrow keys to select an option. Press enter to add the selected option as a chip."),
      this.setupWrapperAria()),
    a.registerSelectedItemWatcher(
      angular.bind(this, function (b) {
        b && !this.hasMaxChipsReached() && (this.appendChip(b), this.resetChipBuffer());
      })
    ),
    this.$element.find("input").on("focus", angular.bind(this, this.onInputFocus)).on("blur", angular.bind(this, this.onInputBlur)));
};
MdChipsCtrl.prototype.shouldAddOnBlur = function () {
  this.validateModel();
  var a = this.getChipBuffer().trim(),
    b = this.ngModelCtrl.$isEmpty(this.ngModelCtrl.$modelValue) || this.ngModelCtrl.$valid,
    d = this.autocompleteCtrl && !this.autocompleteCtrl.hidden;
  this.userInputNgModelCtrl && (b = b && this.userInputNgModelCtrl.$valid);
  return this.addOnBlur && !this.requireMatch && a && b && !d;
};
MdChipsCtrl.prototype.hasFocus = function () {
  return this.inputHasFocus || 0 <= this.selectedChip;
};
MdChipsCtrl.prototype.contentIdFor = function (a) {
  return this.contentIds[a];
};
MdChips.$inject = "$mdTheming $mdUtil $compile $log $timeout $$mdSvgRegistry".split(" ");
angular.module("material.components.chips").directive("mdChips", MdChips);
function MdChips(a, b, d, c, e, f) {
  function g(l, m) {
    function v(p) {
      if (m.ngModel) return (p = n[0].querySelector(p)) && p.outerHTML;
    }
    var n = m.$mdUserTemplate;
    m.$mdUserTemplate = null;
    var q = v("md-chips>md-chip-template");
    l = b
      .prefixer()
      .buildList("md-chip-remove")
      .map(function (p) {
        return "md-chips>*[" + p + "]";
      })
      .join(",");
    var r = v(l) || h.remove,
      x = q || h.default,
      y = v("md-chips>md-autocomplete") || v("md-chips>input") || h.input,
      k = n.find("md-chip");
    n[0].querySelector("md-chip-template>*[md-chip-remove]") && c.warn("invalid placement of md-chip-remove within md-chip-template.");
    return function (p, t, H, A) {
      b.initOptionalProperties(p, m);
      a(t);
      var w = A[0];
      q && (w.enableChipEdit = !1);
      w.chipContentsTemplate = x;
      w.chipRemoveTemplate = r;
      w.chipInputTemplate = y;
      w.mdCloseIcon = f.mdClose;
      t.attr({ tabindex: -1 })
        .on("focus", function () {
          w.onFocus();
        })
        .on("click", function () {
          if (!w.readonly && -1 === w.selectedChip) w.onFocus();
        });
      m.ngModel &&
        (w.configureNgModel(t.controller("ngModel")),
        H.mdTransformChip && w.useTransformChipExpression(),
        H.mdOnAppend && w.useOnAppendExpression(),
        H.mdOnAdd && w.useOnAddExpression(),
        H.mdOnRemove && w.useOnRemoveExpression(),
        H.mdOnSelect && w.useOnSelectExpression(),
        y !== h.input &&
          p.$watch("$mdChipsCtrl.readonly", function (u) {
            u ||
              b.nextTick(function () {
                if (0 === y.indexOf("<md-autocomplete")) {
                  var z = t.find("md-autocomplete");
                  w.configureAutocomplete(z.controller("mdAutocomplete"));
                }
                w.configureUserInput(t.find("input"));
              });
          }),
        b.nextTick(function () {
          var u = t.find("input");
          u && (w.configureInput(u), u.toggleClass("md-input", !0));
        }));
      if (0 < k.length) {
        var B = d(k.clone())(p.$parent);
        e(function () {
          t.find("md-chips-wrap").prepend(B);
        });
      }
    };
  }
  var h = {
    chips: b.processTemplate(
      '      <md-chips-wrap          id="{{$mdChipsCtrl.wrapperId}}"          tabindex="{{$mdChipsCtrl.readonly ? 0 : -1}}"          ng-keydown="$mdChipsCtrl.chipKeydown($event)"          ng-class="{ \'md-focused\': $mdChipsCtrl.hasFocus(),                       \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly,                      \'md-removable\': $mdChipsCtrl.isRemovable() }"          class="md-chips">        <md-chip ng-repeat="$chip in $mdChipsCtrl.items"            index="{{$index}}"             ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly}">          <div class="md-chip-content"              tabindex="{{$mdChipsCtrl.ariaTabIndex === $index ? 0 : -1}}"              id="{{$mdChipsCtrl.contentIdFor($index)}}"              role="option"              aria-selected="{{$mdChipsCtrl.selectedChip === $index}}"              aria-setsize="{{$mdChipsCtrl.items.length}}"              aria-posinset="{{$index+1}}"              ng-click="!$mdChipsCtrl.readonly && $mdChipsCtrl.focusChip($index)"              aria-label="{{$mdChipsCtrl._isChipObject($chip) ? \'\' : $chip + \'. \'}}{{$mdChipsCtrl.isRemovable() ? \'\' + $mdChipsCtrl.deleteHint : \'\'}}"               ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"              md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"></div>          <div ng-if="$mdChipsCtrl.isRemovable()"               class="md-chip-remove-container"               tabindex="-1"               md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"></div>        </md-chip>        <div class="md-chip-input-container" ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl">          <div md-chip-transclude="$mdChipsCtrl.chipInputTemplate"></div>        </div>      </md-chips-wrap>'
    ),
    input: b.processTemplate(
      '        <input            class="md-input"            tabindex="0"            aria-label="{{$mdChipsCtrl.inputAriaLabel}}"            placeholder="{{$mdChipsCtrl.getPlaceholder()}}"            ng-model="$mdChipsCtrl.chipBuffer"            ng-focus="$mdChipsCtrl.onInputFocus()"            ng-blur="$mdChipsCtrl.onInputBlur()"            ng-keydown="$mdChipsCtrl.inputKeydown($event)">'
    ),
    default: b.processTemplate("      <span>{{$chip}}</span>"),
    remove: b.processTemplate(
      '      <button          class="md-chip-remove"          ng-if="$mdChipsCtrl.isRemovable()"          ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index, $event)"          type="button"          tabindex="-1"          aria-label="{{$mdChipsCtrl.deleteButtonLabel}}{{$mdChipsCtrl._isChipObject($chip) ? \'\' : \' \' + $chip}}">        <md-icon md-svg-src="{{$mdChipsCtrl.mdCloseIcon}}" aria-hidden="true"></md-icon>      </button>'
    )
  };
  return {
    template: function (l, m) {
      m.$mdUserTemplate = l.clone();
      return h.chips;
    },
    require: ["mdChips"],
    restrict: "E",
    controller: "MdChipsCtrl",
    controllerAs: "$mdChipsCtrl",
    bindToController: !0,
    compile: g,
    scope: {
      readonly: "=?readonly",
      removable: "=?mdRemovable",
      placeholder: "@?",
      secondaryPlaceholder: "@?",
      maxChips: "@?mdMaxChips",
      transformChip: "&mdTransformChip",
      onAppend: "&?mdOnAppend",
      onAdd: "&?mdOnAdd",
      onRemove: "&?mdOnRemove",
      addedMessage: "@?mdAddedMessage",
      removedMessage: "@?mdRemovedMessage",
      onSelect: "&?mdOnSelect",
      inputAriaDescribedBy: "@?inputAriaDescribedby",
      inputAriaLabelledBy: "@?inputAriaLabelledby",
      inputAriaLabel: "@?",
      containerHint: "@?",
      containerEmptyHint: "@?",
      deleteHint: "@?",
      deleteButtonLabel: "@?",
      separatorKeys: "=?mdSeparatorKeys",
      requireMatch: "=?mdRequireMatch",
      chipAppendDelayString: "@?mdChipAppendDelay",
      ngChange: "&?"
    }
  };
}
MdContactChipsCtrl.$inject = ["$attrs", "$element", "$timeout"];
angular.module("material.components.chips").controller("MdContactChipsCtrl", MdContactChipsCtrl);
function MdContactChipsCtrl(a, b, d) {
  this.$element = b;
  this.$attrs = a;
  this.$timeout = d;
  this.selectedItem = null;
  this.searchText = "";
  this.deRegister = [];
  this.init();
}
MdContactChipsCtrl.prototype.init = function () {
  var a = this,
    b = this.deRegister,
    d = this.$element;
  this.$timeout(function () {
    b.push(
      d
        .find("md-chips")
        .scope()
        .$watchCollection("$mdChipsCtrl.items", function () {
          a.setupChipsAria();
          a.setupAutocompleteAria();
        })
    );
  });
};
MdContactChipsCtrl.prototype.setupChipsAria = function () {
  var a = this.$element.find("md-chips"),
    b = a.controller("mdChips");
  this.removedMessage && (b.removedMessage = this.removedMessage);
  this.containerHint && (b.containerHint = this.containerHint);
  this.containerEmptyHint && (a.attr("container-empty-hint", this.containerEmptyHint), (b.containerEmptyHint = this.containerEmptyHint));
  this.deleteHint && (b.deleteHint = this.deleteHint);
  this.inputAriaLabel && (b.inputAriaLabel = this.inputAriaLabel);
};
MdContactChipsCtrl.prototype.setupAutocompleteAria = function () {
  var a = this.$element.find("md-chips-wrap").find("md-autocomplete").find("input");
  this.inputAriaDescribedBy && a.attr("aria-describedby", this.inputAriaDescribedBy);
  this.inputAriaLabelledBy && (a.removeAttr("aria-label"), a.attr("aria-labelledby", this.inputAriaLabelledBy));
};
MdContactChipsCtrl.prototype.queryContact = function (a) {
  return this.contactQuery({ $query: a });
};
MdContactChipsCtrl.prototype.inputKeydown = function (a) {
  !this.separatorKeys ||
    0 > this.separatorKeys.indexOf(a.keyCode) ||
    (a.stopPropagation(), a.preventDefault(), (a = angular.element(a.target).controller("mdAutocomplete")), a.select(a.index));
};
MdContactChipsCtrl.prototype.itemName = function (a) {
  return a[this.contactName];
};
MdContactChipsCtrl.prototype.$onDestroy = function () {
  for (var a; (a = this.deRegister.pop()); ) a.call(this);
};
MdContactChips.$inject = ["$mdTheming", "$mdUtil"];
angular.module("material.components.chips").directive("mdContactChips", MdContactChips);
function MdContactChips(a, b) {
  function d(c, e) {
    return function (f, g, h, l) {
      var m = l;
      b.initOptionalProperties(f, e);
      a(g);
      g.attr("tabindex", "-1");
      h.$observe("mdChipAppendDelay", function (v) {
        m.chipAppendDelay = v;
      });
    };
  }
  return {
    template: function () {
      return '      <md-chips class="md-contact-chips"          ng-model="$mdContactChipsCtrl.contacts"          ng-change="$mdContactChipsCtrl.ngChange($mdContactChipsCtrl.contacts)"          md-require-match="$mdContactChipsCtrl.requireMatch"          md-chip-append-delay="{{$mdContactChipsCtrl.chipAppendDelay}}"          md-separator-keys="$mdContactChipsCtrl.separatorKeys"          md-autocomplete-snap>          <md-autocomplete              md-menu-class="md-contact-chips-suggestions"              md-selected-item="$mdContactChipsCtrl.selectedItem"              md-search-text="$mdContactChipsCtrl.searchText"              md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"              md-item-text="$mdContactChipsCtrl.itemName(item)"              md-no-cache="true"              md-min-length="$mdContactChipsCtrl.minLength"              md-autoselect              ng-keydown="$mdContactChipsCtrl.inputKeydown($event)"              placeholder="{{$mdContactChipsCtrl.contacts.length === 0 ?                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">            <div class="md-contact-suggestion">              <img                   ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"                  alt="{{item[$mdContactChipsCtrl.contactName]}}"                  ng-if="item[$mdContactChipsCtrl.contactImage]" />              <span class="md-contact-name" md-highlight-text="$mdContactChipsCtrl.searchText"                    md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">                {{item[$mdContactChipsCtrl.contactName]}}              </span>              <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>            </div>          </md-autocomplete>          <md-chip-template>            <div class="md-contact-avatar">              <img                   ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"                  alt="{{$chip[$mdContactChipsCtrl.contactName]}}"                  ng-if="$chip[$mdContactChipsCtrl.contactImage]" />            </div>            <div class="md-contact-name">              {{$chip[$mdContactChipsCtrl.contactName]}}            </div>          </md-chip-template>      </md-chips>';
    },
    restrict: "E",
    controller: "MdContactChipsCtrl",
    controllerAs: "$mdContactChipsCtrl",
    bindToController: !0,
    compile: d,
    scope: {
      contactQuery: "&mdContacts",
      placeholder: "@?",
      secondaryPlaceholder: "@?",
      contactName: "@mdContactName",
      contactImage: "@mdContactImage",
      contactEmail: "@mdContactEmail",
      contacts: "=ngModel",
      ngChange: "&?",
      requireMatch: "=?mdRequireMatch",
      minLength: "=?mdMinLength",
      highlightFlags: "@?mdHighlightFlags",
      chipAppendDelay: "@?mdChipAppendDelay",
      separatorKeys: "=?mdSeparatorKeys",
      removedMessage: "@?mdRemovedMessage",
      inputAriaDescribedBy: "@?inputAriaDescribedby",
      inputAriaLabelledBy: "@?inputAriaLabelledby",
      inputAriaLabel: "@?",
      containerHint: "@?",
      containerEmptyHint: "@?",
      deleteHint: "@?"
    }
  };
}
ngmaterial.components.chips = angular.module("material.components.chips");
(function () {
  function a(e, f, g) {
    function h(r, x) {
      try {
        x && r.css(v(x));
      } catch (y) {
        g.error(y.message);
      }
    }
    function l(r) {
      r = q(r);
      return m(r);
    }
    function m(r, x) {
      x = x || !1;
      var y = e.PALETTES[r.palette][r.hue];
      y = x ? y.contrast : y.value;
      return f.supplant("rgba({0}, {1}, {2}, {3})", [y[0], y[1], y[2], y[3] || r.opacity]);
    }
    function v(r) {
      var x = {},
        y = r.hasOwnProperty("color");
      angular.forEach(r, function (k, p) {
        k = q(k);
        var t = -1 < p.indexOf("background");
        x[p] = m(k);
        t && !y && (x.color = m(k, !0));
      });
      return x;
    }
    function n(r) {
      return angular.isDefined(e.THEMES[r.split("-")[0]]);
    }
    function q(r) {
      r = r.split("-");
      var x = angular.isDefined(e.THEMES[r[0]]);
      x = x ? r.splice(0, 1)[0] : e.defaultTheme();
      var y = r,
        k = x,
        p = 1 < y.length && -1 !== c.indexOf(y[1]);
      var t = y[0].replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      p && (t = y[0] + "-" + y.splice(1, 1));
      if (-1 === c.indexOf(t)) {
        y = e.THEMES[k].colors[t];
        if (!y) throw Error(f.supplant("mdColors: couldn't find '{palette}' in the palettes.", { palette: t }));
        t = y.name;
      }
      y = r;
      k = e.THEMES[x].colors;
      if ("hue" === y[1]) {
        p = parseInt(y.splice(2, 1)[0], 10);
        if (1 > p || 3 < p)
          throw Error(
            f.supplant("mdColors: 'hue-{hueNumber}' is not a valid hue, can be only 'hue-1', 'hue-2' and 'hue-3'", { hueNumber: p })
          );
        y[1] = "hue-" + p;
        if (!(y[0] in k))
          throw Error(
            f.supplant("mdColors: 'hue-x' can only be used with [{availableThemes}], but was used with '{usedTheme}'", {
              availableThemes: Object.keys(k).join(", "),
              usedTheme: y[0]
            })
          );
        y = k[y[0]].hues[y[1]];
      } else y = y[1] || k[y[0] in k ? y[0] : "primary"].hues["default"];
      return { theme: x, palette: t, hue: y, opacity: r[2] || 1 };
    }
    c = c || Object.keys(e.PALETTES);
    return { applyThemeColors: h, getThemeColor: l, hasTheme: n };
  }
  function b(e, f, g, h) {
    return {
      restrict: "A",
      require: ["^?mdTheme"],
      compile: function (l, m) {
        function v() {
          var q = m.mdColors,
            r = -1 < q.indexOf("::"),
            x = r ? !0 : d.test(m.mdColors);
          m.mdColors = q.replace("::", "");
          q = angular.isDefined(m.mdColorsWatch);
          return r || x ? !1 : q ? f.parseAttributeBoolean(m.mdColorsWatch) : !0;
        }
        var n = v();
        return function (q, r, x, y) {
          var k = y[0],
            p = {},
            t = function (w) {
              "string" !== typeof w && (w = "");
              x.mdColors || (x.mdColors = "{}");
              var B = h(x.mdColors)(q);
              k &&
                Object.keys(B).forEach(function (u) {
                  var z = B[u];
                  e.hasTheme(z) || (B[u] = (w || k.$mdTheme) + "-" + z);
                });
              H(B);
              return B;
            },
            H = function (w) {
              if (!angular.equals(w, p)) {
                var B = Object.keys(p);
                p.background && !B.color && B.push("color");
                B.forEach(function (u) {
                  r.css(u, "");
                });
              }
              p = w;
            },
            A = angular.noop;
          k &&
            (A = k.registerChanges(function (w) {
              e.applyThemeColors(r, t(w));
            }));
          q.$on("$destroy", function () {
            A();
          });
          try {
            n ? q.$watch(t, angular.bind(this, e.applyThemeColors, r), !0) : e.applyThemeColors(r, t());
          } catch (w) {
            g.error(w.message);
          }
        };
      }
    };
  }
  b.$inject = ["$mdColors", "$mdUtil", "$log", "$parse"];
  a.$inject = ["$mdTheming", "$mdUtil", "$log"];
  var d = /^{((\s|,)*?["'a-zA-Z-]+?\s*?:\s*?('|")[a-zA-Z0-9-.]*('|"))+\s*}$/,
    c = null;
  angular.module("material.components.colors", ["material.core"]).directive("mdColors", b).service("$mdColors", a);
})();
ngmaterial.components.colors = angular.module("material.components.colors");
mdContentDirective.$inject = ["$mdTheming"];
angular.module("material.components.content", ["material.core"]).directive("mdContent", mdContentDirective);
function mdContentDirective(a) {
  function b(d, c) {
    this.$scope = d;
    this.$element = c;
  }
  return {
    restrict: "E",
    controller: ["$scope", "$element", b],
    link: function (d, c) {
      c.addClass("_md");
      a(c);
      d.$broadcast("$mdContentLoaded", c);
      iosScrollFix(c[0]);
    }
  };
}
function iosScrollFix(a) {
  angular.element(a).on("$md.pressdown", function (b) {
    "t" !== b.pointer.type ||
      b.$materialScrollFixed ||
      ((b.$materialScrollFixed = !0),
      0 === a.scrollTop ? (a.scrollTop = 1) : a.scrollHeight === a.scrollTop + a.offsetHeight && --a.scrollTop);
  });
}
ngmaterial.components.content = angular.module("material.components.content");
angular.module("material.components.datepicker", ["material.core", "material.components.icon", "material.components.virtualRepeat"]);
(function () {
  function a() {
    return {
      template: function (e, f) {
        e = f.hasOwnProperty("ngIf") ? "" : 'ng-if="calendarCtrl.isInitialized"';
        return (e =
          '<div ng-switch="calendarCtrl.currentView" ' +
          e +
          '><md-calendar-year ng-switch-when="year"></md-calendar-year><md-calendar-month ng-switch-default></md-calendar-month></div>');
      },
      scope: {
        minDate: "=mdMinDate",
        maxDate: "=mdMaxDate",
        dateFilter: "=mdDateFilter",
        _mode: "@mdMode",
        _currentView: "@mdCurrentView"
      },
      require: ["ngModel", "mdCalendar"],
      controller: b,
      controllerAs: "calendarCtrl",
      bindToController: !0,
      link: function (e, f, g, h) {
        e = h[0];
        h = h[1];
        h.configureNgModel(e);
      }
    };
  }
  function b(e, f, g, h, l, m, v, n, q) {
    m(e);
    this.$element = e;
    this.$scope = f;
    this.dateUtil = g;
    this.$mdUtil = h;
    this.keyCode = l.KEY_CODE;
    this.$$rAF = v;
    this.$mdDateLocale = q;
    this.today = this.dateUtil.createDateAtMidnight();
    this.ngModelCtrl = null;
    this.SELECTED_DATE_CLASS = "md-calendar-selected-date";
    this.TODAY_CLASS = "md-calendar-date-today";
    this.FOCUSED_DATE_CLASS = "md-focus";
    this.id = d++;
    this.lastRenderableDate = this.firstRenderableDate = this.selectedDate = this.displayDate = null;
    this.isInitialized = !1;
    this.scrollbarWidth = this.width = 0;
    n.tabindex || e.attr("tabindex", "-1");
    var r = angular.bind(this, this.handleKeyEvent);
    var x = e.parent().hasClass("md-datepicker-calendar") ? angular.element(document.body) : e;
    x.on("keydown", r);
    f.$on("$destroy", function () {
      x.off("keydown", r);
    });
    1 === angular.version.major && 4 >= angular.version.minor && this.$onInit();
  }
  b.$inject = "$element $scope $$mdDateUtil $mdUtil $mdConstant $mdTheming $$rAF $attrs $mdDateLocale".split(" ");
  angular.module("material.components.datepicker").directive("mdCalendar", a);
  var d = 0,
    c = { day: "month", month: "year" };
  b.prototype.$onInit = function () {
    this._mode && c.hasOwnProperty(this._mode)
      ? ((this.currentView = c[this._mode]), (this.mode = this._mode))
      : ((this.currentView = this._currentView || "month"), (this.mode = null));
    var e = this.$mdDateLocale;
    this.firstRenderableDate = this.minDate && this.minDate > e.firstRenderableDate ? this.minDate : e.firstRenderableDate;
    this.lastRenderableDate = this.maxDate && this.maxDate < e.lastRenderableDate ? this.maxDate : e.lastRenderableDate;
  };
  b.prototype.configureNgModel = function (e) {
    var f = this;
    f.ngModelCtrl = e;
    f.$mdUtil.nextTick(function () {
      f.isInitialized = !0;
    });
    e.$render = function () {
      var g = this.$viewValue;
      f.$scope.$broadcast("md-calendar-parent-changed", g);
      f.selectedDate || (f.selectedDate = g);
      f.displayDate || (f.displayDate = f.selectedDate || f.today);
    };
  };
  b.prototype.setNgModelValue = function (e) {
    e = this.dateUtil.createDateAtMidnight(e);
    this.focus(e);
    this.$scope.$emit("md-calendar-change", e);
    this.ngModelCtrl.$setViewValue(e);
    this.ngModelCtrl.$render();
    return e;
  };
  b.prototype.setCurrentView = function (e, f) {
    var g = this;
    g.$mdUtil.nextTick(function () {
      g.currentView = e;
      f && (g.displayDate = angular.isDate(f) ? f : new Date(f));
    });
  };
  b.prototype.focus = function (e) {
    if (this.dateUtil.isValidDate(e)) {
      var f = this.$element[0].querySelector("." + this.FOCUSED_DATE_CLASS);
      f && f.classList.remove(this.FOCUSED_DATE_CLASS);
      f = this.getDateId(e, this.currentView);
      if ((f = document.getElementById(f))) f.classList.add(this.FOCUSED_DATE_CLASS), f.focus(), (this.displayDate = e);
    } else (e = this.$element[0].querySelector("[ng-switch]")) && e.focus();
  };
  b.prototype.changeSelectedDate = function (e) {
    var f = this.SELECTED_DATE_CLASS,
      g = this.$element[0].querySelector("." + f);
    g && (g.classList.remove(f), g.setAttribute("aria-selected", "false"));
    e &&
      (g = document.getElementById(this.getDateId(e, this.currentView))) &&
      (g.classList.add(f), g.setAttribute("aria-selected", "true"));
    this.selectedDate = e;
  };
  b.prototype.getActionFromKeyEvent = function (e) {
    var f = this.keyCode;
    switch (e.which) {
      case f.ENTER:
        return "select";
      case f.RIGHT_ARROW:
        return "move-right";
      case f.LEFT_ARROW:
        return "move-left";
      case f.DOWN_ARROW:
        return e.metaKey ? "move-page-down" : "move-row-down";
      case f.UP_ARROW:
        return e.metaKey ? "move-page-up" : "move-row-up";
      case f.PAGE_DOWN:
        return "move-page-down";
      case f.PAGE_UP:
        return "move-page-up";
      case f.HOME:
        return "start";
      case f.END:
        return "end";
      default:
        return null;
    }
  };
  b.prototype.handleKeyEvent = function (e) {
    var f = this;
    this.$scope.$apply(function () {
      if (e.which == f.keyCode.ESCAPE || e.which == f.keyCode.TAB)
        f.$scope.$emit("md-calendar-close"), e.which == f.keyCode.TAB && e.preventDefault();
      else {
        var g = f.getActionFromKeyEvent(e);
        g && (e.preventDefault(), e.stopPropagation(), f.$scope.$broadcast("md-calendar-parent-action", g));
      }
    });
  };
  b.prototype.hideVerticalScrollbar = function (e) {
    function f() {
      var m = g.width || 340,
        v = g.scrollbarWidth,
        n = e.calendarScroller;
      l.style.width = m + "px";
      n.style.width = m + v + "px";
      n.style.paddingRight = v + "px";
    }
    var g = this,
      h = e.$element[0],
      l = h.querySelector(".md-calendar-scroll-mask");
    0 < g.width
      ? f()
      : g.$$rAF(function () {
          var m = e.calendarScroller;
          g.scrollbarWidth = m.offsetWidth - m.clientWidth;
          g.width = h.querySelector("table").offsetWidth;
          f();
        });
  };
  b.prototype.getDateId = function (e, f) {
    if (!f) throw Error("A namespace for the date id has to be specified.");
    return ["md", this.id, f, e.getFullYear(), e.getMonth(), e.getDate()].join("-");
  };
  b.prototype.updateVirtualRepeat = function () {
    var e = this.$scope,
      f = e.$on("$md-resize-enable", function () {
        e.$$phase || e.$apply();
        f();
      });
  };
})();
(function () {
  function a() {
    return {
      template:
        '<table aria-hidden="true" class="md-calendar-day-header"><thead></thead></table><div class="md-calendar-scroll-mask"><md-virtual-repeat-container class="md-calendar-scroll-container" md-offset-size="-220"><table role="grid" tabindex="0" class="md-calendar" aria-readonly="true"><tbody md-calendar-month-body role="rowgroup" md-virtual-repeat="i in monthCtrl.items" md-month-offset="$index" class="md-calendar-month" md-start-index="monthCtrl.getSelectedMonthIndex()" md-item-size="265"><tr aria-hidden="true" md-force-height="\'265px\'"></tr></tbody></table></md-virtual-repeat-container></div>',
      require: ["^^mdCalendar", "mdCalendarMonth"],
      controller: b,
      controllerAs: "monthCtrl",
      bindToController: !0,
      link: function (d, c, e, f) {
        d = f[0];
        f = f[1];
        f.initialize(d);
      }
    };
  }
  function b(d, c, e, f, g, h) {
    this.$element = d;
    this.$scope = c;
    this.$animate = e;
    this.$q = f;
    this.dateUtil = g;
    this.dateLocale = h;
    this.calendarScroller = d[0].querySelector(".md-virtual-repeat-scroller");
    this.isMonthTransitionInProgress = this.isInitialized = !1;
    var l = this;
    this.cellClickHandler = function () {
      var m = g.getTimestampFromNode(this);
      l.$scope.$apply(function () {
        l.calendarCtrl.setNgModelValue(m);
      });
    };
    this.headerClickHandler = function () {
      l.calendarCtrl.setCurrentView("year", g.getTimestampFromNode(this));
    };
  }
  b.$inject = "$element $scope $animate $q $$mdDateUtil $mdDateLocale".split(" ");
  angular.module("material.components.datepicker").directive("mdCalendarMonth", a);
  b.prototype.initialize = function (d) {
    this.items = { length: this.dateUtil.getMonthDistance(d.firstRenderableDate, d.lastRenderableDate) + 2 };
    this.calendarCtrl = d;
    this.attachScopeListeners();
    d.updateVirtualRepeat();
    d.ngModelCtrl && d.ngModelCtrl.$render();
  };
  b.prototype.getSelectedMonthIndex = function () {
    var d = this.calendarCtrl;
    return this.dateUtil.getMonthDistance(d.firstRenderableDate, d.displayDate || d.selectedDate || d.today);
  };
  b.prototype.changeDisplayDate = function (d) {
    if (!this.isInitialized)
      return this.buildWeekHeader(), this.calendarCtrl.hideVerticalScrollbar(this), (this.isInitialized = !0), this.$q.when();
    if (!this.dateUtil.isValidDate(d) || this.isMonthTransitionInProgress) return this.$q.when();
    this.isMonthTransitionInProgress = !0;
    var c = this.animateDateChange(d);
    this.calendarCtrl.displayDate = d;
    var e = this;
    c.then(function () {
      e.isMonthTransitionInProgress = !1;
    });
    return c;
  };
  b.prototype.animateDateChange = function (d) {
    this.dateUtil.isValidDate(d) &&
      ((d = this.dateUtil.getMonthDistance(this.calendarCtrl.firstRenderableDate, d)), (this.calendarScroller.scrollTop = 265 * d));
    return this.$q.when();
  };
  b.prototype.buildWeekHeader = function () {
    for (var d = this.dateLocale.firstDayOfWeek, c = this.dateLocale.shortDays, e = document.createElement("tr"), f = 0; 7 > f; f++) {
      var g = document.createElement("th");
      g.textContent = c[(f + d) % 7];
      e.appendChild(g);
    }
    this.$element.find("thead").append(e);
  };
  b.prototype.attachScopeListeners = function () {
    var d = this;
    d.$scope.$on("md-calendar-parent-changed", function (c, e) {
      d.calendarCtrl.changeSelectedDate(e);
      d.changeDisplayDate(e);
    });
    d.$scope.$on("md-calendar-parent-action", angular.bind(this, this.handleKeyEvent));
  };
  b.prototype.handleKeyEvent = function (d, c) {
    var e = this.calendarCtrl;
    d = e.displayDate;
    if ("select" === c) e.setNgModelValue(d);
    else {
      var f = null,
        g = this.dateUtil;
      switch (c) {
        case "move-right":
          f = g.incrementDays(d, 1);
          break;
        case "move-left":
          f = g.incrementDays(d, -1);
          break;
        case "move-page-down":
          f = g.incrementMonths(d, 1);
          break;
        case "move-page-up":
          f = g.incrementMonths(d, -1);
          break;
        case "move-row-down":
          f = g.incrementDays(d, 7);
          break;
        case "move-row-up":
          f = g.incrementDays(d, -7);
          break;
        case "start":
          f = g.getFirstDateOfMonth(d);
          break;
        case "end":
          f = g.getLastDateOfMonth(d);
      }
      f &&
        ((f = this.dateUtil.clampDate(f, e.minDate, e.maxDate)),
        this.changeDisplayDate(f).then(function () {
          e.focus(f);
        }));
    }
  };
})();
(function () {
  function a(d, c) {
    var e = d('<md-icon md-svg-src="' + c.mdTabsArrow + '"></md-icon>')({})[0];
    return {
      require: ["^^mdCalendar", "^^mdCalendarMonth", "mdCalendarMonthBody"],
      scope: { offset: "=mdMonthOffset" },
      controller: b,
      controllerAs: "mdMonthBodyCtrl",
      bindToController: !0,
      link: function (f, g, h, l) {
        g = l[0];
        h = l[1];
        var m = l[2];
        m.calendarCtrl = g;
        m.monthCtrl = h;
        m.arrowIcon = e.cloneNode(!0);
        f.$watch(
          function () {
            return m.offset;
          },
          function (v) {
            angular.isNumber(v) && m.generateContent();
          }
        );
      }
    };
  }
  function b(d, c, e) {
    this.$element = d;
    this.dateUtil = c;
    this.dateLocale = e;
    this.focusAfterAppend = this.offset = this.calendarCtrl = this.monthCtrl = null;
  }
  a.$inject = ["$compile", "$$mdSvgRegistry"];
  b.$inject = ["$element", "$$mdDateUtil", "$mdDateLocale"];
  angular.module("material.components.datepicker").directive("mdCalendarMonthBody", a);
  b.prototype.generateContent = function () {
    var d = this.dateUtil.incrementMonths(this.calendarCtrl.firstRenderableDate, this.offset);
    this.$element.empty().append(this.buildCalendarForMonth(d));
    this.focusAfterAppend &&
      (this.focusAfterAppend.classList.add(this.calendarCtrl.FOCUSED_DATE_CLASS),
      this.focusAfterAppend.focus(),
      (this.focusAfterAppend = null));
  };
  b.prototype.buildDateCell = function (d) {
    var c = this.monthCtrl,
      e = this.calendarCtrl,
      f = document.createElement("td");
    f.tabIndex = -1;
    f.classList.add("md-calendar-date");
    f.setAttribute("role", "gridcell");
    if (d) {
      f.setAttribute("tabindex", "-1");
      f.setAttribute("aria-label", this.dateLocale.longDateFormatter(d));
      f.id = e.getDateId(d, "month");
      f.setAttribute("data-timestamp", d.getTime());
      this.dateUtil.isSameDay(d, e.today) && f.classList.add(e.TODAY_CLASS);
      this.dateUtil.isValidDate(e.selectedDate) &&
        this.dateUtil.isSameDay(d, e.selectedDate) &&
        (f.classList.add(e.SELECTED_DATE_CLASS), f.setAttribute("aria-selected", "true"));
      var g = this.dateLocale.dates[d.getDate()];
      if (this.isDateEnabled(d)) {
        var h = document.createElement("span");
        h.classList.add("md-calendar-date-selection-indicator");
        h.textContent = g;
        f.appendChild(h);
        f.addEventListener("click", c.cellClickHandler);
        e.displayDate && this.dateUtil.isSameDay(d, e.displayDate) && (this.focusAfterAppend = f);
      } else f.classList.add("md-calendar-date-disabled"), (f.textContent = g);
    }
    return f;
  };
  b.prototype.isDateEnabled = function (d) {
    return (
      this.dateUtil.isDateWithinRange(d, this.calendarCtrl.minDate, this.calendarCtrl.maxDate) &&
      (!angular.isFunction(this.calendarCtrl.dateFilter) || this.calendarCtrl.dateFilter(d))
    );
  };
  b.prototype.buildDateRow = function (d) {
    var c = document.createElement("tr");
    c.setAttribute("role", "row");
    c.setAttribute("aria-label", this.dateLocale.weekNumberFormatter(d));
    return c;
  };
  b.prototype.buildCalendarForMonth = function (d) {
    var c = this.dateUtil.isValidDate(d) ? d : new Date(),
      e = this.dateUtil.getFirstDateOfMonth(c),
      f = this.getLocaleDay_(e),
      g = this.dateUtil.getNumberOfDaysInMonth(c);
    d = document.createDocumentFragment();
    var h = 1,
      l = this.buildDateRow(h);
    d.appendChild(l);
    var m = this.offset === this.monthCtrl.items.length - 1,
      v = 0,
      n = document.createElement("td"),
      q = document.createElement("span"),
      r = this.calendarCtrl;
    q.textContent = this.dateLocale.monthHeaderFormatter(c);
    n.appendChild(q);
    n.classList.add("md-calendar-month-label");
    r.maxDate && e > r.maxDate
      ? n.classList.add("md-calendar-month-label-disabled")
      : r.mode ||
        (n.addEventListener("click", this.monthCtrl.headerClickHandler),
        n.setAttribute("data-timestamp", e.getTime()),
        n.setAttribute("aria-label", this.dateLocale.monthFormatter(c)),
        n.classList.add("md-calendar-label-clickable"),
        n.appendChild(this.arrowIcon.cloneNode(!0)));
    if (2 >= f) {
      if ((n.setAttribute("colspan", "7"), (c = this.buildDateRow()), c.appendChild(n), d.insertBefore(c, l), m)) return d;
    } else (v = 3), n.setAttribute("colspan", "3"), l.appendChild(n);
    for (; v < f; v++) l.appendChild(this.buildDateCell());
    for (v = 1; v <= g; v++) {
      if (7 === f) {
        if (m) return d;
        f = 0;
        h++;
        l = this.buildDateRow(h);
        d.appendChild(l);
      }
      e.setDate(v);
      n = this.buildDateCell(e);
      l.appendChild(n);
      f++;
    }
    for (; 7 > l.childNodes.length; ) l.appendChild(this.buildDateCell());
    for (; 6 > d.childNodes.length; ) {
      g = this.buildDateRow();
      for (h = 0; 7 > h; h++) g.appendChild(this.buildDateCell());
      d.appendChild(g);
    }
    return d;
  };
  b.prototype.getLocaleDay_ = function (d) {
    return (d.getDay() + (7 - this.dateLocale.firstDayOfWeek)) % 7;
  };
})();
(function () {
  function a() {
    return {
      template:
        '<div class="md-calendar-scroll-mask"><md-virtual-repeat-container class="md-calendar-scroll-container"><table role="grid" tabindex="0" class="md-calendar" aria-readonly="true"><tbody md-calendar-year-body role="rowgroup" md-virtual-repeat="i in yearCtrl.items" md-year-offset="$index" class="md-calendar-year" md-start-index="yearCtrl.getFocusedYearIndex()" md-item-size="' +
        d +
        '"><tr aria-hidden="true" md-force-height="\'' +
        d +
        "px'\"></tr></tbody></table></md-virtual-repeat-container></div>",
      require: ["^^mdCalendar", "mdCalendarYear"],
      controller: b,
      controllerAs: "yearCtrl",
      bindToController: !0,
      link: function (c, e, f, g) {
        c = g[0];
        g = g[1];
        g.initialize(c);
      }
    };
  }
  function b(c, e, f, g, h, l) {
    this.$element = c;
    this.$scope = e;
    this.$animate = f;
    this.$q = g;
    this.dateUtil = h;
    this.calendarScroller = c[0].querySelector(".md-virtual-repeat-scroller");
    this.isMonthTransitionInProgress = this.isInitialized = !1;
    this.$mdUtil = l;
    var m = this;
    this.cellClickHandler = function () {
      m.onTimestampSelected(h.getTimestampFromNode(this));
    };
  }
  b.$inject = "$element $scope $animate $q $$mdDateUtil $mdUtil".split(" ");
  angular.module("material.components.datepicker").directive("mdCalendarYear", a);
  var d = 88;
  b.prototype.initialize = function (c) {
    this.items = { length: this.dateUtil.getYearDistance(c.firstRenderableDate, c.lastRenderableDate) + 1 };
    this.calendarCtrl = c;
    this.attachScopeListeners();
    c.updateVirtualRepeat();
    c.ngModelCtrl && c.ngModelCtrl.$render();
  };
  b.prototype.getFocusedYearIndex = function () {
    var c = this.calendarCtrl;
    return this.dateUtil.getYearDistance(c.firstRenderableDate, c.displayDate || c.selectedDate || c.today);
  };
  b.prototype.changeDate = function (c) {
    if (!this.isInitialized) return this.calendarCtrl.hideVerticalScrollbar(this), (this.isInitialized = !0), this.$q.when();
    if (this.dateUtil.isValidDate(c) && !this.isMonthTransitionInProgress) {
      var e = this,
        f = this.animateDateChange(c);
      e.isMonthTransitionInProgress = !0;
      e.calendarCtrl.displayDate = c;
      return f.then(function () {
        e.isMonthTransitionInProgress = !1;
      });
    }
  };
  b.prototype.animateDateChange = function (c) {
    this.dateUtil.isValidDate(c) &&
      ((c = this.dateUtil.getYearDistance(this.calendarCtrl.firstRenderableDate, c)), (this.calendarScroller.scrollTop = c * d));
    return this.$q.when();
  };
  b.prototype.handleKeyEvent = function (c, e) {
    var f = this,
      g = f.calendarCtrl,
      h = g.displayDate;
    if ("select" === e)
      f.changeDate(h).then(function () {
        f.onTimestampSelected(h);
      });
    else {
      var l = null;
      c = f.dateUtil;
      switch (e) {
        case "move-right":
          l = c.incrementMonths(h, 1);
          break;
        case "move-left":
          l = c.incrementMonths(h, -1);
          break;
        case "move-row-down":
          l = c.incrementMonths(h, 6);
          break;
        case "move-row-up":
          l = c.incrementMonths(h, -6);
      }
      if (l) {
        e = g.minDate ? c.getFirstDateOfMonth(g.minDate) : null;
        var m = g.maxDate ? c.getFirstDateOfMonth(g.maxDate) : null;
        l = c.getFirstDateOfMonth(f.dateUtil.clampDate(l, e, m));
        f.changeDate(l).then(function () {
          g.focus(l);
        });
      }
    }
  };
  b.prototype.attachScopeListeners = function () {
    var c = this;
    c.$scope.$on("md-calendar-parent-changed", function (e, f) {
      c.calendarCtrl.changeSelectedDate(f ? c.dateUtil.getFirstDateOfMonth(f) : f);
      c.changeDate(f);
    });
    c.$scope.$on("md-calendar-parent-action", angular.bind(c, c.handleKeyEvent));
  };
  b.prototype.onTimestampSelected = function (c) {
    var e = this.calendarCtrl;
    e.mode
      ? this.$mdUtil.nextTick(function () {
          e.setNgModelValue(c);
        })
      : e.setCurrentView("month", c);
  };
})();
(function () {
  function a() {
    return {
      require: ["^^mdCalendar", "^^mdCalendarYear", "mdCalendarYearBody"],
      scope: { offset: "=mdYearOffset" },
      controller: b,
      controllerAs: "mdYearBodyCtrl",
      bindToController: !0,
      link: function (d, c, e, f) {
        c = f[0];
        e = f[1];
        var g = f[2];
        g.calendarCtrl = c;
        g.yearCtrl = e;
        d.$watch(
          function () {
            return g.offset;
          },
          function (h) {
            angular.isNumber(h) && g.generateContent();
          }
        );
      }
    };
  }
  function b(d, c, e) {
    this.$element = d;
    this.dateUtil = c;
    this.dateLocale = e;
    this.focusAfterAppend = this.offset = this.yearCtrl = this.calendarCtrl = null;
  }
  b.$inject = ["$element", "$$mdDateUtil", "$mdDateLocale"];
  angular.module("material.components.datepicker").directive("mdCalendarYearBody", a);
  b.prototype.generateContent = function () {
    var d = this.dateUtil.incrementYears(this.calendarCtrl.firstRenderableDate, this.offset);
    this.$element.empty().append(this.buildCalendarForYear(d));
    this.focusAfterAppend &&
      (this.focusAfterAppend.classList.add(this.calendarCtrl.FOCUSED_DATE_CLASS),
      this.focusAfterAppend.focus(),
      (this.focusAfterAppend = null));
  };
  b.prototype.buildMonthCell = function (d, c) {
    var e = this.calendarCtrl,
      f = this.yearCtrl,
      g = this.buildBlankCell();
    d = new Date(d, c, 1);
    g.setAttribute("aria-label", this.dateLocale.monthFormatter(d));
    g.id = e.getDateId(d, "year");
    g.setAttribute("data-timestamp", String(d.getTime()));
    this.dateUtil.isSameMonthAndYear(d, e.today) && g.classList.add(e.TODAY_CLASS);
    this.dateUtil.isValidDate(e.selectedDate) &&
      this.dateUtil.isSameMonthAndYear(d, e.selectedDate) &&
      (g.classList.add(e.SELECTED_DATE_CLASS), g.setAttribute("aria-selected", "true"));
    c = this.dateLocale.shortMonths[c];
    if (
      !this.dateUtil.isMonthWithinRange(d, e.minDate, e.maxDate) ||
      (angular.isFunction(this.calendarCtrl.dateFilter) && !this.calendarCtrl.dateFilter(d))
    )
      g.classList.add("md-calendar-date-disabled"), (g.textContent = c);
    else {
      var h = document.createElement("span");
      h.classList.add("md-calendar-date-selection-indicator");
      h.textContent = c;
      g.appendChild(h);
      g.addEventListener("click", f.cellClickHandler);
      e.displayDate && this.dateUtil.isSameMonthAndYear(d, e.displayDate) && (this.focusAfterAppend = g);
    }
    return g;
  };
  b.prototype.buildBlankCell = function () {
    var d = document.createElement("td");
    d.tabIndex = -1;
    d.classList.add("md-calendar-date");
    d.setAttribute("role", "gridcell");
    d.setAttribute("tabindex", "-1");
    return d;
  };
  b.prototype.buildCalendarForYear = function (d) {
    d = d.getFullYear();
    var c = document.createDocumentFragment(),
      e = document.createElement("tr");
    var f = document.createElement("td");
    f.className = "md-calendar-month-label";
    f.textContent = d;
    e.appendChild(f);
    for (f = 0; 6 > f; f++) e.appendChild(this.buildMonthCell(d, f));
    c.appendChild(e);
    e = document.createElement("tr");
    e.appendChild(this.buildBlankCell());
    for (f = 6; 12 > f; f++) e.appendChild(this.buildMonthCell(d, f));
    c.appendChild(e);
    return c;
  };
})();
angular.module("material.components.datepicker").config([
  "$provide",
  function (a) {
    function b() {
      this.dates = this.shortDays = this.days = this.shortMonths = this.months = null;
      this.firstDayOfWeek = 0;
      this.isDateComplete =
        this.longDateFormatter =
        this.weekNumberFormatter =
        this.monthHeaderFormatter =
        this.parseDate =
        this.formatDate =
          null;
      this.msgOpenCalendar = this.msgCalendar = "";
    }
    b.prototype.$get = function (d, c) {
      function e(k, p) {
        if (!k) return "";
        var t = k.toLocaleTimeString(),
          H = k;
        0 !== k.getHours() ||
          (-1 === t.indexOf("11:") && -1 === t.indexOf("23:")) ||
          (H = new Date(k.getFullYear(), k.getMonth(), k.getDate(), 1, 0, 0));
        return c("date")(H, "M/d/yyyy", p);
      }
      function f(k) {
        return new Date(k);
      }
      function g(k) {
        k = k.trim();
        var p = /^(([a-zA-Z]{3,}|[0-9]{1,4})([ .,]+|[/-])){2}([a-zA-Z]{3,}|[0-9]{1,4})$/;
        return p.test(k);
      }
      function h(k) {
        return y.shortMonths[k.getMonth()] + " " + k.getFullYear();
      }
      function l(k) {
        return y.months[k.getMonth()] + " " + k.getFullYear();
      }
      function m(k) {
        return "Week " + k;
      }
      function v(k) {
        return [y.days[k.getDay()], y.months[k.getMonth()], y.dates[k.getDate()], k.getFullYear()].join(" ");
      }
      for (
        var n = d.DATETIME_FORMATS.SHORTDAY.map(function (k) {
            return k.substring(0, 1);
          }),
          q = Array(32),
          r = 1;
        31 >= r;
        r++
      )
        q[r] = r;
      r = new Date(1880, 0, 1);
      var x = new Date(r.getFullYear() + 250, 0, 1),
        y = {
          months: this.months || d.DATETIME_FORMATS.MONTH,
          shortMonths: this.shortMonths || d.DATETIME_FORMATS.SHORTMONTH,
          days: this.days || d.DATETIME_FORMATS.DAY,
          shortDays: this.shortDays || n,
          dates: this.dates || q,
          firstDayOfWeek: this.firstDayOfWeek || 0,
          formatDate: this.formatDate || e,
          parseDate: this.parseDate || f,
          isDateComplete: this.isDateComplete || g,
          monthHeaderFormatter: this.monthHeaderFormatter || h,
          monthFormatter: this.monthFormatter || l,
          weekNumberFormatter: this.weekNumberFormatter || m,
          longDateFormatter: this.longDateFormatter || v,
          msgCalendar: this.msgCalendar || "Calendar",
          msgOpenCalendar: this.msgOpenCalendar || "Open calendar",
          firstRenderableDate: this.firstRenderableDate || r,
          lastRenderableDate: this.lastRenderableDate || x
        };
      return y;
    };
    b.prototype.$get.$inject = ["$locale", "$filter"];
    a.provider("$mdDateLocale", new b());
  }
]);
angular.module("material.components.datepicker").factory("$$mdDateUtil", function () {
  function a(u) {
    return new Date(u.getFullYear(), u.getMonth(), 1);
  }
  function b(u) {
    return new Date(u.getFullYear(), u.getMonth() + 1, 0).getDate();
  }
  function d(u) {
    return new Date(u.getFullYear(), u.getMonth() + 1, 1);
  }
  function c(u) {
    return new Date(u.getFullYear(), u.getMonth() - 1, 1);
  }
  function e(u, z) {
    return u.getFullYear() === z.getFullYear() && u.getMonth() === z.getMonth();
  }
  function f(u, z) {
    return u.getDate() == z.getDate() && e(u, z);
  }
  function g(u, z) {
    u = d(u);
    return e(u, z);
  }
  function h(u, z) {
    u = c(u);
    return e(z, u);
  }
  function l(u, z) {
    return k((u.getTime() + z.getTime()) / 2);
  }
  function m(u) {
    var z = a(u);
    return Math.floor((z.getDay() + u.getDate() - 1) / 7);
  }
  function v(u, z) {
    return new Date(u.getFullYear(), u.getMonth(), u.getDate() + z);
  }
  function n(u, z) {
    z = new Date(u.getFullYear(), u.getMonth() + z, 1);
    var D = b(z);
    D < u.getDate() ? z.setDate(D) : z.setDate(u.getDate());
    return z;
  }
  function q(u, z) {
    return 12 * (z.getFullYear() - u.getFullYear()) + (z.getMonth() - u.getMonth());
  }
  function r(u) {
    return new Date(u.getFullYear(), u.getMonth(), b(u));
  }
  function x(u) {
    return u && u.getTime && !isNaN(u.getTime());
  }
  function y(u) {
    x(u) && u.setHours(0, 0, 0, 0);
  }
  function k(u) {
    u = angular.isUndefined(u) ? new Date() : new Date(u);
    y(u);
    return u;
  }
  function p(u, z, D) {
    u = k(u);
    z = x(z) ? k(z) : null;
    D = x(D) ? k(D) : null;
    return (!z || z <= u) && (!D || D >= u);
  }
  function t(u, z) {
    return n(u, 12 * z);
  }
  function H(u, z) {
    return z.getFullYear() - u.getFullYear();
  }
  function A(u, z, D) {
    var G = u;
    z && u < z && (G = new Date(z.getTime()));
    D && u > D && (G = new Date(D.getTime()));
    return G;
  }
  function w(u) {
    if (u && u.hasAttribute("data-timestamp")) return Number(u.getAttribute("data-timestamp"));
  }
  function B(u, z, D) {
    var G = u.getMonth();
    u = u.getFullYear();
    return (!z || z.getFullYear() < u || z.getMonth() <= G) && (!D || D.getFullYear() > u || D.getMonth() >= G);
  }
  return {
    getFirstDateOfMonth: a,
    getNumberOfDaysInMonth: b,
    getDateInNextMonth: d,
    getDateInPreviousMonth: c,
    isInNextMonth: g,
    isInPreviousMonth: h,
    getDateMidpoint: l,
    isSameMonthAndYear: e,
    getWeekOfMonth: m,
    incrementDays: v,
    incrementMonths: n,
    getLastDateOfMonth: r,
    isSameDay: f,
    getMonthDistance: q,
    isValidDate: x,
    setDateTimeToMidnight: y,
    createDateAtMidnight: k,
    isDateWithinRange: p,
    incrementYears: t,
    getYearDistance: H,
    clampDate: A,
    getTimestampFromNode: w,
    isMonthWithinRange: B
  };
});
(function () {
  function a(c, e, f, g) {
    return {
      template: function (h, l) {
        var m = l.mdHideIcons;
        l = l.ariaLabel || l.mdPlaceholder;
        var v =
            "all" === m || "calendar" === m
              ? ""
              : '<md-button class="md-datepicker-button md-icon-button" type="button" tabindex="-1" aria-hidden="true" ng-click="ctrl.openCalendarPane($event)"><md-icon class="md-datepicker-calendar-icon" aria-label="md-calendar" md-svg-src="' +
                c.mdCalendar +
                '"></md-icon></md-button>',
          n = "";
        "all" !== m &&
          "triangle" !== m &&
          ((n =
            '<md-button type="button" md-no-ink class="md-datepicker-triangle-button md-icon-button" ng-click="ctrl.openCalendarPane($event)" aria-label="{{::ctrl.locale.msgOpenCalendar}}"><div class="md-datepicker-expand-triangle"></div></md-button>'),
          h.addClass("_md-datepicker-has-triangle-icon"));
        return (
          v +
          '<div class="md-datepicker-input-container" ng-class="{\'md-datepicker-focused\': ctrl.isFocused}"><input ' +
          (l ? 'aria-label="' + l + '" ' : "") +
          'class="md-datepicker-input" aria-haspopup="dialog" ng-focus="ctrl.setFocused(true)" ng-blur="ctrl.setFocused(false)"> ' +
          n +
          '</div><div class="md-datepicker-calendar-pane md-whiteframe-z1" id="{{::ctrl.calendarPaneId}}"><div class="md-datepicker-input-mask"><div class="md-datepicker-input-mask-opaque"></div></div><div class="md-datepicker-calendar"><md-calendar role="dialog" aria-label="{{::ctrl.locale.msgCalendar}}" md-current-view="{{::ctrl.currentView}}" md-mode="{{::ctrl.mode}}" md-min-date="ctrl.minDate" md-max-date="ctrl.maxDate" md-date-filter="ctrl.dateFilter" ng-model="ctrl.date" ng-if="ctrl.isCalendarOpen"></md-calendar></div></div>'
        );
      },
      require: ["ngModel", "mdDatepicker", "?^mdInputContainer", "?^form"],
      scope: {
        minDate: "=mdMinDate",
        maxDate: "=mdMaxDate",
        placeholder: "@mdPlaceholder",
        currentView: "@mdCurrentView",
        mode: "@mdMode",
        dateFilter: "=mdDateFilter",
        isOpen: "=?mdIsOpen",
        debounceInterval: "=mdDebounceInterval",
        dateLocale: "=mdDateLocale"
      },
      controller: b,
      controllerAs: "ctrl",
      bindToController: !0,
      link: function (h, l, m, v) {
        var n = v[0],
          q = v[1],
          r = v[2],
          x = v[3];
        v = e.parseAttributeBoolean(m.mdNoAsterisk);
        q.configureNgModel(n, r, g);
        if (r) {
          var y = l[0].querySelector(".md-errors-spacer");
          y && l.after(angular.element("<div>").append(y));
          r.setHasPlaceholder(m.mdPlaceholder);
          r.input = l;
          r.element
            .addClass("_md-datepicker-floating-label")
            .toggleClass("_md-datepicker-has-calendar-icon", "calendar" !== m.mdHideIcons && "all" !== m.mdHideIcons);
          r.label
            ? v ||
              m.$observe("required", function (p) {
                r.label.toggleClass("md-required", !!p);
              })
            : f.expect(l, "aria-label", m.mdPlaceholder);
          h.$watch(
            r.isErrorGetter ||
              function () {
                return n.$invalid && (n.$touched || (x && x.$submitted));
              },
            r.setInvalid
          );
        } else if (x)
          var k = h.$watch(
            function () {
              return x.$submitted;
            },
            function (p) {
              p && (q.updateErrorState(), k());
            }
          );
      }
    };
  }
  function b(c, e, f, g, h, l, m, v, n, q, r, x) {
    this.$window = g;
    this.dateUtil = n;
    this.$mdConstant = h;
    this.$mdUtil = m;
    this.$$rAF = q;
    this.$mdDateLocale = v;
    this.$timeout = x;
    this.documentElement = angular.element(document.documentElement);
    this.ngModelCtrl = null;
    this.inputElement = e[0].querySelector("input");
    this.ngInputElement = angular.element(this.inputElement);
    this.inputContainer = e[0].querySelector(".md-datepicker-input-container");
    this.calendarPane = e[0].querySelector(".md-datepicker-calendar-pane");
    this.calendarButton = e[0].querySelector(".md-datepicker-button");
    this.inputMask = angular.element(e[0].querySelector(".md-datepicker-input-mask-opaque"));
    this.$element = e;
    this.$attrs = f;
    this.$scope = c;
    this.date = null;
    this.isFocused = !1;
    this.isDisabled = void 0;
    this.setDisabled(e[0].disabled || angular.isString(f.disabled));
    this.isCalendarOpen = !1;
    this.openOnFocus = f.hasOwnProperty("mdOpenOnFocus");
    this.calendarPaneOpenedFrom = this.mdInputContainer = null;
    this.calendarPaneId = "md-date-pane-" + m.nextUid();
    this.bodyClickHandler = angular.bind(this, this.handleBodyClick);
    this.windowEventName = d.test(navigator.userAgent || navigator.vendor || window.opera) ? "orientationchange" : "resize";
    this.windowEventHandler = m.debounce(angular.bind(this, this.closeCalendarPane), 100);
    this.windowBlurHandler = angular.bind(this, this.handleWindowBlur);
    this.ngDateFilter = r("date");
    this.leftMargin = 20;
    this.topMargin = null;
    f.tabindex ? (this.ngInputElement.attr("tabindex", f.tabindex), f.$set("tabindex", null)) : f.$set("tabindex", "-1");
    f.$set("aria-owns", this.calendarPaneId);
    l(e);
    l(angular.element(this.calendarPane));
    var y = this;
    c.$on("$destroy", function () {
      y.detachCalendarPane();
    });
    f.mdIsOpen &&
      c.$watch("ctrl.isOpen", function (k) {
        k ? y.openCalendarPane({ target: y.inputElement }) : y.closeCalendarPane();
      });
    1 === angular.version.major && 4 >= angular.version.minor && this.$onInit();
  }
  b.$inject = "$scope $element $attrs $window $mdConstant $mdTheming $mdUtil $mdDateLocale $$mdDateUtil $$rAF $filter $timeout".split(" ");
  a.$inject = ["$$mdSvgRegistry", "$mdUtil", "$mdAria", "inputDirective"];
  angular.module("material.components.datepicker").directive("mdDatepicker", a);
  var d = /ipad|iphone|ipod|android/i;
  b.prototype.$onInit = function () {
    this.locale = this.dateLocale ? angular.extend({}, this.$mdDateLocale, this.dateLocale) : this.$mdDateLocale;
    this.installPropertyInterceptors();
    this.attachChangeListeners();
    this.attachInteractionListeners();
  };
  b.prototype.configureNgModel = function (c, e, f) {
    this.ngModelCtrl = c;
    this.mdInputContainer = e;
    this.$attrs.$set("type", "date");
    f[0].link.pre(this.$scope, { on: angular.noop, val: angular.noop, 0: {} }, this.$attrs, [c]);
    var g = this;
    g.ngModelCtrl.$formatters.push(function (h) {
      angular.isDefined(h);
      if (!(h instanceof Date)) {
        var l = Date.parse(h);
        !isNaN(l) && angular.isNumber(l) && (h = new Date(l));
        if (h && !(h instanceof Date))
          throw Error(
            "The ng-model for md-datepicker must be a Date instance or a value that can be parsed into a date. Currently the model is of type: " +
              typeof h
          );
      }
      g.onExternalChange(h);
      return h;
    });
    c.$viewChangeListeners.unshift(angular.bind(this, this.updateErrorState));
    if ((c = g.$mdUtil.getModelOption(c, "updateOn")))
      this.ngInputElement.on(c, angular.bind(this.$element, this.$element.triggerHandler, c));
  };
  b.prototype.attachChangeListeners = function () {
    var c = this;
    c.$scope.$on("md-calendar-change", function (f, g) {
      c.setModelValue(g);
      c.onExternalChange(g);
      c.closeCalendarPane();
    });
    c.ngInputElement.on("input", angular.bind(c, c.resizeInputElement));
    var e = angular.isDefined(this.debounceInterval) ? this.debounceInterval : 500;
    c.ngInputElement.on("input", c.$mdUtil.debounce(c.handleInputEvent, e, c));
  };
  b.prototype.attachInteractionListeners = function () {
    var c = this,
      e = this.$scope,
      f = this.$mdConstant.KEY_CODE;
    c.ngInputElement.on("keydown", function (g) {
      g.altKey && g.keyCode === f.DOWN_ARROW && (c.openCalendarPane(g), e.$digest());
    });
    c.openOnFocus &&
      (c.ngInputElement.on("focus", angular.bind(c, c.openCalendarPane)),
      c.ngInputElement.on("click", function (g) {
        g.stopPropagation();
      }),
      c.ngInputElement.on("pointerdown", function (g) {
        g.target && g.target.setPointerCapture && g.target.setPointerCapture(g.pointerId);
      }),
      angular.element(c.$window).on("blur", c.windowBlurHandler),
      e.$on("$destroy", function () {
        angular.element(c.$window).off("blur", c.windowBlurHandler);
      }));
    e.$on("md-calendar-close", function () {
      c.closeCalendarPane();
    });
  };
  b.prototype.installPropertyInterceptors = function () {
    var c = this;
    if (this.$attrs.ngDisabled) {
      var e = this.$scope.$parent;
      e &&
        e.$watch(this.$attrs.ngDisabled, function (f) {
          c.setDisabled(f);
        });
    }
    Object.defineProperty(this, "placeholder", {
      get: function () {
        return c.inputElement.placeholder;
      },
      set: function (f) {
        c.inputElement.placeholder = f || "";
      }
    });
  };
  b.prototype.setDisabled = function (c) {
    this.isDisabled = c;
    this.inputElement.disabled = c;
    this.calendarButton && (this.calendarButton.disabled = c);
  };
  b.prototype.updateErrorState = function (c) {
    c = c || this.date;
    this.clearErrorState();
    if (this.dateUtil.isValidDate(c)) {
      c = this.dateUtil.createDateAtMidnight(c);
      if (this.dateUtil.isValidDate(this.minDate)) {
        var e = this.dateUtil.createDateAtMidnight(this.minDate);
        this.ngModelCtrl.$setValidity("mindate", c >= e);
      }
      this.dateUtil.isValidDate(this.maxDate) &&
        ((e = this.dateUtil.createDateAtMidnight(this.maxDate)), this.ngModelCtrl.$setValidity("maxdate", c <= e));
      angular.isFunction(this.dateFilter) && this.ngModelCtrl.$setValidity("filtered", this.dateFilter(c));
    } else this.ngModelCtrl.$setValidity("valid", null == c);
    e = this.inputElement.value;
    var f = this.locale.parseDate(e);
    !this.isInputValid(e, f) && this.ngModelCtrl.$valid && this.ngModelCtrl.$setValidity("valid", null == c);
    angular.element(this.inputContainer).toggleClass("md-datepicker-invalid", !this.ngModelCtrl.$valid);
  };
  b.prototype.isInputValid = function (c, e) {
    return "" === c || (this.dateUtil.isValidDate(e) && this.locale.isDateComplete(c) && this.isDateEnabled(e));
  };
  b.prototype.clearErrorState = function () {
    this.inputContainer.classList.remove("md-datepicker-invalid");
    ["mindate", "maxdate", "filtered", "valid"].forEach(function (c) {
      this.ngModelCtrl.$setValidity(c, !0);
    }, this);
  };
  b.prototype.resizeInputElement = function () {
    this.inputElement.size = this.inputElement.value.length + 3;
  };
  b.prototype.handleInputEvent = function () {
    var c = this.inputElement.value,
      e = c ? this.locale.parseDate(c) : null;
    this.dateUtil.setDateTimeToMidnight(e);
    if ((c = this.isInputValid(c, e))) this.setModelValue(e), (this.date = e);
    this.updateErrorState(e);
  };
  b.prototype.isDateEnabled = function (c) {
    return this.dateUtil.isDateWithinRange(c, this.minDate, this.maxDate) && (!angular.isFunction(this.dateFilter) || this.dateFilter(c));
  };
  b.prototype.attachCalendarPane = function () {
    var c = this.calendarPane,
      e = document.body;
    c.style.transform = "";
    this.$element.addClass("md-datepicker-open");
    this.mdInputContainer && this.mdInputContainer.element.addClass("md-datepicker-open");
    angular.element(e).addClass("md-datepicker-is-showing");
    var f = this.inputContainer.getBoundingClientRect(),
      g = e.getBoundingClientRect();
    if (!this.topMargin || 0 > this.topMargin)
      this.topMargin = (this.inputMask.parent().prop("clientHeight") - this.ngInputElement.prop("clientHeight")) / 2;
    e = f.top - g.top - this.topMargin;
    var h = f.left - g.left - this.leftMargin,
      l = 0 > g.top && 0 == document.body.scrollTop ? -g.top : document.body.scrollTop,
      m = 0 > g.left && 0 == document.body.scrollLeft ? -g.left : document.body.scrollLeft;
    g = l + this.$window.innerHeight;
    var v = m + this.$window.innerWidth;
    this.inputMask.css({
      position: "absolute",
      left: this.leftMargin + "px",
      top: this.topMargin + "px",
      width: f.width - 1 + "px",
      height: f.height - 2 + "px"
    });
    h + 360 > v &&
      (0 < v - 360 ? (h = v - 360) : ((h = m), (f = this.$window.innerWidth / 360), (c.style.transform = "scale(" + f + ")")),
      c.classList.add("md-datepicker-pos-adjusted"));
    e + 368 > g && g - 368 > l && ((e = g - 368), c.classList.add("md-datepicker-pos-adjusted"));
    c.style.left = h + "px";
    c.style.top = e + "px";
    document.body.appendChild(c);
    this.$$rAF(function () {
      c.classList.add("md-pane-open");
    });
  };
  b.prototype.detachCalendarPane = function () {
    this.$element.removeClass("md-datepicker-open");
    this.mdInputContainer && this.mdInputContainer.element.removeClass("md-datepicker-open");
    angular.element(document.body).removeClass("md-datepicker-is-showing");
    this.calendarPane.classList.remove("md-pane-open");
    this.calendarPane.classList.remove("md-datepicker-pos-adjusted");
    this.isCalendarOpen && this.$mdUtil.enableScrolling();
    this.calendarPane.parentNode && this.calendarPane.parentNode.removeChild(this.calendarPane);
  };
  b.prototype.openCalendarPane = function (c) {
    if (!this.isCalendarOpen && !this.isDisabled && !this.inputFocusedOnWindowBlur) {
      this.isCalendarOpen = this.isOpen = !0;
      this.calendarPaneOpenedFrom = c.target;
      this.$mdUtil.disableScrollAround(this.calendarPane);
      this.attachCalendarPane();
      this.focusCalendar();
      this.evalAttr("ngFocus");
      var e = this;
      this.$mdUtil.nextTick(function () {
        e.documentElement.on("click touchstart", e.bodyClickHandler);
      }, !1);
      window.addEventListener(this.windowEventName, this.windowEventHandler);
    }
  };
  b.prototype.closeCalendarPane = function () {
    function c() {
      e.isCalendarOpen = e.isOpen = !1;
    }
    if (this.isCalendarOpen) {
      var e = this;
      e.detachCalendarPane();
      e.ngModelCtrl.$setTouched();
      e.evalAttr("ngBlur");
      e.documentElement.off("click touchstart", e.bodyClickHandler);
      window.removeEventListener(e.windowEventName, e.windowEventHandler);
      e.calendarPaneOpenedFrom.focus();
      e.calendarPaneOpenedFrom = null;
      e.openOnFocus ? e.$timeout(c) : c();
    }
  };
  b.prototype.getCalendarCtrl = function () {
    return angular.element(this.calendarPane.querySelector("md-calendar")).controller("mdCalendar");
  };
  b.prototype.focusCalendar = function () {
    var c = this;
    this.$mdUtil.nextTick(function () {
      c.getCalendarCtrl().focus();
    }, !1);
  };
  b.prototype.setFocused = function (c) {
    c || this.ngModelCtrl.$setTouched();
    this.openOnFocus || this.evalAttr(c ? "ngFocus" : "ngBlur");
    this.isFocused = c;
  };
  b.prototype.handleBodyClick = function (c) {
    this.isCalendarOpen && ((c = this.$mdUtil.getClosest(c.target, "md-calendar")) || this.closeCalendarPane(), this.$scope.$digest());
  };
  b.prototype.handleWindowBlur = function () {
    this.inputFocusedOnWindowBlur = document.activeElement === this.inputElement;
  };
  b.prototype.evalAttr = function (c) {
    this.$attrs[c] && this.$scope.$parent.$eval(this.$attrs[c]);
  };
  b.prototype.setModelValue = function (c) {
    var e = this.$mdUtil.getModelOption(this.ngModelCtrl, "timezone");
    this.ngModelCtrl.$setViewValue(this.ngDateFilter(c, "yyyy-MM-dd", e));
  };
  b.prototype.onExternalChange = function (c) {
    var e = this.$mdUtil.getModelOption(this.ngModelCtrl, "timezone");
    this.date = c;
    this.inputElement.value = this.locale.formatDate(c, e);
    this.mdInputContainer && this.mdInputContainer.setHasValue(!!c);
    this.resizeInputElement();
    this.updateErrorState();
  };
})();
ngmaterial.components.datepicker = angular.module("material.components.datepicker");
MdDialogDirective.$inject = ["$$rAF", "$mdTheming", "$mdDialog"];
MdDialogProvider.$inject = ["$$interimElementProvider"];
angular
  .module("material.components.dialog", ["material.core", "material.components.backdrop"])
  .directive("mdDialog", MdDialogDirective)
  .provider("$mdDialog", MdDialogProvider);
function MdDialogDirective(a, b, d) {
  return {
    restrict: "E",
    link: function (c, e) {
      e.addClass("_md");
      b(e);
      a(function () {
        function f() {
          e.toggleClass("md-content-overflow", g.scrollHeight > g.clientHeight);
        }
        var g = e[0].querySelector("md-dialog-content");
        if (g) {
          var h = g.getElementsByTagName("img");
          f();
          angular.element(h).on("load", f);
        }
        c.$on("$destroy", function () {
          d.destroy(e);
        });
      });
    }
  };
}
function MdDialogProvider(a) {
  function b() {
    return {
      template:
        '<md-dialog md-theme="{{ dialog.theme || dialog.defaultTheme }}" aria-label="{{ dialog.ariaLabel }}" ng-class="dialog.css">  <md-dialog-content class="md-dialog-content" role="document" tabIndex="-1">    <h2 class="md-title">{{ dialog.title }}</h2>    <div ng-if="::dialog.mdHtmlContent" class="md-dialog-content-body"         ng-bind-html="::dialog.mdHtmlContent"></div>    <div ng-if="::!dialog.mdHtmlContent" class="md-dialog-content-body">      <p>{{::dialog.mdTextContent}}</p>    </div>    <md-input-container md-no-float ng-if="::dialog.$type == \'prompt\'" class="md-prompt-input-container">      <input ng-keypress="dialog.keypress($event)" md-autofocus ng-model="dialog.result"              placeholder="{{::dialog.placeholder}}" ng-required="dialog.required">    </md-input-container>  </md-dialog-content>  <md-dialog-actions>    <md-button ng-if="dialog.$type === \'confirm\' || dialog.$type === \'prompt\'"               ng-click="dialog.abort()" class="md-primary md-cancel-button">      {{ dialog.cancel }}    </md-button>    <md-button ng-click="dialog.hide()" class="md-primary md-confirm-button" md-autofocus="dialog.$type===\'alert\'"               ng-disabled="dialog.required && !dialog.result">      {{ dialog.ok }}    </md-button>  </md-dialog-actions></md-dialog>'.replace(
          /\s\s+/g,
          ""
        ),
      controller: d,
      controllerAs: "dialog",
      bindToController: !0
    };
  }
  function d(g, h) {
    this.$onInit = function () {
      var l = "prompt" == this.$type;
      l && this.initialValue && (this.result = this.initialValue);
      this.hide = function () {
        g.hide(l ? this.result : !0);
      };
      this.abort = function () {
        g.cancel();
      };
      this.keypress = function (m) {
        var v = l && this.required && !angular.isDefined(this.result);
        m.keyCode !== h.KEY_CODE.ENTER || v || g.hide(this.result);
      };
    };
  }
  function c(g, h, l, m, v, n, q, r, x, y, k, p, t) {
    function H(K) {
      K.defaultTheme = k.defaultTheme();
      u(K);
    }
    function A(K, M, I, J) {
      if (J) {
        K = J.htmlContent || I.htmlContent || "";
        I = J.textContent || I.textContent || J.content || I.content || "";
        if (K && !y.has("$sanitize")) throw Error("The ngSanitize module must be loaded in order to use htmlContent.");
        if (K && I) throw Error("md-dialog cannot have both `htmlContent` and `textContent`");
        J.mdHtmlContent = K;
        J.mdTextContent = I;
      }
    }
    function w(K, M, I) {
      angular.element(n[0].body).addClass("md-dialog-is-showing");
      var J = M.find("md-dialog");
      J.hasClass("ng-cloak") && x.warn("$mdDialog: using `<md-dialog ng-cloak>` will affect the dialog opening animations.", M[0]);
      z(I);
      N(J, I);
      G(K, M, I);
      D(M, I);
      return O(M, I).then(function () {
        C(M, I);
        M[0].querySelector(".md-actions") && x.warn("Using a class of md-actions is deprecated, please use <md-dialog-actions>.");
        if (I.focusOnOpen) {
          var Q = l.findFocusTarget(M) || M[0].querySelector(".dialog-close, md-dialog-actions button:last-child") || J;
          Q.focus();
        }
      });
    }
    function B(K, M, I) {
      function J() {
        angular.element(n[0].body).removeClass("md-dialog-is-showing");
        I.contentElement && I.reverseContainerStretch();
        I.cleanupElement();
        I.$destroy || "keyboard" !== I.originInteraction || I.origin.focus();
      }
      I.deactivateListeners();
      I.unlockScreenReader();
      I.hideBackdrop(I.$destroy);
      e && e.parentNode && e.parentNode.removeChild(e);
      f && f.parentNode && f.parentNode.removeChild(f);
      return I.$destroy ? J() : S(M, I).then(J);
    }
    function u(K) {
      var M;
      K.targetEvent && K.targetEvent.target && (M = angular.element(K.targetEvent.target));
      M = M && M.controller("mdTheme");
      K.hasTheme = !!M;
      if (K.hasTheme) {
        K.themeWatch = M.$shouldWatch;
        var I = K.theme || M.$mdTheme;
        I && (K.scope.theme = I);
        var J = M.registerChanges(function (Q) {
          K.scope.theme = Q;
          K.themeWatch || J();
        });
      }
    }
    function z(K) {
      function M(J, Q) {
        if ((J = angular.element(J || {})) && J.length) {
          var T = { top: 0, left: 0, height: 0, width: 0 },
            Y = angular.isFunction(J[0].getBoundingClientRect);
          return angular.extend(Q || {}, {
            element: Y ? J : void 0,
            bounds: Y ? J[0].getBoundingClientRect() : angular.extend({}, T, J[0]),
            focus: angular.bind(J, J.focus)
          });
        }
      }
      function I(J, Q) {
        angular.isString(J) && (J = n[0].querySelector(J));
        return angular.element(J || Q);
      }
      K.origin = angular.extend({ element: null, bounds: null, focus: angular.noop }, K.origin || {});
      K.parent = I(K.parent, r);
      K.closeTo = M(I(K.closeTo));
      K.openFrom = M(I(K.openFrom));
      K.targetEvent && ((K.origin = M(K.targetEvent.target, K.origin)), (K.originInteraction = t.getLastInteractionType()));
    }
    function D(K, M) {
      var I = angular.element(q),
        J = l.debounce(function () {
          F(K, M);
        }, 60),
        Q = [],
        T = function () {
          var fa = "alert" == M.$type ? g.hide : g.cancel;
          l.nextTick(fa, !0);
        };
      if (M.escapeToClose) {
        var Y = M.parent,
          R = function (fa) {
            fa.keyCode === m.KEY_CODE.ESCAPE && (fa.stopImmediatePropagation(), fa.preventDefault(), T());
          };
        K.on("keydown", R);
        Y.on("keydown", R);
        Q.push(function () {
          K.off("keydown", R);
          Y.off("keydown", R);
        });
      }
      I.on("resize", J);
      Q.push(function () {
        I.off("resize", J);
      });
      if (M.clickOutsideToClose) {
        var U = K,
          X,
          aa = function (fa) {
            X = fa.target;
          },
          ha = function (fa) {
            X === U[0] && fa.target === U[0] && (fa.stopPropagation(), fa.preventDefault(), T());
          };
        U.on("mousedown", aa);
        U.on("mouseup", ha);
        Q.push(function () {
          U.off("mousedown", aa);
          U.off("mouseup", ha);
        });
      }
      M.deactivateListeners = function () {
        Q.forEach(function (fa) {
          fa();
        });
        M.deactivateListeners = null;
      };
    }
    function G(K, M, I) {
      I.disableParentScroll && (I.restoreScroll = l.disableScrollAround(M, I.parent));
      I.hasBackdrop && ((I.backdrop = l.createBackdrop(K, "md-dialog-backdrop md-opaque")), v.enter(I.backdrop, I.parent));
      I.hideBackdrop = function (J) {
        I.backdrop && (J ? I.backdrop.remove() : v.leave(I.backdrop));
        I.disableParentScroll && (I.restoreScroll && I.restoreScroll(), delete I.restoreScroll);
        I.hideBackdrop = null;
      };
    }
    function N(K, M) {
      var I = "alert" === M.$type ? "alertdialog" : "dialog",
        J = K.find("md-dialog-content"),
        Q = K.attr("id"),
        T = "dialogContent_" + (Q || l.nextUid());
      K.attr({ role: I, tabIndex: "-1" });
      0 === J.length && ((J = K), Q && (T = Q));
      J.attr("id", T);
      K.attr("aria-describedby", T);
      M.ariaLabel
        ? h.expect(K, "aria-label", M.ariaLabel)
        : h.expectAsync(K, "aria-label", function () {
            if (M.title) return M.title;
            var Y = J.text().split(/\s+/);
            3 < Y.length && (Y = Y.slice(0, 3).concat("..."));
            return Y.join(" ");
          });
      e = document.createElement("div");
      e.classList.add("md-dialog-focus-trap");
      e.tabIndex = 0;
      f = e.cloneNode(!1);
      I = function () {
        K.focus();
      };
      e.addEventListener("focus", I);
      f.addEventListener("focus", I);
      K[0].parentNode.insertBefore(e, K[0]);
      K.after(f);
    }
    function C(K, M) {
      function I(Q) {
        a: {
          for (var T = []; Q.parentNode; ) {
            if (Q === document.body) {
              Q = T;
              break a;
            }
            for (var Y = Q.parentNode.children, R = 0; R < Y.length; R++) {
              var U;
              (U = Q === Y[R]) || ((U = ["SCRIPT", "STYLE"]), (U = -1 !== U.indexOf(Y[R].nodeName) ? !0 : void 0));
              U || Y[R].hasAttribute("aria-live") || T.push(Y[R]);
            }
            Q = Q.parentNode;
          }
          Q = T;
        }
        for (T = 0; T < Q.length; T++) Q[T].setAttribute("aria-hidden", J);
      }
      var J = !0;
      I(K[0]);
      M.unlockScreenReader = function () {
        J = !1;
        I(K[0]);
        M.unlockScreenReader = null;
      };
    }
    function F(K, M) {
      var I = "fixed" == q.getComputedStyle(n[0].body).position,
        J = M.backdrop ? q.getComputedStyle(M.backdrop[0]) : null;
      J = J ? Math.min(n[0].body.clientHeight, Math.ceil(Math.abs(parseInt(J.height, 10)))) : 0;
      var Q = { top: K.css("top"), height: K.css("height") };
      M = Math.abs(M.parent[0].getBoundingClientRect().top);
      K.css({ top: (I ? M : 0) + "px", height: J ? J + "px" : "100%" });
      return function () {
        K.css(Q);
      };
    }
    function O(K, M) {
      M.parent.append(K);
      M.reverseContainerStretch = F(K, M);
      var I = K.find("md-dialog"),
        J = l.dom.animator,
        Q = J.calculateZoomToOrigin,
        T = { transitionInClass: "md-transition-in", transitionOutClass: "md-transition-out" },
        Y = J.toTransformCss(Q(I, M.openFrom || M.origin)),
        R = J.toTransformCss("");
      I.toggleClass("md-dialog-fullscreen", !!M.fullscreen);
      return J.translate3d(I, Y, R, T).then(function (U) {
        M.reverseAnimate = function () {
          delete M.reverseAnimate;
          return M.closeTo
            ? ((T = { transitionInClass: "md-transition-out", transitionOutClass: "md-transition-in" }),
              (Y = R),
              (R = J.toTransformCss(Q(I, M.closeTo))),
              J.translate3d(I, Y, R, T))
            : U((R = J.toTransformCss(Q(I, M.origin))));
        };
        M.clearAnimate = function () {
          delete M.clearAnimate;
          I.removeClass([T.transitionOutClass, T.transitionInClass].join(" "));
          return J.translate3d(I, R, J.toTransformCss(""), {});
        };
        return !0;
      });
    }
    function S(K, M) {
      return M.reverseAnimate().then(function () {
        M.contentElement && M.clearAnimate();
      });
    }
    return {
      hasBackdrop: !0,
      isolateScope: !0,
      onCompiling: H,
      onShow: w,
      onShowing: A,
      onRemove: B,
      clickOutsideToClose: !1,
      escapeToClose: !0,
      targetEvent: null,
      closeTo: null,
      openFrom: null,
      focusOnOpen: !0,
      disableParentScroll: !0,
      autoWrap: !0,
      fullscreen: !1,
      transformTemplate: function (K, M) {
        var I = p.startSymbol(),
          J = p.endSymbol();
        I = I + (M.themeWatch ? "" : "::") + "theme" + J;
        I = M.hasTheme ? 'md-theme="' + I + '"' : "";
        M = M.autoWrap && !/<\/md-dialog>/g.test(K) ? "<md-dialog>" + (K || "") + "</md-dialog>" : K || "";
        return '<div class="md-dialog-container" tabindex="-1" ' + I + ">" + M + "</div>";
      }
    };
  }
  d.$inject = ["$mdDialog", "$mdConstant"];
  c.$inject =
    "$mdDialog $mdAria $mdUtil $mdConstant $animate $document $window $rootElement $log $injector $mdTheming $interpolate $mdInteraction".split(
      " "
    );
  var e, f;
  return a("$mdDialog")
    .setDefaults({
      methods:
        "disableParentScroll hasBackdrop clickOutsideToClose escapeToClose targetEvent closeTo openFrom parent fullscreen multiple".split(
          " "
        ),
      options: c
    })
    .addPreset("alert", { methods: "title htmlContent textContent content ariaLabel ok theme css".split(" "), options: b })
    .addPreset("confirm", { methods: "title htmlContent textContent content ariaLabel ok cancel theme css".split(" "), options: b })
    .addPreset("prompt", {
      methods: "title htmlContent textContent initialValue content placeholder ariaLabel ok cancel theme css required".split(" "),
      options: b
    });
}
ngmaterial.components.dialog = angular.module("material.components.dialog");
MdDividerDirective.$inject = ["$mdTheming"];
angular.module("material.components.divider", ["material.core"]).directive("mdDivider", MdDividerDirective);
function MdDividerDirective(a) {
  return { restrict: "E", link: a };
}
ngmaterial.components.divider = angular.module("material.components.divider");
(function () {
  function a(b) {
    return {
      restrict: "E",
      require: ["^?mdFabSpeedDial", "^?mdFabToolbar"],
      compile: function (d) {
        d = d.children();
        var c = b.prefixer().hasAttribute(d, "ng-repeat");
        c ? d.addClass("md-fab-action-item") : d.wrap('<div class="md-fab-action-item">');
      }
    };
  }
  a.$inject = ["$mdUtil"];
  angular.module("material.components.fabActions", ["material.core"]).directive("mdFabActions", a);
})();
ngmaterial.components.fabActions = angular.module("material.components.fabActions");
(function () {
  function a(b, d, c, e, f, g) {
    function h() {
      var w = ["click", "focusin", "focusout"];
      angular.forEach(w, function (B) {
        d.on(B, l);
      });
      b.$on("$destroy", function () {
        angular.forEach(w, function (B) {
          d.off(B, l);
        });
        q();
      });
    }
    function l(w) {
      "click" == w.type && p(w);
      "focusout" != w.type ||
        A ||
        (A = g(
          function () {
            t.close();
          },
          100,
          !1
        ));
      "focusin" == w.type && A && (g.cancel(A), (A = null));
    }
    function m() {
      b.$watch("vm.direction", function (u, z) {
        c.removeClass(d, "md-" + z);
        c.addClass(d, "md-" + u);
        t.currentActionIndex = -1;
      });
      var w, B;
      b.$watch("vm.isOpen", function (u) {
        t.currentActionIndex = -1;
        (w && B) || ((w = d.find("md-fab-trigger")), (B = d.find("md-fab-actions")));
        u ? n() : q();
        var z = u ? "md-is-open" : "",
          D = u ? "" : "md-is-open";
        w.attr("aria-haspopup", !0);
        w.attr("aria-expanded", u);
        B.attr("aria-hidden", !u);
        c.setClass(d, z, D);
      });
    }
    function v() {
      0 < d[0].scrollHeight
        ? c.addClass(d, "_md-animations-ready").then(function () {
            d.removeClass("md-animations-waiting");
          })
        : 10 > H && (g(v, 100), (H += 1));
    }
    function n() {
      d.on("keydown", x);
      e.nextTick(function () {
        angular.element(document).on("click touchend", r);
      });
    }
    function q() {
      d.off("keydown", x);
      angular.element(document).off("click touchend", r);
    }
    function r(w) {
      if (w.target) {
        var B = e.getClosest(w.target, "md-fab-trigger");
        w = e.getClosest(w.target, "md-fab-actions");
        B || w || t.close();
      }
    }
    function x(w) {
      switch (w.which) {
        case f.KEY_CODE.ESCAPE:
          return t.close(), w.preventDefault(), !1;
        case f.KEY_CODE.LEFT_ARROW:
          return "left" === t.direction ? y(w, 1) : y(w, -1), !1;
        case f.KEY_CODE.UP_ARROW:
          return "down" === t.direction ? y(w, -1) : y(w, 1), !1;
        case f.KEY_CODE.RIGHT_ARROW:
          return "left" === t.direction ? y(w, -1) : y(w, 1), !1;
        case f.KEY_CODE.DOWN_ARROW:
          return "up" === t.direction ? y(w, -1) : y(w, 1), !1;
      }
    }
    function y(w, B) {
      var u = k();
      t.currentActionIndex += B;
      t.currentActionIndex = Math.min(u.length - 1, t.currentActionIndex);
      t.currentActionIndex = Math.max(0, t.currentActionIndex);
      B = angular.element(u[t.currentActionIndex]).children()[0];
      angular.element(B).attr("tabindex", 0);
      B.focus();
      w.preventDefault();
      w.stopImmediatePropagation();
    }
    function k() {
      var w = d.find("md-fab-actions")[0].querySelectorAll(".md-fab-action-item");
      angular.forEach(w, function (B) {
        angular.element(angular.element(B).children()[0]).attr("tabindex", -1);
      });
      return w;
    }
    function p(w) {
      e.getClosest(w.target, "md-fab-trigger") && t.toggle();
      e.getClosest(w.target, "md-fab-actions") && t.close();
    }
    var t = this,
      H = 0;
    t.open = function () {
      b.$evalAsync("vm.isOpen = true");
    };
    t.close = function () {
      b.$evalAsync("vm.isOpen = false");
      d.find("md-fab-trigger")[0].focus();
    };
    t.toggle = function () {
      b.$evalAsync("vm.isOpen = !vm.isOpen");
    };
    t.$onInit = function () {
      t.direction = t.direction || "down";
      t.isOpen = t.isOpen || !1;
      t.currentActionIndex = -1;
      d.addClass("md-animations-waiting");
      h();
      m();
      v();
    };
    1 === angular.version.major && 4 >= angular.version.minor && this.$onInit();
    var A;
  }
  a.$inject = "$scope $element $animate $mdUtil $mdConstant $timeout".split(" ");
  angular.module("material.components.fabShared", ["material.core"]).controller("MdFabController", a);
})();
(function () {
  function a() {
    function e(f, g) {
      g.prepend('<div class="_md-css-variables"></div>');
    }
    return {
      restrict: "E",
      scope: { direction: "@?mdDirection", isOpen: "=?mdOpen" },
      bindToController: !0,
      controller: "MdFabController",
      controllerAs: "vm",
      link: e
    };
  }
  function b(e) {
    function f(g) {
      if (!g.hasClass("md-animations-waiting") || g.hasClass("_md-animations-ready")) {
        var h = g[0],
          l = g.controller("mdFabSpeedDial"),
          m = h.querySelectorAll(".md-fab-action-item"),
          v = h.querySelector("md-fab-trigger");
        g = h.querySelector("._md-css-variables");
        var n = parseInt(window.getComputedStyle(g).zIndex);
        angular.forEach(m, function (q, r) {
          q = q.style;
          q.transform = q.webkitTransform = "";
          q.transitionDelay = "";
          q.opacity = 1;
          q.zIndex = m.length - r + n;
        });
        v.style.zIndex = n + m.length + 1;
        l.isOpen ||
          angular.forEach(m, function (q, r) {
            var x = q.style,
              y = (v.clientHeight - q.clientHeight) / 2,
              k = (v.clientWidth - q.clientWidth) / 2;
            switch (l.direction) {
              case "up":
                var p = q.scrollHeight * (r + 1) + y;
                var t = "Y";
                break;
              case "down":
                p = -(q.scrollHeight * (r + 1) + y);
                t = "Y";
                break;
              case "left":
                p = q.scrollWidth * (r + 1) + k;
                t = "X";
                break;
              case "right":
                (p = -(q.scrollWidth * (r + 1) + k)), (t = "X");
            }
            q = "translate" + t + "(" + p + "px)";
            x.transform = x.webkitTransform = q;
          });
      }
    }
    return {
      addClass: function (g, h, l) {
        g.hasClass("md-fling") ? (f(g), e(l, c, !1)) : l();
      },
      removeClass: function (g, h, l) {
        f(g);
        e(l, c, !1);
      }
    };
  }
  function d(e) {
    function f(g) {
      var h = g[0],
        l = g.controller("mdFabSpeedDial"),
        m = h.querySelectorAll(".md-fab-action-item");
      g = h.querySelector("._md-css-variables");
      var v = parseInt(window.getComputedStyle(g).zIndex);
      angular.forEach(m, function (n, q) {
        n = n.style;
        var r = 65 * q;
        n.opacity = l.isOpen ? 1 : 0;
        n.transform = n.webkitTransform = l.isOpen ? "scale(1)" : "scale(0)";
        n.transitionDelay = (l.isOpen ? r : m.length - r) + "ms";
        n.zIndex = m.length - q + v;
      });
    }
    return {
      addClass: function (g, h, l) {
        f(g);
        e(l, c, !1);
      },
      removeClass: function (g, h, l) {
        f(g);
        e(l, c, !1);
      }
    };
  }
  b.$inject = ["$timeout"];
  d.$inject = ["$timeout"];
  var c = 300;
  angular
    .module("material.components.fabSpeedDial", ["material.core", "material.components.fabShared", "material.components.fabActions"])
    .directive("mdFabSpeedDial", a)
    .animation(".md-fling", b)
    .animation(".md-scale", d)
    .service("mdFabSpeedDialFlingAnimation", b)
    .service("mdFabSpeedDialScaleAnimation", d);
})();
ngmaterial.components.fabShared = angular.module("material.components.fabShared");
(function () {
  function a() {
    function d(c, e) {
      e.addClass("md-fab-toolbar");
      e.find("md-fab-trigger").find("button").prepend('<div class="md-fab-toolbar-background"></div>');
    }
    return {
      restrict: "E",
      transclude: !0,
      template: '<div class="md-fab-toolbar-wrapper">  <div class="md-fab-toolbar-content" ng-transclude></div></div>',
      scope: { direction: "@?mdDirection", isOpen: "=?mdOpen" },
      bindToController: !0,
      controller: "MdFabController",
      controllerAs: "vm",
      link: d
    };
  }
  function b() {
    function d(c, e) {
      if (e) {
        var f = c[0];
        e = c.controller("mdFabToolbar");
        var g = f.querySelector(".md-fab-toolbar-background"),
          h = f.querySelector("md-fab-trigger button"),
          l = f.querySelector("md-toolbar"),
          m = f.querySelector("md-fab-trigger button md-icon"),
          v = c.find("md-fab-actions").children();
        if (h && g) {
          var n = window.getComputedStyle(h).getPropertyValue("background-color");
          f = f.offsetWidth;
          var q = (f / h.offsetWidth) * 2;
          g.style.backgroundColor = n;
          g.style.borderRadius = f + "px";
          e.isOpen
            ? ((l.style.pointerEvents = "inherit"),
              (g.style.width = h.offsetWidth + "px"),
              (g.style.height = h.offsetHeight + "px"),
              (g.style.transform = "scale(" + q + ")"),
              (g.style.transitionDelay = "0ms"),
              m && (m.style.transitionDelay = ".3s"),
              angular.forEach(v, function (r, x) {
                r.style.transitionDelay = 25 * (v.length - x) + "ms";
              }))
            : ((l.style.pointerEvents = "none"),
              (g.style.transform = "scale(1)"),
              (g.style.top = "0"),
              c.hasClass("md-right") && ((g.style.left = "0"), (g.style.right = null)),
              c.hasClass("md-left") && ((g.style.right = "0"), (g.style.left = null)),
              (g.style.transitionDelay = "200ms"),
              m && (m.style.transitionDelay = "0ms"),
              angular.forEach(v, function (r, x) {
                r.style.transitionDelay = 200 + 25 * x + "ms";
              }));
        }
      }
    }
    return {
      addClass: function (c, e, f) {
        d(c, e, f);
        f();
      },
      removeClass: function (c, e, f) {
        d(c, e, f);
        f();
      }
    };
  }
  angular
    .module("material.components.fabToolbar", ["material.core", "material.components.fabShared", "material.components.fabActions"])
    .directive("mdFabToolbar", a)
    .animation(".md-fab-toolbar", b)
    .service("mdFabToolbarAnimation", b);
})();
ngmaterial.components.fabToolbar = angular.module("material.components.fabToolbar");
GridListController.$inject = ["$mdUtil"];
GridLayoutFactory.$inject = ["$mdUtil"];
GridListDirective.$inject = ["$interpolate", "$mdConstant", "$mdGridLayout", "$mdMedia", "$mdUtil"];
GridTileDirective.$inject = ["$mdMedia"];
angular
  .module("material.components.gridList", ["material.core"])
  .directive("mdGridList", GridListDirective)
  .directive("mdGridTile", GridTileDirective)
  .directive("mdGridTileFooter", GridTileCaptionDirective)
  .directive("mdGridTileHeader", GridTileCaptionDirective)
  .factory("$mdGridLayout", GridLayoutFactory);
function GridListDirective(a, b, d, c, e) {
  function f(g, h, l, m) {
    function v() {
      for (var F in b.MEDIA) c(F), c.getQuery(b.MEDIA[F]).addListener(w);
      return c.watchResponsiveAttributes(["md-cols", "md-row-height", "md-gutter"], l, q);
    }
    function n() {
      m.layoutDelegate = angular.noop;
      B();
      for (var F in b.MEDIA) c.getQuery(b.MEDIA[F]).removeListener(w);
    }
    function q(F) {
      null == F ? m.invalidateLayout() : c(F) && m.invalidateLayout();
    }
    function r(F) {
      var O = y(),
        S = { tileSpans: k(O), colCount: p(), rowMode: H(), rowHeight: t(), gutter: A(c.getResponsiveAttribute(l, "md-gutter") || 1) };
      if (F || !angular.equals(S, u))
        (F = d(S.colCount, S.tileSpans, O)
          .map(function (K, M) {
            return {
              grid: { element: h, style: x(S.colCount, M, S.gutter, S.rowMode, S.rowHeight) },
              tiles: K.map(function (I, J) {
                J = angular.element(O[J]);
                var Q = I.position;
                I = I.spans;
                var T = S.colCount,
                  Y = M,
                  R = S.gutter,
                  U = S.rowMode,
                  X = S.rowHeight,
                  aa = (1 / T) * 100,
                  ha = (T - 1) / T;
                T = G({ share: aa, gutterShare: ha, gutter: R });
                T = e.isRtl(l)
                  ? {
                      right: N({ unit: T, offset: Q.col, gutter: R }),
                      width: C({ unit: T, span: I.col, gutter: R }),
                      paddingTop: "",
                      marginTop: "",
                      top: "",
                      height: ""
                    }
                  : {
                      left: N({ unit: T, offset: Q.col, gutter: R }),
                      width: C({ unit: T, span: I.col, gutter: R }),
                      paddingTop: "",
                      marginTop: "",
                      top: "",
                      height: ""
                    };
                switch (U) {
                  case "fixed":
                    T.top = N({ unit: X, offset: Q.row, gutter: R });
                    T.height = C({ unit: X, span: I.row, gutter: R });
                    break;
                  case "ratio":
                    Y = aa / X;
                    Y = G({ share: Y, gutterShare: ha, gutter: R });
                    T.paddingTop = C({ unit: Y, span: I.row, gutter: R });
                    T.marginTop = N({ unit: Y, offset: Q.row, gutter: R });
                    break;
                  case "fit":
                    (U = (Y - 1) / Y),
                      (Y = (1 / Y) * 100),
                      (Y = G({ share: Y, gutterShare: U, gutter: R })),
                      (T.top = N({ unit: Y, offset: Q.row, gutter: R })),
                      (T.height = C({ unit: Y, span: I.row, gutter: R }));
                }
                Q = T;
                return { element: J, style: Q };
              })
            };
          })
          .reflow()
          .performance()),
          g.mdOnLayout({ $event: { performance: F } }),
          (u = S);
    }
    function x(F, O, S, K, M) {
      var I = {};
      switch (K) {
        case "fixed":
          I.height = C({ unit: M, span: O, gutter: S });
          I.paddingBottom = "";
          break;
        case "ratio":
          (K = 1 === F ? 0 : (F - 1) / F),
            (F = (1 / F) * 100),
            (M = (1 / M) * F),
            (M = G({ share: M, gutterShare: K, gutter: S })),
            (I.height = ""),
            (I.paddingBottom = C({ unit: M, span: O, gutter: S }));
      }
      return I;
    }
    function y() {
      return [].filter.call(h.children(), function (F) {
        return "MD-GRID-TILE" == F.tagName && !F.$$mdDestroyed;
      });
    }
    function k(F) {
      return [].map.call(F, function (O) {
        O = angular.element(O).controller("mdGridTile");
        return {
          row: parseInt(c.getResponsiveAttribute(O.$attrs, "md-rowspan"), 10) || 1,
          col: parseInt(c.getResponsiveAttribute(O.$attrs, "md-colspan"), 10) || 1
        };
      });
    }
    function p() {
      var F = parseInt(c.getResponsiveAttribute(l, "md-cols"), 10);
      if (isNaN(F)) throw "md-grid-list: md-cols attribute was not found, or contained a non-numeric value";
      return F;
    }
    function t() {
      var F = c.getResponsiveAttribute(l, "md-row-height");
      if (!F) throw "md-grid-list: md-row-height attribute was not found";
      switch (H()) {
        case "fixed":
          return A(F);
        case "ratio":
          return (F = F.split(":")), parseFloat(F[0]) / parseFloat(F[1]);
        case "fit":
          return 0;
      }
    }
    function H() {
      var F = c.getResponsiveAttribute(l, "md-row-height");
      if (!F) throw "md-grid-list: md-row-height attribute was not found";
      return "fit" == F ? "fit" : -1 !== F.indexOf(":") ? "ratio" : "fixed";
    }
    function A(F) {
      return /\D$/.test(F) ? F : F + "px";
    }
    h.addClass("_md");
    h.attr("role", "list");
    m.layoutDelegate = r;
    var w = angular.bind(m, m.invalidateLayout),
      B = v();
    g.$on("$destroy", n);
    var u,
      z = a.startSymbol(),
      D = a.endSymbol(),
      G = a(z + "share" + D + "% - (" + (z + "gutter" + D) + " * " + (z + "gutterShare" + D) + ")"),
      N = a("calc((" + (z + "unit" + D) + " + " + (z + "gutter" + D) + ") * " + (z + "offset" + D) + ")"),
      C = a("calc((" + (z + "unit" + D) + ") * " + (z + "span" + D) + " + (" + (z + "span" + D) + " - 1) * " + (z + "gutter" + D) + ")");
  }
  return { restrict: "E", controller: GridListController, scope: { mdOnLayout: "&" }, link: f };
}
function GridListController(a) {
  this.tilesInvalidated = this.layoutInvalidated = !1;
  this.$timeout_ = a.nextTick;
  this.layoutDelegate = angular.noop;
}
GridListController.prototype = {
  invalidateTiles: function () {
    this.tilesInvalidated = !0;
    this.invalidateLayout();
  },
  invalidateLayout: function () {
    this.layoutInvalidated || ((this.layoutInvalidated = !0), this.$timeout_(angular.bind(this, this.layout)));
  },
  layout: function () {
    try {
      this.layoutDelegate(this.tilesInvalidated);
    } finally {
      this.tilesInvalidated = this.layoutInvalidated = !1;
    }
  }
};
function GridLayoutFactory(a) {
  function b(f, g) {
    var h, l, m, v, n;
    var q = a.time(function () {
      l = c(f, g);
    });
    return (h = {
      layoutInfo: function () {
        return l;
      },
      map: function (r) {
        v = a.time(function () {
          var x = h.layoutInfo();
          m = r(x.positioning, x.rowCount);
        });
        return h;
      },
      reflow: function (r) {
        n = a.time(function () {
          var x = r || e;
          x(m.grid, m.tiles);
        });
        return h;
      },
      performance: function () {
        return { tileCount: g.length, layoutTime: q, mapTime: v, reflowTime: n, totalTime: q + v + n };
      }
    });
  }
  function d(f, g) {
    f.element.css(f.style);
    g.forEach(function (h) {
      h.element.css(h.style);
    });
  }
  function c(f, g) {
    function h(q, r, x) {
      for (var y = q; y < q + r; y++) n[y] = Math.max(n[y] + x, 0);
    }
    function l() {
      for (var q = [], r = 0; r < f; r++) q.push(0);
      return q;
    }
    var m = 0,
      v = 0,
      n = l();
    return {
      positioning: g.map(function (q, r) {
        var x = q;
        if (x.col > f)
          throw "md-grid-list: Tile at position " + r + " has a colspan (" + x.col + ") that exceeds the column count (" + f + ")";
        for (var y = (r = 0); y - r < x.col; )
          if (m >= f) (m = 0), v++, h(0, f, -1);
          else {
            r = n.indexOf(0, m);
            var k;
            if (!(k = -1 === r)) {
              a: {
                for (y = r + 1; y < n.length; y++) if (0 !== n[y]) break a;
                y = y === n.length ? y : void 0;
              }
              k = -1 === y;
            }
            k ? ((m = r = y = 0), v++, h(0, f, -1)) : (m = y + 1);
          }
        h(r, x.col, x.row);
        m = r + x.col;
        x = { col: r, row: v };
        return { spans: q, position: x };
      }),
      rowCount: v + Math.max.apply(Math, n)
    };
  }
  var e = d;
  b.animateWith = function (f) {
    e = angular.isFunction(f) ? f : d;
  };
  return b;
}
function GridTileDirective(a) {
  function b(d, c, e, f) {
    c.attr("role", "listitem");
    var g = a.watchResponsiveAttributes(["md-colspan", "md-rowspan"], e, angular.bind(f, f.invalidateLayout));
    f.invalidateTiles();
    d.$on("$destroy", function () {
      c[0].$$mdDestroyed = !0;
      g();
      f.invalidateLayout();
    });
    angular.isDefined(d.$parent.$index) &&
      d.$watch(
        function () {
          return d.$parent.$index;
        },
        function (h, l) {
          h !== l && f.invalidateTiles();
        }
      );
  }
  return {
    restrict: "E",
    require: "^mdGridList",
    template: "<figure ng-transclude></figure>",
    transclude: !0,
    scope: {},
    controller: [
      "$attrs",
      function (d) {
        this.$attrs = d;
      }
    ],
    link: b
  };
}
function GridTileCaptionDirective() {
  return { template: "<figcaption ng-transclude></figcaption>", transclude: !0 };
}
ngmaterial.components.gridList = angular.module("material.components.gridList");
mdInputContainerDirective.$inject = ["$mdTheming", "$parse", "$$rAF"];
inputTextareaDirective.$inject = ["$mdUtil", "$window", "$mdAria", "$timeout", "$mdGesture"];
mdMaxlengthDirective.$inject = ["$animate", "$mdUtil"];
placeholderDirective.$inject = ["$compile"];
ngMessageDirective.$inject = ["$mdUtil"];
mdSelectOnFocusDirective.$inject = ["$document", "$timeout"];
mdInputInvalidMessagesAnimation.$inject = ["$$AnimateRunner", "$animateCss", "$mdUtil"];
ngMessagesAnimation.$inject = ["$$AnimateRunner", "$animateCss", "$mdUtil"];
ngMessageAnimation.$inject = ["$$AnimateRunner", "$animateCss", "$mdUtil", "$log"];
var inputModule = angular
  .module("material.components.input", ["material.core"])
  .directive("mdInputContainer", mdInputContainerDirective)
  .directive("label", labelDirective)
  .directive("input", inputTextareaDirective)
  .directive("textarea", inputTextareaDirective)
  .directive("mdMaxlength", mdMaxlengthDirective)
  .directive("placeholder", placeholderDirective)
  .directive("ngMessages", ngMessagesDirective)
  .directive("ngMessage", ngMessageDirective)
  .directive("ngMessageExp", ngMessageDirective)
  .directive("mdSelectOnFocus", mdSelectOnFocusDirective)
  .animation(".md-input-invalid", mdInputInvalidMessagesAnimation)
  .animation(".md-input-messages-animation", ngMessagesAnimation)
  .animation(".md-input-message-animation", ngMessageAnimation);
window._mdMocksIncluded &&
  inputModule
    .service("$$mdInput", function () {
      return { messages: { getElement: getMessagesElement } };
    })
    .service("mdInputInvalidAnimation", mdInputInvalidMessagesAnimation)
    .service("mdInputMessagesAnimation", ngMessagesAnimation)
    .service("mdInputMessageAnimation", ngMessageAnimation);
function mdInputContainerDirective(a, b, d) {
  function c(l) {
    var m = l[0].querySelector(g),
      v = l[0].querySelector(h);
    return function (n, q) {
      a(q);
      (m || v) &&
        d(function () {
          var r = q[0].querySelector("md-icon") || q[0].querySelector(".md-icon");
          m && r && q.addClass("md-icon-left");
          v && r && q.addClass("md-icon-right");
        });
    };
  }
  function e(l, m, v, n) {
    var q = this;
    q.isErrorGetter = v.mdIsError && b(v.mdIsError);
    q.delegateClick = function () {
      q.input.focus();
    };
    q.element = m;
    q.setFocused = function (r) {
      m.toggleClass("md-input-focused", !!r);
    };
    q.setHasValue = function (r) {
      m.toggleClass("md-input-has-value", !!r);
    };
    q.setHasPlaceholder = function (r) {
      m.toggleClass("md-input-has-placeholder", !!r);
    };
    q.setInvalid = function (r) {
      r ? n.addClass(m, "md-input-invalid") : n.removeClass(m, "md-input-invalid");
    };
    l.$watch(
      function () {
        return q.label && q.input;
      },
      function (r) {
        r && !q.label.attr("for") && q.label.attr("for", q.input.attr("id"));
      }
    );
  }
  e.$inject = ["$scope", "$element", "$attrs", "$animate"];
  var f = ["INPUT", "TEXTAREA", "SELECT", "MD-SELECT"],
    g = f
      .reduce(function (l, m) {
        return l.concat(["md-icon ~ " + m, ".md-icon ~ " + m]);
      }, [])
      .join(","),
    h = f
      .reduce(function (l, m) {
        return l.concat([m + " ~ md-icon", m + " ~ .md-icon"]);
      }, [])
      .join(",");
  return { restrict: "E", compile: c, controller: e };
}
function labelDirective() {
  return {
    restrict: "E",
    require: "^?mdInputContainer",
    link: function (a, b, d, c) {
      !c ||
        d.mdNoFloat ||
        b.hasClass("md-container-ignore") ||
        ((c.label = b),
        a.$on("$destroy", function () {
          c.label = null;
        }));
    }
  };
}
function inputTextareaDirective(a, b, d, c, e) {
  function f(g, h, l, m) {
    function v(w) {
      x.setHasValue(!k.$isEmpty(w));
      return w;
    }
    function n() {
      x.label &&
        l.$observe("required", function (w) {
          x.label.toggleClass("md-required", w && !t);
        });
    }
    function q() {
      x.setHasValue(0 < h.val().length || (h[0].validity || {}).badInput);
    }
    function r() {
      function w() {
        h.attr("rows", 1).css("height", "auto").addClass("md-no-flex");
        var K = O.offsetHeight;
        var M = O.scrollHeight - K;
        K += Math.max(M, 0);
        F || ((M = h[0].style.padding || ""), (F = h.css("padding", 0).prop("offsetHeight")), (h[0].style.padding = M));
        G && F && (K = Math.max(K, F * G));
        N && F && ((M = F * N), M < K ? (h.attr("md-no-autogrow", ""), (K = M)) : h.removeAttr("md-no-autogrow"));
        F && h.attr("rows", Math.round(K / F));
        h.css("height", K + "px").removeClass("md-no-flex");
      }
      function B(K) {
        a.nextTick(w);
        return K;
      }
      function u() {
        if (D && ((D = !1), angular.element(b).off("resize", w), C && C(), h.attr("md-no-autogrow", "").off("input", w), y)) {
          var K = k.$formatters.indexOf(B);
          -1 < K && k.$formatters.splice(K, 1);
        }
      }
      function z() {
        function K(X) {
          X.preventDefault();
          T = !0;
          Y = parseFloat(h.css("height")) || h.prop("offsetHeight");
        }
        function M(X) {
          T && (X.preventDefault(), u(), R.addClass("md-input-resized"));
        }
        function I(X) {
          T && h.css("height", Y + X.pointer.distanceY + "px");
        }
        function J() {
          T && ((T = !1), R.removeClass("md-input-resized"));
        }
        if (!l.hasOwnProperty("mdNoResize")) {
          var Q = angular.element('<div class="md-resize-handle"></div>'),
            T = !1,
            Y = 0,
            R = x.element,
            U = e.register(Q, "drag", { horizontal: !1 });
          h.wrap('<div class="md-resize-wrapper">').after(Q);
          Q.on("mousedown", K);
          R.on("$md.dragstart", M).on("$md.drag", I).on("$md.dragend", J);
          g.$on("$destroy", function () {
            Q.off("mousedown", K).remove();
            R.off("$md.dragstart", M).off("$md.drag", I).off("$md.dragend", J);
            U();
            U = R = Q = null;
          });
        }
      }
      var D = !l.hasOwnProperty("mdNoAutogrow");
      z();
      if (D) {
        var G = l.hasOwnProperty("rows") ? parseInt(l.rows) : NaN,
          N = l.hasOwnProperty("maxRows") ? parseInt(l.maxRows) : NaN,
          C = g.$on("md-resize-textarea", w),
          F = null,
          O = h[0];
        c(
          function () {
            a.nextTick(w);
          },
          10,
          !1
        );
        h.on("input", w);
        y && k.$formatters.push(B);
        G || h.attr("rows", 1);
        angular.element(b).on("resize", w);
        g.$on("$destroy", u);
        if (l.hasOwnProperty("mdDetectHidden")) {
          var S = (function () {
            var K = !1;
            return function () {
              var M = 0 === O.offsetHeight;
              !1 === M && !0 === K && w();
              K = M;
            };
          })();
          g.$watch(function () {
            a.nextTick(S, !1);
            return !0;
          });
        }
      }
    }
    var x = m[0],
      y = !!m[1],
      k = m[1] || a.fakeNgModel(),
      p = m[2];
    m = angular.isDefined(l.readonly);
    var t = a.parseAttributeBoolean(l.mdNoAsterisk),
      H = h[0].tagName.toLowerCase();
    if (x)
      if ("hidden" === l.type) h.attr("aria-hidden", "true");
      else {
        if (x.input) {
          if (x.input[0].contains(h[0])) return;
          throw Error("<md-input-container> can only have *one* <input>, <textarea> or <md-select> child element!");
        }
        x.input = h;
        n();
        var A = angular.element('<div class="md-errors-spacer">');
        h.after(A);
        A = angular.isString(l.placeholder) ? l.placeholder.trim() : "";
        x.label || A.length || d.expect(h, "aria-label");
        h.addClass("md-input");
        h.attr("id") || h.attr("id", "input_" + a.nextUid());
        "input" === H && "number" === l.type && l.min && l.max && !l.step ? h.attr("step", "any") : "textarea" === H && r();
        y || q();
        H =
          x.isErrorGetter ||
          function () {
            return k.$invalid && (k.$touched || (p && p.$submitted));
          };
        g.$watch(H, x.setInvalid);
        l.ngValue && l.$observe("value", q);
        k.$parsers.push(v);
        k.$formatters.push(v);
        h.on("input", q);
        if (!m)
          h.on("focus", function () {
            a.nextTick(function () {
              x.setFocused(!0);
            });
          }).on("blur", function () {
            a.nextTick(function () {
              x.setFocused(!1);
              q();
            });
          });
        g.$on("$destroy", function () {
          x.setFocused(!1);
          x.setHasValue(!1);
          x.input = null;
        });
      }
  }
  return { restrict: "E", require: ["^?mdInputContainer", "?ngModel", "?^form"], link: f };
}
function mdMaxlengthDirective(a, b) {
  function d(c, e, f, g) {
    function h(k) {
      k = x && !y && angular.isString(k) ? k.trim() : k;
      if (void 0 === k || null === k) k = "";
      return String(k).length;
    }
    function l() {
      q && q.parent() && q.text(h(e.val()) + " / " + m);
    }
    var m = parseInt(f.mdMaxlength);
    isNaN(m) && (m = -1);
    var v = g[0],
      n = g[1],
      q,
      r,
      x = angular.isDefined(f.ngTrim) ? b.parseAttributeBoolean(f.ngTrim) : !0,
      y = "password" === f.type;
    c.$watch(f.mdMaxlength, function (k) {
      m = k;
    });
    v.$validators["md-maxlength"] = function (k, p) {
      if (!angular.isNumber(m) || 0 > m) return !0;
      l();
      k = e.val() || p;
      if (void 0 === k || null === k) k = "";
      k = x && !y && angular.isString(k) ? k.trim() : k;
      return String(k).length <= m;
    };
    v.$isEmpty = function (k) {
      return 0 === h(k);
    };
    b.nextTick(function () {
      r = angular.element(n.element[0].querySelector(".md-errors-spacer"));
      q = angular.element('<div class="md-char-counter">');
      r.append(q);
      f.$observe("ngTrim", function (k) {
        x = angular.isDefined(k) ? b.parseAttributeBoolean(k) : !0;
      });
      c.$watch(f.mdMaxlength, function (k) {
        angular.isNumber(k) && 0 < k ? (q.parent().length || a.enter(q, r), l()) : a.leave(q);
      });
    });
  }
  return { restrict: "A", require: ["ngModel", "^mdInputContainer"], link: d };
}
function placeholderDirective(a) {
  function b(d, c, e, f) {
    if (f) {
      var g = f.element.find("label"),
        h = f.element.attr("md-no-float");
      (g && g.length) || "" === h || d.$eval(h)
        ? f.setHasPlaceholder(!0)
        : "MD-SELECT" !== c[0].nodeName &&
          ((c = angular.element('<label ng-click="delegateClick()" tabindex="-1" aria-hidden="true">' + e.placeholder + "</label>")),
          e.$set("placeholder", null),
          f.element.addClass("md-icon-float").prepend(c),
          a(c)(d));
    }
  }
  return { restrict: "A", require: "^^?mdInputContainer", priority: 200, link: { pre: b } };
}
function mdSelectOnFocusDirective(a, b) {
  function d(c, e) {
    function f() {
      h = !0;
      b(
        function () {
          a[0].activeElement === e[0] && e[0].select();
          h = !1;
        },
        1,
        !1
      );
    }
    function g(l) {
      h && l.preventDefault();
    }
    if ("INPUT" === e[0].nodeName || "TEXTAREA" === e[0].nodeName) {
      var h = !1;
      e.on("focus", f).on("mouseup", g);
      c.$on("$destroy", function () {
        e.off("focus", f).off("mouseup", g);
      });
    }
  }
  return { restrict: "A", link: d };
}
var visibilityDirectives = ["ngIf", "ngShow", "ngHide", "ngSwitchWhen", "ngSwitchDefault"];
function ngMessagesDirective() {
  function a(d, c, e, f) {
    f &&
      (c.toggleClass("md-input-messages-animation", !0),
      c.toggleClass("md-auto-hide", !0),
      ("false" == e.mdAutoHide || b(e)) && c.toggleClass("md-auto-hide", !1));
  }
  function b(d) {
    return visibilityDirectives.some(function (c) {
      return d[c];
    });
  }
  return { restrict: "EA", link: a, require: "^^?mdInputContainer" };
}
function ngMessageDirective(a) {
  function b(d) {
    function c() {
      for (var f = d[0]; (f = f.parentNode); ) if (f.nodeType === Node.DOCUMENT_FRAGMENT_NODE) return !0;
      return !1;
    }
    function e(f) {
      f.toggleClass("md-input-message-animation", !0);
    }
    if (a.getClosest(d, "md-input-container")) e(d);
    else if (c())
      return function (f, g) {
        a.getClosest(g, "md-input-container") && e(d);
      };
  }
  return { restrict: "EA", compile: b, priority: 100 };
}
var $$AnimateRunner, $animateCss, $mdUtil;
function mdInputInvalidMessagesAnimation(a, b, d) {
  saveSharedServices(a, b, d);
  return {
    addClass: function (c, e, f) {
      showInputMessages(c, f);
    }
  };
}
function ngMessagesAnimation(a, b, d) {
  saveSharedServices(a, b, d);
  return {
    enter: function (c, e) {
      showInputMessages(c, e);
    },
    leave: function (c, e) {
      hideInputMessages(c, e);
    },
    addClass: function (c, e, f) {
      "ng-hide" == e ? hideInputMessages(c, f) : f();
    },
    removeClass: function (c, e, f) {
      "ng-hide" == e ? showInputMessages(c, f) : f();
    }
  };
}
function ngMessageAnimation(a, b, d, c) {
  saveSharedServices(a, b, d, c);
  return {
    enter: function (e, f) {
      e = showMessage(e);
      e.start().done(f);
    },
    leave: function (e, f) {
      e = hideMessage(e);
      e.start().done(f);
    }
  };
}
function showInputMessages(a, b) {
  var d = [],
    c;
  a = getMessagesElement(a);
  var e = a.children();
  0 == a.length || 0 == e.length
    ? b()
    : (angular.forEach(e, function (f) {
        c = showMessage(angular.element(f));
        d.push(c.start());
      }),
      $$AnimateRunner.all(d, b));
}
function hideInputMessages(a, b) {
  var d = [],
    c;
  a = getMessagesElement(a);
  var e = a.children();
  0 == a.length || 0 == e.length
    ? b()
    : (angular.forEach(e, function (f) {
        c = hideMessage(angular.element(f));
        d.push(c.start());
      }),
      $$AnimateRunner.all(d, b));
}
function showMessage(a) {
  var b = parseInt(window.getComputedStyle(a[0]).height),
    d = parseInt(window.getComputedStyle(a[0]).marginTop),
    c = getMessagesElement(a);
  var e = a.controller("mdInputContainer");
  e = e.element;
  return (d = d > -b) || (c.hasClass("md-auto-hide") && !e.hasClass("md-input-invalid"))
    ? $animateCss(a, {})
    : $animateCss(a, {
        event: "enter",
        structural: !0,
        from: { opacity: 0, "margin-top": -b + "px" },
        to: { opacity: 1, "margin-top": "0" },
        duration: 0.3
      });
}
function hideMessage(a) {
  var b = a[0].offsetHeight,
    d = window.getComputedStyle(a[0]);
  return 0 === parseInt(d.opacity)
    ? $animateCss(a, {})
    : $animateCss(a, {
        event: "leave",
        structural: !0,
        from: { opacity: 1, "margin-top": 0 },
        to: { opacity: 0, "margin-top": -b + "px" },
        duration: 0.3
      });
}
function getMessagesElement(a) {
  return a.hasClass("md-input-messages-animation")
    ? a
    : a.hasClass("md-input-message-animation")
    ? angular.element(
        $mdUtil.getClosest(a, function (b) {
          return b.classList.contains("md-input-messages-animation");
        })
      )
    : angular.element(a[0].querySelector(".md-input-messages-animation"));
}
function saveSharedServices(a, b, d) {
  $$AnimateRunner = a;
  $animateCss = b;
  $mdUtil = d;
}
ngmaterial.components.input = angular.module("material.components.input");
MdListController.$inject = ["$scope", "$element", "$mdListInkRipple"];
mdListDirective.$inject = ["$mdTheming"];
mdListItemDirective.$inject = ["$mdAria", "$mdConstant", "$mdUtil", "$timeout"];
angular
  .module("material.components.list", ["material.core"])
  .controller("MdListController", MdListController)
  .directive("mdList", mdListDirective)
  .directive("mdListItem", mdListItemDirective);
function mdListDirective(a) {
  return {
    restrict: "E",
    compile: function (b) {
      b[0].setAttribute("role", "list");
      return a;
    }
  };
}
function mdListItemDirective(a, b, d, c) {
  var e = ["md-checkbox", "md-switch", "md-menu"];
  return {
    restrict: "E",
    controller: "MdListController",
    compile: function (f, g) {
      function h() {
        for (var A = ["md-switch", "md-checkbox"], w, B = 0, u; (u = A[B]); ++B)
          if ((w = f.find(u)[0]) && !w.hasAttribute("aria-label")) {
            u = f.find("p")[0];
            if (!u) break;
            w.setAttribute("aria-label", "Toggle " + u.textContent);
          }
      }
      function l() {
        var A = angular.element(y),
          w = A.parent().hasClass("md-secondary-container") || y.parentNode.firstElementChild !== y,
          B = "left";
        w && (B = "right");
        A.attr("md-position-mode") || A.attr("md-position-mode", B + " target");
        A = A.children().eq(0);
        q(A[0]) || A.attr("ng-click", "$mdMenu.open($event)");
        A.attr("aria-label") || A.attr("aria-label", "Open List Menu");
      }
      function m(A) {
        "div" == A
          ? ((k = angular.element('<div class="md-no-style md-list-item-inner">')), k.append(f.contents()), f.addClass("md-proxy-focus"))
          : ((k = angular.element('<div class="md-button md-no-style">   <div class="md-list-item-inner"></div></div>')),
            (A = angular.element('<md-button class="md-no-style"></md-button>')),
            n(f[0], A[0]),
            A.attr("aria-label") || A.attr("aria-label", a.getText(f)),
            f.hasClass("md-no-focus") && A.addClass("md-no-focus"),
            k.prepend(A),
            k.children().eq(1).append(f.contents()),
            f.addClass("_md-button-wrap"));
        f[0].setAttribute("tabindex", "-1");
        f.append(k);
      }
      function v() {
        var A = angular.element('<div class="md-secondary-container">');
        angular.forEach(x, function (w) {
          var B = A,
            u;
          if ((u = w)) (u = w.nodeName.toUpperCase()), (u = "MD-BUTTON" == u || "BUTTON" == u), (u = !u);
          u &&
            w.hasAttribute("ng-click") &&
            (a.expect(w, "aria-label"),
            (u = angular.element('<md-button class="md-secondary md-icon-button">')),
            n(w, u[0], ["ng-if", "ng-hide", "ng-show"]),
            w.setAttribute("tabindex", "-1"),
            u.append(w),
            (w = u[0]));
          w && (!q(w) || (!g.ngClick && -1 != e.indexOf(w.nodeName.toLowerCase()))) && angular.element(w).removeClass("md-secondary");
          f.addClass("md-with-secondary");
          B.append(w);
        });
        k.append(A);
      }
      function n(A, w, B) {
        var u = d.prefixer(
          "ng-if ng-click ng-dblclick aria-label ng-disabled ui-sref href ng-href rel target ng-attr-ui-sref ui-sref-opts download".split(
            " "
          )
        );
        B && (u = u.concat(d.prefixer(B)));
        angular.forEach(u, function (z) {
          A.hasAttribute(z) && (w.setAttribute(z, A.getAttribute(z)), A.removeAttribute(z));
        });
      }
      function q(A) {
        A = A.attributes;
        for (var w = 0; w < A.length; w++) if ("ngClick" === g.$normalize(A[w].name)) return !0;
        return !1;
      }
      function r(A, w, B, u) {
        function z() {
          N &&
            N.children &&
            !F &&
            !O &&
            angular.forEach(e, function (K) {
              angular.forEach(N.querySelectorAll(K + ":not(.md-secondary)"), function (M) {
                G.push(M);
              });
            });
        }
        function D(K) {
          var M = ["md-slider"];
          if (!K.path) return -1 !== M.indexOf(K.target.tagName.toLowerCase());
          for (var I = K.path.indexOf(w.children()[0]), J = 0; J < I; J++) if (-1 !== M.indexOf(K.path[J].tagName.toLowerCase())) return !0;
        }
        w.addClass("_md");
        var G = [],
          N = w[0].firstElementChild,
          C = (B = w.hasClass("_md-button-wrap")) ? N.firstElementChild : N,
          F = C && q(C),
          O = w.hasClass("md-no-proxy");
        z();
        if (1 == G.length || F) w.addClass("md-clickable"), F || u.attachRipple(A, angular.element(w[0].querySelector(".md-no-style")));
        G.length &&
          angular.forEach(G, function (K) {
            K = angular.element(K);
            A.mouseActive = !1;
            K.on("mousedown", function () {
              A.mouseActive = !0;
              c(function () {
                A.mouseActive = !1;
              }, 100);
            }).on("focus", function () {
              !1 === A.mouseActive && w.addClass("md-focused");
              K.on("blur", function I() {
                w.removeClass("md-focused");
                K.off("blur", I);
              });
            });
          });
        var S = function (K) {
          if ("INPUT" != K.target.nodeName && "TEXTAREA" != K.target.nodeName && !K.target.isContentEditable) {
            var M = K.which || K.keyCode;
            M == b.KEY_CODE.SPACE && C && (C.click(), K.preventDefault(), K.stopPropagation());
          }
        };
        F || G.length || (C && C.addEventListener("keypress", S));
        w.off("click");
        w.off("keypress");
        if (1 == G.length && C)
          w.children()
            .eq(0)
            .on("click", function (K) {
              if (!D(K)) {
                var M = d.getClosest(K.target, "BUTTON");
                !M &&
                  C.contains(K.target) &&
                  angular.forEach(G, function (I) {
                    K.target === I ||
                      I.contains(K.target) ||
                      ("MD-MENU" === I.nodeName && (I = I.children[0]), angular.element(I).triggerHandler("click"));
                  });
              }
            });
        A.$on("$destroy", function () {
          C && C.removeEventListener("keypress", S);
        });
      }
      var x = f[0].querySelectorAll(".md-secondary"),
        y,
        k = f;
      f[0].setAttribute("role", "listitem");
      if (g.ngClick || g.ngDblclick || g.ngHref || g.href || g.uiSref || g.ngAttrUiSref) m("button");
      else if (!f.hasClass("md-no-proxy")) {
        for (var p = 0, t; (t = e[p]); ++p)
          if ((y = f[0].querySelector(t))) {
            var H = !0;
            break;
          }
        H ? m("div") : f.addClass("md-no-proxy");
      }
      v();
      h();
      H && "MD-MENU" === y.nodeName && l();
      return r;
    }
  };
}
function MdListController(a, b, d) {
  function c(e, f) {
    var g = {};
    d.attach(e, f, g);
  }
  a = this;
  a.attachRipple = c;
}
ngmaterial.components.list = angular.module("material.components.list");
angular.module("material.components.menu", ["material.core", "material.components.backdrop"]);
MenuController.$inject = "$mdMenu $attrs $element $scope $mdUtil $timeout $rootScope $q $log".split(" ");
angular.module("material.components.menu").controller("mdMenuCtrl", MenuController);
function MenuController(a, b, d, c, e, f, g, h, l) {
  var m = e.prefixer(),
    v,
    n = this,
    q;
  this.nestLevel = parseInt(b.mdNestLevel, 10) || 0;
  this.init = function (k, p) {
    p = p || {};
    v = k;
    q = d[0].querySelector(m.buildSelector(["ng-click", "ng-mouseenter"]));
    q.setAttribute("aria-expanded", "false");
    this.isInMenuBar = p.isInMenuBar;
    this.nestedMenus = e.nodesToArray(v[0].querySelectorAll(".md-nested-menu"));
    v.on("$mdInterimElementRemove", function () {
      n.isOpen = !1;
      e.nextTick(function () {
        n.onIsOpenChanged(n.isOpen);
      });
    });
    e.nextTick(function () {
      n.onIsOpenChanged(n.isOpen);
    });
    k = "menu_container_" + e.nextUid();
    v.attr("id", k);
    angular.element(q).attr({ "aria-owns": k, "aria-haspopup": "true" });
    c.$on(
      "$destroy",
      angular.bind(this, function () {
        this.disableHoverListener();
        a.destroy();
      })
    );
    v.on("$destroy", function () {
      a.destroy();
    });
  };
  var r,
    x,
    y = [];
  this.enableHoverListener = function () {
    y.push(
      g.$on("$mdMenuOpen", function (k, p) {
        v[0].contains(p[0]) &&
          ((n.currentlyOpenMenu = p.controller("mdMenu")),
          (n.isAlreadyOpening = !1),
          n.currentlyOpenMenu.registerContainerProxy(n.triggerContainerProxy.bind(n)));
      })
    );
    y.push(
      g.$on("$mdMenuClose", function (k, p) {
        v[0].contains(p[0]) && (n.currentlyOpenMenu = void 0);
      })
    );
    x = angular.element(e.nodesToArray(v[0].children[0].children));
    x.on("mouseenter", n.handleMenuItemHover);
    x.on("mouseleave", n.handleMenuItemMouseLeave);
  };
  this.disableHoverListener = function () {
    for (; y.length; ) y.shift()();
    x && x.off("mouseenter", n.handleMenuItemHover);
    x && x.off("mouseleave", n.handleMenuItemMouseLeave);
  };
  this.handleMenuItemHover = function (k) {
    if (!n.isAlreadyOpening) {
      var p = k.target.querySelector("md-menu") || e.getClosest(k.target, "MD-MENU");
      r = f(
        function () {
          p && (p = angular.element(p).controller("mdMenu"));
          if (n.currentlyOpenMenu && n.currentlyOpenMenu != p) {
            var t = n.nestLevel + 1;
            n.currentlyOpenMenu.close(!0, { closeTo: t });
            n.isAlreadyOpening = !!p;
            p && p.open();
          } else p && !p.isOpen && p.open && ((n.isAlreadyOpening = !!p), p && p.open());
        },
        p ? 100 : 250
      );
      (k = k.currentTarget.querySelector(".md-button:not([disabled])")) && k.focus();
    }
  };
  this.handleMenuItemMouseLeave = function () {
    r && (f.cancel(r), (r = void 0));
  };
  this.open = function (k) {
    k && k.stopPropagation();
    k && k.preventDefault();
    n.isOpen ||
      (n.enableHoverListener(),
      (n.isOpen = !0),
      e.nextTick(function () {
        n.onIsOpenChanged(n.isOpen);
      }),
      (q = q || (k ? k.target : d[0])),
      q.setAttribute("aria-expanded", "true"),
      c.$emit("$mdMenuOpen", d),
      a
        .show({ scope: c, mdMenuCtrl: n, nestLevel: n.nestLevel, element: v, target: q, preserveElement: !0, parent: "body" })
        .finally(function () {
          q.setAttribute("aria-expanded", "false");
          n.disableHoverListener();
        }));
  };
  this.onIsOpenChanged = function (k) {
    k
      ? (v.attr("aria-hidden", "false"),
        d[0].classList.add("md-open"),
        angular.forEach(n.nestedMenus, function (p) {
          p.classList.remove("md-open");
        }))
      : (v.attr("aria-hidden", "true"), d[0].classList.remove("md-open"));
    c.$mdMenuIsOpen = n.isOpen;
  };
  this.focusMenuContainer = function () {
    var k = v[0].querySelector(m.buildSelector(["md-menu-focus-target", "md-autofocus"]));
    k || (k = v[0].querySelector(".md-button:not([disabled])"));
    k.focus();
  };
  this.registerContainerProxy = function (k) {
    this.containerProxy = k;
  };
  this.triggerContainerProxy = function (k) {
    this.containerProxy && this.containerProxy(k);
  };
  this.destroy = function () {
    return n.isOpen ? a.destroy() : h.when(!1);
  };
  this.close = function (k, p) {
    if (n.isOpen) {
      n.isOpen = !1;
      e.nextTick(function () {
        n.onIsOpenChanged(n.isOpen);
      });
      var t = angular.extend({}, p, { skipFocus: k });
      c.$emit("$mdMenuClose", d, t);
      a.hide(null, p);
      k || ((k = n.restoreFocusTo || d.find("button")[0]), k instanceof angular.element && (k = k[0]), k && k.focus());
    }
  };
  this.positionMode = function () {
    var k = (b.mdPositionMode || "target").split(" ");
    1 === k.length && k.push(k[0]);
    return { left: k[0], top: k[1] };
  };
  this.offsets = function () {
    var k = (b.mdOffset || "0 0").split(" ").map(parseFloat);
    if (2 === k.length) return { left: k[0], top: k[1] };
    if (1 === k.length) return { top: k[0], left: k[0] };
    throw Error("Invalid offsets specified. Please follow format <x, y> or <n>");
  };
  c.$mdMenu = { open: this.open, close: this.close };
  c.$mdOpenMenu = angular.bind(this, function () {
    l.warn("mdMenu: The $mdOpenMenu method is deprecated. Please use `$mdMenu.open`.");
    return this.open.apply(this, arguments);
  });
}
MenuDirective.$inject = ["$mdUtil"];
angular.module("material.components.menu").directive("mdMenu", MenuDirective);
function MenuDirective(a) {
  function b(c) {
    c.addClass("md-menu");
    var e = c.children()[0],
      f = a.prefixer();
    f.hasAttribute(e, "ng-click") || (e = e.querySelector(f.buildSelector(["ng-click", "ng-mouseenter"])) || e);
    f = "MD-BUTTON" === e.nodeName || "BUTTON" === e.nodeName;
    e && f && !e.hasAttribute("type") && e.setAttribute("type", "button");
    if (!e) throw Error("Invalid HTML for md-menu: Expected the menu to have a trigger element.");
    if (2 !== c.children().length)
      throw Error("Invalid HTML for md-menu: Expected two children elements. The second element must have a `md-menu-content` element.");
    e && e.setAttribute("aria-haspopup", "true");
    e = c[0].querySelectorAll("md-menu");
    var g = parseInt(c[0].getAttribute("md-nest-level"), 10) || 0;
    e &&
      angular.forEach(a.nodesToArray(e), function (h) {
        h.hasAttribute("md-position-mode") || h.setAttribute("md-position-mode", "cascade");
        h.classList.add("_md-nested-menu");
        h.setAttribute("md-nest-level", g + 1);
      });
    return d;
  }
  function d(c, e, f, g) {
    c = g[0];
    g = !!g[1];
    var h = angular.element('<div class="_md md-open-menu-container md-whiteframe-z2"></div>');
    f = e.children()[1];
    e.addClass("_md");
    f.hasAttribute("role") || f.setAttribute("role", "menu");
    h.append(f);
    e.on("$destroy", function () {
      h.remove();
    });
    e.append(h);
    h[0].style.display = "none";
    c.init(h, { isInMenuBar: g });
  }
  return { restrict: "E", require: ["mdMenu", "?^mdMenuBar"], controller: "mdMenuCtrl", scope: !0, compile: b };
}
MenuProvider.$inject = ["$$interimElementProvider"];
angular.module("material.components.menu").provider("$mdMenu", MenuProvider);
function MenuProvider(a) {
  function b(c, e, f, g, h, l, m, v, n, q) {
    function r(A, w, B) {
      if (B.nestLevel) return angular.noop;
      B.disableParentScroll && !c.getClosest(B.target, "MD-DIALOG")
        ? (B.restoreScroll = c.disableScrollAround(B.element, B.parent))
        : (B.disableParentScroll = !1);
      B.hasBackdrop && ((B.backdrop = c.createBackdrop(A, "md-menu-backdrop md-click-catcher")), n.enter(B.backdrop, g[0].body));
      return function () {
        B.backdrop && B.backdrop.remove();
        B.disableParentScroll && B.restoreScroll();
      };
    }
    function x(A, w, B) {
      function u() {
        w.removeClass("md-active");
        var z = w,
          D = B;
        D.preserveElement ? (d(z).style.display = "none") : d(z).parentNode === d(D.parent) && d(D.parent).removeChild(d(z));
        B.alreadyOpen = !1;
      }
      B.cleanupInteraction();
      B.cleanupBackdrop();
      B.cleanupResizing();
      B.hideBackdrop();
      w.removeClass("md-clickable");
      return !0 === B.$destroy ? u() : v(w, { addClass: "md-leave" }).start().then(u);
    }
    function y(A, w, B) {
      function u() {
        B.parent.append(w);
        w[0].style.display = "";
        return l(function (C) {
          var F = p(w, B);
          w.removeClass("md-leave");
          v(w, { addClass: "md-active", from: H.toCss(F), to: H.toCss({ transform: "" }) })
            .start()
            .then(C);
        });
      }
      function z() {
        var C = (function (F, O) {
          return m.throttle(function () {
            if (!B.isRemoved) {
              var S = p(F, O);
              F.css(H.toCss(S));
            }
          });
        })(w, B);
        h.addEventListener("resize", C);
        h.addEventListener("orientationchange", C);
        return function () {
          h.removeEventListener("resize", C);
          h.removeEventListener("orientationchange", C);
        };
      }
      function D() {
        if (!B.backdrop) return angular.noop;
        B.backdrop.on("click", G);
        return function () {
          B.backdrop.off("click", G);
        };
      }
      function G(C) {
        C.preventDefault();
        C.stopPropagation();
        A.$apply(function () {
          B.mdMenuCtrl.close(!0, { closeAll: !0 });
        });
      }
      function N() {
        function C(I) {
          switch (I.keyCode) {
            case f.KEY_CODE.ESCAPE:
              B.mdMenuCtrl.close(!1, { closeAll: !0 });
              var J = !0;
              break;
            case f.KEY_CODE.TAB:
              B.mdMenuCtrl.close(!1, { closeAll: !0 });
              J = !1;
              break;
            case f.KEY_CODE.UP_ARROW:
              k(I, B.menuContentEl, B, -1) || B.nestLevel || B.mdMenuCtrl.triggerContainerProxy(I);
              J = !0;
              break;
            case f.KEY_CODE.DOWN_ARROW:
              k(I, B.menuContentEl, B, 1) || B.nestLevel || B.mdMenuCtrl.triggerContainerProxy(I);
              J = !0;
              break;
            case f.KEY_CODE.LEFT_ARROW:
              B.nestLevel ? B.mdMenuCtrl.close() : B.mdMenuCtrl.triggerContainerProxy(I);
              J = !0;
              break;
            case f.KEY_CODE.RIGHT_ARROW:
              (J = c.getClosest(I.target, "MD-MENU")) && J != B.parent[0] ? I.target.click() : B.mdMenuCtrl.triggerContainerProxy(I),
                (J = !0);
          }
          J && (I.preventDefault(), I.stopImmediatePropagation());
        }
        function F(I) {
          function J() {
            A.$apply(function () {
              B.mdMenuCtrl.close(!0, { closeAll: !0 });
            });
          }
          function Q(Y, R) {
            if (!Y) return !1;
            for (var U = 0, X; (X = R[U]); ++U) if (t.hasAttribute(Y, X)) return !0;
            return !1;
          }
          I = I.target;
          do {
            if (I == B.menuContentEl[0]) break;
            if (
              (Q(I, ["ng-click", "ng-href", "ui-sref"]) || "BUTTON" == I.nodeName || "MD-BUTTON" == I.nodeName) &&
              !Q(I, ["md-prevent-menu-close"])
            ) {
              var T = c.getClosest(I, "MD-MENU");
              I.hasAttribute("disabled") || (T && T != B.parent[0]) || J();
              break;
            }
          } while ((I = I.parentNode));
        }
        if (!B.menuContentEl[0]) return angular.noop;
        B.menuContentEl.on("keydown", C);
        B.menuContentEl[0].addEventListener("click", F, !0);
        var O = B.menuContentEl[0].querySelector(t.buildSelector(["md-menu-focus-target", "md-autofocus"]));
        if (!O)
          for (var S = B.menuContentEl[0].children.length, K = 0; K < S; K++) {
            var M = B.menuContentEl[0].children[K];
            if ((O = M.querySelector(".md-button:not([disabled])"))) break;
            if (M.firstElementChild && !M.firstElementChild.disabled) {
              O = M.firstElementChild;
              break;
            }
          }
        O && O.focus();
        return function () {
          B.menuContentEl.off("keydown", C);
          B.menuContentEl[0].removeEventListener("click", F, !0);
        };
      }
      if (!B.target) throw Error("$mdMenu.show() expected a target to animate from in options.target");
      angular.extend(B, {
        alreadyOpen: !1,
        isRemoved: !1,
        target: angular.element(B.target),
        parent: angular.element(B.parent),
        menuContentEl: angular.element(w[0].querySelector("md-menu-content"))
      });
      B.menuContentEl[0]
        ? e.inherit(B.menuContentEl, B.target)
        : q.warn(
            "$mdMenu: Menu elements should always contain a `md-menu-content` element,otherwise interactivity features will not work properly.",
            w
          );
      B.cleanupResizing = z();
      B.hideBackdrop = r(A, w, B);
      return u().then(function (C) {
        B.alreadyOpen = !0;
        B.cleanupInteraction = N();
        B.cleanupBackdrop = D();
        w.addClass("md-clickable");
        return C;
      });
    }
    function k(A, w, B, u) {
      A = c.getClosest(A.target, "MD-MENU-ITEM");
      w = c.nodesToArray(w[0].children);
      A = w.indexOf(A);
      for (A += u; 0 <= A && A < w.length; A += u) {
        var z = w[A].querySelector(".md-button");
        z && -1 != z.getAttribute("tabindex") ? (z.focus(), (z = g[0].activeElement == z)) : (z = void 0);
        if (z) break;
      }
      return z;
    }
    function p(A, w) {
      function B(Q) {
        Q.top = Math.max(Math.min(Q.top, S.bottom - z.offsetHeight), S.top);
        Q.left = Math.max(Math.min(Q.left, S.right - z.offsetWidth), S.left);
      }
      function u() {
        for (var Q = 0; Q < D.children.length; ++Q) if ("none" != h.getComputedStyle(D.children[Q]).display) return D.children[Q];
      }
      var z = A[0],
        D = A[0].firstElementChild,
        G = D.getBoundingClientRect(),
        N = g[0].body,
        C = N.getBoundingClientRect(),
        F = h.getComputedStyle(D),
        O = w.target[0].querySelector(t.buildSelector("md-menu-origin")) || w.target[0];
      N = O.getBoundingClientRect();
      var S = {
          left: C.left + 8,
          top: Math.max(C.top, 0) + 8,
          bottom: Math.max(C.bottom, Math.max(C.top, 0) + C.height) - 8,
          right: C.right - 8
        },
        K = { top: 0, left: 0, right: 0, bottom: 0 },
        M = { top: 0, left: 0, right: 0, bottom: 0 },
        I = w.mdMenuCtrl.positionMode();
      if ("target" === I.top || "target" === I.left || "target-right" === I.left)
        if ((C = u()))
          (C = C.firstElementChild || C),
            (C = C.querySelector(t.buildSelector("md-menu-align-target")) || C),
            (K = C.getBoundingClientRect()),
            (M = { top: parseFloat(z.style.top || 0), left: parseFloat(z.style.left || 0) });
      C = {};
      var J = "top ";
      switch (I.top) {
        case "target":
          C.top = M.top + N.top - K.top;
          break;
        case "cascade":
          C.top = N.top - parseFloat(F.paddingTop) - O.style.top;
          break;
        case "bottom":
          C.top = N.top + N.height;
          break;
        default:
          throw Error('Invalid target mode "' + I.top + '" specified for md-menu on Y axis.');
      }
      A = c.isRtl(A);
      switch (I.left) {
        case "target":
          C.left = M.left + N.left - K.left;
          J += A ? "right" : "left";
          break;
        case "target-left":
          C.left = N.left;
          J += "left";
          break;
        case "target-right":
          C.left = N.right - G.width + (G.right - K.right);
          J += "right";
          break;
        case "cascade":
          A = A ? N.left - G.width < S.left : N.right + G.width < S.right;
          C.left = A ? N.right - O.style.left : N.left - O.style.left - G.width;
          J += A ? "left" : "right";
          break;
        case "right":
          A ? ((C.left = N.right - N.width), (J += "left")) : ((C.left = N.right - G.width), (J += "right"));
          break;
        case "left":
          A ? ((C.left = N.right - G.width), (J += "right")) : ((C.left = N.left), (J += "left"));
          break;
        default:
          throw Error('Invalid target mode "' + I.left + '" specified for md-menu on X axis.');
      }
      G = w.mdMenuCtrl.offsets();
      C.top += G.top;
      C.left += G.left;
      B(C);
      G = Math.round(100 * Math.min(N.width / z.offsetWidth, 1)) / 100;
      N = Math.round(100 * Math.min(N.height / z.offsetHeight, 1)) / 100;
      return {
        top: Math.round(C.top),
        left: Math.round(C.left),
        transform: w.alreadyOpen ? void 0 : c.supplant("scale({0},{1})", [G, N]),
        transformOrigin: J
      };
    }
    var t = c.prefixer(),
      H = c.dom.animator;
    return {
      parent: "body",
      onShow: y,
      onRemove: x,
      hasBackdrop: !0,
      disableParentScroll: !0,
      skipCompile: !0,
      preserveScope: !0,
      multiple: !0,
      themable: !0
    };
  }
  function d(c) {
    c instanceof angular.element && (c = c[0]);
    return c;
  }
  b.$inject = "$mdUtil $mdTheming $mdConstant $document $window $q $$rAF $animateCss $animate $log".split(" ");
  return a("$mdMenu").setDefaults({ methods: ["target"], options: b });
}
ngmaterial.components.menu = angular.module("material.components.menu");
angular.module("material.components.menuBar", ["material.core", "material.components.icon", "material.components.menu"]);
MenuBarController.$inject = "$scope $rootScope $element $attrs $mdConstant $document $mdUtil $timeout".split(" ");
angular.module("material.components.menuBar").controller("MenuBarController", MenuBarController);
var BOUND_MENU_METHODS = ["handleKeyDown", "handleMenuHover", "scheduleOpenHoveredMenu", "cancelScheduledOpen"];
function MenuBarController(a, b, d, c, e, f, g, h) {
  this.$element = d;
  this.$attrs = c;
  this.$mdConstant = e;
  this.$mdUtil = g;
  this.$document = f;
  this.$scope = a;
  this.$rootScope = b;
  this.$timeout = h;
  var l = this;
  angular.forEach(BOUND_MENU_METHODS, function (m) {
    l[m] = angular.bind(l, l[m]);
  });
}
MenuBarController.prototype.init = function () {
  var a = this.$element,
    b = this.$mdUtil,
    d = this.$scope,
    c = this,
    e = [];
  a.on("keydown", this.handleKeyDown);
  this.parentToolbar = b.getClosest(a, "MD-TOOLBAR");
  e.push(
    this.$rootScope.$on("$mdMenuOpen", function (f, g) {
      -1 != c.getMenus().indexOf(g[0]) &&
        (a[0].classList.add("md-open"),
        g[0].classList.add("md-open"),
        (c.currentlyOpenMenu = g.controller("mdMenu")),
        c.currentlyOpenMenu.registerContainerProxy(c.handleKeyDown),
        c.enableOpenOnHover());
    })
  );
  e.push(
    this.$rootScope.$on("$mdMenuClose", function (f, g, h) {
      f = c.getMenus();
      -1 != f.indexOf(g[0]) && (a[0].classList.remove("md-open"), g[0].classList.remove("md-open"));
      if (a[0].contains(g[0])) {
        for (g = g[0]; g && -1 == f.indexOf(g); ) g = b.getClosest(g, "MD-MENU", !0);
        g &&
          (h.skipFocus || g.querySelector("button:not([disabled])").focus(),
          (c.currentlyOpenMenu = void 0),
          c.disableOpenOnHover(),
          c.setKeyboardMode(!0));
      }
    })
  );
  d.$on("$destroy", function () {
    for (c.disableOpenOnHover(); e.length; ) e.shift()();
  });
  this.setKeyboardMode(!0);
};
MenuBarController.prototype.setKeyboardMode = function (a) {
  a ? this.$element[0].classList.add("md-keyboard-mode") : this.$element[0].classList.remove("md-keyboard-mode");
};
MenuBarController.prototype.enableOpenOnHover = function () {
  if (!this.openOnHoverEnabled) {
    var a = this;
    a.openOnHoverEnabled = !0;
    a.parentToolbar &&
      (a.parentToolbar.classList.add("md-has-open-menu"),
      a.$mdUtil.nextTick(function () {
        angular.element(a.parentToolbar).on("click", a.handleParentClick);
      }, !1));
    angular.element(a.getMenus()).on("mouseenter", a.handleMenuHover);
  }
};
MenuBarController.prototype.handleMenuHover = function (a) {
  this.setKeyboardMode(!1);
  this.openOnHoverEnabled && this.scheduleOpenHoveredMenu(a);
};
MenuBarController.prototype.disableOpenOnHover = function () {
  this.openOnHoverEnabled &&
    ((this.openOnHoverEnabled = !1),
    this.parentToolbar &&
      (this.parentToolbar.classList.remove("md-has-open-menu"), angular.element(this.parentToolbar).off("click", this.handleParentClick)),
    angular.element(this.getMenus()).off("mouseenter", this.handleMenuHover));
};
MenuBarController.prototype.scheduleOpenHoveredMenu = function (a) {
  a = angular.element(a.currentTarget);
  a = a.controller("mdMenu");
  this.setKeyboardMode(!1);
  this.scheduleOpenMenu(a);
};
MenuBarController.prototype.scheduleOpenMenu = function (a) {
  var b = this,
    d = this.$timeout;
  a != b.currentlyOpenMenu &&
    (d.cancel(b.pendingMenuOpen),
    (b.pendingMenuOpen = d(
      function () {
        b.pendingMenuOpen = void 0;
        b.currentlyOpenMenu && b.currentlyOpenMenu.close(!0, { closeAll: !0 });
        a.open();
      },
      200,
      !1
    )));
};
MenuBarController.prototype.handleKeyDown = function (a) {
  var b = this.$mdConstant.KEY_CODE,
    d = this.currentlyOpenMenu,
    c = d && d.isOpen;
  this.setKeyboardMode(!0);
  switch (a.keyCode) {
    case b.DOWN_ARROW:
      d ? d.focusMenuContainer() : this.openFocusedMenu();
      var e = !0;
      break;
    case b.UP_ARROW:
      d && d.close();
      e = !0;
      break;
    case b.LEFT_ARROW:
      b = this.focusMenu(-1);
      c && ((c = angular.element(b).controller("mdMenu")), this.scheduleOpenMenu(c));
      e = !0;
      break;
    case b.RIGHT_ARROW:
      (b = this.focusMenu(1)), c && ((c = angular.element(b).controller("mdMenu")), this.scheduleOpenMenu(c)), (e = !0);
  }
  e && (a && a.preventDefault && a.preventDefault(), a && a.stopImmediatePropagation && a.stopImmediatePropagation());
};
MenuBarController.prototype.focusMenu = function (a) {
  var b = this.getMenus(),
    d = this.getFocusedMenuIndex();
  -1 == d && (d = this.getOpenMenuIndex());
  var c = !1;
  if (-1 == d) (d = 0), (c = !0);
  else if ((0 > a && 0 < d) || (0 < a && d < b.length - a)) (d += a), (c = !0);
  if (c) return b[d].querySelector("button").focus(), b[d];
};
MenuBarController.prototype.openFocusedMenu = function () {
  var a = this.getFocusedMenu();
  a && angular.element(a).controller("mdMenu").open();
};
MenuBarController.prototype.getMenus = function () {
  var a = this.$element;
  return this.$mdUtil.nodesToArray(a[0].children).filter(function (b) {
    return "MD-MENU" == b.nodeName;
  });
};
MenuBarController.prototype.getFocusedMenu = function () {
  return this.getMenus()[this.getFocusedMenuIndex()];
};
MenuBarController.prototype.getFocusedMenuIndex = function () {
  var a = this.$mdUtil;
  a = a.getClosest(this.$document[0].activeElement, "MD-MENU");
  return a ? (a = this.getMenus().indexOf(a)) : -1;
};
MenuBarController.prototype.getOpenMenuIndex = function () {
  for (var a = this.getMenus(), b = 0; b < a.length; ++b) if (a[b].classList.contains("md-open")) return b;
  return -1;
};
MenuBarController.prototype.handleParentClick = function (a) {
  var b = this.querySelector("md-menu.md-open");
  b && !b.contains(a.target) && angular.element(b).controller("mdMenu").close(!0, { closeAll: !0 });
};
MenuBarDirective.$inject = ["$mdUtil", "$mdTheming"];
angular.module("material.components.menuBar").directive("mdMenuBar", MenuBarDirective);
function MenuBarDirective(a, b) {
  return {
    restrict: "E",
    require: "mdMenuBar",
    controller: "MenuBarController",
    compile: function (d, c) {
      c.ariaRole || d[0].setAttribute("role", "menubar");
      angular.forEach(d[0].children, function (e) {
        "MD-MENU" == e.nodeName &&
          (e.hasAttribute("md-position-mode") ||
            (e.setAttribute("md-position-mode", "left bottom"), e.querySelector("button, a, md-button").setAttribute("role", "menuitem")),
          (e = a.nodesToArray(e.querySelectorAll("md-menu-content"))),
          angular.forEach(e, function (f) {
            f.classList.add("md-menu-bar-menu");
            f.classList.add("md-dense");
            f.hasAttribute("width") || f.setAttribute("width", 5);
          }));
      });
      d.find("md-menu-item").addClass("md-in-menu-bar");
      return function (e, f, g, h) {
        f.addClass("_md");
        b(e, f);
        h.init();
      };
    }
  };
}
angular.module("material.components.menuBar").directive("mdMenuDivider", MenuDividerDirective);
function MenuDividerDirective() {
  return {
    restrict: "E",
    compile: function (a, b) {
      b.role || a[0].setAttribute("role", "separator");
    }
  };
}
MenuItemController.$inject = ["$scope", "$element", "$attrs"];
angular.module("material.components.menuBar").controller("MenuItemController", MenuItemController);
function MenuItemController(a, b, d) {
  this.$element = b;
  this.$attrs = d;
  this.$scope = a;
}
MenuItemController.prototype.init = function (a) {
  var b = this.$element,
    d = this.$attrs;
  this.ngModel = a;
  if ("checkbox" == d.type || "radio" == d.type)
    (this.mode = d.type), (this.iconEl = b[0].children[0]), (this.buttonEl = b[0].children[1]), a && this.initClickListeners();
};
MenuItemController.prototype.clearNgAria = function () {
  var a = this.$element[0],
    b = ["role", "tabindex", "aria-invalid", "aria-checked"];
  angular.forEach(b, function (d) {
    a.removeAttribute(d);
  });
};
MenuItemController.prototype.initClickListeners = function () {
  function a(m) {
    if (m) h.off("click", l);
    else h.on("click", l);
  }
  var b = this,
    d = this.ngModel,
    c = this.$scope,
    e = this.$attrs,
    f = this.mode;
  this.handleClick = angular.bind(this, this.handleClick);
  var g = this.iconEl,
    h = angular.element(this.buttonEl),
    l = this.handleClick;
  e.$observe("disabled", a);
  a(e.disabled);
  d.$render = function () {
    b.clearNgAria();
    if ("radio" == f) {
      var m = e.ngValue ? c.$eval(e.ngValue) : e.value;
      m = d.$modelValue == m;
    } else m = d.$modelValue;
    m ? ((g.style.display = ""), h.attr("aria-checked", "true")) : ((g.style.display = "none"), h.attr("aria-checked", "false"));
  };
  c.$$postDigest(d.$render);
};
MenuItemController.prototype.handleClick = function () {
  var a = this.mode,
    b = this.ngModel,
    d = this.$attrs,
    c;
  "checkbox" == a ? (c = !b.$modelValue) : "radio" == a && (c = d.ngValue ? this.$scope.$eval(d.ngValue) : d.value);
  b.$setViewValue(c);
  b.$render();
};
MenuItemDirective.$inject = ["$mdUtil", "$mdConstant", "$$mdSvgRegistry"];
angular.module("material.components.menuBar").directive("mdMenuItem", MenuItemDirective);
function MenuItemDirective(a, b, d) {
  return {
    controller: "MenuItemController",
    require: ["mdMenuItem", "?ngModel"],
    priority: b.BEFORE_NG_ARIA,
    compile: function (c, e) {
      function f(n, q, r) {
        r = r || c;
        r instanceof angular.element && (r = r[0]);
        r.hasAttribute(n) || r.setAttribute(n, q);
      }
      function g(n) {
        n = a.prefixer(n);
        angular.forEach(n, function (q) {
          if (c[0].hasAttribute(q)) {
            var r = c[0].getAttribute(q);
            m[0].setAttribute(q, r);
            c[0].removeAttribute(q);
          }
        });
      }
      var h = e.type;
      if (("checkbox" !== h && "radio" !== h) || !c.hasClass("md-in-menu-bar"))
        f("role", "menuitem", c[0].querySelector("md-button, button, a"));
      else {
        var l = c[0].textContent,
          m = angular.element('<md-button type="button"></md-button>'),
          v = '<md-icon md-svg-src="' + d.mdChecked + '"></md-icon>';
        m.html(l);
        m.attr("tabindex", "0");
        angular.isDefined(e.mdPreventMenuClose) && m.attr("md-prevent-menu-close", e.mdPreventMenuClose);
        c.html("");
        c.append(angular.element(v));
        c.append(m);
        c.addClass("md-indent").removeClass("md-in-menu-bar");
        f("role", "checkbox" === h ? "menuitemcheckbox" : "menuitemradio", m);
        g("ng-disabled");
      }
      return function (n, q, r, x) {
        n = x[0];
        x = x[1];
        n.init(x);
      };
    }
  };
}
ngmaterial.components.menuBar = angular.module("material.components.menuBar");
MdNavBar.$inject = ["$mdAria", "$mdTheming"];
MdNavBarController.$inject = ["$element", "$scope", "$timeout", "$mdConstant"];
MdNavItem.$inject = ["$mdAria", "$$rAF", "$mdUtil", "$window"];
MdNavItemController.$inject = ["$element"];
angular
  .module("material.components.navBar", ["material.core"])
  .controller("MdNavBarController", MdNavBarController)
  .directive("mdNavBar", MdNavBar)
  .controller("MdNavItemController", MdNavItemController)
  .directive("mdNavItem", MdNavItem);
function MdNavBar(a, b) {
  return {
    restrict: "E",
    transclude: !0,
    controller: MdNavBarController,
    controllerAs: "ctrl",
    bindToController: !0,
    scope: { mdSelectedNavItem: "=?", mdNoInkBar: "=?", navBarAriaLabel: "@?" },
    template:
      '<div class="md-nav-bar"><nav role="navigation"><ul class="_md-nav-bar-list" ng-transclude role="tablist" ng-focus="ctrl.onFocus()" aria-label="{{ctrl.navBarAriaLabel}}"></ul></nav><md-nav-ink-bar ng-hide="ctrl.mdNoInkBar"></md-nav-ink-bar></div>',
    link: function (d, c, e, f) {
      b(c);
      f.navBarAriaLabel || a.expectAsync(c, "aria-label", angular.noop);
    }
  };
}
function MdNavBarController(a, b, d, c) {
  this._$timeout = d;
  this._$scope = b;
  this._$mdConstant = c;
  this._navBarEl = a[0];
  var e = this,
    f = this._$scope.$watch(
      function () {
        return e._navBarEl.querySelectorAll("._md-nav-button").length;
      },
      function (g) {
        0 < g && (e._initTabs(), f());
      }
    );
}
MdNavBarController.prototype._initTabs = function () {
  this._inkbar = angular.element(this._navBarEl.querySelector("md-nav-ink-bar"));
  var a = this;
  this._$timeout(function () {
    a._updateTabs(a.mdSelectedNavItem, void 0);
  });
  this._$scope.$watch("ctrl.mdSelectedNavItem", function (b, d) {
    a._$timeout(function () {
      a._updateTabs(b, d);
    });
  });
};
MdNavBarController.prototype._updateTabs = function (a, b) {
  var d = this,
    c = this._getTabs(),
    e = a === b;
  if (c) {
    var f = -1,
      g = -1,
      h = this._getTabByName(a),
      l = this._getTabByName(b);
    l && (l.setSelected(!1), (f = c.indexOf(l)));
    h && (h.setSelected(!0), (g = c.indexOf(h)));
    this._$timeout(function () {
      d._updateInkBarStyles(h, g, f);
      h && l && !e && d._moveFocus(l, h);
    });
  }
};
MdNavBarController.prototype._updateInkBarStyles = function (a, b, d) {
  this._inkbar.toggleClass("_md-left", b < d).toggleClass("_md-right", b > d);
  this._inkbar.css({ display: 0 > b ? "none" : "" });
  a && ((a = a.getButtonEl()), (b = a.offsetLeft), this._inkbar.css({ left: b + "px", width: a.offsetWidth + "px" }));
};
MdNavBarController.prototype._getTabs = function () {
  var a = Array.prototype.slice.call(this._navBarEl.querySelectorAll(".md-nav-item")).map(function (b) {
    return angular.element(b).controller("mdNavItem");
  });
  return a.indexOf(void 0) ? a : null;
};
MdNavBarController.prototype._getTabByName = function (a) {
  return this._findTab(function (b) {
    return b.getName() === a;
  });
};
MdNavBarController.prototype._getSelectedTab = function () {
  return this._findTab(function (a) {
    return a.isSelected();
  });
};
MdNavBarController.prototype.getFocusedTab = function () {
  return this._findTab(function (a) {
    return a.hasFocus();
  });
};
MdNavBarController.prototype._findTab = function (a, b) {
  var d = this._getTabs();
  if (void 0 === b || null === b) b = 0;
  for (; b < d.length; b++) if (a(d[b])) return d[b];
  return null;
};
MdNavBarController.prototype._findTabReverse = function (a, b) {
  var d = this._getTabs();
  if (void 0 === b || null === b) b = d.length - 1;
  for (; 0 <= b; b--) if (a(d[b])) return d[b];
  return null;
};
MdNavBarController.prototype.onFocus = function () {
  var a = this._getSelectedTab();
  a && a.setFocused(!0);
};
MdNavBarController.prototype._moveFocus = function (a, b) {
  a.setFocused(!1);
  b.setFocused(!0);
};
MdNavBarController.prototype._focusFirstTab = function () {
  var a = this._getTabs();
  a &&
    (a = this._findTab(function (b) {
      return b._isEnabled();
    })) &&
    this._moveFocus(this.getFocusedTab(), a);
};
MdNavBarController.prototype._focusLastTab = function () {
  var a = this._getTabs();
  a &&
    (a = this._findTabReverse(function (b) {
      return b._isEnabled();
    })) &&
    this._moveFocus(this.getFocusedTab(), a);
};
MdNavBarController.prototype._focusNextTab = function (a) {
  var b = this._getTabs();
  b &&
    ((a = this._findTab(function (d) {
      return d._isEnabled();
    }, a + 1))
      ? this._moveFocus(this.getFocusedTab(), a)
      : this._focusFirstTab());
};
MdNavBarController.prototype._focusPreviousTab = function (a) {
  var b = this._getTabs();
  b &&
    ((a = this._findTabReverse(function (d) {
      return d._isEnabled();
    }, a - 1))
      ? this._moveFocus(this.getFocusedTab(), a)
      : this._focusLastTab());
};
MdNavBarController.prototype.onKeydown = function (a) {
  var b = this._$mdConstant.KEY_CODE,
    d = this._getTabs(),
    c = this.getFocusedTab();
  if (c && d)
    switch (((d = d.indexOf(c)), a.keyCode)) {
      case b.UP_ARROW:
      case b.LEFT_ARROW:
        a.preventDefault();
        this._focusPreviousTab(d);
        break;
      case b.DOWN_ARROW:
      case b.RIGHT_ARROW:
        a.preventDefault();
        this._focusNextTab(d);
        break;
      case b.SPACE:
      case b.ENTER:
        this._$timeout(function () {
          c.getButtonEl().click();
        });
        break;
      case b.HOME:
        a.preventDefault();
        this._focusFirstTab();
        break;
      case b.END:
        a.preventDefault(), this._focusLastTab();
    }
};
function MdNavItem(a, b, d, c) {
  return {
    restrict: "E",
    require: ["mdNavItem", "^mdNavBar"],
    controller: MdNavItemController,
    bindToController: !0,
    controllerAs: "ctrl",
    replace: !0,
    transclude: !0,
    template: function (e, f) {
      e = f.mdNavClick;
      var g = f.mdNavHref,
        h = f.mdNavSref;
      f = f.srefOpts;
      var l;
      if (1 < (e ? 1 : 0) + (g ? 1 : 0) + (h ? 1 : 0))
        throw Error(
          "Please do not specify more than one of the md-nav-click, md-nav-href, or md-nav-sref attributes per nav-item directive."
        );
      if (void 0 !== e && null !== e) e = 'ng-click="ctrl.mdNavClick()"';
      else if (void 0 !== g && null !== g) e = 'ng-href="{{ctrl.mdNavHref}}"';
      else if (void 0 !== h && null !== h) e = 'ui-sref="{{ctrl.mdNavSref}}"';
      else throw Error("Please specify at least one of the md-nav-click, md-nav-href, or md-nav-sref attributes per nav-item directive.");
      f = f ? 'ui-sref-opts="{{ctrl.srefOpts}}" ' : "";
      e &&
        (l =
          '<md-button class="_md-nav-button md-accent" ng-class="ctrl.getNgClassMap()" ng-blur="ctrl.setFocused(false)" ng-disabled="ctrl.disabled" tabindex="-1" role="tab" ng-attr-aria-label="{{ctrl.navItemAriaLabel ? ctrl.navItemAriaLabel : undefined}}" aria-selected="{{ctrl.isSelected()}}" ' +
          f +
          e +
          '><span ng-transclude class="_md-nav-button-text"></span></md-button>');
      return '<li class="md-nav-item" role="presentation">' + (l || "") + "</li>";
    },
    scope: { mdNavClick: "&?", mdNavHref: "@?", mdNavSref: "@?", srefOpts: "=?", name: "@", navItemAriaLabel: "@?" },
    link: function (e, f, g, h) {
      var l, m, v, n;
      b(function () {
        m = h[0];
        v = h[1];
        n = angular.element(f[0].querySelector("._md-nav-button"));
        m.name || (m.name = angular.element(f[0].querySelector("._md-nav-button-text")).text().trim());
        n.on("keydown", function (y) {
          v.onKeydown(y);
        });
        n.on("focus", function () {
          if (!v.getFocusedTab()) v.onFocus();
        });
        n.on("click", function () {
          v.mdSelectedNavItem = m.name;
          e.$apply();
        });
        m.disabled = d.parseAttributeBoolean(g.disabled, !1);
        if ("MutationObserver" in c) {
          var q = { attributes: !0, attributeFilter: ["disabled"] },
            r = f[0],
            x = function (y) {
              d.nextTick(function () {
                m.disabled = d.parseAttributeBoolean(g[y[0].attributeName], !1);
              });
            };
          x = new MutationObserver(x);
          x.observe(r, q);
          l = x.disconnect.bind(x);
        } else
          g.$observe("disabled", function (y) {
            m.disabled = d.parseAttributeBoolean(y, !1);
          });
        m.navItemAriaLabel || a.expectWithText(n, "aria-label");
      });
      e.$on("destroy", function () {
        n.off("keydown");
        n.off("focus");
        n.off("click");
        l();
      });
    }
  };
}
function MdNavItemController(a) {
  this._$element = a;
  this._focused = this._selected = !1;
}
MdNavItemController.prototype.getNgClassMap = function () {
  return { "md-active": this._selected, "md-primary": this._selected, "md-unselected": !this._selected, "md-focused": this._focused };
};
MdNavItemController.prototype.getName = function () {
  return this.name;
};
MdNavItemController.prototype.getButtonEl = function () {
  return this._$element[0].querySelector("._md-nav-button");
};
MdNavItemController.prototype.setSelected = function (a) {
  (this._selected = a) ? this.getButtonEl().setAttribute("tabindex", "0") : this.getButtonEl().setAttribute("tabindex", "-1");
};
MdNavItemController.prototype.isSelected = function () {
  return this._selected;
};
MdNavItemController.prototype.setFocused = function (a) {
  (this._focused = a) && this.getButtonEl().focus();
};
MdNavItemController.prototype.hasFocus = function () {
  return this._focused;
};
MdNavItemController.prototype._isEnabled = function () {
  return !this._$element.attr("disabled");
};
ngmaterial.components.navBar = angular.module("material.components.navBar");
MdPanelService.$inject = ["presets", "$rootElement", "$rootScope", "$injector", "$window"];
angular.module("material.components.panel", ["material.core", "material.components.backdrop"]).provider("$mdPanel", MdPanelProvider);
var FOCUS_TRAP_TEMPLATE,
  _presets = {};
function MdPanelProvider() {
  return { definePreset: definePreset, getAllPresets: getAllPresets, clearPresets: clearPresets, $get: $getProvider() };
}
function definePreset(a, b) {
  if (!a || !b) throw Error("mdPanelProvider: The panel preset definition is malformed. The name and preset object are required.");
  if (_presets.hasOwnProperty(a)) throw Error("mdPanelProvider: The panel preset you have requested has already been defined.");
  delete b.id;
  delete b.position;
  delete b.animation;
  _presets[a] = b;
}
function getAllPresets() {
  return angular.copy(_presets);
}
function clearPresets() {
  _presets = {};
}
function $getProvider() {
  return [
    "$rootElement",
    "$rootScope",
    "$injector",
    "$window",
    function (a, b, d, c) {
      return new MdPanelService(_presets, a, b, d, c);
    }
  ];
}
function MdPanelService(a, b, d, c, e) {
  this._defaultConfigOptions = {
    bindToController: !0,
    clickOutsideToClose: !1,
    disableParentScroll: !1,
    escapeToClose: !1,
    focusOnOpen: !0,
    fullscreen: !1,
    hasBackdrop: !1,
    propagateContainerEvents: !1,
    transformTemplate: angular.bind(this, this._wrapTemplate),
    trapFocus: !1,
    zIndex: 80
  };
  this._config = {};
  this._presets = a;
  this._$rootElement = b;
  this._$rootScope = d;
  this._$injector = c;
  this._$window = e;
  this._$mdUtil = this._$injector.get("$mdUtil");
  this._trackedPanels = {};
  this._groups = Object.create(null);
  this.animation = MdPanelAnimation.animation;
  this.xPosition = MdPanelPosition.xPosition;
  this.yPosition = MdPanelPosition.yPosition;
  this.interceptorTypes = MdPanelRef.interceptorTypes;
  this.closeReasons = MdPanelRef.closeReasons;
  this.absPosition = MdPanelPosition.absPosition;
}
MdPanelService.prototype.create = function (a, b) {
  "string" === typeof a ? (a = this._getPresetByName(a)) : "object" !== typeof a || (!angular.isUndefined(b) && b) || ((b = a), (a = {}));
  a = a || {};
  b = b || {};
  if (angular.isDefined(b.id) && this._trackedPanels[b.id]) return (a = this._trackedPanels[b.id]), angular.extend(a.config, b), a;
  this._config = angular.extend(
    { id: b.id || "panel_" + this._$mdUtil.nextUid(), scope: this._$rootScope.$new(!0), attachTo: this._$rootElement },
    this._defaultConfigOptions,
    b,
    a
  );
  var d = new MdPanelRef(this._config, this._$injector);
  this._trackedPanels[this._config.id] = d;
  this._config.groupName &&
    (angular.isString(this._config.groupName) && (this._config.groupName = [this._config.groupName]),
    angular.forEach(this._config.groupName, function (c) {
      d.addToGroup(c);
    }));
  this._config.scope.$on("$destroy", angular.bind(d, d.detach));
  return d;
};
MdPanelService.prototype.open = function (a, b) {
  var d = this.create(a, b);
  return d.open().then(function () {
    return d;
  });
};
MdPanelService.prototype._getPresetByName = function (a) {
  if (!this._presets[a])
    throw Error(
      "mdPanel: The panel preset configuration that you requested does not exist. Use the $mdPanelProvider to create a preset before requesting one."
    );
  return this._presets[a];
};
MdPanelService.prototype.newPanelPosition = function () {
  return new MdPanelPosition(this._$injector);
};
MdPanelService.prototype.newPanelAnimation = function () {
  return new MdPanelAnimation(this._$injector);
};
MdPanelService.prototype.newPanelGroup = function (a, b) {
  this._groups[a] ||
    ((b = b || {}), (b = { panels: [], openPanels: [], maxOpen: 0 < b.maxOpen ? b.maxOpen : Infinity }), (this._groups[a] = b));
  return this._groups[a];
};
MdPanelService.prototype.setGroupMaxOpen = function (a, b) {
  if (this._groups[a]) this._groups[a].maxOpen = b;
  else throw Error("mdPanel: Group does not exist yet. Call newPanelGroup().");
};
MdPanelService.prototype._openCountExceedsMaxOpen = function (a) {
  return this._groups[a] ? ((a = this._groups[a]), 0 < a.maxOpen && a.openPanels.length > a.maxOpen) : !1;
};
MdPanelService.prototype._closeFirstOpenedPanel = function (a) {
  this._groups[a].openPanels[0].close();
};
MdPanelService.prototype._wrapTemplate = function (a) {
  a = a || "";
  return '<div class="md-panel-outer-wrapper">  <div class="md-panel _md-panel-offscreen">' + a + "</div></div>";
};
MdPanelService.prototype._wrapContentElement = function (a) {
  var b = angular.element('<div class="md-panel-outer-wrapper">');
  a.addClass("md-panel _md-panel-offscreen");
  b.append(a);
  return b;
};
function MdPanelRef(a, b) {
  this._$q = b.get("$q");
  this._$mdCompiler = b.get("$mdCompiler");
  this._$mdConstant = b.get("$mdConstant");
  this._$mdUtil = b.get("$mdUtil");
  this._$mdTheming = b.get("$mdTheming");
  this._$rootScope = b.get("$rootScope");
  this._$animate = b.get("$animate");
  this._$mdPanel = b.get("$mdPanel");
  this._$log = b.get("$log");
  this._$window = b.get("$window");
  this._$$rAF = b.get("$$rAF");
  this.id = a.id;
  this.config = a;
  this.isAttached = !1;
  this._removeListeners = [];
  this._restoreScroll = null;
  this._interceptors = Object.create(null);
  this._compilerCleanup = null;
  this._restoreCache = { styles: "", classes: "" };
}
MdPanelRef.interceptorTypes = { CLOSE: "onClose" };
MdPanelRef.prototype.open = function () {
  var a = this;
  return this._$q(function (b, d) {
    b = a._done(b, a);
    var c = a._simpleBind(a.show, a),
      e = function () {
        a.config.groupName &&
          angular.forEach(a.config.groupName, function (f) {
            a._$mdPanel._openCountExceedsMaxOpen(f) && a._$mdPanel._closeFirstOpenedPanel(f);
          });
      };
    a.attach().then(c).then(e).then(b).catch(d);
  });
};
MdPanelRef.prototype.close = function (a) {
  var b = this;
  return this._$q(function (d, c) {
    b._callInterceptors(MdPanelRef.interceptorTypes.CLOSE).then(function () {
      var e = b._done(d, b),
        f = b._simpleBind(b.detach, b),
        g = b.config.onCloseSuccess || angular.noop;
      g = angular.bind(b, g, b, a);
      b.hide().then(f).then(e).then(g).catch(c);
    }, c);
  });
};
MdPanelRef.prototype.attach = function () {
  if (this.isAttached && this.panelEl) return this._$q.when(this);
  var a = this;
  return this._$q(function (b, d) {
    b = a._done(b, a);
    var c = a.config.onDomAdded || angular.noop,
      e = function (f) {
        a.isAttached = !0;
        a._addEventListeners();
        return f;
      };
    a._$q
      .all([a._createBackdrop(), a._createPanel().then(e).catch(d)])
      .then(c)
      .then(b)
      .catch(d);
  });
};
MdPanelRef.prototype.detach = function () {
  if (!this.isAttached) return this._$q.when(this);
  var a = this,
    b = a.config.onDomRemoved || angular.noop;
  this._restoreScroll && (this._restoreScroll(), (this._restoreScroll = null));
  return this._$q(function (d, c) {
    d = a._done(d, a);
    var e = a._$q,
      f = e.all;
    a._removeEventListeners();
    a._topFocusTrap && a._topFocusTrap.parentNode && a._topFocusTrap.parentNode.removeChild(a._topFocusTrap);
    a._bottomFocusTrap && a._bottomFocusTrap.parentNode && a._bottomFocusTrap.parentNode.removeChild(a._bottomFocusTrap);
    a._restoreCache.classes && (a.panelEl[0].className = a._restoreCache.classes);
    a.panelEl[0].style.cssText = a._restoreCache.styles || "";
    a._compilerCleanup();
    a.panelContainer.remove();
    a.isAttached = !1;
    var g = a._$q.when(a);
    f.call(e, [g, a._backdropRef ? a._backdropRef.detach() : !0])
      .then(b)
      .then(d)
      .catch(c);
  });
};
MdPanelRef.prototype.destroy = function () {
  var a = this;
  this.config.groupName &&
    angular.forEach(this.config.groupName, function (b) {
      a.removeFromGroup(b);
    });
  this.config.scope.$destroy();
  this.config.locals = null;
  this.config.onDomAdded = null;
  this.config.onDomRemoved = null;
  this.config.onRemoving = null;
  this._interceptors = this.config.onOpenComplete = null;
};
MdPanelRef.prototype.show = function () {
  if (!this.panelContainer)
    return this._$q(function (b, d) {
      d("mdPanel: Panel does not exist yet. Call open() or attach().");
    });
  if (!this.panelContainer.hasClass("_md-panel-hidden")) return this._$q.when(this);
  var a = this;
  return this._$q(function (b, d) {
    b = a._done(b, a);
    var c = a.config.onOpenComplete || angular.noop,
      e = function () {
        a.config.groupName &&
          angular.forEach(a.config.groupName, function (m) {
            a._$mdPanel._groups[m].openPanels.push(a);
          });
      },
      f = a._$q,
      g = f.all,
      h = a._backdropRef ? a._backdropRef.show() : a;
    a.panelContainer.removeClass("_md-panel-hidden");
    var l = a._animateOpen();
    g.call(f, [
      h,
      l.then(function () {
        a._focusOnOpen();
      }, d)
    ])
      .then(c)
      .then(e)
      .then(b)
      .catch(d);
  });
};
MdPanelRef.prototype.hide = function () {
  if (!this.panelContainer)
    return this._$q(function (b, d) {
      d("mdPanel: Panel does not exist yet. Call open() or attach().");
    });
  if (this.panelContainer.hasClass("_md-panel-hidden")) return this._$q.when(this);
  var a = this;
  return this._$q(function (b, d) {
    b = a._done(b, a);
    var c = a.config.onRemoving || angular.noop,
      e = function () {
        a.panelContainer.addClass("_md-panel-hidden");
      },
      f = function () {
        if (a.config.groupName) {
          var h;
          angular.forEach(a.config.groupName, function (l) {
            l = a._$mdPanel._groups[l];
            h = l.openPanels.indexOf(a);
            -1 < h && l.openPanels.splice(h, 1);
          });
        }
      },
      g = function () {
        var h = a.config.origin;
        h && getElement(h).focus();
      };
    a._$q.all([a._backdropRef ? a._backdropRef.hide() : a, a._animateClose().then(c).then(e).then(f).then(g).catch(d)]).then(b, d);
  });
};
MdPanelRef.prototype.addClass = function (a, b) {
  this._$log.warn(
    "mdPanel: The addClass method is in the process of being deprecated. Full deprecation is scheduled for the AngularJS Material 1.2 release. To achieve the same results, use the panelContainer or panelEl JQLite elements that are referenced in MdPanelRef."
  );
  if (!this.panelContainer) throw Error("mdPanel: Panel does not exist yet. Call open() or attach().");
  b || this.panelContainer.hasClass(a) ? b && !this.panelEl.hasClass(a) && this.panelEl.addClass(a) : this.panelContainer.addClass(a);
};
MdPanelRef.prototype.removeClass = function (a, b) {
  this._$log.warn(
    "mdPanel: The removeClass method is in the process of being deprecated. Full deprecation is scheduled for the AngularJS Material 1.2 release. To achieve the same results, use the panelContainer or panelEl JQLite elements that are referenced in MdPanelRef."
  );
  if (!this.panelContainer) throw Error("mdPanel: Panel does not exist yet. Call open() or attach().");
  !b && this.panelContainer.hasClass(a) ? this.panelContainer.removeClass(a) : b && this.panelEl.hasClass(a) && this.panelEl.removeClass(a);
};
MdPanelRef.prototype.toggleClass = function (a, b) {
  this._$log.warn(
    "mdPanel: The toggleClass method is in the process of being deprecated. Full deprecation is scheduled for the AngularJS Material 1.2 release. To achieve the same results, use the panelContainer or panelEl JQLite elements that are referenced in MdPanelRef."
  );
  if (!this.panelContainer) throw Error("mdPanel: Panel does not exist yet. Call open() or attach().");
  b ? this.panelEl.toggleClass(a) : this.panelContainer.toggleClass(a);
};
MdPanelRef.prototype._compile = function () {
  var a = this;
  return a._$mdCompiler.compile(a.config).then(function (b) {
    var d = a.config;
    d.contentElement
      ? ((d = b.element),
        (a._restoreCache.styles = d[0].style.cssText),
        (a._restoreCache.classes = d[0].className),
        (a.panelContainer = a._$mdPanel._wrapContentElement(d)),
        (a.panelEl = d))
      : ((a.panelContainer = b.link(d.scope)), (a.panelEl = angular.element(a.panelContainer[0].querySelector(".md-panel"))));
    a._compilerCleanup = b.cleanup;
    getElement(a.config.attachTo).append(a.panelContainer);
    return a;
  });
};
MdPanelRef.prototype._createPanel = function () {
  var a = this;
  return this._$q(function (b, d) {
    a.config.locals || (a.config.locals = {});
    a.config.locals.mdPanelRef = a;
    a._compile().then(function () {
      a.config.disableParentScroll &&
        (a._restoreScroll = a._$mdUtil.disableScrollAround(null, a.panelContainer, { disableScrollMask: !0 }));
      a.config.panelClass && a.panelEl.addClass(a.config.panelClass);
      a.config.propagateContainerEvents && (a.panelContainer.css("pointer-events", "none"), a.panelEl.css("pointer-events", "all"));
      a._$animate.pin && a._$animate.pin(a.panelContainer, getElement(a.config.attachTo));
      a._configureTrapFocus();
      a._addStyles().then(function () {
        b(a);
      }, d);
    }, d);
  });
};
MdPanelRef.prototype._addStyles = function () {
  var a = this;
  return this._$q(function (b) {
    a.panelContainer.css("z-index", a.config.zIndex);
    a.panelEl.css("z-index", a.config.zIndex + 1);
    var d = function () {
      a._setTheming();
      a.panelEl.removeClass("_md-panel-offscreen");
      a.panelContainer.addClass("_md-panel-hidden");
      b(a);
    };
    if (a.config.fullscreen) a.panelEl.addClass("_md-panel-fullscreen"), d();
    else {
      var c = a.config.position;
      c
        ? a._$rootScope.$$postDigest(function () {
            a._updatePosition(!0);
            a._setTheming();
            b(a);
          })
        : d();
    }
  });
};
MdPanelRef.prototype._setTheming = function () {
  this._$mdTheming(this.panelEl);
  this._$mdTheming(this.panelContainer);
};
MdPanelRef.prototype.updatePosition = function (a) {
  if (!this.panelContainer) throw Error("mdPanel: Panel does not exist yet. Call open() or attach().");
  this.config.position = a;
  this._updatePosition();
};
MdPanelRef.prototype._updatePosition = function (a) {
  var b = this.config.position;
  b &&
    (b._setPanelPosition(this.panelEl),
    a && (this.panelEl.removeClass("_md-panel-offscreen"), this.panelContainer.addClass("_md-panel-hidden")),
    this.panelEl.css(MdPanelPosition.absPosition.TOP, b.getTop()),
    this.panelEl.css(MdPanelPosition.absPosition.BOTTOM, b.getBottom()),
    this.panelEl.css(MdPanelPosition.absPosition.LEFT, b.getLeft()),
    this.panelEl.css(MdPanelPosition.absPosition.RIGHT, b.getRight()));
};
MdPanelRef.prototype._focusOnOpen = function () {
  if (this.config.focusOnOpen) {
    var a = this;
    this._$rootScope.$$postDigest(function () {
      var b = a._$mdUtil.findFocusTarget(a.panelEl) || a.panelEl;
      b.focus();
    });
  }
};
MdPanelRef.prototype._createBackdrop = function () {
  if (this.config.hasBackdrop) {
    if (!this._backdropRef) {
      var a = this._$mdPanel
        .newPanelAnimation()
        .openFrom(this.config.attachTo)
        .withAnimation({ open: "_md-opaque-enter", close: "_md-opaque-leave" });
      this.config.animation && a.duration(this.config.animation._rawDuration);
      a = {
        animation: a,
        attachTo: this.config.attachTo,
        focusOnOpen: !1,
        panelClass: "_md-panel-backdrop",
        zIndex: this.config.zIndex - 1
      };
      this._backdropRef = this._$mdPanel.create(a);
    }
    if (!this._backdropRef.isAttached) return this._backdropRef.attach();
  }
};
MdPanelRef.prototype._addEventListeners = function () {
  this._configureEscapeToClose();
  this._configureClickOutsideToClose();
  this._configureScrollListener();
};
MdPanelRef.prototype._removeEventListeners = function () {
  this._removeListeners &&
    this._removeListeners.forEach(function (a) {
      a();
    });
  this._removeListeners = [];
};
MdPanelRef.prototype._configureEscapeToClose = function () {
  if (this.config.escapeToClose) {
    var a = getElement(this.config.attachTo),
      b = this,
      d = function (c) {
        c.keyCode === b._$mdConstant.KEY_CODE.ESCAPE && (c.stopPropagation(), c.preventDefault(), b.close(MdPanelRef.closeReasons.ESCAPE));
      };
    this.panelContainer.on("keydown", d);
    a.on("keydown", d);
    this._removeListeners.push(function () {
      b.panelContainer.off("keydown", d);
      a.off("keydown", d);
    });
  }
};
MdPanelRef.prototype._configureClickOutsideToClose = function () {
  if (this.config.clickOutsideToClose) {
    var a = this.config.propagateContainerEvents ? angular.element(document.body) : this.panelContainer,
      b,
      d = function (f) {
        b = f.target;
      },
      c = this,
      e = function (f) {
        c.config.propagateContainerEvents
          ? b === c.panelEl[0] || c.panelEl[0].contains(b) || c.close()
          : b === a[0] && f.target === a[0] && (f.stopPropagation(), f.preventDefault(), c.close(MdPanelRef.closeReasons.CLICK_OUTSIDE));
      };
    a.on("mousedown", d);
    a.on("mouseup", e);
    this._removeListeners.push(function () {
      a.off("mousedown", d);
      a.off("mouseup", e);
    });
  }
};
MdPanelRef.prototype._configureScrollListener = function () {
  if (!this.config.disableParentScroll) {
    var a = angular.bind(this, this._updatePosition),
      b = this._$$rAF.throttle(a),
      d = this,
      c = function () {
        b();
      };
    this._$window.addEventListener("scroll", c, !0);
    this._removeListeners.push(function () {
      d._$window.removeEventListener("scroll", c, !0);
    });
  }
};
MdPanelRef.prototype._configureTrapFocus = function () {
  this.panelEl.attr("tabIndex", "-1");
  if (this.config.trapFocus) {
    var a = this.panelEl;
    if (!FOCUS_TRAP_TEMPLATE) {
      var b = document.createElement("div");
      b.className = "_md-panel-focus-trap";
      b.tabIndex = 0;
      FOCUS_TRAP_TEMPLATE = angular.element(b);
    }
    this._topFocusTrap = FOCUS_TRAP_TEMPLATE.clone()[0];
    this._bottomFocusTrap = FOCUS_TRAP_TEMPLATE.clone()[0];
    var d = function () {
      a.focus();
    };
    this._topFocusTrap.addEventListener("focus", d);
    this._bottomFocusTrap.addEventListener("focus", d);
    this._removeListeners.push(
      this._simpleBind(function () {
        this._topFocusTrap.removeEventListener("focus", d);
        this._bottomFocusTrap.removeEventListener("focus", d);
      }, this)
    );
    a[0].parentNode.insertBefore(this._topFocusTrap, a[0]);
    a.after(this._bottomFocusTrap);
  }
};
MdPanelRef.prototype.updateAnimation = function (a) {
  this.config.animation = a;
  this._backdropRef && this._backdropRef.config.animation.duration(a._rawDuration);
};
MdPanelRef.prototype._animateOpen = function () {
  this.panelContainer.addClass("md-panel-is-showing");
  var a = this.config.animation;
  if (!a) return this.panelContainer.addClass("_md-panel-shown"), this._$q.when(this);
  var b = this;
  return this._$q(function (d) {
    var c = b._done(d, b);
    d = function () {
      b._$log.warn("mdPanel: MdPanel Animations failed. Showing panel without animating.");
      c();
    };
    a.animateOpen(b.panelEl).then(c, d);
  });
};
MdPanelRef.prototype._animateClose = function () {
  var a = this.config.animation;
  if (!a)
    return this.panelContainer.removeClass("md-panel-is-showing"), this.panelContainer.removeClass("_md-panel-shown"), this._$q.when(this);
  var b = this;
  return this._$q(function (d) {
    var c = function () {
        b.panelContainer.removeClass("md-panel-is-showing");
        d(b);
      },
      e = function () {
        b._$log.warn("mdPanel: MdPanel Animations failed. Hiding panel without animating.");
        c();
      };
    a.animateClose(b.panelEl).then(c, e);
  });
};
MdPanelRef.prototype.registerInterceptor = function (a, b) {
  var d = null;
  angular.isString(a)
    ? angular.isFunction(b) || (d = "Interceptor callback must be a function, instead got " + typeof b)
    : (d = "Interceptor type must be a string, instead got " + typeof a);
  if (d) throw Error("MdPanel: " + d);
  a = this._interceptors[a] = this._interceptors[a] || [];
  -1 === a.indexOf(b) && a.push(b);
  return this;
};
MdPanelRef.prototype.removeInterceptor = function (a, b) {
  b = this._interceptors[a] ? this._interceptors[a].indexOf(b) : -1;
  -1 < b && this._interceptors[a].splice(b, 1);
  return this;
};
MdPanelRef.prototype.removeAllInterceptors = function (a) {
  a ? (this._interceptors[a] = []) : (this._interceptors = Object.create(null));
  return this;
};
MdPanelRef.prototype._callInterceptors = function (a) {
  var b = this,
    d = b._$q;
  a = (b._interceptors && b._interceptors[a]) || [];
  return a.reduceRight(function (c, e) {
    var f = e && angular.isFunction(e.then),
      g = f ? e : null;
    return c.then(function () {
      if (!g)
        try {
          g = e(b);
        } catch (h) {
          g = d.reject(h);
        }
      return g;
    });
  }, d.resolve(b));
};
MdPanelRef.prototype._simpleBind = function (a, b) {
  return function (d) {
    return a.apply(b, d);
  };
};
MdPanelRef.prototype._done = function (a, b) {
  return function () {
    a(b);
  };
};
MdPanelRef.prototype.addToGroup = function (a) {
  this._$mdPanel._groups[a] || this._$mdPanel.newPanelGroup(a);
  a = this._$mdPanel._groups[a];
  var b = a.panels.indexOf(this);
  0 > b && a.panels.push(this);
};
MdPanelRef.prototype.removeFromGroup = function (a) {
  if (!this._$mdPanel._groups[a]) throw Error("mdPanel: The group " + a + " does not exist.");
  a = this._$mdPanel._groups[a];
  var b = a.panels.indexOf(this);
  -1 < b && a.panels.splice(b, 1);
};
MdPanelRef.closeReasons = { CLICK_OUTSIDE: "clickOutsideToClose", ESCAPE: "escapeToClose" };
function MdPanelPosition(a) {
  this._$window = a.get("$window");
  this._isRTL = a.get("$mdUtil").isRtl();
  this._$mdConstant = a.get("$mdConstant");
  this._absolute = !1;
  this._right = this._left = this._bottom = this._top = "";
  this._translateX = [];
  this._translateY = [];
  this._positions = [];
}
MdPanelPosition.xPosition = {
  CENTER: "center",
  ALIGN_START: "align-start",
  ALIGN_END: "align-end",
  OFFSET_START: "offset-start",
  OFFSET_END: "offset-end"
};
MdPanelPosition.yPosition = { CENTER: "center", ALIGN_TOPS: "align-tops", ALIGN_BOTTOMS: "align-bottoms", ABOVE: "above", BELOW: "below" };
MdPanelPosition.absPosition = { TOP: "top", RIGHT: "right", BOTTOM: "bottom", LEFT: "left" };
MdPanelPosition.viewportMargin = 8;
MdPanelPosition.prototype.absolute = function () {
  this._absolute = !0;
  return this;
};
MdPanelPosition.prototype._setPosition = function (a, b) {
  if (a === MdPanelPosition.absPosition.RIGHT || a === MdPanelPosition.absPosition.LEFT) this._left = this._right = "";
  else if (a === MdPanelPosition.absPosition.BOTTOM || a === MdPanelPosition.absPosition.TOP) this._top = this._bottom = "";
  else throw ((a = Object.keys(MdPanelPosition.absPosition).join().toLowerCase()), Error("mdPanel: Position must be one of " + a + "."));
  this["_" + a] = angular.isString(b) ? b : "0";
  return this;
};
MdPanelPosition.prototype.top = function (a) {
  return this._setPosition(MdPanelPosition.absPosition.TOP, a);
};
MdPanelPosition.prototype.bottom = function (a) {
  return this._setPosition(MdPanelPosition.absPosition.BOTTOM, a);
};
MdPanelPosition.prototype.start = function (a) {
  var b = this._isRTL ? MdPanelPosition.absPosition.RIGHT : MdPanelPosition.absPosition.LEFT;
  return this._setPosition(b, a);
};
MdPanelPosition.prototype.end = function (a) {
  var b = this._isRTL ? MdPanelPosition.absPosition.LEFT : MdPanelPosition.absPosition.RIGHT;
  return this._setPosition(b, a);
};
MdPanelPosition.prototype.left = function (a) {
  return this._setPosition(MdPanelPosition.absPosition.LEFT, a);
};
MdPanelPosition.prototype.right = function (a) {
  return this._setPosition(MdPanelPosition.absPosition.RIGHT, a);
};
MdPanelPosition.prototype.centerHorizontally = function () {
  this._left = "50%";
  this._right = "";
  this._translateX = ["-50%"];
  return this;
};
MdPanelPosition.prototype.centerVertically = function () {
  this._top = "50%";
  this._bottom = "";
  this._translateY = ["-50%"];
  return this;
};
MdPanelPosition.prototype.center = function () {
  return this.centerHorizontally().centerVertically();
};
MdPanelPosition.prototype.relativeTo = function (a) {
  this._absolute = !1;
  this._relativeToEl = getElement(a);
  return this;
};
MdPanelPosition.prototype.addPanelPosition = function (a, b) {
  if (!this._relativeToEl) throw Error("mdPanel: addPanelPosition can only be used with relative positioning. Set relativeTo first.");
  this._validateXPosition(a);
  this._validateYPosition(b);
  this._positions.push({ x: a, y: b });
  return this;
};
MdPanelPosition.prototype._validateYPosition = function (a) {
  if (null != a) {
    for (var b = Object.keys(MdPanelPosition.yPosition), d = [], c, e = 0; (c = b[e]); e++)
      if (((c = MdPanelPosition.yPosition[c]), d.push(c), c === a)) return;
    throw Error("mdPanel: Panel y position only accepts the following values:\n" + d.join(" | "));
  }
};
MdPanelPosition.prototype._validateXPosition = function (a) {
  if (null != a) {
    for (var b = Object.keys(MdPanelPosition.xPosition), d = [], c, e = 0; (c = b[e]); e++)
      if (((c = MdPanelPosition.xPosition[c]), d.push(c), c === a)) return;
    throw Error("mdPanel: Panel x Position only accepts the following values:\n" + d.join(" | "));
  }
};
MdPanelPosition.prototype.withOffsetX = function (a) {
  this._translateX.push(addUnits(a));
  return this;
};
MdPanelPosition.prototype.withOffsetY = function (a) {
  this._translateY.push(addUnits(a));
  return this;
};
MdPanelPosition.prototype.getTop = function () {
  return this._top;
};
MdPanelPosition.prototype.getBottom = function () {
  return this._bottom;
};
MdPanelPosition.prototype.getLeft = function () {
  return this._left;
};
MdPanelPosition.prototype.getRight = function () {
  return this._right;
};
MdPanelPosition.prototype.getTransform = function () {
  var a = this._reduceTranslateValues("translateX", this._translateX),
    b = this._reduceTranslateValues("translateY", this._translateY);
  return (a + " " + b).trim();
};
MdPanelPosition.prototype._setTransform = function (a) {
  return a.css(this._$mdConstant.CSS.TRANSFORM, this.getTransform());
};
MdPanelPosition.prototype._isOnscreen = function (a) {
  var b = parseInt(this.getLeft()),
    d = parseInt(this.getTop());
  if (this._translateX.length || this._translateY.length) {
    var c = this._$mdConstant.CSS.TRANSFORM,
      e = getComputedStyle(a[0] || a)[c],
      f = e.indexOf("("),
      g = e.lastIndexOf(")");
    c = { x: 0, y: 0 };
    -1 < f &&
      -1 < g &&
      ((e = e
        .substring(f + 1, g)
        .split(", ")
        .slice(-2)),
      (c.x = parseInt(e[0])),
      (c.y = parseInt(e[1])));
    b += c.x;
    d += c.y;
  }
  c = b + a[0].offsetWidth;
  a = d + a[0].offsetHeight;
  return 0 <= b && 0 <= d && a <= this._$window.innerHeight && c <= this._$window.innerWidth;
};
MdPanelPosition.prototype.getActualPosition = function () {
  return this._actualPosition;
};
MdPanelPosition.prototype._reduceTranslateValues = function (a, b) {
  return b
    .map(function (d) {
      d = angular.isFunction(d) ? addUnits(d(this)) : d;
      return a + "(" + d + ")";
    }, this)
    .join(" ");
};
MdPanelPosition.prototype._setPanelPosition = function (a) {
  a.removeClass("_md-panel-position-adjusted");
  if (this._absolute) this._setTransform(a);
  else {
    if (this._actualPosition) this._calculatePanelPosition(a, this._actualPosition), this._setTransform(a);
    else
      for (var b = 0; b < this._positions.length; b++)
        if (
          ((this._actualPosition = this._positions[b]),
          this._calculatePanelPosition(a, this._actualPosition),
          this._setTransform(a),
          this._isOnscreen(a))
        )
          return;
    this._constrainToViewport(a);
  }
};
MdPanelPosition.prototype._constrainToViewport = function (a) {
  var b = MdPanelPosition.viewportMargin,
    d = this._top,
    c = this._left;
  if (this.getTop()) {
    var e = parseInt(this.getTop()),
      f = a[0].offsetHeight + e,
      g = this._$window.innerHeight;
    e < b ? (this._top = b + "px") : f > g && (this._top = e - (f - g + b) + "px");
  }
  this.getLeft() &&
    ((e = parseInt(this.getLeft())),
    (f = a[0].offsetWidth + e),
    (g = this._$window.innerWidth),
    e < b ? (this._left = b + "px") : f > g && (this._left = e - (f - g + b) + "px"));
  a.toggleClass("_md-panel-position-adjusted", this._top !== d || this._left !== c);
};
MdPanelPosition.prototype._reverseXPosition = function (a) {
  return a === MdPanelPosition.xPosition.CENTER ? a : -1 < a.indexOf("start") ? a.replace("start", "end") : a.replace("end", "start");
};
MdPanelPosition.prototype._bidi = function (a) {
  return this._isRTL ? this._reverseXPosition(a) : a;
};
MdPanelPosition.prototype._calculatePanelPosition = function (a, b) {
  var d = a[0].getBoundingClientRect(),
    c = Math.max(d.width, a[0].clientWidth);
  a = Math.max(d.height, a[0].clientHeight);
  d = this._relativeToEl[0].getBoundingClientRect();
  var e = d.left,
    f = d.right,
    g = d.width;
  switch (this._bidi(b.x)) {
    case MdPanelPosition.xPosition.OFFSET_START:
      this._left = e - c + "px";
      break;
    case MdPanelPosition.xPosition.ALIGN_END:
      this._left = f - c + "px";
      break;
    case MdPanelPosition.xPosition.CENTER:
      c = e + 0.5 * g - 0.5 * c;
      this._left = c + "px";
      break;
    case MdPanelPosition.xPosition.ALIGN_START:
      this._left = e + "px";
      break;
    case MdPanelPosition.xPosition.OFFSET_END:
      this._left = f + "px";
  }
  c = d.top;
  e = d.bottom;
  d = d.height;
  switch (b.y) {
    case MdPanelPosition.yPosition.ABOVE:
      this._top = c - a + "px";
      break;
    case MdPanelPosition.yPosition.ALIGN_BOTTOMS:
      this._top = e - a + "px";
      break;
    case MdPanelPosition.yPosition.CENTER:
      b = c + 0.5 * d - 0.5 * a;
      this._top = b + "px";
      break;
    case MdPanelPosition.yPosition.ALIGN_TOPS:
      this._top = c + "px";
      break;
    case MdPanelPosition.yPosition.BELOW:
      this._top = e + "px";
  }
};
function MdPanelAnimation(a) {
  this._$mdUtil = a.get("$mdUtil");
  this._animationClass = "";
}
MdPanelAnimation.animation = { SLIDE: "md-panel-animate-slide", SCALE: "md-panel-animate-scale", FADE: "md-panel-animate-fade" };
MdPanelAnimation.prototype.openFrom = function (a) {
  a = a.target ? a.target : a;
  this._openFrom = this._getPanelAnimationTarget(a);
  this._closeTo || (this._closeTo = this._openFrom);
  return this;
};
MdPanelAnimation.prototype.closeTo = function (a) {
  this._closeTo = this._getPanelAnimationTarget(a);
  return this;
};
MdPanelAnimation.prototype.duration = function (a) {
  function b(d) {
    if (angular.isNumber(d)) return d / 1e3;
  }
  a &&
    (angular.isNumber(a)
      ? (this._openDuration = this._closeDuration = b(a))
      : angular.isObject(a) && ((this._openDuration = b(a.open)), (this._closeDuration = b(a.close))));
  this._rawDuration = a;
  return this;
};
MdPanelAnimation.prototype._getPanelAnimationTarget = function (a) {
  return angular.isDefined(a.top) || angular.isDefined(a.left)
    ? { element: void 0, bounds: { top: a.top || 0, left: a.left || 0 } }
    : this._getBoundingClientRect(getElement(a));
};
MdPanelAnimation.prototype.withAnimation = function (a) {
  this._animationClass = a;
  return this;
};
MdPanelAnimation.prototype.animateOpen = function (a) {
  var b = this._$mdUtil.dom.animator;
  this._fixBounds(a);
  var d = a[0].style.transform || "",
    c = b.toTransformCss(d),
    e = b.toTransformCss(d);
  switch (this._animationClass) {
    case MdPanelAnimation.animation.SLIDE:
      a.css("opacity", "1");
      var f = { transitionInClass: "_md-panel-animate-enter" };
      c = b.calculateSlideToOrigin(a, this._openFrom) || "";
      c = b.toTransformCss(c + " " + d);
      break;
    case MdPanelAnimation.animation.SCALE:
      f = { transitionInClass: "_md-panel-animate-enter" };
      c = b.calculateZoomToOrigin(a, this._openFrom) || "";
      c = b.toTransformCss(d + " " + c);
      break;
    case MdPanelAnimation.animation.FADE:
      f = { transitionInClass: "_md-panel-animate-enter" };
      break;
    default:
      f = angular.isString(this._animationClass)
        ? { transitionInClass: this._animationClass }
        : { transitionInClass: this._animationClass.open, transitionOutClass: this._animationClass.close };
  }
  f.duration = this._openDuration;
  return b.translate3d(a, c, e, f);
};
MdPanelAnimation.prototype.animateClose = function (a) {
  var b = this._$mdUtil.dom.animator,
    d = a[0].style.transform || "",
    c = b.toTransformCss(d),
    e = b.toTransformCss(d);
  switch (this._animationClass) {
    case MdPanelAnimation.animation.SLIDE:
      a.css("opacity", "1");
      var f = { transitionInClass: "_md-panel-animate-leave" };
      e = b.calculateSlideToOrigin(a, this._closeTo) || "";
      e = b.toTransformCss(e + " " + d);
      break;
    case MdPanelAnimation.animation.SCALE:
      f = { transitionInClass: "_md-panel-animate-scale-out _md-panel-animate-leave" };
      e = b.calculateZoomToOrigin(a, this._closeTo) || "";
      e = b.toTransformCss(d + " " + e);
      break;
    case MdPanelAnimation.animation.FADE:
      f = { transitionInClass: "_md-panel-animate-fade-out _md-panel-animate-leave" };
      break;
    default:
      f = angular.isString(this._animationClass)
        ? { transitionOutClass: this._animationClass }
        : { transitionInClass: this._animationClass.close, transitionOutClass: this._animationClass.open };
  }
  f.duration = this._closeDuration;
  return b.translate3d(a, c, e, f);
};
MdPanelAnimation.prototype._fixBounds = function (a) {
  var b = a[0].offsetWidth;
  a = a[0].offsetHeight;
  this._openFrom && null == this._openFrom.bounds.height && (this._openFrom.bounds.height = a);
  this._openFrom && null == this._openFrom.bounds.width && (this._openFrom.bounds.width = b);
  this._closeTo && null == this._closeTo.bounds.height && (this._closeTo.bounds.height = a);
  this._closeTo && null == this._closeTo.bounds.width && (this._closeTo.bounds.width = b);
};
MdPanelAnimation.prototype._getBoundingClientRect = function (a) {
  if (a instanceof angular.element) return { element: a, bounds: a[0].getBoundingClientRect() };
};
function getElement(a) {
  a = angular.isString(a) ? document.querySelector(a) : a;
  return angular.element(a);
}
function addUnits(a) {
  return angular.isNumber(a) ? a + "px" : a;
}
ngmaterial.components.panel = angular.module("material.components.panel");
angular.module("material.components.progressCircular", ["material.core"]);
MdProgressCircularDirective.$inject = "$window $mdProgressCircular $mdTheming $mdUtil $interval $log".split(" ");
angular.module("material.components.progressCircular").directive("mdProgressCircular", MdProgressCircularDirective);
function MdProgressCircularDirective(a, b, d, c, e) {
  function f(n, q, r) {
    function x(N, C, F, O, S, K) {
      function M(ha) {
        A.attr("stroke-dashoffset", (T - Y) * a.Math.PI * ((3 * (aa || 100)) / 100 - ha / 100));
        A.attr("transform", "rotate(" + X + " " + T / 2 + " " + T / 2 + ")");
      }
      var I = ++z,
        J = c.now(),
        Q = C - N,
        T = l(n.mdDiameter),
        Y = (b.strokeWidth / 100) * T,
        R = F || b.easeFn,
        U = O || b.duration,
        X = -90 * (S || 0),
        aa = K || 100;
      C === N
        ? M(C)
        : (D = m(function fa() {
            var ea = a.Math.max(0, a.Math.min(c.now() - J, U));
            M(R(ea, N, Q, U));
            I === z && ea < U && (D = m(fa));
          }));
    }
    function y() {
      x(w, B, b.easeFnIndeterminate, b.durationIndeterminate, u, 75);
      u = ++u % 4;
    }
    function k() {
      G || ((G = e(y, b.durationIndeterminate, 0, !1)), y(), q.addClass("md-mode-indeterminate").removeAttr("aria-valuenow"));
    }
    function p() {
      G && (e.cancel(G), (G = null), q.removeClass("md-mode-indeterminate"));
    }
    var t = q[0],
      H = angular.element(t.querySelector("svg")),
      A = angular.element(t.querySelector("path")),
      w = b.startIndeterminate,
      B = b.endIndeterminate,
      u = 0,
      z = 0,
      D,
      G;
    d(q);
    q.toggleClass("_md-progress-circular-disabled", r.hasOwnProperty("disabled"));
    "indeterminate" === n.mdMode && k();
    n.$on("$destroy", function () {
      p();
      D && v(D);
    });
    n.$watchGroup(
      [
        "value",
        "mdMode",
        function () {
          var N = t.disabled;
          return !0 === N || !1 === N ? N : angular.isDefined(q.attr("disabled"));
        }
      ],
      function (N, C) {
        var F = N[1],
          O = N[2],
          S = C[2];
        O !== S && q.toggleClass("_md-progress-circular-disabled", !!O);
        O
          ? p()
          : ("determinate" !== F && "indeterminate" !== F && ((F = "indeterminate"), r.$set("mdMode", F)),
            "indeterminate" === F
              ? ("determinate" === C[1] &&
                  ((C = l(n.mdDiameter)),
                  (O = (b.strokeWidth / 100) * C),
                  A.attr("d", g(C, O, !0)),
                  A.attr("stroke-dasharray", (C - O) * a.Math.PI * 0.75)),
                k())
              : ((N = h(N[0])),
                (F = h(C[0])),
                p(),
                "indeterminate" === C[1] &&
                  ((C = l(n.mdDiameter)),
                  (O = (b.strokeWidth / 100) * C),
                  A.attr("d", g(C, O, !1)),
                  A.attr("stroke-dasharray", (C - O) * a.Math.PI)),
                q.attr("aria-valuenow", N),
                x(F, N)));
      }
    );
    n.$watch("mdDiameter", function (N) {
      N = l(N);
      var C = (b.strokeWidth / 100) * N,
        F = h(n.value),
        O = N / 2 + "px",
        S = { width: N + "px", height: N + "px" };
      H[0].setAttribute("viewBox", "0 0 " + N + " " + N);
      H.css(S).css("transform-origin", O + " " + O + " " + O);
      q.css(S);
      A.attr("stroke-width", C);
      A.attr("stroke-linecap", "square");
      "indeterminate" == n.mdMode
        ? (A.attr("d", g(N, C, !0)),
          A.attr("stroke-dasharray", (N - C) * a.Math.PI * 0.75),
          A.attr("stroke-dashoffset", (N - C) * a.Math.PI * 2.24))
        : (A.attr("d", g(N, C, !1)),
          A.attr("stroke-dasharray", (N - C) * a.Math.PI),
          A.attr("stroke-dashoffset", (N - C) * a.Math.PI * 3),
          x(F, F));
    });
  }
  function g(n, q, r) {
    n /= 2;
    var x = q / 2;
    q = n + "," + x;
    var y = x + "," + n;
    n -= x;
    return "M" + q + "A" + n + "," + n + " 0 1 1 " + y + (r ? "" : "A" + n + "," + n + " 0 0 1 " + q);
  }
  function h(n) {
    return a.Math.max(0, a.Math.min(n || 0, 100));
  }
  function l(n) {
    var q = b.progressSize;
    if (n) {
      var r = parseFloat(n);
      n.lastIndexOf("%") === n.length - 1 && (r = (r / 100) * q);
      return r;
    }
    return q;
  }
  var m = a.requestAnimationFrame || a.webkitRequestAnimationFrame || angular.noop,
    v = a.cancelAnimationFrame || a.webkitCancelAnimationFrame || a.webkitCancelRequestAnimationFrame || angular.noop;
  return {
    restrict: "E",
    scope: { value: "@", mdDiameter: "@", mdMode: "@" },
    template: '<svg xmlns="http://www.w3.org/2000/svg"><path fill="none"/></svg>',
    compile: function (n, q) {
      n.attr({ "aria-valuemin": 0, "aria-valuemax": 100, role: "progressbar" });
      angular.isUndefined(q.mdMode)
        ? ((n = q.hasOwnProperty("value") ? "determinate" : "indeterminate"), q.$set("mdMode", n))
        : q.$set("mdMode", q.mdMode.trim());
      return f;
    }
  };
}
angular.module("material.components.progressCircular").provider("$mdProgressCircular", MdProgressCircularProvider);
function MdProgressCircularProvider() {
  function a(c, e, f, g) {
    return (f * c) / g + e;
  }
  function b(c, e, f, g) {
    g = (c /= g) * c;
    c *= g;
    return e + f * (6 * c * g + -15 * g * g + 10 * c);
  }
  var d = {
    progressSize: 50,
    strokeWidth: 10,
    duration: 100,
    easeFn: a,
    durationIndeterminate: 1333,
    startIndeterminate: 1,
    endIndeterminate: 149,
    easeFnIndeterminate: b,
    easingPresets: { linearEase: a, materialEase: b }
  };
  return {
    configure: function (c) {
      return (d = angular.extend(d, c || {}));
    },
    $get: function () {
      return d;
    }
  };
}
ngmaterial.components.progressCircular = angular.module("material.components.progressCircular");
MdProgressLinearDirective.$inject = ["$mdTheming", "$mdUtil", "$log"];
angular.module("material.components.progressLinear", ["material.core"]).directive("mdProgressLinear", MdProgressLinearDirective);
function MdProgressLinearDirective(a, b) {
  function d(e) {
    e.attr("aria-valuemin", 0);
    e.attr("aria-valuemax", 100);
    e.attr("role", "progressbar");
    return c;
  }
  function c(e, f, g) {
    function h() {
      g.$observe("value", function (p) {
        p = Math.max(0, Math.min(p || 0, 100));
        f.attr("aria-valuenow", p);
        "query" != m() && v(y, p);
      });
      g.$observe("mdBufferValue", function (p) {
        v(x, Math.max(0, Math.min(p || 0, 100)));
      });
      g.$observe("disabled", function (p) {
        q = !0 === p || !1 === p ? !!p : angular.isDefined(p);
        f.toggleClass("_md-progress-linear-disabled", q);
        k.toggleClass(n, !q);
      });
      g.$observe("mdMode", function (p) {
        n && k.removeClass(n);
        switch (p) {
          case "query":
          case "buffer":
          case "determinate":
          case "indeterminate":
            k.addClass((n = "md-mode-" + p));
            break;
          default:
            k.addClass((n = "md-mode-indeterminate"));
        }
      });
    }
    function l() {
      if (angular.isUndefined(g.mdMode)) {
        var p = angular.isDefined(g.value);
        p = p ? "determinate" : "indeterminate";
        f.attr("md-mode", p);
        g.mdMode = p;
      }
    }
    function m() {
      var p = (g.mdMode || "").trim();
      if (p)
        switch (p) {
          case "determinate":
          case "indeterminate":
          case "buffer":
          case "query":
            break;
          default:
            p = "indeterminate";
        }
      return p;
    }
    function v(p, t) {
      !q &&
        m() &&
        ((t = b.supplant("translateX({0}%) scale({1},1)", [(t - 100) / 2, t / 100])), (t = r({ transform: t })), angular.element(p).css(t));
    }
    a(f);
    var n,
      q = g.hasOwnProperty("disabled"),
      r = b.dom.animator.toCss,
      x = angular.element(f[0].querySelector(".md-bar1")),
      y = angular.element(f[0].querySelector(".md-bar2")),
      k = angular.element(f[0].querySelector(".md-container"));
    f.attr("md-mode", m()).toggleClass("_md-progress-linear-disabled", q);
    l();
    h();
  }
  return {
    restrict: "E",
    template:
      '<div class="md-container"><div class="md-dashed"></div><div class="md-bar md-bar1"></div><div class="md-bar md-bar2"></div></div>',
    compile: d
  };
}
ngmaterial.components.progressLinear = angular.module("material.components.progressLinear");
mdRadioGroupDirective.$inject = ["$mdUtil", "$mdConstant", "$mdTheming", "$timeout"];
mdRadioButtonDirective.$inject = ["$mdAria", "$mdUtil", "$mdTheming"];
angular
  .module("material.components.radioButton", ["material.core"])
  .directive("mdRadioGroup", mdRadioGroupDirective)
  .directive("mdRadioButton", mdRadioButtonDirective);
function mdRadioGroupDirective(a, b, d, c) {
  function e(l, m, v, n) {
    function q() {
      m.hasClass("md-focused") || m.addClass("md-focused");
    }
    function r(y) {
      var k = y.which || y.keyCode;
      if (k == b.KEY_CODE.ENTER || y.currentTarget == y.target)
        switch (k) {
          case b.KEY_CODE.LEFT_ARROW:
          case b.KEY_CODE.UP_ARROW:
            y.preventDefault();
            x.selectPrevious();
            q();
            break;
          case b.KEY_CODE.RIGHT_ARROW:
          case b.KEY_CODE.DOWN_ARROW:
            y.preventDefault();
            x.selectNext();
            q();
            break;
          case b.KEY_CODE.ENTER:
            (y = angular.element(a.getClosest(m[0], "form"))), 0 < y.length && y.triggerHandler("submit");
        }
    }
    m.addClass("_md");
    d(m);
    var x = n[0];
    v = n[1] || a.fakeNgModel();
    x.init(v);
    l.mouseActive = !1;
    m.attr({ role: "radiogroup", tabIndex: m.attr("tabindex") || "0" })
      .on("keydown", r)
      .on("mousedown", function () {
        l.mouseActive = !0;
        c(function () {
          l.mouseActive = !1;
        }, 100);
      })
      .on("focus", function () {
        !1 === l.mouseActive && x.$element.addClass("md-focused");
      })
      .on("blur", function () {
        x.$element.removeClass("md-focused");
      });
  }
  function f(l) {
    this._radioButtonRenderFns = [];
    this.$element = l;
  }
  function g() {
    return {
      init: function (l) {
        this._ngModelCtrl = l;
        this._ngModelCtrl.$render = angular.bind(this, this.render);
      },
      add: function (l) {
        this._radioButtonRenderFns.push(l);
      },
      remove: function (l) {
        l = this._radioButtonRenderFns.indexOf(l);
        -1 !== l && this._radioButtonRenderFns.splice(l, 1);
      },
      render: function () {
        this._radioButtonRenderFns.forEach(function (l) {
          l();
        });
      },
      setViewValue: function (l, m) {
        this._ngModelCtrl.$setViewValue(l, m);
        this.render();
      },
      getViewValue: function () {
        return this._ngModelCtrl.$viewValue;
      },
      selectNext: function () {
        return h(this.$element, 1);
      },
      selectPrevious: function () {
        return h(this.$element, -1);
      },
      setActiveDescendant: function (l) {
        this.$element.attr("aria-activedescendant", l);
      },
      isDisabled: function () {
        return this.$element[0].hasAttribute("disabled");
      }
    };
  }
  function h(l, m) {
    var v = a.iterator(l[0].querySelectorAll("md-radio-button"), !0);
    if (v.count()) {
      var n = function (q) {
        return !angular.element(q).attr("disabled");
      };
      l = l[0].querySelector("md-radio-button.md-checked");
      m = v[0 > m ? "previous" : "next"](l, n) || v.first();
      angular.element(m).triggerHandler("click");
    }
  }
  f.prototype = g();
  return { restrict: "E", controller: ["$element", f], require: ["mdRadioGroup", "?ngModel"], link: { pre: e } };
}
function mdRadioButtonDirective(a, b, d) {
  function c(e, f, g, h) {
    function l() {
      if (!h) throw "RadioButton: No RadioGroupController could be found.";
      h.add(v);
      g.$observe("value", v);
      f.on("click", m).on("$destroy", function () {
        h.remove(v);
      });
    }
    function m(r) {
      f[0].hasAttribute("disabled") ||
        h.isDisabled() ||
        e.$apply(function () {
          h.setViewValue(g.value, r && r.type);
        });
    }
    function v() {
      var r = h.getViewValue() == g.value;
      r !== q &&
        ("md-radio-group" !== f[0].parentNode.nodeName.toLowerCase() && f.parent().toggleClass("md-checked", r),
        r && h.setActiveDescendant(f.attr("id")),
        (q = r),
        f.attr("aria-checked", r).toggleClass("md-checked", r));
    }
    function n(r) {
      r.attr({ id: g.id || "radio_" + b.nextUid(), role: "radio", "aria-checked": "false" });
      a.expectWithText(r, "aria-label");
    }
    var q;
    d(f);
    n(f, e);
    g.ngValue ? b.nextTick(l, !1) : l();
  }
  return {
    restrict: "E",
    require: "^mdRadioGroup",
    transclude: !0,
    template:
      '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox><div class="md-off"></div><div class="md-on"></div></div><div ng-transclude class="md-label"></div>',
    link: c
  };
}
ngmaterial.components.radioButton = angular.module("material.components.radioButton");
SelectDirective.$inject = "$mdSelect $mdUtil $mdConstant $mdTheming $mdAria $parse $sce $injector".split(" ");
SelectMenuDirective.$inject = ["$parse", "$mdUtil", "$mdConstant", "$mdTheming"];
OptionDirective.$inject = ["$mdButtonInkRipple", "$mdUtil", "$mdTheming"];
SelectProvider.$inject = ["$$interimElementProvider"];
var selectNextId = 0,
  CHECKBOX_SELECTION_INDICATOR;
angular
  .module("material.components.select", ["material.core", "material.components.backdrop"])
  .directive("mdSelect", SelectDirective)
  .directive("mdSelectMenu", SelectMenuDirective)
  .directive("mdOption", OptionDirective)
  .directive("mdOptgroup", OptgroupDirective)
  .directive("mdSelectHeader", SelectHeaderDirective)
  .provider("$mdSelect", SelectProvider);
function SelectDirective(a, b, d, c, e, f, g) {
  function h(l, m) {
    var v = angular.element("<md-select-value><span></span></md-select-value>");
    v.append('<span class="md-select-icon" aria-hidden="true"></span>');
    v.addClass("md-select-value");
    v[0].hasAttribute("id") || v.attr("id", "select_value_label_" + b.nextUid());
    var n = l.find("md-content");
    n.length || l.append(angular.element("<md-content>").append(l.contents()));
    n.attr("role", "presentation");
    m.mdOnOpen &&
      (l
        .find("md-content")
        .prepend(
          angular.element(
            '<div> <md-progress-circular md-mode="indeterminate" ng-if="$$loadingAsyncDone === false" md-diameter="25px"></md-progress-circular></div>'
          )
        ),
      l.find("md-option").attr("ng-show", "$$loadingAsyncDone"));
    if (m.name) {
      var q = angular.element('<select class="md-visually-hidden"></select>');
      q.attr({ name: m.name, "aria-hidden": "true", tabindex: "-1" });
      n = l.find("md-option");
      angular.forEach(n, function (y) {
        var k = angular.element("<option>" + y.innerHTML + "</option>");
        y.hasAttribute("ng-value")
          ? k.attr("ng-value", y.getAttribute("ng-value"))
          : y.hasAttribute("value") && k.attr("value", y.getAttribute("value"));
        q.append(k);
      });
      q.append('<option ng-value="' + m.ngModel + '" selected></option>');
      l.parent().append(q);
    }
    var r = b.parseAttributeBoolean(m.multiple);
    n = r ? "multiple" : "";
    var x =
      '<div class="md-select-menu-container" aria-hidden="true" role="presentation"><md-select-menu role="presentation" {0}>{1}</md-select-menu></div>';
    x = b.supplant(x, [n, l.html()]);
    l.empty().append(v);
    l.append(x);
    m.tabindex || m.$set("tabindex", 0);
    return function (y, k, p, t) {
      function H() {
        J && ((T = T || J.find("md-select-menu").controller("mdSelectMenu")), F.setLabelText(T.selectedLabels()));
      }
      function A() {
        if (N) {
          var U = T.selectedLabels({ mode: "aria" });
          k.attr("aria-label", U.length ? N + ": " + U : N);
        }
      }
      function w() {
        b.nextTick(function () {
          C && C.setHasValue(0 < T.selectedLabels().length || (k[0].validity || {}).badInput);
        });
      }
      function B() {
        J = angular.element(k[0].querySelector(".md-select-menu-container"));
        Q = y;
        if (p.mdContainerClass) {
          var U = J[0].getAttribute("class") + " " + p.mdContainerClass;
          J[0].setAttribute("class", U);
        }
        T = J.find("md-select-menu").controller("mdSelectMenu");
        T.init(O, p.ngModel);
        k.on("$destroy", function () {
          J.remove();
        });
      }
      function u(U) {
        d.isNavigationKey(U)
          ? (U.preventDefault(), z(U))
          : shouldHandleKey(U, d) &&
            (U.preventDefault(),
            (U = T.optNodeForKeyboardSearch(U)) &&
              !U.hasAttribute("disabled") &&
              ((U = angular.element(U).controller("mdOption")),
              T.isMultiple || T.deselect(Object.keys(T.selected)[0]),
              T.select(U.hashKey, U.value),
              T.refreshViewValue()));
      }
      function z() {
        Q._mdSelectIsOpen = !0;
        k.attr("aria-expanded", "true");
        a.show({
          scope: Q,
          preserveScope: !0,
          skipCompile: !0,
          element: J,
          target: k[0],
          selectCtrl: F,
          preserveElement: !0,
          hasBackdrop: !0,
          loadingAsync: p.mdOnOpen ? y.$eval(p.mdOnOpen) || !0 : !1
        }).finally(function () {
          Q._mdSelectIsOpen = !1;
          k.attr("aria-expanded", "false");
          O.$setTouched();
        });
      }
      var D = !0,
        G,
        N,
        C = t[0],
        F = t[1],
        O = t[2],
        S = t[3],
        K = k.find("md-select-value");
      t = angular.isDefined(p.readonly);
      var M = b.parseAttributeBoolean(p.mdNoAsterisk);
      M && k.addClass("md-no-asterisk");
      if (C) {
        var I =
          C.isErrorGetter ||
          function () {
            return O.$invalid && (O.$touched || (S && S.$submitted));
          };
        if (C.input && k.find("md-select-header").find("input")[0] !== C.input[0])
          throw Error("<md-input-container> can only have *one* child <input>, <textarea> or <select> element!");
        C.input = k;
        C.label || e.expect(k, "aria-label", k.attr("placeholder"));
        y.$watch(I, C.setInvalid);
      }
      var J, Q, T;
      B();
      c(k);
      var Y = O.$render;
      O.$render = function () {
        Y();
        H();
        A();
        w();
      };
      p.$observe("placeholder", O.$render);
      C &&
        C.label &&
        p.$observe("required", function (U) {
          C.label.toggleClass("md-required", U && !M);
        });
      F.setLabelText = function (U) {
        F.setIsPlaceholder(!U);
        var X = !1;
        if (p.mdSelectedText && p.mdSelectedHtml) throw Error("md-select cannot have both `md-selected-text` and `md-selected-html`");
        p.mdSelectedText || p.mdSelectedHtml
          ? ((U = f(p.mdSelectedText || p.mdSelectedHtml)(y)), (X = !0))
          : U || ((U = (U = p.placeholder || (C && C.label ? C.label.text() : "")) || ""), (X = !0));
        var aa = K.children().eq(0);
        p.mdSelectedHtml ? aa.html(g.getTrustedHtml(U)) : X ? aa.text(U) : aa.html(U);
      };
      F.setIsPlaceholder = function (U) {
        U
          ? (K.addClass("md-select-placeholder"), C && C.label && C.label.addClass("md-placeholder"))
          : (K.removeClass("md-select-placeholder"), C && C.label && C.label.removeClass("md-placeholder"));
      };
      t ||
        ((t = function (U) {
          D && ((D = !1), Q._mdSelectIsOpen && U.stopImmediatePropagation());
          C && C.setFocused(!1);
          w();
        }),
        (I = function () {
          C && C.setFocused(!0);
        }),
        k.on("focus", I),
        k.on("blur", t));
      F.triggerClose = function () {
        f(p.mdOnClose)(y);
      };
      y.$$postDigest(function () {
        var U = k.attr("aria-label") || k.attr("placeholder");
        !U && C && C.label && (U = C.label.text());
        N = U;
        e.expect(k, "aria-label", U);
        H();
        A();
      });
      y.$watch(function () {
        return T.selectedLabels();
      }, H);
      var R;
      p.$observe("ngMultiple", function (U) {
        R && R();
        var X = f(U);
        R = y.$watch(
          function () {
            return X(y);
          },
          function (aa, ha) {
            if (void 0 !== aa || void 0 !== ha)
              aa ? k.attr("multiple", "multiple") : k.removeAttr("multiple"),
                k.attr("aria-multiselectable", aa ? "true" : "false"),
                J &&
                  (T.setMultiple(aa),
                  (Y = O.$render),
                  (O.$render = function () {
                    Y();
                    H();
                    A();
                    w();
                  }),
                  O.$render());
          }
        );
      });
      p.$observe("disabled", function (U) {
        angular.isString(U) && (U = !0);
        if (void 0 === G || G !== U)
          if ((G = U)) k.attr({ "aria-disabled": "true" }).removeAttr("tabindex").off("click", z).off("keydown", u);
          else k.attr({ tabindex: p.tabindex, "aria-disabled": "false" }).on("click", z).on("keydown", u);
      });
      p.hasOwnProperty("disabled") ||
        p.hasOwnProperty("ngDisabled") ||
        (k.attr({ "aria-disabled": "false" }), k.on("click", z), k.on("keydown", u));
      t = { role: "listbox", "aria-expanded": "false", "aria-multiselectable": r && !p.ngMultiple ? "true" : "false" };
      k[0].hasAttribute("id") || (t.id = "select_" + b.nextUid());
      I = "select_container_" + b.nextUid();
      J.attr("id", I);
      k.find("md-select-menu").length || (t["aria-owns"] = I);
      k.attr(t);
      y.$on("$destroy", function () {
        a.destroy().finally(function () {
          C && (C.setFocused(!1), C.setHasValue(!1), (C.input = null));
          O.$setTouched();
        });
      });
    };
  }
  return { restrict: "E", require: ["^?mdInputContainer", "mdSelect", "ngModel", "?^form"], compile: h, controller: function () {} };
}
function SelectMenuDirective(a, b, d, c) {
  function e(g, h, l, m) {
    function v(r) {
      (13 != r.keyCode && 32 != r.keyCode) || n(r);
    }
    function n(r) {
      var x = b.getClosest(r.target, "md-option"),
        y = x && angular.element(x).data("$mdOptionController");
      if (x && y) {
        if (x.hasAttribute("disabled")) return r.stopImmediatePropagation(), !1;
        var k = q.hashGetter(y.value),
          p = angular.isDefined(q.selected[k]);
        g.$apply(function () {
          q.isMultiple ? (p ? q.deselect(k) : q.select(k, y.value)) : p || (q.deselect(Object.keys(q.selected)[0]), q.select(k, y.value));
          q.refreshViewValue();
        });
      }
    }
    var q = m[0];
    h.addClass("_md");
    c(h);
    h.on("click", n);
    h.on("keypress", v);
  }
  function f(g, h, l) {
    function m() {
      var p = n.ngModel.$modelValue || n.ngModel.$viewValue || [];
      if (angular.isArray(p)) {
        var t = Object.keys(n.selected),
          H = p.map(n.hashGetter);
        t = t.filter(function (A) {
          return -1 === H.indexOf(A);
        });
        t.forEach(n.deselect);
        H.forEach(function (A, w) {
          n.select(A, p[w]);
        });
      }
    }
    function v() {
      var p = n.ngModel.$viewValue || n.ngModel.$modelValue;
      Object.keys(n.selected).forEach(n.deselect);
      n.select(n.hashGetter(p), p);
    }
    var n = this;
    n.isMultiple = angular.isDefined(h.multiple);
    n.selected = {};
    n.options = {};
    g.$watchCollection(
      function () {
        return n.options;
      },
      function () {
        n.ngModel.$render();
      }
    );
    var q;
    n.setMultiple = function (p) {
      function t(B, u) {
        return angular.isArray(B || u || []);
      }
      var H = n.ngModel;
      n.isMultiple = p;
      q && q();
      if (n.isMultiple) {
        var A = !1,
          w = function (B) {
            A
              ? m(B)
              : b.nextTick(function () {
                  m(B);
                  A = !0;
                });
          };
        H.$validators["md-multiple"] = t;
        H.$render = w;
        g.$watchCollection(n.modelBinding, function (B) {
          t(B) && w(B);
        });
        H.$isEmpty = function (B) {
          return !B || 0 === B.length;
        };
      } else delete H.$validators["md-multiple"], (H.$render = v);
    };
    var r = "",
      x,
      y,
      k;
    n.optNodeForKeyboardSearch = function (p) {
      x && clearTimeout(x);
      x = setTimeout(function () {
        x = void 0;
        r = "";
        y = k = void 0;
      }, 300);
      r += p.key;
      p = new RegExp("^" + r, "i");
      y ||
        ((y = l.find("md-option")),
        (k = Array(y.length)),
        angular.forEach(y, function (H, A) {
          k[A] = H.textContent.trim();
        }));
      for (var t = 0; t < k.length; ++t) if (p.test(k[t])) return y[t];
    };
    n.init = function (p, t) {
      n.ngModel = p;
      n.modelBinding = t;
      n.ngModel.$isEmpty = function (w) {
        return !n.options[n.hashGetter(w)];
      };
      if ((p = b.getModelOption(p, "trackBy"))) {
        var H = {},
          A = a(p);
        n.hashGetter = function (w, B) {
          H.$value = w;
          return A(B || g, H);
        };
      } else
        n.hashGetter = function (w) {
          return angular.isObject(w) ? "object_" + (w.$$mdSelectId || (w.$$mdSelectId = ++selectNextId)) : w;
        };
      n.setMultiple(n.isMultiple);
    };
    n.selectedLabels = function (p) {
      p = p || {};
      p = p.mode || "html";
      var t = b.nodesToArray(l[0].querySelectorAll("md-option[selected]"));
      if (t.length) {
        var H;
        "html" == p
          ? (H = function (A) {
              if (A.hasAttribute("md-option-empty")) return "";
              var w = A.innerHTML,
                B = A.querySelector(".md-ripple-container");
              B && (w = w.replace(B.outerHTML, ""));
              (A = A.querySelector(".md-container")) && (w = w.replace(A.outerHTML, ""));
              return w;
            })
          : "aria" == p &&
            (H = function (A) {
              return A.hasAttribute("aria-label") ? A.getAttribute("aria-label") : A.textContent;
            });
        return b.uniq(t.map(H)).join(", ");
      }
      return "";
    };
    n.select = function (p, t) {
      var H = n.options[p];
      H && H.setSelected(!0);
      n.selected[p] = t;
    };
    n.deselect = function (p) {
      var t = n.options[p];
      t && t.setSelected(!1);
      delete n.selected[p];
    };
    n.addOption = function (p, t) {
      if (angular.isDefined(n.options[p]))
        throw Error('Duplicate md-option values are not allowed in a select. Duplicate value "' + t.value + '" found.');
      n.options[p] = t;
      angular.isDefined(n.selected[p]) &&
        (n.select(p, t.value),
        angular.isDefined(n.ngModel.$$rawModelValue) && n.hashGetter(n.ngModel.$$rawModelValue) === p && n.ngModel.$validate(),
        n.refreshViewValue());
    };
    n.removeOption = function (p) {
      delete n.options[p];
    };
    n.refreshViewValue = function () {
      var p = [],
        t;
      for (H in n.selected) (t = n.options[H]) ? p.push(t.value) : p.push(n.selected[H]);
      t = b.getModelOption(n.ngModel, "trackBy");
      p = n.isMultiple ? p : p[0];
      var H = n.ngModel.$modelValue;
      (t ? angular.equals(H, p) : H + "" === p) || (n.ngModel.$setViewValue(p), n.ngModel.$render());
    };
  }
  f.$inject = ["$scope", "$attrs", "$element"];
  return { restrict: "E", require: ["mdSelectMenu"], scope: !1, controller: f, link: { pre: e } };
}
function OptionDirective(a, b, d) {
  function c(g, h) {
    g.append(angular.element('<div class="md-text">').append(g.contents()));
    g.attr("tabindex", h.tabindex || "0");
    var l = h.value;
    h = h.ngValue;
    (l = l || h) || g.attr("md-option-empty", "");
    return e;
  }
  function e(g, h, l, m) {
    function v(x, y, k) {
      if (r.hashGetter) {
        k = r.hashGetter(y, g);
        var p = r.hashGetter(x, g);
        q.hashKey = p;
        q.value = x;
        r.removeOption(k, q);
        r.addOption(p, q);
      } else
        k ||
          g.$$postDigest(function () {
            v(x, y, !0);
          });
    }
    function n() {
      var x = { role: "option", "aria-selected": "false" };
      h[0].hasAttribute("id") || (x.id = "select_option_" + b.nextUid());
      h.attr(x);
    }
    var q = m[0],
      r = m[1];
    d(h);
    r.isMultiple &&
      (h.addClass("md-checkbox-enabled"),
      CHECKBOX_SELECTION_INDICATOR ||
        ((m = document.createElement("div")),
        (m.className = "md-container"),
        m.appendChild(document.createElement("div")),
        (m.firstChild.className = "md-icon"),
        (CHECKBOX_SELECTION_INDICATOR = angular.element(m))),
      h.prepend(CHECKBOX_SELECTION_INDICATOR.clone()));
    angular.isDefined(l.ngValue)
      ? g.$watch(l.ngValue, v)
      : angular.isDefined(l.value)
      ? v(l.value)
      : g.$watch(function () {
          return h.text().trim();
        }, v);
    l.$observe("disabled", function (x) {
      x ? h.attr("tabindex", "-1") : h.attr("tabindex", "0");
    });
    g.$$postDigest(function () {
      l.$observe("selected", function (x) {
        angular.isDefined(x) &&
          ("string" == typeof x && (x = !0),
          x ? (r.isMultiple || r.deselect(Object.keys(r.selected)[0]), r.select(q.hashKey, q.value)) : r.deselect(q.hashKey),
          r.refreshViewValue());
      });
    });
    a.attach(g, h);
    n();
    g.$on("$destroy", function () {
      r.removeOption(q.hashKey, q);
    });
  }
  function f(g) {
    this.selected = !1;
    this.setSelected = function (h) {
      h && !this.selected
        ? g.attr({ selected: "selected", "aria-selected": "true" })
        : !h && this.selected && (g.removeAttr("selected"), g.attr("aria-selected", "false"));
      this.selected = h;
    };
  }
  f.$inject = ["$element"];
  return { restrict: "E", require: ["mdOption", "^^mdSelectMenu"], controller: f, compile: c };
}
function OptgroupDirective() {
  function a(b, d) {
    if (!b.parent().find("md-select-header").length) {
      var c = b.find("label");
      c.length || ((c = angular.element("<label>")), b.prepend(c));
      c.addClass("md-container-ignore");
      c.attr("aria-hidden", "true");
      d.label && c.text(d.label);
    }
  }
  return { restrict: "E", compile: a };
}
function SelectHeaderDirective() {
  return { restrict: "E" };
}
function SelectProvider(a) {
  function b(d, c, e, f, g, h, l, m, v) {
    function n(k, p, t) {
      function H() {
        w();
        p.removeClass("md-active")
          .attr("aria-hidden", "true")
          .css({ display: "none", top: "", right: "", bottom: "", left: "", "font-size": "", "min-width": "" });
        p.parent().find("md-select-value").removeAttr("aria-hidden");
        var B = t.selectCtrl;
        if (B) {
          var u = t.selectEl.controller("mdSelectMenu");
          B.setLabelText(u ? u.selectedLabels() : "");
          B.triggerClose();
        }
        !t.$destroy && t.restoreFocus && t.target.focus();
      }
      var A = null,
        w = k.$on("$destroy", function () {
          A.end();
        });
      t = t || {};
      t.cleanupInteraction();
      t.cleanupResizing();
      t.hideBackdrop();
      !0 === t.$destroy ? (k = H()) : ((A = l(p, { addClass: "md-leave" })), (k = A.start()), (k = k.then(H)));
      return k;
    }
    function q(k, p, t) {
      function H(N, C, F) {
        F.parent !== C.parent() && C.parent().attr("aria-owns", C.attr("id"));
        C.parent().find("md-select-value").attr("aria-hidden", "true");
        F.parent.append(C);
        return g(function (O, S) {
          try {
            l(C, { removeClass: "md-leave", duration: 0 }).start().then(A).then(O);
          } catch (K) {
            S(K);
          }
        });
      }
      function A() {
        return g(function (N) {
          if (t.isRemoved) return g.reject(!1);
          var C = r(k, p, t);
          C.container.element.css(x.toCss(C.container.styles));
          C.dropDown.element.css(x.toCss(C.dropDown.styles));
          h(function () {
            p.addClass("md-active");
            C.dropDown.element.css(x.toCss({ transform: "" }));
            B(t.focusedNode);
            N();
          });
        });
      }
      function w(N, C, F) {
        F.disableParentScroll && !e.getClosest(F.target, "MD-DIALOG")
          ? (F.restoreScroll = e.disableScrollAround(F.element, F.parent))
          : (F.disableParentScroll = !1);
        F.hasBackdrop &&
          ((F.backdrop = e.createBackdrop(N, "md-select-backdrop md-click-catcher")),
          m.enter(F.backdrop, v[0].body, null, { duration: 0 }));
        return function () {
          F.backdrop && F.backdrop.remove();
          F.disableParentScroll && F.restoreScroll();
          delete F.restoreScroll;
        };
      }
      function B(N) {
        N && !N.hasAttribute("disabled") && N.focus();
      }
      function u(N, C) {
        N = p.find("md-select-menu");
        if (!C.target) throw Error(e.supplant("$mdSelect.show() expected a target element in options.target but got '{0}'!", [C.target]));
        angular.extend(C, {
          isRemoved: !1,
          target: angular.element(C.target),
          parent: angular.element(C.parent),
          selectEl: N,
          contentEl: p.find("md-content"),
          optionNodes: N[0].getElementsByTagName("md-option")
        });
      }
      function z() {
        var N = (function (F, O, S) {
            return function () {
              if (!S.isRemoved) {
                var K = r(F, O, S),
                  M = K.container;
                K = K.dropDown;
                M.element.css(x.toCss(M.styles));
                K.element.css(x.toCss(K.styles));
              }
            };
          })(k, p, t),
          C = angular.element(f);
        C.on("resize", N);
        C.on("orientationchange", N);
        return function () {
          C.off("resize", N);
          C.off("orientationchange", N);
        };
      }
      function D() {
        t.loadingAsync &&
          !t.isRemoved &&
          ((k.$$loadingAsyncDone = !1),
          g
            .when(t.loadingAsync)
            .then(function () {
              k.$$loadingAsyncDone = !0;
              delete t.loadingAsync;
            })
            .then(function () {
              h(A);
            }));
      }
      function G() {
        function N(M) {
          M.preventDefault();
          M.stopPropagation();
          t.restoreFocus = !1;
          e.nextTick(d.hide, !0);
        }
        function C(M) {
          M.preventDefault();
          M.stopPropagation();
          switch (M.keyCode) {
            case y.UP_ARROW:
              return F("prev"), (M = void 0);
            case y.DOWN_ARROW:
              return F("next"), (M = void 0);
            case y.SPACE:
            case y.ENTER:
              var I = e.getClosest(M.target, "md-option");
              I && (S.triggerHandler({ type: "click", target: I }), M.preventDefault());
              O(M);
              break;
            case y.TAB:
            case y.ESCAPE:
              M.stopPropagation();
              M.preventDefault();
              t.restoreFocus = !0;
              e.nextTick(d.hide, !0);
              break;
            default:
              shouldHandleKey(M, c) &&
                ((M = S.controller("mdSelectMenu").optNodeForKeyboardSearch(M)), (t.focusedNode = M || t.focusedNode), M && M.focus());
          }
        }
        function F(M) {
          var I = e.nodesToArray(t.optionNodes),
            J = I.indexOf(t.focusedNode);
          do {
            -1 === J ? (J = 0) : "next" === M && J < I.length - 1 ? J++ : "prev" === M && 0 < J && J--;
            var Q = I[J];
            Q.hasAttribute("disabled") && (Q = void 0);
          } while (!Q && J < I.length - 1 && 0 < J);
          Q && Q.focus();
          t.focusedNode = Q;
        }
        function O(M) {
          function I() {
            var Q = !1;
            if (M && 0 < M.currentTarget.children.length) {
              var T = M.currentTarget.children[0],
                Y = T.scrollHeight > T.clientHeight;
              Y &&
                0 < T.children.length &&
                ((Y = M.pageX - M.currentTarget.getBoundingClientRect().left), Y > T.querySelector("md-option").offsetWidth && (Q = !0));
            }
            return Q;
          }
          if (!((M && "click" == M.type && M.currentTarget != S[0]) || I())) {
            var J = e.getClosest(M.target, "md-option");
            J &&
              J.hasAttribute &&
              !J.hasAttribute("disabled") &&
              (M.preventDefault(),
              M.stopPropagation(),
              K.isMultiple ||
                ((t.restoreFocus = !0),
                e.nextTick(function () {
                  d.hide(K.ngModel.$viewValue);
                }, !0)));
          }
        }
        if (!t.isRemoved) {
          var S = t.selectEl,
            K = S.controller("mdSelectMenu") || {};
          p.addClass("md-clickable");
          t.backdrop && t.backdrop.on("click", N);
          S.on("keydown", C);
          S.on("click", O);
          return function () {
            t.backdrop && t.backdrop.off("click", N);
            S.off("keydown", C);
            S.off("click", O);
            p.removeClass("md-clickable");
            t.isRemoved = !0;
          };
        }
      }
      D();
      u(k, t);
      t.hideBackdrop = w(k, p, t);
      return H(k, p, t).then(function (N) {
        p.attr("aria-hidden", "false");
        t.alreadyOpen = !0;
        t.cleanupInteraction = G();
        t.cleanupResizing = z();
        B(t.focusedNode);
        return N;
      }, t.hideBackdrop);
    }
    function r(k, p, t) {
      k = p[0];
      var H = t.target[0].children[0],
        A = v[0].body,
        w = t.selectEl[0],
        B = t.contentEl[0],
        u = A.getBoundingClientRect(),
        z = H.getBoundingClientRect();
      A = { left: u.left + 8, top: 8, bottom: u.height - 8, right: u.width - 8 - (e.floatingScrollbars() ? 16 : 0) };
      var D = { top: z.top - A.top, left: z.left - A.left, right: A.right - (z.left + z.width), bottom: A.bottom - (z.top + z.height) };
      u = u.width - 16;
      var G = w.querySelector("md-option[selected]"),
        N = w.getElementsByTagName("md-option"),
        C = w.getElementsByTagName("md-optgroup"),
        F = B,
        O = p[0].style.display;
      p[0].style.display = "block";
      F = F.scrollHeight > F.offsetHeight;
      p[0].style.display = O;
      p = F;
      C = (O = (O = t.loadingAsync) && angular.isFunction(O.then))
        ? B.firstElementChild || B
        : G
        ? G
        : C.length
        ? C[0]
        : N.length
        ? N[0]
        : B.firstElementChild || B;
      B.offsetWidth > u ? (B.style["max-width"] = u + "px") : (B.style.maxWidth = null);
      p && w.classList.add("md-overflow");
      G = C;
      "MD-OPTGROUP" === (G.tagName || "").toUpperCase() && (C = G = N[0] || B.firstElementChild || B);
      t.focusedNode = G;
      k.style.display = "block";
      N = w.getBoundingClientRect();
      G = C
        ? { left: C.offsetLeft, top: C.offsetTop, width: C.offsetWidth, height: C.offsetHeight }
        : { left: 0, top: 0, width: 0, height: 0 };
      C &&
        ((C = f.getComputedStyle(C)),
        (G.paddingLeft = parseInt(C.paddingLeft, 10) || 0),
        (G.paddingRight = parseInt(C.paddingRight, 10) || 0));
      p &&
        ((C = B.offsetHeight / 2),
        (B.scrollTop = G.top + G.height / 2 - C),
        D.top < C
          ? (B.scrollTop = Math.min(G.top, B.scrollTop + C - D.top))
          : D.bottom < C && (B.scrollTop = Math.max(G.top + G.height - N.height, B.scrollTop - C + D.bottom)));
      D = z.left + G.left - G.paddingLeft + 2;
      C = Math.floor(z.top + z.height / 2 - G.height / 2 - G.top + B.scrollTop) + 2;
      B = G.left + z.width / 2 + "px " + (G.top + G.height / 2 - B.scrollTop) + "px 0px";
      u = Math.min(z.width + G.paddingLeft + G.paddingRight, u);
      H = window.getComputedStyle(H)["font-size"];
      G = k.getBoundingClientRect();
      p = Math.round(100 * Math.min(z.width / N.width, 1)) / 100;
      z = Math.round(100 * Math.min(z.height / N.height, 1)) / 100;
      return {
        container: {
          element: angular.element(k),
          styles: {
            left: Math.floor(Math.max(A.left, Math.min(D, A.right - G.width))),
            top: Math.floor(Math.max(A.top, Math.min(C, A.bottom - G.height))),
            "min-width": u,
            "font-size": H
          }
        },
        dropDown: {
          element: angular.element(w),
          styles: { transformOrigin: B, transform: t.alreadyOpen ? "" : e.supplant("scale({0},{1})", [p, z]) }
        }
      };
    }
    var x = e.dom.animator,
      y = c.KEY_CODE;
    return { parent: "body", themable: !0, onShow: q, onRemove: n, hasBackdrop: !0, disableParentScroll: !0 };
  }
  b.$inject = "$mdSelect $mdConstant $mdUtil $window $q $$rAF $animateCss $animate $document".split(" ");
  return a("$mdSelect").setDefaults({ methods: ["target"], options: b });
}
function shouldHandleKey(a, b) {
  var d = String.fromCharCode(a.keyCode),
    c = 31 >= a.keyCode;
  return d && d.length && !c && !b.isMetaKey(a) && !b.isFnLockKey(a) && !b.hasModifierKey(a);
}
ngmaterial.components.select = angular.module("material.components.select");
SidenavService.$inject = ["$mdComponentRegistry", "$mdUtil", "$q", "$log"];
SidenavDirective.$inject =
  "$mdMedia $mdUtil $mdConstant $mdTheming $mdInteraction $animate $compile $parse $log $q $document $window $$rAF".split(" ");
SidenavController.$inject = ["$scope", "$attrs", "$mdComponentRegistry", "$q", "$interpolate"];
angular
  .module("material.components.sidenav", ["material.core", "material.components.backdrop"])
  .factory("$mdSidenav", SidenavService)
  .directive("mdSidenav", SidenavDirective)
  .directive("mdSidenavFocus", SidenavFocusDirective)
  .controller("$mdSidenavController", SidenavController);
function SidenavService(a, b, d, c) {
  function e(l, m) {
    var v = function () {
        return !1;
      },
      n = function () {
        return d.when(b.supplant("SideNav '{0}' is not available! Did you use md-component-id='{0}'?", [m || ""]));
      };
    return angular.extend(
      {
        isLockedOpen: v,
        isOpen: v,
        toggle: n,
        open: n,
        close: n,
        onClose: angular.noop,
        then: function (q) {
          return g(m).then(q || angular.noop);
        }
      },
      l
    );
  }
  function f(l, m) {
    var v = a.get(l);
    if (v || m) return v;
    c.error(b.supplant("SideNav '{0}' is not available! Did you use md-component-id='{0}'?", [l || ""]));
  }
  function g(l) {
    return a.when(l).catch(c.error);
  }
  var h = { find: f, waitFor: g };
  return function (l, m) {
    if (angular.isUndefined(l)) return h;
    var v = !0 === m,
      n = h.find(l, v);
    return !n && v ? h.waitFor(l) : !n && angular.isUndefined(m) ? e(h, l) : n;
  };
}
function SidenavFocusDirective() {
  return { restrict: "A", require: "^mdSidenav", link: function () {} };
}
function SidenavDirective(a, b, d, c, e, f, g, h, l, m, v, n, q) {
  function r(x, y, k, p) {
    function t(J, Q) {
      x.isLockedOpen = J;
      if (J === Q) y.toggleClass("md-locked-open", !!J);
      else f[J ? "addClass" : "removeClass"](y, "md-locked-open");
      D && D.toggleClass("md-locked-open", !!J);
    }
    function H(J) {
      var Q = b.findFocusTarget(y) || b.findFocusTarget(y, "[md-sidenav-focus]") || y,
        T = y.parent();
      if (!N && (T[J ? "on" : "off"]("keydown", B), D)) D[J ? "on" : "off"]("click", u);
      var Y = A(T, J);
      J && ((F = v[0].activeElement), (C = e.getLastInteractionType()));
      J && !z ? ((z = G.css("overflow")), G.css("overflow", "hidden")) : angular.isDefined(z) && (G.css("overflow", z), (z = void 0));
      return (S = m
        .all([J && D ? f.enter(D, T) : D ? f.leave(D) : m.when(!0), f[J ? "removeClass" : "addClass"](y, "md-closed")])
        .then(function () {
          x.isOpen &&
            (q(function () {
              M.triggerHandler("resize");
            }),
            Q && Q.focus());
          Y && Y();
        }));
    }
    function A(J, Q) {
      var T = y[0],
        Y = J[0].scrollTop;
      Q &&
        Y &&
        ((O = { top: T.style.top, bottom: T.style.bottom, height: T.style.height }),
        (J = { top: Y + "px", bottom: "auto", height: J[0].clientHeight + "px" }),
        y.css(J),
        D.css(J));
      if (!Q && O)
        return function () {
          T.style.top = O.top;
          T.style.bottom = O.bottom;
          T.style.height = O.height;
          D[0].style.top = null;
          D[0].style.bottom = null;
          O = D[0].style.height = null;
        };
    }
    function w(J) {
      if (x.isOpen === J) return m.when(!0);
      if (x.isOpen && p.onCloseCb) p.onCloseCb();
      return m(function (Q) {
        x.isOpen = J;
        b.nextTick(function () {
          S.then(function (T) {
            !x.isOpen && F && "keyboard" === C && (F.focus(), (F = null));
            Q(T);
          });
        });
      });
    }
    function B(J) {
      var Q = J.keyCode === d.KEY_CODE.ESCAPE;
      return Q ? u(J) : m.when(!0);
    }
    function u(J) {
      J.preventDefault();
      return p.close();
    }
    var z,
      D,
      G = null,
      N,
      C,
      F = null,
      O,
      S = m.when(!0),
      K = h(k.mdIsLockedOpen),
      M = angular.element(n),
      I = function () {
        return K(x.$parent, {
          $media: function (J) {
            l.warn("$media is deprecated for is-locked-open. Use $mdMedia instead.");
            return a(J);
          },
          $mdMedia: a
        });
      };
    k.mdDisableScrollTarget &&
      ((G = v[0].querySelector(k.mdDisableScrollTarget))
        ? (G = angular.element(G))
        : l.warn(
            b.supplant('mdSidenav: couldn\'t find element matching selector "{selector}". Falling back to parent.', {
              selector: k.mdDisableScrollTarget
            })
          ));
    G || (G = y.parent());
    k.hasOwnProperty("mdDisableBackdrop") || (D = b.createBackdrop(x, "md-sidenav-backdrop md-opaque ng-enter"));
    k.hasOwnProperty("mdDisableCloseEvents") && (N = !0);
    y.addClass("_md");
    c(y);
    D && c.inherit(D, y);
    y.on("$destroy", function () {
      D && D.remove();
      p.destroy();
    });
    x.$on("$destroy", function () {
      D && D.remove();
    });
    x.$watch(I, t);
    x.$watch("isOpen", H);
    p.$toggleOpen = w;
  }
  return {
    restrict: "E",
    scope: { isOpen: "=?mdIsOpen" },
    controller: "$mdSidenavController",
    compile: function (x) {
      x.addClass("md-closed").attr("tabIndex", "-1");
      return r;
    }
  };
}
function SidenavController(a, b, d, c, e) {
  var f = this;
  f.isOpen = function () {
    return !!a.isOpen;
  };
  f.isLockedOpen = function () {
    return !!a.isLockedOpen;
  };
  f.onClose = function (l) {
    f.onCloseCb = l;
    return f;
  };
  f.open = function () {
    return f.$toggleOpen(!0);
  };
  f.close = function () {
    return f.$toggleOpen(!1);
  };
  f.toggle = function () {
    return f.$toggleOpen(!a.isOpen);
  };
  f.$toggleOpen = function (l) {
    return c.when((a.isOpen = l));
  };
  var g = b.mdComponentId,
    h = g && -1 < g.indexOf(e.startSymbol());
  e = h ? e(g)(a.$parent) : g;
  f.destroy = d.register(f, e);
  h &&
    b.$observe("mdComponentId", function (l) {
      l && l !== f.$$mdHandle && (f.destroy(), (f.destroy = d.register(f, l)));
    });
}
ngmaterial.components.sidenav = angular.module("material.components.sidenav");
SliderDirective.$inject = "$$rAF $window $mdAria $mdUtil $mdConstant $mdTheming $mdGesture $parse $log $timeout".split(" ");
angular
  .module("material.components.slider", ["material.core"])
  .directive("mdSlider", SliderDirective)
  .directive("mdSliderContainer", SliderContainerDirective);
var stepPageSize = 10,
  modifierMultiplier = 4;
function SliderContainerDirective() {
  return {
    controller: function () {},
    compile: function (a) {
      var b = a.find("md-slider");
      if (b) {
        var d = b.attr("md-vertical");
        void 0 !== d && a.attr("md-vertical", "");
        b.attr("flex") || b.attr("flex", "");
        return function (c, e, f, g) {
          function h(v) {
            e.children().attr("disabled", v);
            e.find("input").attr("disabled", v);
          }
          e.addClass("_md");
          var l = angular.noop;
          f.disabled
            ? h(!0)
            : f.ngDisabled &&
              (l = c.$watch(f.ngDisabled, function (v) {
                h(v);
              }));
          c.$on("$destroy", function () {
            l();
          });
          var m;
          g.fitInputWidthToTextLength = function (v) {
            var n = e[0].querySelector("md-input-container");
            if (n) {
              var q = getComputedStyle(n),
                r = parseInt(q.minWidth),
                x = parseInt(q.paddingLeft) + parseInt(q.paddingRight);
              m = m || parseInt(q.maxWidth);
              v = Math.max(m, r + x + (r / 2) * v);
              n.style.maxWidth = v + "px";
            }
          };
        };
      }
    }
  };
}
function SliderDirective(a, b, d, c, e, f, g, h, l, m) {
  function v(q, r) {
    var x = angular.element(q[0].getElementsByClassName("md-slider-wrapper")),
      y = r.tabindex || 0;
    x.attr("tabindex", y);
    (r.disabled || r.ngDisabled) && x.attr("tabindex", -1);
    x.attr("role", "slider");
    d.expect(q, "aria-label");
    return n;
  }
  function n(q, r, x, y) {
    function k() {
      u();
      S();
    }
    function p(E) {
      W = parseFloat(E);
      ea.$viewValue = K(ea.$modelValue, W, ya);
      ma.attr("aria-valuemin", E);
      k();
    }
    function t(E) {
      ya = parseFloat(E);
      ea.$viewValue = K(ea.$modelValue, W, ya);
      ma.attr("aria-valuemax", E);
      k();
    }
    function H(E) {
      va = parseFloat(E);
    }
    function A(E) {
      L = K(parseInt(E), 0, 6);
    }
    function w() {
      r.attr("aria-disabled", !!da());
    }
    function B() {
      if (Ia && !da() && !angular.isUndefined(va)) {
        if (0 >= va)
          throw (
            (l.error("Slider step value must be greater than zero when in discrete mode"),
            Error("Slider step value must be greater than zero when in discrete mode"))
          );
        var E = Math.floor((ya - W) / va);
        ua || ((ua = angular.element("<canvas>").css("position", "absolute")), Aa.append(ua), (qa = ua[0].getContext("2d")));
        var P = z();
        !P || P.height || P.width || (u(), (P = ta));
        ua[0].width = P.width;
        ua[0].height = P.height;
        for (var Z, ja = 0; ja <= E; ja++)
          (Z = b.getComputedStyle(Aa[0])),
            (qa.fillStyle = Z.color || "black"),
            (Z = Math.floor((ja / E) * (oa ? P.height : P.width))),
            qa.fillRect(oa ? 0 : Z - 1, oa ? Z - 1 : 0, oa ? P.width : 2, oa ? 2 : P.height);
      }
    }
    function u() {
      ta = Ga[0].getBoundingClientRect();
    }
    function z() {
      za();
      return ta;
    }
    function D(E) {
      if (!da()) {
        var P = e.KEY_CODE;
        switch (E.keyCode) {
          case P.DOWN_ARROW:
          case P.LEFT_ARROW:
            E.preventDefault();
            var Z = -va;
            break;
          case P.UP_ARROW:
          case P.RIGHT_ARROW:
            E.preventDefault();
            Z = va;
            break;
          case P.PAGE_DOWN:
            E.preventDefault();
            Z = -va * stepPageSize;
            break;
          case P.PAGE_UP:
            E.preventDefault();
            Z = va * stepPageSize;
            break;
          case P.HOME:
            E.preventDefault();
            E.stopPropagation();
            G(W);
            break;
          case P.END:
            E.preventDefault(), E.stopPropagation(), G(ya);
        }
        if (Z) {
          Z = xa ? -Z : Z;
          if (E.metaKey || E.ctrlKey || E.altKey) Z *= modifierMultiplier;
          E.preventDefault();
          E.stopPropagation();
          G(ea.$viewValue + Z);
        }
      }
    }
    function G(E) {
      q.$evalAsync(function () {
        O(E);
      });
    }
    function N() {
      B();
      q.mouseActive = !0;
      ma.removeClass("md-focused");
      m(function () {
        q.mouseActive = !1;
      }, 100);
    }
    function C() {
      !1 === q.mouseActive && ma.addClass("md-focused");
    }
    function F() {
      ma.removeClass("md-focused");
      r.removeClass("md-active");
      if (ua && qa) {
        var E = z();
        qa.clearRect(0, 0, E.width, E.height);
      }
    }
    function O(E) {
      ea.$setViewValue(K(M(E)));
    }
    function S() {
      isNaN(ea.$viewValue) && (ea.$viewValue = ea.$modelValue);
      ea.$viewValue = K(ea.$viewValue);
      var E = fa(ea.$viewValue);
      q.modelValue = ea.$viewValue;
      ma.attr("aria-valuenow", ea.$viewValue);
      I(E);
      la.text(ea.$viewValue);
    }
    function K(E, P, Z) {
      if (angular.isNumber(E)) return (P = angular.isNumber(P) ? P : W), (Z = angular.isNumber(Z) ? Z : ya), Math.max(P, Math.min(Z, E));
    }
    function M(E) {
      if (angular.isNumber(E)) {
        var P = Math.round((E - W) / va) * va + W;
        P = Math.round(P * Math.pow(10, L)) / Math.pow(10, L);
        ca &&
          ca.fitInputWidthToTextLength &&
          c.debounce(function () {
            ca.fitInputWidthToTextLength(P.toString().length);
          }, 100)();
        return P;
      }
    }
    function I(E) {
      E = Math.max(0, Math.min(E || 0, 1));
      var P = 100 * E + "%",
        Z = xa ? 100 * (1 - E) + "%" : P;
      oa ? pa.css("bottom", P) : c.bidiProperty(pa, "left", "right", P);
      wa.css(oa ? "height" : "width", Z);
      r.toggleClass(xa ? "md-max" : "md-min", 0 === E);
      r.toggleClass(xa ? "md-min" : "md-max", 1 === E);
    }
    function J(E) {
      if (!da()) {
        r.addClass("md-active");
        r[0].focus();
        u();
        E = ha(aa(oa ? E.pointer.y : E.pointer.x));
        var P = K(M(E));
        q.$apply(function () {
          O(P);
          I(fa(P));
        });
      }
    }
    function Q(E) {
      if (!da()) {
        r.removeClass("md-dragging");
        E = ha(aa(oa ? E.pointer.y : E.pointer.x));
        var P = K(M(E));
        q.$apply(function () {
          O(P);
          S();
        });
      }
    }
    function T(E) {
      da() || ((sa = !0), E.stopPropagation(), r.addClass("md-dragging"), U(E));
    }
    function Y(E) {
      sa && (E.stopPropagation(), U(E));
    }
    function R(E) {
      sa && (E.stopPropagation(), (sa = !1));
    }
    function U(E) {
      if (Ia) {
        E = oa ? E.pointer.y : E.pointer.x;
        var P = ha(aa(E));
        P = K(M(P));
        I(aa(E));
        la.text(P);
      } else X(oa ? E.pointer.y : E.pointer.x);
    }
    function X(E) {
      q.$evalAsync(function () {
        O(ha(aa(E)));
      });
    }
    function aa(E) {
      var P = oa ? ta.top : ta.left,
        Z = oa ? ta.height : ta.width;
      E = (E - P) / Z;
      !oa && c.isRtl(x) && (E = 1 - E);
      return Math.max(0, Math.min(1, oa ? 1 - E : E));
    }
    function ha(E) {
      E = xa ? 1 - E : E;
      return W + E * (ya - W);
    }
    function fa(E) {
      E = (E - W) / (ya - W);
      return xa ? 1 - E : E;
    }
    f(r);
    var ea = y[0] || {
        $setViewValue: function (E) {
          this.$viewValue = E;
          this.$viewChangeListeners.forEach(function (P) {
            P();
          });
        },
        $parsers: [],
        $formatters: [],
        $viewChangeListeners: []
      },
      ca = y[1];
    angular.element(c.getClosest(r, "_md-slider-container", !0));
    var da = x.ngDisabled
      ? angular.bind(null, h(x.ngDisabled), q.$parent)
      : function () {
          return r[0].hasAttribute("disabled");
        };
    y = angular.element(r[0].querySelector(".md-thumb"));
    var la = angular.element(r[0].querySelector(".md-thumb-text")),
      pa = y.parent(),
      Ga = angular.element(r[0].querySelector(".md-track-container")),
      wa = angular.element(r[0].querySelector(".md-track-fill")),
      Aa = angular.element(r[0].querySelector(".md-track-ticks")),
      ma = angular.element(r[0].getElementsByClassName("md-slider-wrapper"));
    angular.element(r[0].getElementsByClassName("md-slider-content"));
    var za = c.throttle(u, 5e3),
      oa = angular.isDefined(x.mdVertical),
      Ia = angular.isDefined(x.mdDiscrete),
      xa = angular.isDefined(x.mdInvert);
    angular.isDefined(x.min) ? x.$observe("min", p) : p(0);
    angular.isDefined(x.max) ? x.$observe("max", t) : t(100);
    angular.isDefined(x.step) ? x.$observe("step", H) : H(1);
    angular.isDefined(x.round) ? x.$observe("round", A) : A(3);
    x.ngDisabled && q.$parent.$watch(x.ngDisabled, w);
    g.register(ma, "drag", { horizontal: !oa });
    q.mouseActive = !1;
    ma.on("keydown", D)
      .on("mousedown", N)
      .on("focus", C)
      .on("blur", F)
      .on("$md.pressdown", J)
      .on("$md.pressup", Q)
      .on("$md.dragstart", T)
      .on("$md.drag", Y)
      .on("$md.dragend", R);
    setTimeout(k, 0);
    var Fa = a.throttle(k);
    angular.element(b).on("resize", Fa);
    q.$on("$destroy", function () {
      angular.element(b).off("resize", Fa);
    });
    ea.$render = S;
    ea.$viewChangeListeners.push(S);
    ea.$formatters.push(K);
    ea.$formatters.push(M);
    var W,
      ya,
      va,
      L,
      ua,
      qa,
      ta = {};
    u();
    var sa = !1;
  }
  return {
    scope: {},
    require: ["?ngModel", "?^mdSliderContainer"],
    template:
      '<div class="md-slider-wrapper"><div class="md-slider-content"><div class="md-track-container"><div class="md-track"></div><div class="md-track md-track-fill"></div><div class="md-track-ticks"></div></div><div class="md-thumb-container"><div class="md-thumb"></div><div class="md-focus-thumb"></div><div class="md-focus-ring"></div><div class="md-sign"><span class="md-thumb-text"></span></div><div class="md-disabled-thumb"></div></div></div></div>',
    compile: v
  };
}
ngmaterial.components.slider = angular.module("material.components.slider");
MdSticky.$inject = ["$mdConstant", "$$rAF", "$mdUtil", "$compile"];
angular.module("material.components.sticky", ["material.core", "material.components.content"]).factory("$mdSticky", MdSticky);
function MdSticky(a, b, d, c) {
  function e(h) {
    function l(t, H) {
      H.addClass("md-sticky-clone");
      var A = { element: t, clone: H };
      p.items.push(A);
      d.nextTick(function () {
        y.prepend(A.clone);
      });
      k();
      return function () {
        p.items.forEach(function (w, B) {
          w.element[0] === t[0] && (p.items.splice(B, 1), w.clone.remove());
        });
        k();
      };
    }
    function m() {
      p.items.forEach(v);
      p.items = p.items.sort(function (w, B) {
        return w.top < B.top ? -1 : 1;
      });
      for (var t, H = y.prop("scrollTop"), A = p.items.length - 1; 0 <= A; A--)
        if (H > p.items[A].top) {
          t = p.items[A];
          break;
        }
      q(t);
    }
    function v(t) {
      var H = t.element[0];
      t.top = 0;
      t.left = 0;
      for (t.right = 0; H && H !== y[0]; )
        (t.top += H.offsetTop),
          (t.left += H.offsetLeft),
          H.offsetParent && (t.right += H.offsetParent.offsetWidth - H.offsetWidth - H.offsetLeft),
          (H = H.offsetParent);
      t.height = t.element.prop("offsetHeight");
      H = d.floatingScrollbars() ? "0" : void 0;
      d.bidi(t.clone, "margin-left", t.left, H);
      d.bidi(t.clone, "margin-right", H, t.right);
    }
    function n() {
      var t = y.prop("scrollTop"),
        H = t > (n.prevScrollTop || 0);
      n.prevScrollTop = t;
      if (0 === t) q(null);
      else {
        if (H) {
          if (p.next && p.next.top <= t) {
            q(p.next);
            return;
          }
          if (p.current && p.next && p.next.top - t <= p.next.height) {
            x(p.current, t + (p.next.top - p.next.height - t));
            return;
          }
        }
        if (!H) {
          if (p.current && p.prev && t < p.current.top) {
            q(p.prev);
            return;
          }
          if (p.next && p.current && t >= p.next.top - p.current.height) {
            x(p.current, t + (p.next.top - t - p.current.height));
            return;
          }
        }
        p.current && x(p.current, t);
      }
    }
    function q(t) {
      p.current !== t &&
        (p.current && (x(p.current, null), r(p.current, null)),
        t && r(t, "active"),
        (p.current = t),
        (t = p.items.indexOf(t)),
        (p.next = p.items[t + 1]),
        (p.prev = p.items[t - 1]),
        r(p.next, "next"),
        r(p.prev, "prev"));
    }
    function r(t, H) {
      t &&
        t.state !== H &&
        (t.state && (t.clone.attr("sticky-prev-state", t.state), t.element.attr("sticky-prev-state", t.state)),
        t.clone.attr("sticky-state", H),
        t.element.attr("sticky-state", H),
        (t.state = H));
    }
    function x(t, H) {
      t &&
        (null === H || void 0 === H
          ? t.translateY && ((t.translateY = null), t.clone.css(a.CSS.TRANSFORM, ""))
          : ((t.translateY = H),
            d.bidi(t.clone, a.CSS.TRANSFORM, "translate3d(" + t.left + "px," + H + "px,0)", "translateY(" + H + "px)")));
    }
    var y = h.$element,
      k = b.throttle(m);
    f(y);
    y.on("$scrollstart", k);
    y.on("$scroll", n);
    var p;
    return (p = { prev: null, current: null, next: null, items: [], add: l, refreshElements: m });
  }
  function f(h) {
    function l() {
      200 < +d.now() - v ? ((m = !1), h.triggerHandler("$scrollend")) : (h.triggerHandler("$scroll"), b.throttle(l));
    }
    var m, v;
    h.on("scroll touchmove", function () {
      m || ((m = !0), b.throttle(l), h.triggerHandler("$scrollstart"));
      h.triggerHandler("$scroll");
      v = +d.now();
    });
  }
  var g = d.checkStickySupport();
  return function (h, l, m) {
    var v = l.controller("mdContent");
    if (v)
      if (g) l.css({ position: g, top: 0, "z-index": 2 });
      else {
        var n = v.$element.data("$$sticky");
        n || ((n = e(v)), v.$element.data("$$sticky", n));
        m = m || c(l.clone())(h);
        l = n.add(l, m);
        h.$on("$destroy", l);
      }
  };
}
ngmaterial.components.sticky = angular.module("material.components.sticky");
MdSubheaderDirective.$inject = ["$mdSticky", "$compile", "$mdTheming", "$mdUtil", "$mdAria"];
angular
  .module("material.components.subheader", ["material.core", "material.components.sticky"])
  .directive("mdSubheader", MdSubheaderDirective);
function MdSubheaderDirective(a, b, d, c, e) {
  return {
    restrict: "E",
    replace: !0,
    transclude: !0,
    template: '<div class="md-subheader _md">  <div class="md-subheader-inner">    <div class="md-subheader-content"></div>  </div></div>',
    link: function (f, g, h, l, m) {
      function v(q) {
        return angular.element(q[0].querySelector(".md-subheader-content"));
      }
      d(g);
      g.addClass("_md");
      c.prefixer().removeAttribute(g, "ng-repeat");
      var n = g[0].outerHTML;
      h.$set("role", "heading");
      e.expect(g, "aria-level", "2");
      m(f, function (q) {
        v(g).append(q);
      });
      g.hasClass("md-no-sticky") ||
        m(f, function (q) {
          var r = b('<div class="md-subheader-wrapper" aria-hidden="true">' + n + "</div>")(f);
          c.nextTick(function () {
            v(r).append(q);
          });
          a(f, g, r);
        });
    }
  };
}
ngmaterial.components.subheader = angular.module("material.components.subheader");
angular
  .module("material.components.swipe", ["material.core"])
  .directive("mdSwipeLeft", getDirective("SwipeLeft"))
  .directive("mdSwipeRight", getDirective("SwipeRight"))
  .directive("mdSwipeUp", getDirective("SwipeUp"))
  .directive("mdSwipeDown", getDirective("SwipeDown"));
function getDirective(a) {
  function b(e) {
    function f(g, h, l) {
      var m = e(l[d]);
      h.on(c, function (v) {
        var n = v.currentTarget;
        g.$applyAsync(function () {
          m(g, { $event: v, $target: { current: n } });
        });
      });
    }
    return { restrict: "A", link: f };
  }
  b.$inject = ["$parse"];
  var d = "md" + a,
    c = "$md." + a.toLowerCase();
  return b;
}
ngmaterial.components.swipe = angular.module("material.components.swipe");
MdSwitch.$inject = "mdCheckboxDirective $mdUtil $mdConstant $parse $$rAF $mdGesture $timeout".split(" ");
angular.module("material.components.switch", ["material.core", "material.components.checkbox"]).directive("mdSwitch", MdSwitch);
function MdSwitch(a, b, d, c, e, f, g) {
  function h(m, v) {
    var n = l.compile(m, v).post;
    m.addClass("md-dragging");
    return function (q, r, x, y) {
      function k(G) {
        (w && w(q)) || (G.stopPropagation(), r.addClass("md-dragging"), (D = { width: B.prop("offsetWidth") }));
      }
      function p(G) {
        D &&
          (G.stopPropagation(),
          G.srcEvent && G.srcEvent.preventDefault(),
          (G = G.pointer.distanceX / D.width),
          (G = A.$viewValue ? 1 + G : G),
          (G = Math.max(0, Math.min(1, G))),
          B.css(d.CSS.TRANSFORM, "translate3d(" + 100 * G + "%,0,0)"),
          (D.translate = G));
      }
      function t(G) {
        D &&
          (G.stopPropagation(),
          r.removeClass("md-dragging"),
          B.css(d.CSS.TRANSFORM, ""),
          (G = A.$viewValue ? 0.5 > D.translate : 0.5 < D.translate) && H(!A.$viewValue),
          (D = null),
          (q.skipToggle = !0),
          g(function () {
            q.skipToggle = !1;
          }, 1));
      }
      function H(G) {
        q.$apply(function () {
          A.$setViewValue(G);
          A.$render();
        });
      }
      var A = y[1] || b.fakeNgModel(),
        w = null;
      null != x.disabled
        ? (w = function () {
            return !0;
          })
        : x.ngDisabled && (w = c(x.ngDisabled));
      var B = angular.element(r[0].querySelector(".md-thumb-container")),
        u = angular.element(r[0].querySelector(".md-container")),
        z = angular.element(r[0].querySelector(".md-label"));
      e(function () {
        r.removeClass("md-dragging");
      });
      n(q, r, x, y);
      w &&
        q.$watch(w, function (G) {
          r.attr("tabindex", G ? -1 : 0);
        });
      x.$observe("mdInvert", function (G) {
        (G = b.parseAttributeBoolean(G)) ? r.prepend(z) : r.prepend(u);
        r.toggleClass("md-inverted", G);
      });
      f.register(u, "drag");
      u.on("$md.dragstart", k).on("$md.drag", p).on("$md.dragend", t);
      var D;
    };
  }
  var l = a[0];
  return {
    restrict: "E",
    priority: d.BEFORE_NG_ARIA,
    transclude: !0,
    template:
      '<div class="md-container"><div class="md-bar"></div><div class="md-thumb-container"><div class="md-thumb" md-ink-ripple md-ink-ripple-checkbox></div></div></div><div ng-transclude class="md-label"></div>',
    require: ["^?mdInputContainer", "?ngModel", "?^form"],
    compile: h
  };
}
ngmaterial.components.switch = angular.module("material.components.switch");
angular.module("material.components.tabs", ["material.core", "material.components.icon"]);
angular.module("material.components.tabs").service("MdTabsPaginationService", MdTabsPaginationService);
function MdTabsPaginationService() {
  function a(e, f) {
    var g = e.canvas;
    e = d(e);
    var h;
    for (h = 0; h < e.length; h++)
      if (e[h] >= f) {
        var l = e[h];
        break;
      }
    return Math.max(0, l - g.clientWidth);
  }
  function b(e, f) {
    var g = e.canvas,
      h = c(e) - g.clientWidth;
    e = d(e);
    var l;
    for (l = 0; l < e.length, e[l] <= f + g.clientWidth; l++) var m = e[l];
    return Math.min(h, m);
  }
  function d(e) {
    var f,
      g = 0,
      h = [];
    for (f = 0; f < e.tabs.length; f++) {
      var l = e.tabs[f];
      h.push(g);
      g += l.offsetWidth;
    }
    return h;
  }
  function c(e) {
    var f = 0,
      g;
    for (g = 0; g < e.tabs.length; g++) {
      var h = e.tabs[g];
      f += h.offsetWidth;
    }
    return f;
  }
  return { decreasePageOffset: a, increasePageOffset: b, getTabOffsets: d, getTotalTabsWidth: c };
}
angular.module("material.components.tabs").directive("mdTab", MdTab);
function MdTab() {
  function a(d, c, e, f) {
    if (f) {
      e = f.getTabElementIndex(c);
      var g = b(c, "md-tab-body").remove(),
        h = b(c, "md-tab-label").remove(),
        l = f.insertTab({ scope: d, parent: d.$parent, index: e, element: c, template: g.html(), label: h.html() }, e);
      d.select = d.select || angular.noop;
      d.deselect = d.deselect || angular.noop;
      d.$watch("active", function (m) {
        m && f.select(l.getIndex(), !0);
      });
      d.$watch("disabled", function () {
        f.refreshIndex();
      });
      d.$watch(
        function () {
          return f.getTabElementIndex(c);
        },
        function (m) {
          l.index = m;
          f.updateTabOrder();
        }
      );
      d.$on("$destroy", function () {
        f.removeTab(l);
      });
    }
  }
  function b(d, c) {
    d = d[0].children;
    for (var e = 0, f = d.length; e < f; e++) {
      var g = d[e];
      if (g.tagName === c.toUpperCase()) return angular.element(g);
    }
    return angular.element();
  }
  return {
    require: "^?mdTabs",
    terminal: !0,
    compile: function (d, c) {
      var e = b(d, "md-tab-label"),
        f = b(d, "md-tab-body");
      0 === e.length &&
        ((e = angular.element("<md-tab-label></md-tab-label>")),
        c.label ? e.text(c.label) : e.append(d.contents()),
        0 === f.length && ((c = d.contents().detach()), (f = angular.element("<md-tab-body></md-tab-body>")), f.append(c)));
      d.append(e);
      f.html() && d.append(f);
      return a;
    },
    scope: { active: "=?mdActive", disabled: "=?ngDisabled", select: "&?mdOnSelect", deselect: "&?mdOnDeselect", tabClass: "@mdTabClass" }
  };
}
angular.module("material.components.tabs").directive("mdTabItem", MdTabItem);
function MdTabItem() {
  return {
    require: "^?mdTabs",
    link: function (a, b, d, c) {
      c && c.attachRipple(a, b);
    }
  };
}
angular.module("material.components.tabs").directive("mdTabLabel", MdTabLabel);
function MdTabLabel() {
  return { terminal: !0 };
}
MdTabScroll.$inject = ["$parse"];
angular.module("material.components.tabs").directive("mdTabScroll", MdTabScroll);
function MdTabScroll(a) {
  return {
    restrict: "A",
    compile: function (b, d) {
      var c = a(d.mdTabScroll, null, !0);
      return function (e, f) {
        f.on("wheel", function (g) {
          e.$apply(function () {
            c(e, { $event: g });
          });
        });
      };
    }
  };
}
MdTabsController.$inject =
  "$scope $element $window $mdConstant $mdTabInkRipple $mdUtil $animateCss $attrs $compile $mdTheming $mdInteraction $timeout MdTabsPaginationService".split(
    " "
  );
angular.module("material.components.tabs").controller("MdTabsController", MdTabsController);
function MdTabsController(a, b, d, c, e, f, g, h, l, m, v, n, q) {
  function r() {
    k("stretchTabs", H);
    ca("focusIndex", D, L.selectedIndex || 0);
    ca("offsetLeft", z, 0);
    ca("hasContent", u, !1);
    ca("maxTabWidth", w, pa());
    ca("shouldPaginate", B, !1);
    p("noInkBar", J);
    p("dynamicHeight", Q);
    p("noPagination");
    p("swipeContent");
    p("noDisconnect");
    p("autoselect");
    p("noSelectClick");
    p("centerTabs", A, !1);
    p("enableDisconnect");
    L.scope = a;
    L.parent = a.$parent;
    L.tabs = [];
    L.lastSelectedIndex = null;
    L.hasFocus = !1;
    L.styleTabItemFocus = !1;
    L.shouldCenterTabs = L.centerTabs && !L.shouldPaginate;
    L.tabContentPrefix = "tab-content-";
    L.navigationHint = "Use the left and right arrow keys to navigate between tabs";
    x();
  }
  function x() {
    L.selectedIndex = L.selectedIndex || 0;
    y();
    a.$watch("$mdTabsCtrl.selectedIndex", G);
    angular.element(d).on("resize", I);
    a.$on("$destroy", t);
    m(b);
    f.nextTick(function () {
      xa();
      ma();
      Fa();
      L.tabs[L.selectedIndex] && L.tabs[L.selectedIndex].scope.select();
      sa = !0;
      da();
    });
  }
  function y() {
    var E = h.$mdTabsTemplate,
      P = angular.element(b[0].querySelector("md-tab-data"));
    P.html(E);
    l(P.contents())(L.parent);
    delete h.$mdTabsTemplate;
  }
  function k(E, P) {
    var Z = h.$normalize("md-" + E);
    P && ca(E, P);
    h.$observe(Z, function (ja) {
      L[E] = ja;
    });
  }
  function p(E, P) {
    function Z(na) {
      L[E] = "false" !== na;
    }
    var ja = h.$normalize("md-" + E);
    P && ca(E, P);
    h.hasOwnProperty(ja) && Z(h[ja]);
    h.$observe(ja, Z);
  }
  function t() {
    ta = !0;
    angular.element(d).off("resize", I);
  }
  function H() {
    var E = R();
    angular.element(E.wrapper).toggleClass("md-stretch-tabs", ha());
    Fa();
  }
  function A() {
    L.shouldCenterTabs = L.centerTabs && !L.shouldPaginate;
  }
  function w(E, P) {
    E !== P &&
      ((P = R()),
      angular.forEach(P.tabs, function (Z) {
        Z.style.maxWidth = E + "px";
      }),
      angular.forEach(P.dummies, function (Z) {
        Z.style.maxWidth = E + "px";
      }),
      f.nextTick(L.updateInkBarStyles));
  }
  function B(E, P) {
    E !== P &&
      ((L.maxTabWidth = pa()),
      (L.shouldCenterTabs = L.centerTabs && !L.shouldPaginate),
      f.nextTick(function () {
        L.maxTabWidth = pa();
        ma(L.selectedIndex);
      }));
  }
  function u(E) {
    b[E ? "removeClass" : "addClass"]("md-no-tab-content");
  }
  function z(E) {
    E = (L.shouldCenterTabs || f.isRtl(h) ? "" : "-") + E + "px";
    E = E.replace("--", "");
    angular.element(R().paging).css(c.CSS.TRANSFORM, "translate(" + E + ", 0)");
    a.$broadcast("$mdTabsPaginationChanged");
  }
  function D(E, P) {
    E !== P && R().tabs[E] && (ma(), Aa());
  }
  function G(E, P) {
    E !== P &&
      ((L.selectedIndex = ea(E)),
      (L.lastSelectedIndex = P),
      L.updateInkBarStyles(),
      xa(),
      ma(E),
      a.$broadcast("$mdTabsChanged"),
      L.tabs[P] && L.tabs[P].scope.deselect(),
      L.tabs[E] && L.tabs[E].scope.select());
  }
  function N(E) {
    var P = b[0].getElementsByTagName("md-tab");
    return Array.prototype.indexOf.call(P, E[0]);
  }
  function C() {
    C.watcher ||
      (C.watcher = a.$watch(function () {
        f.nextTick(function () {
          C.watcher && b.prop("offsetParent") && (C.watcher(), (C.watcher = null), I());
        }, !1);
      }));
  }
  function F(E) {
    switch (E.keyCode) {
      case c.KEY_CODE.LEFT_ARROW:
        E.preventDefault();
        wa(-1, !0);
        break;
      case c.KEY_CODE.RIGHT_ARROW:
        E.preventDefault();
        wa(1, !0);
        break;
      case c.KEY_CODE.SPACE:
      case c.KEY_CODE.ENTER:
        E.preventDefault();
        ua || O(L.focusIndex);
        break;
      case c.KEY_CODE.TAB:
        L.focusIndex !== L.selectedIndex && (L.focusIndex = L.selectedIndex);
    }
  }
  function O(E, P) {
    ua || (L.focusIndex = L.selectedIndex = E);
    (P && L.noSelectClick) ||
      f.nextTick(function () {
        L.tabs[E].element.triggerHandler("click");
      }, !1);
  }
  function S(E) {
    L.shouldPaginate &&
      (E.preventDefault(),
      E.deltaY ? (L.offsetLeft = W(L.offsetLeft + E.deltaY)) : E.deltaX && (L.offsetLeft = W(L.offsetLeft + E.deltaX)));
  }
  function K() {
    if (L.canPageForward()) {
      var E = q.increasePageOffset(R(), L.offsetLeft);
      L.offsetLeft = W(E);
    }
  }
  function M() {
    if (L.canPageBack()) {
      var E = q.decreasePageOffset(R(), L.offsetLeft);
      L.offsetLeft = W(E);
    }
  }
  function I() {
    L.lastSelectedIndex = L.selectedIndex;
    L.offsetLeft = W(L.offsetLeft);
    f.nextTick(function () {
      L.updateInkBarStyles();
      da();
    });
  }
  function J(E) {
    angular.element(R().inkBar).toggleClass("ng-hide", E);
  }
  function Q(E) {
    b.toggleClass("md-dynamic-height", E);
  }
  function T(E) {
    if (!ta) {
      var P = L.selectedIndex;
      E = L.tabs.splice(E.getIndex(), 1)[0];
      Ia();
      L.selectedIndex === P && (E.scope.deselect(), L.tabs[L.selectedIndex] && L.tabs[L.selectedIndex].scope.select());
      f.nextTick(function () {
        da();
        L.offsetLeft = W(L.offsetLeft);
      });
    }
  }
  function Y(E, P) {
    var Z = sa,
      ja = {
        getIndex: function () {
          return L.tabs.indexOf(na);
        },
        isActive: function () {
          return this.getIndex() === L.selectedIndex;
        },
        isLeft: function () {
          return this.getIndex() < L.selectedIndex;
        },
        isRight: function () {
          return this.getIndex() > L.selectedIndex;
        },
        shouldRender: function () {
          return !L.noDisconnect || this.isActive();
        },
        hasFocus: function () {
          return L.styleTabItemFocus && L.hasFocus && this.getIndex() === L.focusIndex;
        },
        id: f.nextUid(),
        hasContent: !(!E.template || !E.template.trim())
      },
      na = angular.extend(ja, E);
    angular.isDefined(P) ? L.tabs.splice(P, 0, na) : L.tabs.push(na);
    za();
    oa();
    f.nextTick(function () {
      da();
      va(na);
      Z &&
        L.autoselect &&
        f.nextTick(function () {
          f.nextTick(function () {
            O(L.tabs.indexOf(na));
          });
        });
    });
    return na;
  }
  function R() {
    var E = {},
      P = b[0];
    E.wrapper = P.querySelector("md-tabs-wrapper");
    E.canvas = E.wrapper.querySelector("md-tabs-canvas");
    E.paging = E.canvas.querySelector("md-pagination-wrapper");
    E.inkBar = E.paging.querySelector("md-ink-bar");
    E.nextButton = P.querySelector("md-next-button");
    E.prevButton = P.querySelector("md-prev-button");
    E.contents = P.querySelectorAll("md-tabs-content-wrapper > md-tab-content");
    E.tabs = E.paging.querySelectorAll("md-tab-item");
    E.dummies = E.canvas.querySelectorAll("md-dummy-tab");
    return E;
  }
  function U() {
    return 0 < L.offsetLeft;
  }
  function X() {
    var E = R(),
      P = E.tabs[E.tabs.length - 1];
    return f.isRtl(h)
      ? L.offsetLeft < E.paging.offsetWidth - E.canvas.offsetWidth
      : P && P.offsetLeft + P.offsetWidth > E.canvas.clientWidth + L.offsetLeft;
  }
  function aa() {
    var E = L.tabs[L.focusIndex];
    return E && E.id ? "tab-item-" + E.id : null;
  }
  function ha() {
    switch (L.stretchTabs) {
      case "always":
        return !0;
      case "never":
        return !1;
      default:
        return !L.shouldPaginate && d.matchMedia("(max-width: 600px)").matches;
    }
  }
  function fa() {
    if (L.noPagination || !sa) return !1;
    var E = b.prop("clientWidth");
    angular.forEach(R().tabs, function (Z) {
      E -= Z.offsetWidth;
    });
    var P = 0 > E;
    f.msie && (P ? (R().paging.style.width = "999999px") : (R().paging.style.width = void 0));
    return P;
  }
  function ea(E) {
    if (-1 === E) return -1;
    var P = Math.max(L.tabs.length - E, E),
      Z,
      ja;
    for (Z = 0; Z <= P; Z++)
      if (((ja = L.tabs[E + Z]) && !0 !== ja.scope.disabled) || ((ja = L.tabs[E - Z]) && !0 !== ja.scope.disabled)) return ja.getIndex();
    return E;
  }
  function ca(E, P, Z) {
    Object.defineProperty(L, E, {
      get: function () {
        return Z;
      },
      set: function (ja) {
        var na = Z;
        Z = ja;
        P && P(ja, na);
      }
    });
  }
  function da() {
    L.maxTabWidth = pa();
    L.shouldPaginate = fa();
  }
  function la(E) {
    var P = 0;
    angular.forEach(E, function (Z) {
      P += Math.max(Z.offsetWidth, Z.getBoundingClientRect().width);
    });
    return Math.ceil(P);
  }
  function pa() {
    var E = R();
    E = E.canvas.clientWidth;
    return Math.max(0, Math.min(E - 1, 264));
  }
  function Ga() {
    var E = L.tabs[L.selectedIndex],
      P = L.tabs[L.focusIndex];
    L.tabs = L.tabs.sort(function (Z, ja) {
      return Z.index - ja.index;
    });
    L.selectedIndex = L.tabs.indexOf(E);
    L.focusIndex = L.tabs.indexOf(P);
  }
  function wa(E, P) {
    var Z = P ? "focusIndex" : "selectedIndex",
      ja = L[Z];
    for (P = ja + E; L.tabs[P] && L.tabs[P].scope.disabled; P += E);
    P = (ja + E + L.tabs.length) % L.tabs.length;
    L.tabs[P] && (L[Z] = P);
  }
  function Aa() {
    L.styleTabItemFocus = "keyboard" === v.getLastInteractionType();
    var E = R().tabs[L.focusIndex];
    E && E.focus();
  }
  function ma(E) {
    var P = R();
    angular.isNumber(E) || (E = L.focusIndex);
    if (P.tabs[E] && !L.shouldCenterTabs) {
      var Z = P.tabs[E],
        ja = Z.offsetLeft;
      Z = Z.offsetWidth + ja;
      0 === E
        ? (L.offsetLeft = 0)
        : f.isRtl(h)
        ? ((ja = la(Array.prototype.slice.call(P.tabs, 0, E))),
          (E = la(Array.prototype.slice.call(P.tabs, 0, E + 1))),
          (L.offsetLeft = Math.min(L.offsetLeft, W(ja))),
          (L.offsetLeft = Math.max(L.offsetLeft, W(E - P.canvas.clientWidth))))
        : ((L.offsetLeft = Math.max(L.offsetLeft, W(Z - P.canvas.clientWidth + 32))), (L.offsetLeft = Math.min(L.offsetLeft, W(ja))));
    }
  }
  function za() {
    qa.forEach(function (E) {
      f.nextTick(E);
    });
    qa = [];
  }
  function oa() {
    var E = !1,
      P;
    for (P = 0; P < L.tabs.length; P++)
      if (L.tabs[P].hasContent) {
        E = !0;
        break;
      }
    L.hasContent = E;
  }
  function Ia() {
    L.selectedIndex = ea(L.selectedIndex);
    L.focusIndex = ea(L.focusIndex);
  }
  function xa() {
    if (!L.dynamicHeight) return b.css("height", "");
    if (!L.tabs.length) return qa.push(xa);
    var E = R(),
      P = E.contents[L.selectedIndex];
    P = P ? P.offsetHeight : 0;
    E = E.wrapper.offsetHeight;
    P += E;
    var Z = b.prop("clientHeight");
    Z !== P &&
      ("bottom" === b.attr("md-align-tabs") && ((Z -= E), (P -= E), void 0 !== b.attr("md-border-bottom") && ++Z),
      (ua = !0),
      (E = { height: Z + "px" }),
      (P = { height: P + "px" }),
      b.css(E),
      g(b, { from: E, to: P, easing: "cubic-bezier(0.35, 0, 0.25, 1)", duration: 0.5 })
        .start()
        .done(function () {
          b.css({ transition: "none", height: "" });
          f.nextTick(function () {
            b.css("transition", "");
          });
          ua = !1;
        }));
  }
  function Fa(E, P) {
    if (!L.noInkBar) {
      var Z = R();
      if (Z.tabs[L.selectedIndex])
        if (L.tabs.length)
          if (b.prop("offsetParent")) {
            var ja = L.selectedIndex,
              na = Z.paging.offsetWidth,
              Ba = Z.tabs[ja];
            ja = Ba.offsetLeft;
            Ba = na - ja - Ba.offsetWidth;
            if (L.shouldCenterTabs) {
              var V = la(Z.tabs);
              na > V && E !== na && P !== V && n(Fa, 0, !0, na, V);
            }
            na = R();
            E = L.selectedIndex;
            P = L.lastSelectedIndex;
            na = angular.element(na.inkBar);
            angular.isNumber(P) && na.toggleClass("md-left", E < P).toggleClass("md-right", E > P);
            angular.element(Z.inkBar).css({ left: ja + "px", right: Ba + "px" });
          } else C();
        else qa.push(L.updateInkBarStyles);
      else angular.element(Z.inkBar).css({ left: "auto", right: "auto" });
    }
  }
  function W(E) {
    var P = R();
    if (!P.tabs.length || !L.shouldPaginate) return 0;
    var Z = P.tabs[P.tabs.length - 1];
    Z = Z.offsetLeft + Z.offsetWidth;
    f.isRtl(h)
      ? ((E = Math.min(P.paging.offsetWidth - P.canvas.clientWidth, E)), (E = Math.max(0, E)))
      : ((E = Math.max(0, E)), (E = Math.min(Z - P.canvas.clientWidth, E)));
    return E;
  }
  function ya(E, P) {
    var Z = R();
    Z = { colorElement: angular.element(Z.inkBar) };
    e.attach(E, P, Z);
  }
  function va(E) {
    if (E.hasContent) {
      var P = b[0].querySelectorAll('[md-tab-id="' + E.id + '"]');
      angular.element(P).attr("aria-controls", L.tabContentPrefix + E.id);
    }
  }
  var L = this,
    ua = !1,
    qa = [],
    ta = !1,
    sa = !1;
  L.$onInit = r;
  L.updatePagination = f.debounce(da, 100);
  L.redirectFocus = Aa;
  L.attachRipple = ya;
  L.insertTab = Y;
  L.removeTab = T;
  L.select = O;
  L.scroll = S;
  L.nextPage = K;
  L.previousPage = M;
  L.keydown = F;
  L.canPageForward = X;
  L.canPageBack = U;
  L.refreshIndex = Ia;
  L.incrementIndex = wa;
  L.getTabElementIndex = N;
  L.updateInkBarStyles = f.debounce(Fa, 100);
  L.updateTabOrder = f.debounce(Ga, 100);
  L.getFocusedTabId = aa;
  1 === angular.version.major && 4 >= angular.version.minor && this.$onInit();
}
MdTabs.$inject = ["$$mdSvgRegistry"];
angular.module("material.components.tabs").directive("mdTabs", MdTabs);
function MdTabs(a) {
  return {
    scope: { navigationHint: "@?mdNavigationHint", selectedIndex: "=?mdSelected" },
    template: function (b, d) {
      d.$mdTabsTemplate = b.html();
      return (
        '<md-tabs-wrapper> <md-tab-data></md-tab-data> <md-prev-button tabindex="-1" role="button" aria-label="Previous Page" aria-disabled="{{!$mdTabsCtrl.canPageBack()}}" ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageBack() }" ng-if="$mdTabsCtrl.shouldPaginate" ng-click="$mdTabsCtrl.previousPage()"> <md-icon md-svg-src="' +
        a.mdTabsArrow +
        '"></md-icon> </md-prev-button> <md-next-button tabindex="-1" role="button" aria-label="Next Page" aria-disabled="{{!$mdTabsCtrl.canPageForward()}}" ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageForward() }" ng-if="$mdTabsCtrl.shouldPaginate" ng-click="$mdTabsCtrl.nextPage()"> <md-icon md-svg-src="' +
        a.mdTabsArrow +
        '"></md-icon> </md-next-button> <md-tabs-canvas tabindex="{{ $mdTabsCtrl.hasFocus ? -1 : 0 }}" ng-focus="$mdTabsCtrl.redirectFocus()" ng-class="{ \'md-paginated\': $mdTabsCtrl.shouldPaginate, \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" ng-keydown="$mdTabsCtrl.keydown($event)"> <md-pagination-wrapper ng-class="{ \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" md-tab-scroll="$mdTabsCtrl.scroll($event)" role="tablist" aria-label="{{::$mdTabsCtrl.navigationHint}}"><md-tab-item tabindex="{{ tab.isActive() ? 0 : -1 }}" class="md-tab {{::tab.scope.tabClass}}" ng-repeat="tab in $mdTabsCtrl.tabs" role="tab" id="tab-item-{{::tab.id}}" md-tab-id="{{::tab.id}}" aria-selected="{{tab.isActive()}}" aria-disabled="{{tab.scope.disabled || \'false\'}}" ng-click="$mdTabsCtrl.select(tab.getIndex())" ng-focus="$mdTabsCtrl.hasFocus = true" ng-blur="$mdTabsCtrl.hasFocus = false" ng-class="{ \'md-active\':    tab.isActive(), \'md-focused\':   tab.hasFocus(), \'md-disabled\':  tab.scope.disabled }" ng-disabled="tab.scope.disabled" md-swipe-left="$mdTabsCtrl.nextPage()" md-swipe-right="$mdTabsCtrl.previousPage()" md-tabs-template="::tab.label" md-scope="::tab.parent"></md-tab-item> <md-ink-bar></md-ink-bar> </md-pagination-wrapper> <md-tabs-dummy-wrapper aria-hidden="true" class="md-visually-hidden md-dummy-wrapper"> <md-dummy-tab class="md-tab" tabindex="-1" ng-focus="$mdTabsCtrl.hasFocus = true" ng-blur="$mdTabsCtrl.hasFocus = false" ng-repeat="tab in $mdTabsCtrl.tabs" md-tabs-template="::tab.label" md-scope="::tab.parent"></md-dummy-tab> </md-tabs-dummy-wrapper> </md-tabs-canvas> </md-tabs-wrapper> <md-tabs-content-wrapper ng-show="$mdTabsCtrl.hasContent && $mdTabsCtrl.selectedIndex >= 0" class="_md"> <md-tab-content id="{{:: $mdTabsCtrl.tabContentPrefix + tab.id}}" class="_md" role="tabpanel" aria-labelledby="tab-item-{{::tab.id}}" md-swipe-left="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(1)" md-swipe-right="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(-1)" ng-if="tab.hasContent" ng-repeat="(index, tab) in $mdTabsCtrl.tabs" ng-class="{ \'md-no-transition\': $mdTabsCtrl.lastSelectedIndex == null, \'md-active\':        tab.isActive(), \'md-left\':          tab.isLeft(), \'md-right\':         tab.isRight(), \'md-no-scroll\':     $mdTabsCtrl.dynamicHeight }"> <div md-tabs-template="::tab.template" md-connected-if="tab.isActive()" md-scope="::tab.parent" ng-if="$mdTabsCtrl.enableDisconnect || tab.shouldRender()"></div> </md-tab-content> </md-tabs-content-wrapper>'
      );
    },
    controller: "MdTabsController",
    controllerAs: "$mdTabsCtrl",
    bindToController: !0
  };
}
MdTabsDummyWrapper.$inject = ["$mdUtil", "$window"];
angular.module("material.components.tabs").directive("mdTabsDummyWrapper", MdTabsDummyWrapper);
function MdTabsDummyWrapper(a, b) {
  return {
    require: "^?mdTabs",
    link: function (d, c, e, f) {
      if (f) {
        var g = function () {
          f.updatePagination();
          f.updateInkBarStyles();
        };
        if ("MutationObserver" in b) {
          e = { childList: !0, subtree: !0, characterData: !0 };
          g = new MutationObserver(g);
          g.observe(c[0], e);
          var h = g.disconnect.bind(g);
        } else (e = a.debounce(g, 15, null, !1)), c.on("DOMSubtreeModified", e), (h = c.off.bind(c, "DOMSubtreeModified", e));
        d.$on("$destroy", function () {
          h();
        });
      }
    }
  };
}
MdTabsTemplate.$inject = ["$compile", "$mdUtil"];
angular.module("material.components.tabs").directive("mdTabsTemplate", MdTabsTemplate);
function MdTabsTemplate(a, b) {
  function d(c, e, f, g) {
    function h() {
      c.$watch("connected", function (v) {
        !1 === v ? g.enableDisconnect && b.disconnectScope(m) : l();
      });
      c.$on("$destroy", l);
    }
    function l() {
      g.enableDisconnect && b.reconnectScope(m);
    }
    if (g) {
      var m = g.enableDisconnect ? c.compileScope.$new() : c.compileScope;
      e.html(c.template);
      a(e.contents())(m);
      return b.nextTick(h);
    }
  }
  return {
    restrict: "A",
    link: d,
    scope: { template: "=mdTabsTemplate", connected: "=?mdConnectedIf", compileScope: "=mdScope" },
    require: "^?mdTabs"
  };
}
ngmaterial.components.tabs = angular.module("material.components.tabs");
MdToastDirective.$inject = ["$mdToast"];
MdToastProvider.$inject = ["$$interimElementProvider"];
angular
  .module("material.components.toast", ["material.core", "material.components.button"])
  .directive("mdToast", MdToastDirective)
  .provider("$mdToast", MdToastProvider);
function MdToastDirective(a) {
  return {
    restrict: "E",
    link: function (b, d) {
      d.addClass("_md");
      b.$on("$destroy", function () {
        a.destroy();
      });
    }
  };
}
function MdToastProvider(a) {
  function b(f) {
    e = f;
  }
  function d(f, g, h) {
    this.$onInit = function () {
      var l = this;
      l.highlightAction && (g.highlightClasses = ["md-highlight", l.highlightClass]);
      l.action &&
        !l.actionKey &&
        h.warn(
          "Toasts with actions should define an actionKey for accessibility.",
          "Details: https://material.angularjs.org/latest/api/service/$mdToast#mdtoast-simple"
        );
      l.actionKey && !l.actionHint && (l.actionHint = 'Press Control-"' + l.actionKey + '" to ');
      l.dismissHint || (l.dismissHint = "Press Escape to dismiss.");
      g.$watch(
        function () {
          return e;
        },
        function () {
          l.content = e;
        }
      );
      this.resolve = function () {
        f.hide("ok");
      };
    };
  }
  function c(f, g, h, l, m) {
    function v(x, y, k) {
      e = k.textContent || k.content;
      var p = !l("gt-sm");
      y = h.extractElementByName(y, "md-toast", !0);
      k.element = y;
      k.onSwipe = function (t) {
        t = t.type.replace("$md.", "");
        var H = t.replace("swipe", "");
        ("down" === H && -1 !== k.position.indexOf("top") && !p) ||
          ("up" === H && (-1 !== k.position.indexOf("bottom") || p)) ||
          (("left" === H || "right" === H) && p) ||
          (y.addClass("md-" + t), h.nextTick(g.cancel));
      };
      k.openClass = q(k.position);
      y.addClass(k.toastClass);
      k.parent.addClass(k.openClass);
      h.hasComputedStyle(k.parent, "position", "static") && k.parent.css("position", "relative");
      r(x.toast && x.toast.actionKey ? x.toast.actionKey : void 0);
      y.on("$md.swipeleft $md.swiperight $md.swipeup $md.swipedown", k.onSwipe);
      y.addClass(
        p
          ? "md-bottom"
          : k.position
              .split(" ")
              .map(function (t) {
                return "md-" + t;
              })
              .join(" ")
      );
      k.parent && k.parent.addClass("md-toast-animating");
      return f.enter(y, k.parent).then(function () {
        k.parent && k.parent.removeClass("md-toast-animating");
      });
    }
    function n(x, y, k) {
      x.toast && x.toast.actionKey && m.off("keydown");
      y.off("$md.swipeleft $md.swiperight $md.swipeup $md.swipedown", k.onSwipe);
      k.parent && k.parent.addClass("md-toast-animating");
      k.openClass && k.parent.removeClass(k.openClass);
      return (!0 === k.$destroy ? y.remove() : f.leave(y)).then(function () {
        k.parent && k.parent.removeClass("md-toast-animating");
        h.hasComputedStyle(k.parent, "position", "static") && k.parent.css("position", "");
      });
    }
    function q(x) {
      return l("gt-xs") ? "md-toast-open-" + (-1 < x.indexOf("top") ? "top" : "bottom") : "md-toast-open-bottom";
    }
    function r(x) {
      var y = function (k) {
        "Escape" === k.key && g.hide(!1);
        x && k.key === x && k.ctrlKey && g.hide("ok");
      };
      m.on("keydown", y);
    }
    return {
      onShow: v,
      onRemove: n,
      toastClass: "",
      position: "bottom left",
      themable: !0,
      hideDelay: 3e3,
      autoWrap: !0,
      transformTemplate: function (x, y) {
        if ((y = y.autoWrap && x && !/md-toast-content/g.test(x))) {
          y = document.createElement("md-template");
          y.innerHTML = x;
          for (x = 0; x < y.children.length; x++)
            if ("MD-TOAST" === y.children[x].nodeName) {
              var k = angular.element('<div class="md-toast-content">');
              k.append(angular.element(y.children[x].childNodes));
              y.children[x].appendChild(k[0]);
            }
          return y.innerHTML;
        }
        return x || "";
      }
    };
  }
  d.$inject = ["$mdToast", "$scope", "$log"];
  c.$inject = ["$animate", "$mdToast", "$mdUtil", "$mdMedia", "$document"];
  var e;
  return (a = a("$mdToast")
    .setDefaults({ methods: "position hideDelay capsule parent position toastClass".split(" "), options: c })
    .addPreset("simple", {
      argOption: "textContent",
      methods: "textContent content action actionKey actionHint highlightAction highlightClass theme parent dismissHint".split(" "),
      options: [
        "$mdToast",
        "$mdTheming",
        function (f, g) {
          return {
            template:
              '<md-toast md-theme="{{ toast.theme }}" ng-class="{\'md-capsule\': toast.capsule}">  <div class="md-toast-content" aria-live="polite" aria-relevant="all">    <span class="md-toast-text">      {{ toast.content }}    </span>    <span class="md-visually-hidden">{{ toast.dismissHint }}</span>    <span class="md-visually-hidden" ng-if="toast.action && toast.actionKey">      {{ toast.actionHint }}    </span>    <md-button class="md-action" ng-if="toast.action" ng-click="toast.resolve()"                ng-class="highlightClasses">      {{ toast.action }}    </md-button>  </div></md-toast>',
            controller: d,
            theme: g.defaultTheme(),
            controllerAs: "toast",
            bindToController: !0
          };
        }
      ]
    })
    .addMethod("updateTextContent", b)
    .addMethod("updateContent", b));
}
ngmaterial.components.toast = angular.module("material.components.toast");
mdToolbarDirective.$inject = ["$$rAF", "$mdConstant", "$mdUtil", "$mdTheming", "$animate"];
angular.module("material.components.toolbar", ["material.core", "material.components.content"]).directive("mdToolbar", mdToolbarDirective);
function mdToolbarDirective(a, b, d, c, e) {
  var f = angular.bind(null, d.supplant, "translate3d(0,{0}px,0)");
  return {
    template: "",
    restrict: "E",
    link: function (g, h, l) {
      function m() {
        function v(u) {
          var z = h.parent().find("md-content");
          !k && z.length && n(null, z);
          u = g.$eval(u);
          !1 === u ? p() : (p = r());
        }
        function n(u, z) {
          z && h.parent()[0] === z.parent()[0] && (k && k.off("scroll", w), (k = z), (p = r()));
        }
        function q(u) {
          u = u ? u.target.scrollTop : H;
          B();
          t = Math.min(y / A, Math.max(0, t + u - H));
          h.css(b.CSS.TRANSFORM, f([-t * A]));
          k.css(b.CSS.TRANSFORM, f([(y - t) * A]));
          H = u;
          d.nextTick(function () {
            var z = h.hasClass("md-whiteframe-z1");
            z && !t ? e.removeClass(h, "md-whiteframe-z1") : !z && t && e.addClass(h, "md-whiteframe-z1");
          });
        }
        function r() {
          if (!k) return angular.noop;
          k.on("scroll", w);
          k.attr("scroll-shrink", "true");
          d.nextTick(x, !1);
          return function () {
            k.off("scroll", w);
            k.attr("scroll-shrink", "false");
            x();
          };
        }
        function x() {
          y = h.prop("offsetHeight");
          var u = -y * A + "px";
          k.css({ "margin-top": u, "margin-bottom": u });
          q();
        }
        var y,
          k,
          p = angular.noop,
          t = 0,
          H = 0,
          A = l.mdShrinkSpeedFactor || 0.5,
          w = a.throttle(q),
          B = d.debounce(x, 5e3);
        g.$on("$mdContentLoaded", n);
        l.$observe("mdScrollShrink", v);
        l.ngShow && g.$watch(l.ngShow, x);
        l.ngHide && g.$watch(l.ngHide, x);
        g.$on("$destroy", p);
      }
      h.addClass("_md");
      c(h);
      d.nextTick(function () {
        h.addClass("_md-toolbar-transitions");
      }, !1);
      angular.isDefined(l.mdScrollShrink) && m();
    }
  };
}
ngmaterial.components.toolbar = angular.module("material.components.toolbar");
MdTooltipDirective.$inject = "$timeout $window $$rAF $document $interpolate $mdUtil $mdPanel $$mdTooltipRegistry".split(" ");
angular
  .module("material.components.tooltip", ["material.core", "material.components.panel"])
  .directive("mdTooltip", MdTooltipDirective)
  .service("$$mdTooltipRegistry", MdTooltipRegistry);
function MdTooltipDirective(a, b, d, c, e, f, g, h) {
  function l(v, n, q) {
    function r() {
      v.mdZIndex = v.mdZIndex || 100;
      v.mdDelay = v.mdDelay || 0;
      m[v.mdDirection] || (v.mdDirection = "bottom");
    }
    function x(K) {
      K = K || e(n.text().trim())(v.$parent);
      if ((!B.attr("aria-label") && !B.attr("aria-labelledby")) || B.attr("md-labeled-by-tooltip"))
        B.attr("aria-label", K), B.attr("md-labeled-by-tooltip") || B.attr("md-labeled-by-tooltip", w);
    }
    function y() {
      r();
      C && C.panelEl && C.panelEl.removeClass(D);
      D = "md-origin-" + v.mdDirection;
      G = m[v.mdDirection];
      N = g.newPanelPosition().relativeTo(B).addPanelPosition(G.x, G.y);
      C && C.panelEl && (C.panelEl.addClass(D), C.updatePosition(N));
    }
    function k() {
      function K(U) {
        U.some(function (X) {
          return "disabled" === X.attributeName && B[0].disabled;
        });
        return !1;
      }
      function M() {
        t(!1);
      }
      function I() {
        S = document.activeElement === B[0];
      }
      function J(U) {
        if ("focus" === U.type && S) S = !1;
        else if (!v.mdVisible && (B.on("blur touchcancel mouseleave", Q), t(!0), "touchstart" === U.type))
          B.one("touchend", function () {
            f.nextTick(function () {
              c.one("touchend", Q);
            }, !1);
          });
      }
      function Q() {
        if ((F = v.hasOwnProperty("mdAutohide") ? v.mdAutohide : q.hasOwnProperty("mdAutohide")) || z || c[0].activeElement !== B[0])
          O && (a.cancel(O), (t.queued = !1), (O = null)), B.off("blur touchcancel mouseleave", Q), B.triggerHandler("blur"), t(!1);
        z = !1;
      }
      function T() {
        z = !0;
      }
      function Y() {
        h.deregister("scroll", M, !0);
        h.deregister("blur", I);
        h.deregister("resize", u);
        B.off("focus touchstart mouseenter", J).off("blur touchcancel mouseleave", Q).off("mousedown", T);
        Q();
        R && R.disconnect();
      }
      if (B[0] && "MutationObserver" in b) {
        var R = new MutationObserver(function (U) {
          K(U) &&
            f.nextTick(function () {
              t(!1);
            });
        });
        R.observe(B[0], { attributes: !0 });
      }
      S = !1;
      h.register("scroll", M, !0);
      h.register("blur", I);
      h.register("resize", u);
      v.$on("$destroy", Y);
      B.on("mousedown", T);
      B.on("focus touchstart mouseenter", J);
    }
    function p() {
      function K() {
        v.$destroy();
      }
      if (n[0] && "MutationObserver" in b) {
        var M = new MutationObserver(function (I) {
          I.forEach(function (J) {
            "md-visible" !== J.attributeName || v.visibleWatcher || (v.visibleWatcher = v.$watch("mdVisible", H));
          });
        });
        M.observe(n[0], { attributes: !0 });
        q.hasOwnProperty("mdVisible") && (v.visibleWatcher = v.$watch("mdVisible", H));
      } else v.visibleWatcher = v.$watch("mdVisible", H);
      v.$watch("mdDirection", y);
      n.one("$destroy", K);
      B.one("$destroy", K);
      v.$on("$destroy", function () {
        t(!1);
        C && C.destroy();
        M && M.disconnect();
        n.remove();
      });
      -1 < n.text().indexOf(e.startSymbol()) &&
        v.$watch(function () {
          return n.text().trim();
        }, x);
    }
    function t(K) {
      (t.queued && t.value === !!K) ||
        (!t.queued && v.mdVisible === !!K) ||
        ((t.value = !!K),
        t.queued ||
          (K
            ? ((t.queued = !0),
              (O = a(function () {
                v.mdVisible = t.value;
                t.queued = !1;
                O = null;
                v.visibleWatcher || H(v.mdVisible);
              }, v.mdDelay)))
            : f.nextTick(function () {
                v.mdVisible = !1;
                v.visibleWatcher || H(!1);
              })));
    }
    function H(K) {
      K ? A() : C && C.close();
    }
    function A() {
      if (!n[0].textContent.trim())
        throw Error("Text for the tooltip has not been provided. Please include text within the mdTooltip element.");
      if (!C) {
        var K = angular.element(document.body),
          M = g.newPanelAnimation().openFrom(B).closeTo(B).withAnimation({ open: "md-show", close: "md-hide" });
        K = {
          id: w,
          attachTo: K,
          contentElement: n,
          propagateContainerEvents: !0,
          panelClass: "md-tooltip",
          animation: M,
          position: N,
          zIndex: v.mdZIndex,
          focusOnOpen: !1,
          onDomAdded: function () {
            C.panelEl.addClass(D);
          }
        };
        C = g.create(K);
      }
      C.open().then(function () {
        C.panelEl.attr("role", "tooltip");
      });
    }
    var w = "md-tooltip-" + f.nextUid(),
      B = f.getParentWithPointerEvents(n),
      u = d.throttle(y),
      z = !1,
      D,
      G,
      N,
      C,
      F,
      O,
      S = null;
    r();
    x();
    n.detach();
    y();
    k();
    p();
  }
  var m = {
    top: { x: g.xPosition.CENTER, y: g.yPosition.ABOVE },
    right: { x: g.xPosition.OFFSET_END, y: g.yPosition.CENTER },
    bottom: { x: g.xPosition.CENTER, y: g.yPosition.BELOW },
    left: { x: g.xPosition.OFFSET_START, y: g.yPosition.CENTER }
  };
  return {
    restrict: "E",
    priority: 210,
    scope: {
      mdZIndex: "=?mdZIndex",
      mdDelay: "=?mdDelay",
      mdVisible: "=?mdVisible",
      mdAutohide: "=?mdAutohide",
      mdDirection: "@?mdDirection"
    },
    link: l
  };
}
function MdTooltipRegistry() {
  function a(f) {
    c[f.type] &&
      c[f.type].forEach(function (g) {
        g.call(this, f);
      }, this);
  }
  function b(f, g, h) {
    var l = (c[f] = c[f] || []);
    l.length || (h ? window.addEventListener(f, a, !0) : e.on(f, a));
    -1 === l.indexOf(g) && l.push(g);
  }
  function d(f, g, h) {
    var l = c[f];
    g = l ? l.indexOf(g) : -1;
    -1 < g && (l.splice(g, 1), 0 === l.length && (h ? window.removeEventListener(f, a, !0) : e.off(f, a)));
  }
  var c = {},
    e = angular.element(window);
  return { register: b, deregister: d };
}
ngmaterial.components.tooltip = angular.module("material.components.tooltip");
MdWhiteframeDirective.$inject = ["$log"];
angular.module("material.components.whiteframe", ["material.core"]).directive("mdWhiteframe", MdWhiteframeDirective);
function MdWhiteframeDirective(a) {
  function b(d, c, e) {
    var f = "";
    e.$observe("mdWhiteframe", function (g) {
      g = parseInt(g, 10) || 4;
      -1 != g &&
        (24 < g || 1 > g) &&
        (a.warn("md-whiteframe attribute value is invalid. It should be a number between 1 and 24", c[0]), (g = 4));
      g = -1 == g ? "" : "md-whiteframe-" + g + "dp";
      e.$updateClass(g, f);
      f = g;
    });
  }
  return { link: b };
}
ngmaterial.components.whiteframe = angular.module("material.components.whiteframe"); /*
 Angular Material Design
 https://github.com/angular/material
 @license MIT
 v1.1.0
*/
angular.module(
  "ngMaterial",
  "ng ngAnimate ngAria material.core material.core.gestures material.core.layout material.core.theming.palette material.core.theming material.core.animate material.components.autocomplete material.components.backdrop material.components.bottomSheet material.components.button material.components.card material.components.checkbox material.components.chips material.components.colors material.components.content material.components.datepicker material.components.dialog material.components.divider material.components.fabActions material.components.fabShared material.components.fabSpeedDial material.components.fabToolbar material.components.gridList material.components.icon material.components.input material.components.list material.components.menu material.components.menuBar material.components.navBar material.components.panel material.components.progressCircular material.components.progressLinear material.components.radioButton material.components.select material.components.showHide material.components.sidenav material.components.slider material.components.sticky material.components.subheader material.components.swipe material.components.switch material.components.tabs material.components.toast material.components.toolbar material.components.tooltip material.components.virtualRepeat material.components.whiteframe".split(
    " "
  )
);
